<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaSE-面向对象2]]></title>
    <url>%2Fcategory%2FJavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12%2F</url>
    <content type="text"><![CDATA[面向对象2继承关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为超类，基类或父类，新类称为子类。派生类等。子类比超类拥有的功能更加丰富。在通过扩展父类定义子类的时候，仅需要指出子类与超类的不同之处。因为在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。由于子类的构造器不能访问父类的私有域，所以必须利用父类的构造器对这部分私有域进行初始化，我们可以通过super实现对父类构造器的调用，使用super调用构造器的语句必须是子类构造器的第一条语句。如果子类的构造器没有显示的调用父类构造器，则将自动的调用超类默认的构造器，如果超类没有不带参数的构造器，并且子类的构造器中又没有显示的调用超类其他的构造器，则Java编译器将报告错误。由一个公共超类派生出来的所有类的集合被称为继承层次，从某个特定的类到其祖先的路径称为该类的继承链。把多个类中相同的内容给提取出来定义到一个类中例如1234567891011121314151617181920class dog&#123; String name; int age; public void eat(String name)&#123; System.out.println(name+"吃饭"); &#125; public void sleep(String name)&#123; System.out.println(name+"睡觉"); &#125;&#125;class cat&#123; String name; int age; public void eat(String name)&#123; System.out.println(name+"吃饭"); &#125; public void sleep(String name)&#123; System.out.println(name+"睡觉"); &#125;&#125;像这种情况，可以把公共的提取出来，然后去继承提取的那个类，也就是父类123456789101112131415161718class animal&#123; //animal类可以看作所有动物类的父类，任何动物都可以有名字，年龄，都会吃饭睡觉，所以将这些公共的提取出来，那么子类只需要继承这个类便拥有这些方法以及成员变量 String name; int age; public void eat(String name)&#123; System.out.println(name+"吃饭"); &#125; public void sleep(String name)&#123; System.out.println(name+"睡觉"); &#125;&#125;class dog extends animal()&#123; //这里子类dog就拥有父类animal的成员变量以及方法，可以对其赋值或者方法的重写&#125;class cat extends animal()&#123; &#125;像这样的extends关系就叫做继承，但是继承中子类不能继承父类的私有成员，构造方法(但可以通过super去访问)，继承体现的是is a的关系，在java中只支持单继承，但可以多层继承(继承体系)继承的标准格式就是：class 子类名 extends 父类名{}使用了继承有什么好处呢？提高了代码的复用性提高了代码的维护性让类与类之间产生了关系，是多态的前提(同时这一点也是弊端，当类与类之间产生了关系，就不可避免的会有耦合，然而在开发原则里明确表示：低耦合高内聚，当耦合度高了可以这么形容，”牵一发而动全身“)假设我们有这么一个需求，有一家做信息检索的公司，他们需要对手机的各个品牌做一个统计以及对比，现在需要开发一个软件，需要编写entity，在使用继承并且掌握现有知识的前提下如何去设计呢？首先我们应该分析一下，这家公司对产品内不同品牌进行对比，那么主题是手机，手机下有不同的品牌123456789101112131415161718192021222324252627//假设我们手机有这些功能以及参数class Phone()&#123; double size; String color; String name; String cpu_id; int ram_size; int rom_size; int camera_pixel;//摄像头像素 ... public void takePhone()&#123; System.out.println("打电话"); &#125; public void takePhoto()&#123; System.out.println("拍照"); &#125; ...&#125;//我现在有一个华为手机，那么我定义一个类HuaweiPhone继承Phoneclass HuaweiPhone extends Phone&#123; //在这里我就不用每添加一个品牌再去写那些共有的特性，而是去继承父类，如果功能有特殊的那么重写或新加 int camera_num; //摄像头数量 public void takeMaxPhoto()&#123; System.out.println("夜拍，徕卡相机拍更厉害的照片"); &#125;&#125;//同样小米手机，等其他手机也是类似，当我们新加一个手机品牌那么只需要继承这个类即可，再去写我们特有的功能在上述代码中可能会好奇，为什么只是写了一个关键字extends，子类便可以使用父类的成员变量，成员方法。继承中构造方法：在继承体系中，子类会继承父类中的数据，可能还会使用父类的数据。那么我们知道，在一个类中，给成员变量赋值有两种方法，一种是用方法赋值，一种是构造方法赋值。用构造方法赋值在new一个对象时需要对有参的构造方法传入值。而构造方法当自己没有声明，java会帮你写一个无参的构造方法。但是当你写了一个有参的构造方法如果还要使用无参的构造方法必须声名一个。系统不会再帮你生成无参构造方法。在这里，子类的构造方法默认访问了父类中空参数的构造方法，从而构造出父类对象。构造方法用于初始化一个实例对象，所以static修饰是没有任何意义的;多个线程不会同时创建内存地址相同的同一个对象，所以synchronized修饰没有意义;构造方法不能被子类继承，所以final和abstract修饰没有意义构造方法是没有返回类型的，void也不行。当用户没有给java类定义明确的构造方法的时候,java为我们提供了一个默认的构造方法,这个构造方法没有参数,修饰符是public并且方法体为空。如果用户有定义构造方法，就不会有默认构造方法！！！其实默认的构造方法还分为两种,一种就是刚刚说过的隐藏的构造方法,另一种就是显示定义的默认构造方法.如果一个类中定义了一个或者多个构造方法,并且每一个构造方法都是带有参数形式的,那么这个类就没有默认的构造方法（需要显示的声明无参构造方法）this与super：“this”的用法：实例方法中可以使用this关键字,它指向正在执行方法的类的实例对象,当然static方法中是不可以使用this对象的,因为静态方法不属于类的实例对象;而构造方法中同样可以使用this关键字,构造器中的this是指向同一个对象中不同参数的另一个构造器。构造方法中通过this关键字调用其他构造方法时,那么这句代码必须放在第一行,否则会编译错误。构造方法中只能通过this调用一次其他的构造方法。“super”的用法：实例方法和构造方法中的super关键字都用于去指向父类,实例方法中的super关键字是去调用父类当中的某个方法构造器中使用super关键字调用父类中的构造器在实例化子类对象时,程序会先调用父类的默认构造方法,然后再执行子类的构造方法。在实例化类的对象时,类中的成员变量会首先进行初始化,如果其中的成员变量有对象，那么它们也会按照顺序执行初始化工作。在所有类成员初始化完成后，才调用对象所在类的构造方法创建对象。构造方法作用就是初始化。如果一个类中有静态对象,那么他会在非静态对象初始化前进行初始化,但只初始化一次。而非静态对象每次调用时都要初始化。程序中主类的静态变量会在main()方法执行前初始化一个类初始化顺序：父类的静态成员—&gt;子类的静态成员—&gt;父类的非静态成员—&gt;父类的默认构造函数被调用—&gt;子类的非静态对象（变量）—&gt; 子类的构造函数。继承中成员方法的关系子类中的方法和父类中的方法声明不一样 直接调用子类中的方法和父类中的方法声明一样：通过子类调用方法：先找子类中看有没有这个方法，有就使用再看父类有没有这个方法，有就使用如果没有就报错方法重写与方法重载方法重写（Override）：子类中出现了和父类中方法声明一模一样的方法方法重载（Overload）：本类中出现的方法名一样，参数列表不同的方法。与返回值无关子类对象调用方法的时候：先找子类本身，再找父类方法重写的应用：当子类需要父类的功能，而功能主体子类有自己的特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。注意事项：父类中私有的方法不能被重写子类重写父类方法是，访问权限不能更低父类静态方法，子类必须通过静态方法进行重写子类重写父类方法的时候，最好声明一模一样多态同一个对象（事务），在不同时刻体现出来的不同状态比如小米手机是小米手机同样也是手机在上面的例子中当Phone p = new XiaomiPhone()可以看作是多态多态的前提：要有继承关系，要有方法重写（也可以没有，但是没有这个就没有意义）要有父类引用子类对象fu f = new zi()多态中成员访问特点：成员变量编译看左边，运行看左边构造方法创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化成员方法编译看左边，运行看右边静态方法编译看左边，运行看左边（静态和类相关，算不上重写，所以访问还是左边的）由于成员方法存在方法重写，所以它运行看右边。多态的好处提高了代码的维护性（继承保证）提高了代码的扩展性（多态保证）多态的弊端不能使用子类的特有功能。父类使用子类特有功能创建子类对象调用方法即可（可以，但是很多时候不合理，而且太占内存）把父类的引用强制转换为子类的引用（向下转型）12345//对象间转型问题//向上转型Fu f = new Zi();//向下转型Zi z = new (Zi)f;//要求该f必须能够转换为Zi的多态中的内存图解：对象变化内存图解：封装封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。使用封装有三大好处：良好的封装能够减少耦合。类内部的结构可以自由修改。可以对成员进行更精确的控制。隐藏信息，实现细节。所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。可以对成员变量进行更精确的控制Package关键字包的概述：其实就是文件夹作用：把对相同的类名放到不同的包中对类进行分类管理包的定义：Package 包名；多级包用.分开注意事项：package语句必须是程序的第一条可执行的代码package语句在一个java文件中只能有一个如果没有package，默认表示无包名带包的编译和运行：手动式编写一个带包的Java文件通过Javac命令编译该Java文件手动创建包名把b步骤的class文件放到c步骤的最低层包回到和包根目录在同一个目录的地方，然后运行带包运行自动式编写一个带包的java文件javac编译的时候带上-d即可Javac -d .HelloWorld.java回到和包根目录在同一个目录的地方，然后运行带包运行import关键字的概述和使用导包：格式：import 包名；这种方式导入是到类的名称。注意：我们用谁就导谁面试题：package，import，class有没有顺序关系？有package&gt;import&gt;classpackage：只能有一个import：可以有多个class：可以有多个，建议是一个四种权限修饰符本类同一个包下（子类和无关类）不同包下（子类）不同包下（无关类）privateY默认（default）YYprotectedYYYpublicYYYY类及其组成所使用的常见修饰符修饰符：权限修饰符：private，默认修饰符，protected，public状态修饰符：static，final抽象修饰符：abstract类：权限修饰符：默认修饰符，public状态修饰符：final抽象修饰符：abstract用的最多的就是public成员变量：权限修饰符：private，默认修饰符，protected，public状态修饰符：static，final用的最多的就是，private构造方法：权限修饰符：private，默认修饰符，protected，public用的最多的就是public成员方法：权限修饰符：private，默认修饰符，protected，public状态修饰符：static，final抽象修饰符：abstract用的最多的就是public除此以外的组合规则：成员变量：public static final成员方法：public staticpublic abstractpublic final类初始化过程类初始化过程加载class文件进内存在栈内存开辟空间在对内存为类对象开辟空间对对象的成员变量进行默认初始化对对象的成员变量进行显示初始化通过构造方法对对象的成员变量赋值对象初始化完毕，吧对象地址复制给变量对象析构与finalize方法：在析构器中最常见的操作是回收分配给对象的存储空间，但Java不支持析构器，可以为任何一个类添加finalize方法，将在垃圾回收器清除对象之前调用。动态绑定：调用对象方法的执行过程：编译器查看对象的声明类型和方法名编译器查看调用方法时提供的参数类型如果是private方法、static方法、final方法、或者构造器，那么编译器将准备的知道该调用哪个方法，这种调用方式为静态绑定。调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。当程序运行时，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。虚拟机为了节省开销和时间，为每个类预先创建了一个方法表。内部类把类定义在其他类的内部，这个类就被称为内部类1234class Outer&#123; class Inner&#123; &#125;&#125;内部类的访问特点内部类可以直接访问外部类的成员，包括私有外部类要访问内部类的成员，必须创建对象123456789101112class Outer&#123; private int num = 10; class Inner&#123; public void show()&#123; System.out.println(num); &#125; public void method()&#123; Inner i = new Inner(); i.show(); &#125; &#125;&#125;内部类位置：成员位置：在成员位置定义的类，称为成员内部类。局部位置：在局部位置定义的类，称为局部内部类成员内部类：如何直接访问内部类的成员：外部类名.内部类名 对象名 = 外部类对象.内部类对象123456789101112class Outer&#123; private int num = 10; class Inner&#123; public void show()&#123; System.out.println(num); &#125;&#125; class InnerClassDemo&#123; public static void main(Stringp[] args)&#123; Outer.Inner oi = new Outer().new Inner(); &#125; &#125;成员内部类的修饰符：private 为了保证数据的安全性static 为了方便访问数据注意：静态内部类访问的外部类数据必须用静态修饰成员内部类被静态修饰后的访问方式是：格式：外部类名.内部类名 对象名 = new 外部类名.内部类名();12345678910111213141516171819202122class Outer&#123; private int num = 10; private static int num2 = 100; public static class Inner&#123; public void show()&#123; System.out.println(num2); &#125; public static void show2()&#123; System.out.println(num2); &#125; &#125;&#125;class InnerClassDemo&#123; public static void main(String[] args)&#123; Outer.Inner oi = new Outer.Inner(); oi.show(); oi.show2(); //show2另一种调用方式 Outer.Inner.show2(); &#125;&#125;局部内部类：可以直接访问外部类的成员在局部位置，可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能面试题：局部内部类访问局部变量的注意事项？局部内部类访问局部变量必须用final修饰为什么呢？局部变量是随着方法的额调用而调用，随着调用完毕而消失。而堆内存的内容并不会立即消失，所以我们加final修饰。加入final修饰后，这个变量就常量。123456789101112class Outer&#123; private int num = 10; public void method()&#123; class Inner&#123; public void show()&#123; System.out.println(num); &#125; &#125; Inner i = new Inner() i.show(); &#125;&#125;匿名内部类就是内部类的简化写法前提：存在一个类或者接口这里的类可以是具体类也可以是抽象类格式：123new 类名或者接口名()&#123;重写方法;&#125;本质是什么呢？是一个继承了该类或者实现了该接口的子类匿名对象123456789101112interface Inter&#123; public abstract void show();&#125;class Outer&#123; public void method()&#123; new Inter()&#123; public void show()&#123; System.out.println("show"); &#125; &#125;; &#125;&#125;匿名内部类的方法调用调用一个方法：123456789101112interface Inter&#123; public abstract void show();&#125;class Outer&#123; public void method()&#123; new Inter()&#123; public void show()&#123; System.out.println("show"); &#125; &#125;.show(); &#125;&#125;调用多个方法：12345678910Inter i = new Inter()&#123;//多态 public void show()&#123; System.out.println("show"); &#125; public void show2()&#123; System.out.println("show2"); &#125;&#125;;i.show();i.show2();匿名内部类在开发中的应用：1234567891011121314151617181920212223242526272829303132333435interface Person&#123; public abstract void study();&#125;class PersonDemo&#123; //接口名作为形式参数 //这里需要的不是接口，而是接口的实现类的对象 public void method(Person p)&#123; p.study(); &#125;&#125;//实现类class Student implements Person&#123; public void study()&#123; System.out.println("好好学习，天天向上"); &#125;&#125;class InnerClassDemo&#123; public static void main(String[] args)&#123; //测试 PersonDemo pd = new PersonDemo(); Person p = new Person(); pd.method(p); Systemout.println("------"); //匿名内部类在开发中的使用 //匿名内部类的本质是继承类或者实现了接口的子类匿名对象 pd.method(new Person()&#123; public void study()&#123; System.out.println("好好学习，天天向上"); &#125; &#125;); &#125;&#125;内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据内部类可以对同一个包中的其他类隐藏起来当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷内部类可以直接访问外部类的成员，包括私有外部类要访问内部类的成员，必须创建对象内部类的位置:成员位置:成员内部类外部类名.内部类名 对象名 = 外部类对象.内部类对象private:私有。 外部类创建方法，方法内创建对象，调用内部类方法。Static(为了方便访问数据)内部类用静态修饰是因为内部类可以看出是外部类的成员,内部类被静态修饰后，访问外部类数据必须用静态修饰局部位置:局部内部类使用内部类访问对象状态:内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。内部类的特殊语法规则:OuterClass.this:表示外围类引用OuterClass.InnerClass:在外围类的作用域之后，引用内部类局部内部类:局部类不能用public或private访问说明符进行声明。它的作用域被限定在声明这个具备类的块中。局部类有一个优势，即对外部世界可以完全的隐藏起来。可以直接访问外部类成员在局部位置，可以创建内部类对象，通过内部类对象，通过对象内部类方法，来使用局部内部类功能匿名内部类:假如只创建这个类的一个对象，就不必命名，这种类被称为匿名内部类new SuperType(construction parameters){Inner class methods and data}由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器，取而代之的是，将构造器参数传递给超类构造器，尤其是内部类实现接口的时候，不能有任何构造参数。前提:存在一个类或者接口，这里的类可以是具体类也可以是抽象类new 类名或者接口名(){重写方法;}本质是一个继承了该类或者实现了该接口的子类匿名对象静态内部类:有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象，为此，可以将内部类声明为static，以便取消产生的引用]]></content>
      <categories>
        <category>JavaSE面向对象</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-基础语法]]></title>
    <url>%2Fcategory%2FJavaSE-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaSE-基础语法关键字被Java语言赋予特定含义的单词特点：全部小写，goto和const作为保留字存在abstractassertbooleanbreakbytecasecatchcharclassconstcontinuedefaultdodoubleelseenumextendsfinalfinallyfloatforgotoifimplementsimportinstanceofintinterfacelongnativenewpackageprivateprotectedpublicreturnstrictfpshortstaticsuperswitchsynchronizedthisthrowthrowstransienttryvoidvolatilewhile标识符给类、接口、方法、变量等起名的字符序列组成规则：数字、字母、下划线和$（见名知意），不能以数字开头，不能是java中的关键字，区分大小写1234int count = 10;float size01 = 25.0F;double size_02 = 30.23;char size$03 = 'a';常量字面值常量在程序执行过程中，其值不发生改变的量，常量在编译阶段会存入到调用这个常量的方法所在类的常量池中。并且调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。字符串常量“a”、”hello”、等双引号括起来的常量12String s = "a";String s2 = "hello";整数常量1、2、123等数值类型常量12int a = 1;int b = 2;小数常量12.345等小数形式常量1float f = 12.32F;字符常量‘a’、’A’、’0’等用单引号括起来的常量可与是英文字母、数字、标点符号以及由转义序列来表示的特殊字符。’\u0000’表示一个空白字符，即在单引号之间没有任何字符，之所以能这样表示，是因为Java采用Unicode字符集，Unicode字符以\u开头，空白字符在Unicode码表中对应的值为’\u0000’12char c = 'a';char c1 = 'A';布尔常量只有两种值类型的常量：true/false12boolean b = true;boolean b1 = false;自定义常量利用关键字final指示常量，表示这个变量只能被赋值一次，且常量名建议使用全大写1final int MAX_SIZE = 10;变量变量就是程序运行中可变的量，定义格式：数据类型 变量名 = 初始化值;1int a = 10;在Java中，每一个变量属于一种数据类型，在生命变量时，变量所属的类型位于变量之前，变量就是指在程序执行过程中值在某个范围内可以发生改变的量。声明一个变量后，必须使用赋值语句对变量进行显示初始化，变量的声明尽可能靠近变量第一次使用的地方。数据类型1、基本数据类型Java种基本数据类型有4类8种分别为：整数类型数据类型默认值大小取值范围byte08bit == 1byte-128~127short016bit == 2byte-32768~32767int032bit == 4byte-2147483648~2147483647long0L64bit == 8byte-9223372036854775808~9223372036854775807123456789101112//整数byte b = 1;short s = 2;int i = 4;long l = 8L;byte b4 = 3 + 4;/* 这里不报错是因为右边先进行计算，得到数值然后进行判断，是否在byte的范围内， 如果在就不报错，如果不在就报错*///byte b5 = 100+150; 报错浮点数类型数据类型默认值大小取值范围float0.0f32bit == 4byte1.4E-45~3.4028235E38double0.064bit == 8byte4.9E-324~1.7976931348623157E308123456789101112131415//浮点数float f = 4.0F;double d = 8.0;//float f2 = 3.14; 报错/* 可以看到这里会报错，是因为在定义浮点类型数据的时候如果不加修饰符默认是double类型 当double赋值给float，大类型转小类型则会报错*/float f3 = 3.1415F;float f4 = (float) 3.1415; //这里加了强制类型转换，所以也不报错/* 那f3、f4有什么区别吗？ f3定义的是一个float类型，f4最初定义的是一个double类型，然后强制转换成float类型*/字符类型数据类型默认值大小取值范围char‘\u0000’16bit == 2byte0~655312//字符类型char c = 'a';布尔类型数据类型默认值大小取值范围布尔类型false8bit == 1bytetrue/false12//布尔类型boolean bool = false;数据类型转换数据类型转换:(隐式转换)byte、short、char —&gt; int —&gt; long —&gt; float —&gt; doublebyte、short、char之间不参与相互转换，直接转换成int类型参与运算强制类型转换:(强制转换)格式:目标数据类型 变量名 = (目标数据类型) (被转换的数据)强制类型转换会损失精度。2、引用类型底层结构和基本类型差别较大类类型当传入的值是一个类类型时，需要传入的是该类的对象接口类型当传入值是一个接口类型时，需要传入的是该接口的实现类对象数组类型枚举注解运算符算数运算符+、-、*、/、%、++、—++在前，先自增再运算，++在后先运算再自增—同理12345678910a = 3；b = 4；b = a++;//在这里，++在后，先赋值再自增System.out.println("a: "+ a+"b: "+b);//a = 4 , b = 4c = a;c = ++b;System.out.println("b: "+ b+"c: "+c);//b = 5 , c = 5d = c;d = --a + b--;System.out.println("a: "+ a+"b: "+b+"d "+d);//a = 3 , b = 4 , d = 8赋值运算符=、+=、-=、*=、/=、%==代表赋值运算符，将右边的值赋给左边在这里需要注意+=、-=、=、/=、%=。这代表的是一个运算符，相对于+、-、、/，如果在等号两边数据类型不一致时，+=会进行自动类型转换1234byte a = 1;byte b = 2;a = a + b; //这里会报错，因为a和b是byte类型，执行完相加赋值给a时会自动转为int类型，而a是byte类型，就会出现类型不匹配问题这里相当于 a = (int) a + b;a += b; //这里不会报错，+=在运算时会自动进行类型转换总结：+ 、+=举例+：在编译将右边表达式结果计算出来后，和左边的变量类型比较精度，如果左边的精度低于右边的结果的精度，编译器会显式的报错，告诉程序员去强制转型。所以（a = a+b;）会报错，最后将表达式的结果复制到变量所在的内存区+=：编译器自动隐式直接将+=运算符后面的操作数强制装换为前面变量的类型，然后在变量所在的内存区上直接根据右边的操作数修改左边变量内存存储的二进制数值所以 （a += b;）不报错最后达到和赋值运算符相同的目的。与前者相比，由于后者是位操作，效率也较前者高。比较运算符==、！=、&gt;、&lt;、&gt;=、&lt;===代表判断是否相等，比较运算符返回值都是boolean类型在这里需要注意的是，==比较基本数据类型时比较的是值，比较引用类型时比较的是两个对象的地址值逻辑运算符&amp;、|、^、!、&amp;&amp;、||逻辑运算符用来连接boolean类型的表达式&amp;(逻辑与)：有false则false|(逻辑或)：有true则true^(异或)：相同则false，不同则true!(非)：非true则false，非false则true&amp;&amp;(短路与)：和&amp;相同，不过有短路效果，左边是false，右边不执行||(短路或)：和|相同，有短路效果，左边是true，右边不执行位运算符操作二进制&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;、&amp;、|、^、~&lt;&lt;：左移，空位补0，被移除的最高位丢弃3 &lt;&lt; 2 = 12 ——- 3 2 2 = 12.&gt;&gt;：右移，被移位的二进制最高位是0，右移后，空缺位补0，最高位是1.最高位补13 &gt;&gt; 1 = 1 ——- 3/2=1.&gt;&gt;&gt;：无符号右移，被移位二进制最高位无论是0或者是1，空缺位都用0补3 &gt;&gt;&gt; 1 = 1 ——- 3/2=1&amp;：与运算，任何二进制位和0进行&amp;运算，结果是0，和1进行&amp;运算结果是原值6&amp;3=2|：或运算，任何二进制位和0进行|运算，结果是原值，和1进行|运算结果是16|3=7^：异或运算，任何相同二进制位进行^运算，结果是0，不相同二进制位^运算结果是16^3=5一个数据对另外一个数据异或两次，该数不变~：反码~6=-7三元运算符格式：比较表达式?表达式1:表达式2;执行流程：首先计算比较表达式的值，是true就执行表达式1，是false就执行表达式2123int a = 3;int b = 4;a &gt; b ? ++a : ++b;控制流条件语句If(condition) statement这里的条件必须用括号括起来If(condition) statement1 else statement21234567891011public static void main(String[] args)&#123; int a = 3; int b = 4; if(a&gt;b)&#123; a++; &#125;else if(a == b)&#123; a--; &#125;else&#123; b++ &#125;&#125;循环while循环当条件是true时，while循环执行一条语句。While(condition) statement12345public static void main(String[] args)&#123; while(true)&#123; System.out.println("这是一个死循环"); &#125;&#125;do-while循环先执行语句，再检测循环条件Do statement while (condition);123456public static void main(String[] args)&#123; int n = 1; do&#123; System.out.println("我数到第"+n+"个数了"); &#125;while(n&gt;0);&#125;确定循环for(初始化语句;判断条件语句;控制条件语句){循环体语句;}1234567//九九乘法表for (int x = 1; x &lt;= 9; x++) &#123; for (int y = 1; y &lt;= x; y++) &#123; System.out.println(x + "*" + y + "=" + x * y + "\t"); &#125; System.out.println();&#125;for each循环Java有一种功能很强的循环结构，可以用来依次处理数组中的每个元素for(variable: collection) statement多重选择123456789101112131415Switch (chioce)//这里可选择数据类型有：基本数据类型，引用类型String，以及枚举和基本类型的封装类型&#123;case 1:…break;case 2:…break;...defalut:…break;&#125;在这里简单说一下break、continue、return三者的区别？break语句的使用场合主要是switch语句和循环结构。在循环结构中使用break语句，如果执行了break语句，那么就退出循环，接着执行循环结构下面的第一条语句。如果在多重嵌套循环中使用break语句，当执行break语句的时候，退出的是它所在的循环结构，对外层循环没有任何影响。如果循环结构里有switch语句，并且在switch语句中使用了break语句，当执行switch语句中的break语句时，仅退出switch语句，不会退出外面的循环结构。break可以跳出单层循环，也可以跳出多层循环（需要标签语句配合）123456789101112131415161718int n = 1;do&#123; System.out.println("我数到第"+n+"个数了"); break;//这里可以看到，break跳出do-while循环，接着执行while循环&#125;while(n&gt;0);while(n&lt;100)&#123; System.out.println("这是一个循环"); n++;&#125;//输出结果/*我数到第1个数了这是一个循环这是一个循环这是一个循环...*/continue语句是最特殊的，因为它并没有真的退出循环，而是只结束本次循环体的执行，所以在使用continue的时候要注意这一点。在for循环中，首先执行表达式1（注意表达式1在整个循环中仅执行一次），接着执行表达式2，如果满足条件，那么执行循环体，如果在循环体中执行了continue语句，那么就跳转到表达式3处执行，接下进行下一次循环，执行表达式2，看是否满足条件；在while循环中，如果执行了continue语句，那么就直接跳转到表达式处，开始下一次的循环判断；在do while循环体中如果执行了continue语句，那么就跳转到表达式处进行下一次的循环判断，return语句，如果在程序中遇到return语句，那么代码就退出该函数的执行，返回到函数的调用处，如果是main()函数，那么结束整个程序的运行。JavaSE12扩展Switch语句大数值如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类:BigInteger和BigDecimal。前者实现了任意精度的整数运算，后者实现了任意精度的浮点数运算。使用静态的valueOf方法可以将普通的数值转换为大数值处理大数值用大数值类中的add和multiply方法。123BigInteger a = BigInteger.valueOf(100);BigInteger c = a.add(b); //c=a+b;BigInteger d = c.multiply(b.add(BigInteger.valueOf(2)));//d=c*(b+2)BigInteger：任意精度的整数运算BigDecimal：任意精度的浮点数运算12345678910111213141516171819202122232425262728293031/*** 下面的方法都来自：java.math.BigInteger 包*/BigInteger add(BigInteger other)BigInteger subtract(BigInteger other)BigInteger multiply(BigInteger other)BigInteger divide(BigInteger other)BigInteger mod(BigInteger other)/* 返回这个大整数和另一个大整数 other 的和、差、积、商以及余数 */int compareTo(BigInteger other)/* 如果这个大整数与另一个大整数 other 相等，返回 0；如果这个大整数小于另一个大整数 other，返回负数；否则，返回正数 */static BigInteger valueOf(long x)/* 返回值等于 x 的大整数 */BigDecimal add(BigDecimal other)BigDecimal subtract(BigDecimal other)BigDecimal multiply(BigDecimal other)BigDecimal divide(BigDecimal other)/* 返回这个大实数和另一个大实数 other 的和、差、积、商。在此，需要注意的是：想要计算商，必须给出舍入方式，例如 RoundingModel.HALF_UP */int compareTo(BigDecimal other)/* 如果这个大实数与另一个大实数 other 相等，返回 0；如果这个大实数小于另一个大实数 other，返回负数；否则，返回正数 */static BigDecimal valueOf(long x)static BigDecimal valueOf(long x, int scale)/* 返回值等于 x 或者 x/10^(scale) 的大实数 */进制进制也就是进位制，是人们规定的一种进位方法。对于任何一种进制—-X进制，就表示某一位置上的数运算时是逢X进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x进制就是逢x进位。二进制用8个这样的信号来表示一个数据，这个数据的单位叫做：字节1 byte = 8 bit1k = 1024byte1m = 1024k通过数字1,0来表示开关，这样由1,0组成的数据就是二进制数据二进制数有两个特点：它由两个基本数字0，1组成，二进制数运算规律是逢二进一。为区别于其它进制数，二进制数的书写通常在数的右下方注上基数2，或加后面加B表示。例如：二进制数10110011可以写成（10110011）2，或写成10110011B八进制把二进制的数据，从右开始，每三位一组合，最左边不够的时候，补0。然后分别计算出对应的十进制数值，最后，再把每个十进制数据组合起来，就是一个八进制数据。十进制人们通常使用的是十进制。它的特点有两个：有0，1，2….9十个基本数字组成，十进制数运算是按“逢十进一”的规则进行的.十六进制把二进制的数据从右开始，每四位一组合，最左边不够的时候补0.然后分别进算出对应的的十进制数值，最后，再把每个十进制数据组合起来，就是一个十六进制数据。不同进制的组成二进制由0,1组成，以0b开头八进制由0,1…7组成，以0开头十进制由0,1…9组成，整数默认是十进制十六进制由0,1…9,a,b,c,d,e,f(大小均可)组成，以0x开头进制转换其他进制到十进制的转换十进制到其他进制的转换8421码（进制的快速转换）有符号数据表示在计算机内，有符号数由3种表示法：原码、反码和补码。所有的数据的运算都是采用补码进行的。原码就是二进制定点表示法，即最高位为符号位，”0“表示正，”1“表示负，其余位表示数值大小。反码正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。补码正数的补码与其原码相同；负数的补码是在其反码的末位+1。+7、-7的原码反码补码表示：]]></content>
      <categories>
        <category>JavaSE基础语法</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-面向对象]]></title>
    <url>%2Fcategory%2FJavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象对象与类类类是构造对象的模板或蓝图，类可以看作是一组对象的集合。一类事物的抽象。举个很简单的例子，经常会听到很多人说：“我不是那类人”。比如那一类就可以理解为“类”。那对象呢，对象就是”我“。在类与类之间，最常见的关系有：依赖（uses-a）、聚合（has-a）、继承（is-a）对象由类构造对象的过程称为创建类的实例，而这个示例就是对象，对于每个特定的类实例（对象）都有一组特定的实例域值，这些值的集合就是这个对象的当前状态。对象中的数据称为实例域，操作数据的过程称为方法。对象的三个主要特征：对象的行为，对象的状态，对象标识对象状态的改变必须通过调用方法实现作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。要想使用对象，必须首先构造对象，并指定其初始状态，然后对对象应用方法。在Java中，使用构造器构造新实例。构造器是一种特殊的方法，用来构造并初始化对象，构造器的名字应该与类名相同。一个对象变量并没有实际包含一个对象，而仅仅引用一个对象，任何对象变量的值都是对存储在另外一个地方的一个对象的引用，new操作符的返回值也是一个引用。如果将一个方法应用于一个值为null的对象上，就会产生错误。局部变量不会自动初始化为null，必须通过调用new或将他们呢设置为null进行初始化对象内存图在Java1.8之后永久区（PremGen）没有，方法区改为MetaSpace物理内存具体可以看这篇文章：Java内存区域与Java对象成员变量与局部变量定义这个对象的信息成员变量与局部变量的区别在类中位置在内存中位置生命周期初始化值成员变量在类中方法外在堆内存随着对象创建而存在，随着对象消失而消失有默认初始化值局部变量在方法内或者方法声明上在栈内存随着方法调用而存在，随着方法调用完毕而消失没有默认初始化值，必须先定义赋值再使用注意：当局部变量名称和成员变量名称一致时，采用就近原则1234567891011121314public class Cat &#123; String name;//默认值为null int age;//默认值为0 int num;//默认值为0 public static void main(String[] args) &#123; int num = 3;//局部变量 System.out.println("这里有"+num+"只小猫");//输出为3 Cat c = new Cat();//创建Cat对象 c.name="大大"; c.age=18; System.out.println(c.name+c.age);//大大18 &#125;&#125;方法方法就是函数，函数在Java中被称为方法。方法是完成特定功能的代码块方法在内存中位于方法区方法是随着调用才会加载方法与方法是平级关系，不能嵌套定义方法定义时候参数之间用逗号隔开方法调用升级后不用再传递数据类型如果方法有明确返回值，一定要有return带回一个值格式：修饰符 返回值类型 方法名 (参数类型 参数名1,参数类型 参数名2…){函数体; return 返回值;}1234567public void eat(String name,Date date)&#123; System.out.println(date+"吃了"+name);&#125;public String MyName(String firstName,String lastName)&#123; String myname = firstName+lastName; return myname;&#125;方法的重载在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可特点：与返回值类型无关，只看方法名和参数列表，在调用时虚拟机通过参数列表的不同来区分同名方法1234567891011public class Cat &#123; String name; int age; int num; public void eat()&#123; System.out.println("猫吃鱼"); &#125; public void eat(String name)&#123; System.out.println("猫吃"+name); &#125;&#125;形参与实参形参：方法被调用时需要传递进来的参数，如：show(int a)中的a，它只有在show被调用期间a才有意义，也就是会被分配内存空间，在方法show执行完成后，a就会被销毁释放空间，也就是不存在了实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。12345678public static void show(int a) &#123; a = 20; System.out.println(a);&#125;public static void main(String[] args) &#123; int a = 10;//实参 show(a);&#125;int a=10;中的a在被调用之前就已经创建并初始化，在调用show方法时，他被当做参数传入，所以这个a是实参。而show(int a)中的a只有在show被调用时它的生命周期才开始，而在show调用结束之后，它也随之被JVM释放掉，，所以这个a是形参。当形式参数和返回值类型是引用类型时会和基本类型不同：形参和返回值是类类型：实际传入的是该类对象形参和返回值是抽象类：实际传入的是该抽象类的子类对象形参和返回值是接口：需要的是该接口的实现类对象Java到底是值传递还是传引用？首先在Java里面有两种数据类型，基本数据类型与引用类型。基本类型直接保存在变量中，引用类型变量保存的只是实际对象的地址，一般这种变量为”引用“，引用指向实际对象，实际对象中保存着内容。按值调用(call by value):表示方法接收的是调用者提供的值按引用调用(call byreference):表示方法接收的是调用者提供的变量地址一个方法不能修改一个基本数据类型的参数（数值型和布尔型）一个方法可以改变一个对象参数的状态一个方法不能让对象参数引用一个新的对象一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。Java语言总是采用按值调用，也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。按引用调用，方法得到是对象引用及其他的拷贝同时引用同一个对象。12int num = 1;//变量num保存着1这个值int[] arr = new int[5];//变量arr在栈内存保存的是这个数组在堆内存的地址值，这个地址值引用堆内存的数组实际值=：表示赋值运算符，对于基本数据类型，赋值运算符会直接改变变量的值，原本的值被覆盖，对于引用类型，赋值运算符改变引用中的地址值，而不是在堆内存的实际值。1int[] arr = new int[3];//这里并不会改变原本数组的值，而只是把新数组的引用赋值给arr局部变量和方法参数在jvm中的储存方法是相同的，都是在栈上开辟空间来储存的，随着进入方法开辟，退出方法回收。以32位JVM为例，boolean/byte/short/char/int/float以及引用都是分配4字节空间，long/double分配8字节空间。对于每个方法来说，最多占用多少空间是一定的，这在编译时就可以计算好。我们都知道JVM内存模型中有，stack和heap的存在，但是更准确的说，是每个线程都分配一个独享的stack，所有线程共享一个heap。对于每个方法的局部变量来说，是绝对无法被其他方法，甚至其他线程的同一方法所访问到的，更别说修改。当我们在方法中声明一个 int i = 0，或者 Object obj = null 时，仅仅涉及stack，不影响到heap，当我们 new Object() 时，会在heap中开辟一段内存并初始化Object对象。当我们将这个对象赋予obj变量时，仅仅是stack中代表obj的那4个字节变更为这个对象的地址。当我们声明一个数组时，如int[] arr = new int[10]，因为数组也是对象，arr实际上是引用，stack上仅仅占用4字节空间，new int[10]会在heap中开辟一个数组对象，然后arr指向它。当我们声明一个二维数组时，如 int[][] arr2 = new int[2]4]，arr2同样仅在stack中占用4个字节，会在内存中开辟一个长度为2的，类型为int[]的数组，然后arr2指向这个数组。这个数组内部有两个引用（大小为4字节），分别指向两个长度为4的类型为int的数组。所以当我们传递一个数组引用给一个方法时，数组的元素是可以被改变的，但是无法让数组引用指向新的数组。那Java是如何存储各种类型的数据呢？Java语言并不能操纵内存，一切都是由JVM来管理控制的，因此Java内存区域的划分也就是JVM的区域划分。详细底层可以参考：Java的值传递和引用传递匿名对象匿名对象就是没有名字的对象（是对象的一种简化表示形式）匿名对象调用完毕就是垃圾，可以被垃圾回收器回收。匿名对象可以作为实际参数传递对象调用方法仅仅一次的时候：12345678910//带名字的调用Student s = new Student();s.show();s.show();System.out.println("-------");//匿名对象调用方法new Student().show();new Student().show();//不同的是，这里是创建了一个新的对象，并不是一个对象调用两次//对于匿名对象，任何时候使用==比较，返回值是falseSystem.out.println("-------")作为实际参数传递：123StudentDemo sd = new StudentDemo();sd.method(new Student());//这里是method方法参数是一个学生类对象，这里使用匿名对象传入new StudentDemo().method(new Student());//链式编程，等同于上面this关键字代表所在类的对象引用方法被哪个对象调用，this就代表哪个对象当局部变量隐藏成员变量，可以使用thisthis可以看作是一个变量，它的值是当前对象的引用12345678910111213141516171819202122public class Dog &#123; int age; public Dog(int age) &#123; this.age = age;//这个age是形参age，就近原则 /* 这里的this是区分局部的形参age和成员变量this， 这个this.age相当于Dog d = new Dog;d.age; */ &#125; public Dog growDog()&#123;//这个方法需要一个Dog对象的返回值 age++; return this;//this相当于Dog类的对象 &#125; public void ageNow()&#123; System.out.println("今年我"+age+"岁了"); &#125; public static void main(String[] args) &#123; Dog d = new Dog(3); d.growDog().ageNow(); //这里可以说是一个链式编程，创建dog类对象调用growDog方法，返回dog类对象再调用ageNow方法 &#125;&#125;这个程序执行流程详解：由上可以看出来，this一般出现在方法里，代表调用者，一开始this并不确定是谁，只有当谁调用了这个方法或者谁创建了这个对象，那么this就代表谁。final关键字final：最终的意思。常见的是它可以修饰类，方法，变量。特点：final可以修饰类，该类不能被继承。final可以修饰方法，该方法不能被重写。（覆盖，复写）final可以修饰变量，该变量不能被重新赋值，因为这个变量其实是常量。当final修饰局部变量的问题：基本类型：基本类型的值不能发生改变引用类型：引用类型的地址值不能发生改变，但是该对象堆内存的值可以改变123456789101112131415public static void main (String[] args)&#123; int x = 100; x = 200; System.out.println("x:"+x);//x:200 final int y = 300; //y = 400; 报错，无法为最终变量赋值 Student s = new Student();//Student类里有一个final int age = 10; System.out.println(s.age); //s.age = 20;报错 final Student ss = new Student();//final修饰引用类型，去掉Student上age的final ss.age = 100; //重新分配内存空间 //ss = new Student(); 报错&#125;final修饰变量的初始化时机：被final修饰的变量只能赋值一次在构造方法完毕前(非静态常量)1234567891011class finalDemo()&#123; int num; final int num2; &#123; //num2 = 20;报错 &#125; public finalDemo()&#123; num = 10; //num2 = 20;报错 &#125;&#125;由于继承中方法有一个现象：方法重写所以父类的功能就会被子类给覆盖掉。有时候我们不想让子类去覆盖掉父类的功能，只能让他使用。这个时候，针对这种情况，Java就提供了一个关键字：finalstatic关键字针对多个对象有共同的相同的成员变量值的时候，Java就提供了一个关键字来修饰：staticstatic的特点：（可以修饰成员变量、成员方法）随着类的加载而加载优先于对象存在被类的所有对象共享可以通过类名调用（也可以通过对象名-一般不选择这种）静态修饰的内容一般我们称其为：与类相关的，类成员static关键字注意事项：在静态方法中是没有this关键字的静态是随着类的加载而加载，this是随着对象的创建而存在。静态比对象先存在静态方法只能访问静态的成员变量和静态的成员方法静态方法：成员变量：只能访问静态变量成员方法：只能访问静态成员方法非静态方法：成员变量：可以是静态的，也可以是非静态的成员方法：可以是静态的成员方法，也可以是非静态的成员方法静态只能访问静态静态变量和成员变量的区别：所属不同静态变量属于类，所以也称为类变量成员变量属于对象，所以也称为实例变量（对象变量）内存中位置不同静态变量存储于方法区的静态区成与变量存储于堆内存内存出现时间不同静态变量随着类的加载而加载，随着类的消失而消失成员变量随着对象的创建而存在，也可以通过对象调用调用不同静态变量可以通过类名调用，也可以通过对象调用成员变量只能通过对象名调用构造方法给对象的数据进行初始化格式：方法名与类名相同没有返回值类型，连void都没有没有具体的返回值构造方法的注意事项：如果我们没有给出构造方法，系统将自动提供一个无参构造方法如果我们给出了构造方法，系统将不再提供默认的无参构造方法如果我们还想使用无参构造方法，就必须自己给出。建议永远给出给成员变量赋值有两种方式：setXxx()构造方法类的组成成员变量构造方法成员方法：根据返回值：void与非void根据形式参数列表：空参与非空参Student类初始化过程：类初始化过程：加载class文件进内存在栈内存开辟空间在对内存为类对象开辟空间对对象的成员变量进行默认初始化对对象的成员变量进行显示初始化通过构造方法对对象的成员变量赋值对象初始化完毕，吧对象地址复制给变量对象析构与finalize方法：在析构器中最常见的操作是回收分配给对象的存储空间，但Java不支持析构器，可以为任何一个类添加finalize方法，将在垃圾回收器清除对象之前调用。动态绑定：调用对象方法的执行过程：编译器查看对象的声明类型和方法名编译器查看调用方法时提供的参数类型如果是private方法、static方法、final方法、或者构造器，那么编译器将准备的知道该调用哪个方法，这种调用方式为静态绑定。调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。当程序运行时，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。虚拟机为了节省开销和时间，为每个类预先创建了一个方法表。什么时候定义成员变量：如果这个变量是用来描述这个类的信息的，那么该变量就应该定义为成员变量变量的范围越小越好，因为能及时收回main方法格式：代码块在Java中，使用{ }括起来的代码被称为代码块根据其位置和声明不同，可以分为局部代码块：局部位置，用于限定变量的生命周期，及早释放，提高内存利用率构造代码块在类中的成员位置，用{ }括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。作用：可以把多个构造方法中的共同代码放到一起，对对象进行初始化。静态代码块：在类中的成员位置，用{ }括起来的代码，只不过它用static修饰了对类的数据进行初始化，仅仅只执行一次作用：一般是对类进行初始化面试题：静态代码块，构造代码块，构造方法的执行顺序？静态代码块 — 构造代码块 — 构造方法静态代码块：只执行一次构造代码块：每次调用构造方法都执行]]></content>
      <categories>
        <category>JavaSE面向对象</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloJava]]></title>
    <url>%2Fcategory%2FHelloJava%2F</url>
    <content type="text"><![CDATA[-&gt;HelloJava!Goya：Java是一门伟大的艺术，至少在我看来是的了，也许如果没有Java出现会出现别的类似编程语言，但是因为它的存在，促进了互联网的&gt;发展。当我第一次接触Java是在初中，那时候有的塞班系统的手机上会出现一个Java的一些小游戏或者小应用，回忆中的样子应该是如此。到了大学，大二开始学习Java知道了这门著名的编程语言。那时候老师也不会将很多学习Java先要了解的一些知识，只是告诉你James Gosling发明了Java，并且在Sun公司，之后Sun被Oracle收购等等一些常识。然后便开始了Java语言的学习，那时候只知道按部就班的安装那些必备软件，然后开始敲。学习Java我认为首先需要了解一下什么是Java？它用来干什么？它怎么实现的？它发展是什么？我想在这个大时代背景下，程序员，编程，代码几乎人人皆知。而退十年来讲，都是陌生的。随着时代的发展，让这些一部分人知道的事务变成众人皆知的事务，这就是互联网的进步以及大时代的笼罩下造成的氛围。你离开了这些就仿佛一个原始人，这么说也许太片面，但离了这些产品那真的会回退一个时代。很多人都说互联网时代已经告去，大数据人工智能时代来临并飞速发展，那么怎么来，靠什么发展。我想这就是为什么电子信息专业的火爆以及许多人认为的“高薪资”。那什么是Java在1990年代之前，比较熟知的C、C++、SQL等著名语言被开发在1990年代，推动编程语言发展的思想则是“提升程序员的生产力”，出现了很多快速应用程序开发，这些语言大都有相应的集成开发环境，也大多是面向对象的编程语言。像Java、Python、Ruby、Visual Basic、JavaScript、PHP等。而Java的出现则更加保守。所以Java的产生可以理解为一门可以提高程序员生产力的语言。而那时候的Java叫Oak，是为了服务家用电器等小型系统的编程语言。但那时候这种智能化电器则不像现在般火爆。于是Sun便开始改造。摘自维基百科：Java编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在Java SE 1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装/拆箱特性。Sun对Java语言的解释是：“Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”Java不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了Java程序的运行效率。但在J2SE1.4.2发布后，Java的运行速度有了大幅提升。与传统类型不同，Sun公司在推出Java时就将其作为开放的技术。全球的Java开发公司被要求所设计的Java软件必须相互兼容。“Java语言靠群体的力量而非公司的力量”是Sun公司的口号之一，并获得了广大软件开发商的认同。这与微软公司所倡导的注重精英和封闭式的模式完全不同，此外，微软公司后来推出了与之竞争的.NET平台以及模仿Java的C#语言。后来Sun公司被甲骨文公司并购，Java也随之成为甲骨文公司的产品。总结下来就是Java是一个面向对象的拥有“简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”这些特点的语言。并且是一门开源语言（开放源代码全世界人学习或者修改加入自己的想法，但是Sun公司拥有Java的一部分权力）那么首先我们可以分析一下，什么是编程语言：编程语言是用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。所以Java就是一门我们可以根据Java的语法规则写出来的代码，它来编译成计算机识别的指令来操作计算机或者其他设备的语言。那么Java如何识别我们写的代码再编译成计算机识别的指令呢？举一个例子：我们写一个HelloWorld.java这个时候可以不用纠结这些看不懂12345class HelloWorld&#123; public static void main (String[] args)&#123; System.out.println("HelloWorld!"); &#125;&#125;然后通过控制台执行javac可以看到在HelloWorld.java同级目录生成一个.class文件接着执行java命令可以看到我们写的代码被计算机所解释编译执行，输出HelloWorld那么这个javac是什么呢？当安装好jdk后可以在jdk安装目录bin文件夹下看到这个脚本。它是用来编译java程序的源代码，但是它本质是基于jdk标准类库中的javac类库实现，所以java的编译器实质是一个java程序javac又被称为前端编译器，仅负责源代码与字节码之间的转换，而在jvm内部还存在一个后置编译器（根据热点探测技术，可以将最有价值的字节码转换为机器码执行从而提升java程序的运行效率）javac 的意义就在于 将源码编译为字节码，同时做一些词法，语法，语义上的检查，最后生成可供jvm运行的字节码文件。可以在lib中的tools jar包中sun.tools.javac;包下管理者java前端编译器的class文件，Main类中的main方法执行的是javac程序的执行入口。同时在bin目录下可以看到很多脚本文件，比如java、javaw等那这个.class文件又是什么呢？.class文件又称字节码文件，它就是java帮我们进行的第一道翻译工作后的结果，这道翻译工作就是javac，可以理解为将源码编译为字节码，同时做一些词法，语法，语义上的检查，最后生成的.class文件供jvm运行。这一过程就叫编译，更准确的是称为前端编译。.class文件也就是前端编译产生的代码。前端编译：词法分析：词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，将字符序列转换为标记（token）序列的过程。这里的标记是一个字符串，是构成源代码的最小单位。在这个过程中，词法分析器还会对标记进行分类 。词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。语法分析：语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述。将源代码中的字符流构造成抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方法。填充符号表： 符号表是一组符号地址和符号信息构成的表格。注解处理器处理：我们平时使用的Java注解，本质就是用来对语法树做出修改，处理器的任务便是在编译是识别出这些注解同时修改抽象语法树。语义分析与字节码生成：语义分析是编译过程的一个逻辑阶段， 语义分析的任务是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。语义分析的一个重要部分就是类型检查。比如很多语言要求数组下标必须为整数，如果使用浮点数作为下标，编译器就必须报错。再比如，很多语言允许某些类型转换，称为自动类型转换。标注检查：语义分析的第一个步骤，用来检查包括诸如使用的变量是否已经声明、变量与赋值之间的数据类型是否能够匹配。其中有一个重要的步骤就是常量折叠如：int a = 3 + 2， javap查看生成的class字节码，iconst指令向操作数栈中压入的是常量值5，这样在运行时期就不会CPU的运算量重新计算。数据及控制流分析用于检查诸如局部变量在使用前是否已经赋值，方法的每条路径上是否都有返回值，受查异常是否都被正常处理等问题。解语法糖（desugar）Java中我们经常使用的语法糖有泛型、自动装箱/拆箱、遍历循环、条件编译等.. 由于这些语法在运行时无法被识别，因此需要在编译阶段就将他们还原回简单的基础语法结构。泛型泛型的本质是参数化类型的应用，参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。在Java中，泛型只在源码中存在，一旦经常编译，就会替换成原来的原生类型并且在相应的地方加上了强制类型转换代码。这一过程也叫做类型擦除自动装箱/拆箱基本类型自动装箱成包装类型，包装类型拆箱成基本类型，大多数Java程序员都已经了解。只是使用上有些地方需要注意，比方包装类型在使用“==”进行比较时，只有遇到算术运算时才会自动拆箱。遍历循环诸如 for(int i : list) {} 这样的loop循环在编译后都会转换成对数据结构iterator的调用条件编译对于if和常量搭配使用，在编译器发现不会执行到的语句块，将不会出现在编译之后的class文件当中生成字节码class文件在Compiler生成class文件时，不仅仅将前面步骤生成的信息转化成字节码，还会进行少量的代码添加和转换工作，如和就是在该阶段添加进class文件当中，如果Compiler发现代码中没有任何构造器，那么将会添加一个无参数的、访问性与当前类一致的构造器（也即经常所说的默认无参构造器）后端编译在Java中，javac执行的结果就是得到一个字节码，而这个字节码其实就是一种中间代码。然后得到的class文件并不能被机器所识别。这个时候就通过JVM来解释字节码，将其翻译成对应的机器指令，逐条读入，逐条解释执行，这是传统的JVM解释器的功能，为了解决这种效率问题，引入了JIT技术。（即使编译器）深入浅出JIT编译当JVM通过类加载器加载class文件里的字节码后，会通过解释器解释称汇编指令最终再转译成CPU可以识别的机器指令，解释器是软件来实现的，主要是为了实现同一份 Java 字节码可以在不同的硬件平台上运行，而将汇编指令转换成机器指令由硬件直接实现。从软件层面上， class 文件被加载进虚拟机后，类信息会存放在方法区，在实际运行的时候会执行方法区中的代码，在 JVM 中所有的线程共享堆内存和方法区，而每个线程有自己独立的 Java 方法栈，本地方法栈（面向 native 方法），PC寄存器（存放线程执行位置），当调用一个方法的时候， Java 虚拟机会在当前线程对应的方法栈中压入一个栈帧，用来存放 Java 字节码操作数以及局部变量，这个方法执行完会弹出栈帧，一个线程会连续执行多个方法，对应不同的栈帧的压入和弹出，压入栈帧后就是 JVM 解释执行的过程了。JAVA程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。当 JVM 执行代码时，它并不立即开始编译代码。首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。在机器上，执行java -version命令就可以看到自己安装的JDK中JIT是哪种模式:热点检测上面我们说过，要想触发JIT，首先需要识别出热点代码。目前主要的热点代码识别方式是热点探测（Hot Spot Detection），有以下两种：基于采样的方式探测（Sample Based Hot Spot Detection) ：周期性检测各个线程的栈顶，发现某个方法经常出险在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因干扰热点探测。基于计数器的热点探测（Counter Based Hot Spot Detection)。采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。方法计数器。顾名思义，就是记录一个方法被调用次数的计数器。回边计数器。是记录方法中的for或者while的运行次数的计数器。编译优化前面提到过，JIT除了具有缓存的功能外，还会对代码做各种优化。说到这里，不得不佩服HotSpot的开发者，他们在JIT中对于代码优化真的算是面面俱到了。经过前端编译与后端编译，最终我们的java文件被机器所执行。JDK、JRE与JVM：JDKJava Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。最主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了属于自己的JDK。JDK有以下三种版本：J2SE， standard edition，标准版，是我们通常用的一个版本J2EE， enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序J2ME，micro edtion，主要用于移动设备、嵌入式设备上的java应用程序JREJava Runtime Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。JVM我们刚生成的.class文件就是通过jvm来编译执行Java Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的组成包括 JVM 指令集，符号表以及一些补助信息。至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
</search>
