<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从零开始Intellij的使用]]></title>
    <url>%2Fcategory%2FIntelij%2F</url>
    <content type="text"><![CDATA[IDEAIDEA的主要优势(相较于Eclipse而言)强大的整合能力，比如Git、Maven、Spring等提示功能的快速、便捷提示功能的范围广好用的快捷键和代码模板精准搜索…IDEA的目录结构bin：容器，执行文件和启动参数help：快捷键文档和其他帮助文档jre64：64位java运行环境lib：idea依赖的类库license：各个插件许可plugin：插件设置目录结构：config目录是Intellij个性化设置目录system目录是Intellij系统文件目录IDEA的使用如何调整VM配置文件创建Java工程Create New Project：创建一个新的工程Import Project：导入一个现有工程Open：打开一个已有工程Check out form Version Control： 可以通过服务器上的项目地址 check out Github 上面项目或其他 Git 托管服务器上的项目设置显示常见的视图Module:模块在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module。一个 Project IntelliJ IDEA 的安装、配置与使用 可以有多个 Module。目前主流的大型项目都是分布式部署的，结构都是类似这 种多 Module 结构。这类项目一般是这样划分的，比如：core Module、web Module、plugin Module、 solr Module 等等，模块之间彼此可以相互依赖。通过这些 Module 的命名也可 以看出，他们之间都是处于同一个项目业务下的模块，彼此之间是有不可分割的 业务关系的。相比较于多 Module 项目，小项目就无需搞得这么复杂。只有一个 Module 的 结构 IntelliJ IDEA 也是支持的，并且 IntelliJ IDEA 创建项目的时候，默认就是单 IntelliJ IDEA 的安装、配置与使用 Module 的结构的。如何删除模块查看项目配置：常用配置Appearance &amp; Behavior设置主题设置窗体及菜单的字体及字体大小(可忽略)设置编辑区主题(可忽略)Idea默认提供了两个编辑区主题，可以通过如下的方式进行选择如果想要更多的主题效果，可以到如下网站下载：主题下载以后，导入主题file - &gt; import settings - &gt; 选中下载的主题jar文件 -&gt; 一路确认 - &gt; 重启Editor - General设置鼠标滚轮修改字体大小(可忽略)可以增加 Ctrl + 鼠标滚轮 快捷键来控制代码字体大小写显示设置鼠标悬浮提示设置自动导包功能Add unambiguous imports on the fly：自动导入不明确的结构Optimize imports on the fly：自动帮我们优化导入的包设置显示行号和方法间的分隔符如上图红圈所示，可以勾选Show line numers：显示行数，建议一般勾选上Show method separators：显示方法分隔线，有助于区分开方法，建议勾选忽略大小写提示IDEA的代码提示和补充功能有一个特性，区分大小写，如上图标注所示，默认就是First letter区分大小写的。新版：2019-1-3这样修改设置取消单行显示tabs的操作Editor - Font设置默认的字体、字体大小、字体行间距Editor - Color Scheme修改当前字体、字体大小、字体行间距(可忽略)如果当前主题不希望使用默认字体、字体大小、字体行间距、还可以单独设置修改当前主题的控制台输出的字体及字体大小(可忽略)修改代码中注释的字体颜色Doc Comment-Text：修改文档注释的字体颜色Block Comment：修改多行注释的字体颜色Line Comment：修改单行注释的字体颜色Editor - Code Style设置超过指定import个数，改为*，(可忽略)Editor - File and Code Templates修改类头的文档注释信息/** @author shkstart @create ${YEAR}-${MONTH}-${DAY} ${TIME} *///常用的预设的变量，这里直接贴出官网给的：123456789101112131415$&#123;PACKAGE_NAME&#125; - the name of the target package where the new class or interface will be created. $&#123;PROJECT_NAME&#125; - the name of the current project. $&#123;FILE_NAME&#125; - the name of the PHP file that will be created.$&#123;NAME&#125; - the name of the new file which you specify in the New File dialog box during the file creation. $&#123;USER&#125; - the login name of the current user. $&#123;DATE&#125; - the current system date. $&#123;TIME&#125; - the current system time. $&#123;YEAR&#125; - the current year. $&#123;MONTH&#125; - the current month. $&#123;DAY&#125; - the current day of the month. $&#123;HOUR&#125; - the current hour. $&#123;MINUTE&#125; - the current minute. $&#123;PRODUCT_NAME&#125; - the name of the IDE in which the file will be created. $&#123;MONTH_NAME_SHORT&#125; - the first 3 letters of the month name. Example: Jan, Feb, etc. $&#123;MONTH_NAME_FULL&#125; - full name of a month. Example: January, February, etcEditor - File Encodings设置项目文件编码说明：Transparent native-to-ascii conversion主要用于转换ascii，一般都要勾选，不然Properties文件中的注释信息显示的都不是中文Build,Execution,Deployment设置自动编译设置省电模式(可忽略)设置代码水平或垂直显示设置快捷键(Keymap)设置快捷键为Eclipse快捷键通过快捷键功能修改快捷键设置通过指定快捷键，查找或修改其他功能导入已有的设置关于模板(Templates)(Editor - Live Templates 和 Editor - General - Postfix Completion)Live Templates(实时代码模板)功能介绍它的原理就是配置一些常用代码字母缩写，在输入简写时可以出现你预定义的固定模式的代码，使得开发效率大大提高，同时也可以增加个性化。最简单的例子 就是在 Java 中输入 sout 会出现 System.out.println();已有的常用模板Postfix Completion默认如下Live Templates默认如下二者的区别：Live Templates可以自定义，而Postfix Completion不可以，同时，有些操作二者都提供了模板，Postfix Templates较Live Templates能快0.01s举例：psvm：可生成main方法sout：System.out.println()快捷输出类似的：soutp = System.out.println(“方法形参名 = “ + 形参名);soutv = System.out.println(“变量名 = “ + 变量);soutm = System.out.println(“当前类名.当前方法”);“abc”.sout =&gt; System.out.println(“abc”);fori：可生成for循环iter：可成增强for循环itar：可生成普通for循环list.for：可生成集合list的for循环ifn：可生成if(xxx = null)**prsf：可生成private static final类似的：psf：可生成 public static finalpsfi：可生成 pubic static final intpsfs：可生成 public static final String修改现有模板：Live Templates通过调用psvm调用不习惯，可以修改自定义模板先定义一个模板组：选中自定义的模板组，点击”+”来定义模板Abbreviation：模板的缩略名称Description：模板的描述Template text：模板的代码片段应用范围，比如点击Define,选择如下配置Tomcat在IDEA中配置Tomcat之前，需要保证已经安装并配置了Tomcat的环境变量关联数据库关联方式常用操作版本控制(Version Control)不管是个人开发还是团队开发，版本控制都会被使用，而IDEA也很好的集成了版本控制相关结果很多人认为Intellij自带了SVN或是Git等版本控制工具，认为只要安装了IntellijIDEa就可以完全使用版本控制应有的功能，这是一种完全错误的解读，Intellij IDEA是自带对这些版本控制工具的插件支持，但是该装什么版本控制客户端还是要照样装的Intellij IDEA对版本控制的支持是以插件化的方式来实现的，旗舰版默认支持目前主流的版本控制软件，CVS、Subversion(SVN)、Git、Mercurial、Perforce、TFS。又因为目前太多人使用Github进行协同或是项目版本管理，所以Intellij IDEA同时自带了Github插件，方便Checkout和管理你的Github项目在实际开发中，发现IDEA中使用SVN经历不算愉快，经常会遇到很多问题，比如紧急下IDEA无法更新、提交等提前安装好Git客户端Git的msysGit官网下载Git客户端TortoiseGit官网下载关联git.exe关联GitHub上的账户，并测试连接在Github上创建账户下的一个新的仓库作为测试支持从当前登录的github账号上直接Checkout项目在IDEA中clone Github上的仓库这里需要在Github的自己账户下，复制项目仓库路径，填写上图git repository URL中连接成功会下载github上的项目根据自己需要，选择本窗口还是开启一个新窗口除此之外，还可以通过如下方式连接GitHub本地代码分享到GitHub此时会在github上创建一个新的仓库，而非更新已经存在的仓库Git的常用操作clone：拷贝远程仓库commit：本地提交push：远程提交pull：更新到本地没有使用Git时本地历史记录的查看即使我们项目没有使用版本控制功能，Intellij IDEA也给我们提供了本地文件历史记录断点调试Debug的设置设置Debug连接方式，默认时Socket，Shared memory是Windows特有的一个属性，一般在Windows系统下建议使用此设置，内存占用相对较少常用断点调试快捷键条件断点说明：调试的时候，在循环里增加条件判断，可以极大的提高效率，心情也能愉悦具体操作：在断点处点击调出条件断点，可以在满足某个条件下，实施断点查看表达式的值(Ctrl+u)选择行 ctrl+u 还可以查看框中输入编写代码时的其他方法配置MavenMavan介绍Maven -&gt; Ant -&gt; Maven -&gt; GradleMave是Apache提供的一款自动化构建工具，用于自动化构建和依赖管理，开发团队基本不用花多少时间就能自动完成工程的基础构建配置，因为Maven使用了一个标准的目录结构和一个默认的构建生命周期。构建环节：Maven的配置maven下载-解压-配置(settings配置仓库reposiroty)Maven home directory：可以指定本地Maven的安装目录所在，因为已经配置了M2_HOME系统参数，所以直接这样配置Intellij IDEA是可以找到的，但是加入没有配置，这里选择Maven安装目录，此外不建议使用IDEA默认的User settings file/Local repository：我们还可以指定Maven的settings.xml位置和本地仓库位置Import Maven projects atuomaticallu：表示Intellij IDEA会实时监控项目的pom.xml文件，进行项目变动设置Automatically download：在Maven导入依赖包时候，是否自动下载源码和文档，不建议勾选，因为会加快项目从外网导入依赖包的速度。Intellij支持直接从公网下载源码和文档，如果需要我们可以针对某个依赖包进行联网下载VM options for importer：可以设置导入的VM参数，一般不需要主动该，除非项目真的导入太慢了我们再增大此参数创建对应的ModuleGroup：组织或公司域名，倒叙Artiface：项目模块名称Version：默认maven生成版本其中常用的是clean、compile、package、install。如果其他项目需要将这里的模块作为依赖使用，那就可以install安装到本地仓库的位置maven下创建的web工程目录会和eclipse不一样，需要手动创建resource、java、test文件其他设置生成javadoc输入：Locale：输入语言类型：zh_CNOther command line arguments：-encoding UTF-8 -charset UTF-8缓存和索引的清理取消更新IDEA]]></content>
      <categories>
        <category>工具使用</category>
        <category>Intellij</category>
      </categories>
      <tags>
        <tag>Intellij</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国际化实现原理]]></title>
    <url>%2Fcategory%2F%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[国际化程序实现原理定义保存文字的文件信息根据不同的区域语言的编码读取指定的资源信息把与语言相关的所有字符串都写成变量写两个配置文件，一个文件中存放中文信息、另一个存放英文信息Locale类描述区域和语言编码的类123456public Locale(String language);public Locale(String language,String country);Locale loc = new Locale("zh","CN"); //中文环境Locale.getDefault(): //默认环境读取资源文件：ResourceBundle获取ResourceBundle类对象的方法:public static final ResourceBundle getBundle(String baseName);baseName -&gt; 描述资源文件的名称，但是没有后缀String getString():获取资源信息使用一个类，来通过语言环境，最终识别加载哪一个文件的信息：ResourceBundle语言环境：Localenew Locale(“zh”,”CN”);Locale.getDefault();Locale.CHINA消息格式化MessageFormat类占位符 {0},format():处理占位符信息步骤123获取Locale，这是由客户端的浏览器提供的Locale创建ResourceBundle把所有语言信息使用rb.getString("xxx")来替换]]></content>
      <categories>
        <category>Java相关</category>
        <category>国际化实现原理</category>
      </categories>
      <tags>
        <tag>Java相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-注解]]></title>
    <url>%2Fcategory%2FJavaSE-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解什么是注解语法：@注解名称注解的作用：替代xml配置文件servlet3.0就可以不使用web.xml,而是所有配置都使用注解注解是由框架来读取使用的以前，『XML』是各大框架的青睐者，它以松耦合的方式完成了框架中几乎所有的配置，但是随着项目越来越庞大，『XML』的内容也越来越复杂，维护成本变高。于是就有人提出来一种标记式高耦合的配置方式，『注解』。方法上可以进行注解，类上也可以注解，字段属性上也可以注解，反正几乎需要配置的地方都可以进行注解。关于『注解』和『XML』两种不同的配置模式，争论了好多年了，各有各的优劣，注解可以提供更大的便捷性，易于维护修改，但耦合度高，而 XML 相对于注解则是相反的。追求低耦合就要抛弃高效率，追求效率必然会遇到耦合。实际上Java注解与普通修饰符(public、static、void等)的使用方式并没有多大区别，下面的例子是常见的注解：1234567891011121314public class AnnotationDemo &#123; //@Test注解修饰方法A @Test public static void A()&#123; System.out.println("Test....."); &#125; //一个方法上可以拥有多个不同的注解 @Deprecated @SuppressWarnings("uncheck") public static void B()&#123; &#125;&#125;通过在方法上使用@Test注解后，在运行该方法时，测试框架会自动识别该方法并单独调用，@Test实际上是一种标记注解，起标记作用，运行时告诉测试框架该方法为测试方法。而对于@Deprecated和@SuppressWarnings(“uncheck”)，则是Java本身内置的注解，在代码中，可以经常看见它们，但这并不是一件好事，毕竟当方法或是类上面有@Deprecated注解时，说明该方法或是类都已经过期不建议再用，@SuppressWarnings 则表示忽略指定警告，比如@SuppressWarnings(“uncheck”)，这就是注解的最简单的使用方式注解的本质「java.lang.annotation.Annotation」接口中有这么一句话，用来描述『注解』。123The common interface extended by all annotation types//所有的注解类型都继承自这个普通的接口（Annotation）这句话有点抽象，但却说出了注解的本质。我们看一个 JDK 内置注解的定义：12345@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;这是注解 @Override 的定义，其实它本质上就是：123public interface Override extends Annotation&#123; &#125;没错，注解的本质就是一个继承了 Annotation 接口的接口。有关这一点，你可以去反编译任意一个注解类，你会得到结果的。一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有解析它的代码，它可能连注释都不如。而解析一个类或者方法的注解往往有两种形式，一种是编译期直接的扫描，一种是运行期反射。反射的事情我们待会说，而编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。典型的就是注解 @Override，一旦编译器检测到某个方法被修饰了 @Override 注解，编译器就会检查当前方法的方法签名是否真正重写了父类的某个方法，也就是比较父类中是否具有一个同样的方法签名。这一种情况只适用于那些编译器已经熟知的注解类，比如 JDK 内置的几个注解，而你自定义的注解，编译器是不知道你这个注解的作用的，当然也不知道该如何处理，往往只是会根据该注解的作用范围来选择是否编译进字节码文件，仅此而已。元注解『元注解』是用于修饰注解的注解，通常用在注解的定义上，例如：12345@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;这是我们 @Override 注解的定义，你可以看到其中的 @Target，@Retention 两个注解就是我们所谓的『元注解』，『元注解』一般用于指定某个注解生命周期以及作用目标等信息。JAVA 中有以下几个『元注解』：@Target：注解的作用目标@Retention：注解的生命周期@Documented：注解是否应当被包含在 JavaDoc 文档中@Inherited：是否允许子类继承该注解其中，@Target 用于指明被修饰的注解最终可以作用的目标是谁，也就是指明，你的注解到底是用来修饰方法的？修饰类的？还是用来修饰字段属性的。@Target 的定义如下：我们可以通过以下的方式来为这个 value 传值：1@Target(value = &#123;ElementType.FIELD&#125;)被这个 @Target 注解修饰的注解将只能作用在成员字段上，不能用于修饰方法或者类。其中，ElementType 是一个枚举类型，有以下一些值：ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上ElementType.FIELD：允许作用在属性字段上ElementType.METHOD：允许作用在方法上ElementType.PARAMETER：允许作用在方法参数上ElementType.CONSTRUCTOR：允许作用在构造器上ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上ElementType.ANNOTATION_TYPE：允许作用在注解上ElementType.PACKAGE：允许作用在包上@Retention 用于指明当前注解的生命周期，它的基本定义如下：同样的，它也有一个 value 属性：1@Retention(value = RetentionPolicy.RUNTIME这里的 RetentionPolicy 依然是一个枚举类型，它有以下几个枚举值可取：RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件RetentionPolicy.RUNTIME：永久保存，可以反射获取@Retention 注解指定了被修饰的注解的生命周期，一种是只能在编译期可见，编译后会被丢弃，一种会被编译器编译进 class 文件中，无论是类或是方法，乃至字段，他们都是有属性表的，而 JAVA 虚拟机也定义了几种注解属性表用于存储注解信息，但是这种可见性不能带到方法区，类加载时会予以丢弃，最后一种则是永久存在的可见性。剩下两种类型的注解我们日常用的不多，也比较简单，这里不再详细的进行介绍了，你只需要知道他们各自的作用即可。@Documented 注解修饰的注解，当我们执行 JavaDoc 文档打包时会被保存进 doc 文档，反之将在打包时丢弃。@Inherited 注解修饰的注解是具有可继承性的，也就说我们的注解修饰了一个类，而该类的子类将自动继承父类的该注解。Java的内置三大注解除了上述四种元注解外，JDK 还为我们预定义了另外三种注解，它们是：@Override@Deprecated@SuppressWarnings@Override 注解想必是大家很熟悉的了，它的定义如下：1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;它没有任何的属性，所以并不能存储任何其他信息。它只能作用于方法之上，编译结束后将被丢弃。所以你看，它就是一种典型的『标记式注解』，仅被编译器可知，编译器在对 java 文件进行编译成字节码的过程中，一旦检测到某个方法上被修饰了该注解，就会去匹对父类中是否具有一个同样方法签名的函数，如果不是，自然不能通过编译。@Deprecated 的基本定义如下：依然是一种『标记式注解』，永久存在，可以修饰所有的类型，作用是，标记当前的类或者方法或者字段等已经不再被推荐使用了，可能下一次的 JDK 版本就会删除。当然，编译器并不会强制要求你做什么，只是告诉你 JDK 已经不再推荐使用当前的方法或者类了，建议你使用某个替代者。@SuppressWarnings 主要用来压制 java 的警告，它的基本定义如下：它有一个 value 属性需要你主动的传值，这个 value 代表一个什么意思呢，这个 value 代表的就是需要被压制的警告类型。例如：123public static void main(String[] args) &#123; Date date = new Date(2018, 7, 11);&#125;这么一段代码，程序启动时编译器会报一个警告。1Warning:(8, 21) java: java.util.Date 中的 Date(int,int,int) //已过时而如果我们不希望程序启动时，编译器检查代码中过时的方法，就可以使用 @SuppressWarnings 注解并给它的 value 属性传入一个参数值来压制编译器的检查。1234@SuppressWarning(value = "deprecated")public static void main(String[] args) &#123; Date date = new Date(2018, 7, 11);&#125;这样你就会发现，编译器不再检查 main 方法下是否有过时的方法调用，也就压制了编译器对于这种警告的检查。当然，JAVA 中还有很多的警告类型，他们都会对应一个字符串，通过设置 value 属性的值即可压制对于这一类警告类型的检查。自定义注解的相关内容就不再赘述了，比较简单，通过类似以下的语法即可自定义一个注解。123public @interface InnotationName&#123; &#125;当然，自定义注解的时候也可以选择性的使用元注解进行修饰，这样你可以更加具体的指定你的注解的生命周期、作用范围等信息。注解的使用定义注解类@Overrid：作用在方法上的注解，当方法不是重写父类的方法时会报错@Deprecated：作用在方法伤害，标记该方法为作废方法（已过时）@SuppressWarnings：作用在方法上，压制警告定义注解使用@interfacepublic @interface MyAnn{}所有的注解都是Annotation的子类使用注解注解的作用目标：类（接口、枚举）属性方法构造器参数局部变量包注解的属性定义属性格式：类型 属性名()使用注解时给属性赋值@MyAnno1(age=100,name=”zhangSan”)注解属性的默认值：在定义注解时，可以给注解指定默认值int age() default 100;在使用注解时，可以不给带有默认值的属性赋值名为value的属性的特权当使用注解时，如果只给名为value的属性赋值时，可以省略”value=”例如：@MyAnno1(value=”hello”),可以书写成 @MyAnno1(“hello”)注解属性的类型8种基本类型StringEnumClass注解类型以上类型的一维数组类型当给数组类型的属性赋值时，若数组元素的个数为1时，可以省略大括号注解的作用目标限定以及保存策略限定让一个注解，它的作用目标只能在类上，不能再方法上，这就叫作用目标的限定再定义注解时，给注解添加注解，这个注解是@Target保留策略源代码文件(SOURCE)：只在源代码种存在，当编译时就被忽略了字节码文件(CLASS)：注解在源代码中存在，然后编译时会把注解信息放到class文件，但jvm在加载类时，会忽略注解JVM中(RUNTIME)：注解在源代码、字节码文件中存在，并且在JVM加载类时，会把注解加载到JVM内存中（它是唯一可反射注解)限定注解的保留策略：使用Retention注解与反射「注解的本质就是一个继承了 Annotation 接口的接口」，现在我们就来从虚拟机的层面看看，注解的本质到底是什么。首先，我们自定义一个注解类型：这里我们指定了 Hello 这个注解只能修饰字段和方法，并且该注解永久存活，以便我们反射获取。之前我们说过，虚拟机规范定义了一系列和注解相关的属性表，也就是说，无论是字段、方法或是类本身，如果被注解修饰了，就可以被写进字节码文件。属性表有以下几种：RuntimeVisibleAnnotations：运行时可见的注解RuntimeInVisibleAnnotations：运行时不可见的注解RuntimeVisibleParameterAnnotations：运行时可见的方法参数注解RuntimeInVisibleParameterAnnotations：运行时不可见的方法参数注解AnnotationDefault：注解类元素的默认值给大家看虚拟机的这几个注解相关的属性表的目的在于，让大家从整体上构建一个基本的印象，注解在字节码文件中是如何存储的。所以，对于一个类或者接口来说，Class 类中提供了以下一些方法用于反射注解。getAnnotation：返回指定的注解isAnnotationPresent：判定当前元素是否被指定注解修饰getAnnotations：返回所有的注解getDeclaredAnnotation：返回本元素的指定注解getDeclaredAnnotations：返回本元素的所有注解，不包含父类继承而来的方法、字段中相关反射注解的方法基本是类似的，这里不再赘述，我们下面看一个完整的例子。首先，设置一个虚拟机启动参数，用于捕获 JDK 动态代理类。1-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true然后 main 函数。我们说过，注解本质上是继承了 Annotation 接口的接口，而当你通过反射，也就是我们这里的 getAnnotation 方法去获取一个注解类实例的时候，其实 JDK 是通过动态代理机制生成一个实现我们注解（接口）的代理类。我们运行程序后，会看到输出目录里有这么一个代理类，反编译之后是这样的：代理类实现接口 Hello 并重写其所有方法，包括 value 方法以及接口 Hello 从 Annotation 接口继承而来的方法。而这个关键的 InvocationHandler 实例是谁？AnnotationInvocationHandler 是 JAVA 中专门用于处理注解的 Handler， 这个类的设计也非常有意思。这里有一个 memberValues，它是一个 Map 键值对，键是我们注解属性名称，值就是该属性当初被赋上的值。而这个 invoke 方法就很有意思了，大家注意看，我们的代理类代理了 Hello 接口中所有的方法，所以对于代理类中任何方法的调用都会被转到这里来。var2 指向被调用的方法实例，而这里首先用变量 var4 获取该方法的简明名称，接着 switch 结构判断当前的调用方法是谁，如果是 Annotation 中的四大方法，将 var7 赋上特定的值。如果当前调用的方法是 toString，equals，hashCode，annotationType 的话，AnnotationInvocationHandler 实例中已经预定义好了这些方法的实现，直接调用即可。那么假如 var7 没有匹配上这四种方法，说明当前的方法调用的是自定义注解字节声明的方法，例如我们 Hello 注解的 value 方法。这种情况下，将从我们的注解 map 中获取这个注解属性对应的值。其实，JAVA 中的注解设计个人觉得有点反人类，明明是属性的操作，非要用方法来实现。当然，如果你有不同的见解，欢迎留言探讨。最后我们再总结一下整个反射注解的工作原理：首先，我们通过键值对的形式可以为注解属性赋值，像这样：@Hello（value = “hello”）。接着，你用注解修饰某个元素，编译器将在编译期扫描每个类或者方法上的注解，会做一个基本的检查，你的这个注解是否允许作用在当前位置，最后会将注解信息写入元素的属性表。然后，当你进行反射的时候，虚拟机将所有生命周期在 RUNTIME 的注解取出来放到一个 map 中，并创建一个 AnnotationInvocationHandler 实例，把这个 map 传递给它。最后，虚拟机将采用 JDK 动态代理机制生成一个目标注解的代理类，并初始化好处理器。那么这样，一个注解的实例就创建出来了，它本质上就是一个代理类，你应当去理解好 AnnotationInvocationHandler 中 invoke 方法的实现逻辑，这是核心。一句话概括就是，通过方法名返回注解属性值。Java8中注解增强元注解@Repeatable元注解@Repeatable是JDK1.8新加入的，它表示在同一个位置重复相同的注解。在没有该注解前，一般是无法在同一个类型上使用相同的注解的1234//Java8前无法这样使用@FilterPath("/web/update")@FilterPath("/web/add")public class A &#123;&#125;Java8前如果是想实现类似的功能，我们需要在定义@FilterPath注解时定义一个数组元素接收多个值如下123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface FilterPath &#123; String [] value();&#125;//使用@FilterPath(&#123;"/update","/add"&#125;)public class A &#123; &#125;但在Java8新增了@Repeatable注解后就可以采用如下的方式定义并使用了1234567891011121314151617181920212223package com.zejian.annotationdemo;import java.lang.annotation.*;//使用Java8新增@Repeatable原注解@Target(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Repeatable(FilterPaths.class)//参数指明接收的注解classpublic @interface FilterPath &#123; String value();&#125;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface FilterPaths &#123; FilterPath[] value();&#125;//使用案例@FilterPath("/web/update")@FilterPath("/web/add")@FilterPath("/web/delete")class AA&#123; &#125;我们可以简单理解为通过使用@Repeatable后，将使用@FilterPaths注解作为接收同一个类型上重复注解的容器，而每个@FilterPath则负责保存指定的路径串。为了处理上述的新增注解，Java8还在AnnotatedElement接口新增了getDeclaredAnnotationsByType() 和 getAnnotationsByType()两个方法并在接口给出了默认实现，在指定@Repeatable的注解时，可以通过这两个方法获取到注解相关信息。但请注意，旧版API中的getDeclaredAnnotation()和 getAnnotation()是不对@Repeatable注解的处理的(除非该注解没有在同一个声明上重复出现)。注意getDeclaredAnnotationsByType方法获取到的注解不包括父类，其实当 getAnnotationsByType()方法调用时，其内部先执行了getDeclaredAnnotationsByType方法，只有当前类不存在指定注解时，getAnnotationsByType()才会继续从其父类寻找，但请注意如果@FilterPath和@FilterPaths没有使用了@Inherited的话，仍然无法获取。下面通过代码来演示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//使用Java8新增@Repeatable原注解@Target(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Repeatable(FilterPaths.class)public @interface FilterPath &#123; String value();&#125;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface FilterPaths &#123; FilterPath[] value();&#125;@FilterPath("/web/list")class CC &#123; &#125;//使用案例@FilterPath("/web/update")@FilterPath("/web/add")@FilterPath("/web/delete")class AA extends CC&#123; public static void main(String[] args) &#123; Class&lt;?&gt; clazz = AA.class; //通过getAnnotationsByType方法获取所有重复注解 FilterPath[] annotationsByType = clazz.getAnnotationsByType(FilterPath.class); FilterPath[] annotationsByType2 = clazz.getDeclaredAnnotationsByType(FilterPath.class); if (annotationsByType != null) &#123; for (FilterPath filter : annotationsByType) &#123; System.out.println("1:"+filter.value()); &#125; &#125; System.out.println("-----------------"); if (annotationsByType2 != null) &#123; for (FilterPath filter : annotationsByType2) &#123; System.out.println("2:"+filter.value()); &#125; &#125; System.out.println("使用getAnnotation的结果:"+clazz.getAnnotation(FilterPath.class)); /** * 执行结果(当前类拥有该注解FilterPath,则不会从CC父类寻找) 1:/web/update 1:/web/add 1:/web/delete ----------------- 2:/web/update 2:/web/add 2:/web/delete 使用getAnnotation的结果:null */ &#125;&#125;从执行结果来看如果当前类拥有该注解@FilterPath,则getAnnotationsByType方法不会从CC父类寻找，下面看看另外一种情况，即AA类上没有@FilterPath注解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//使用Java8新增@Repeatable原注解@Target(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited //添加可继承元注解@Repeatable(FilterPaths.class)public @interface FilterPath &#123; String value();&#125;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Inherited //添加可继承元注解@interface FilterPaths &#123; FilterPath[] value();&#125;@FilterPath("/web/list")@FilterPath("/web/getList")class CC &#123; &#125;//AA上不使用@FilterPath注解,getAnnotationsByType将会从父类查询class AA extends CC&#123; public static void main(String[] args) &#123; Class&lt;?&gt; clazz = AA.class; //通过getAnnotationsByType方法获取所有重复注解 FilterPath[] annotationsByType = clazz.getAnnotationsByType(FilterPath.class); FilterPath[] annotationsByType2 = clazz.getDeclaredAnnotationsByType(FilterPath.class); if (annotationsByType != null) &#123; for (FilterPath filter : annotationsByType) &#123; System.out.println("1:"+filter.value()); &#125; &#125; System.out.println("-----------------"); if (annotationsByType2 != null) &#123; for (FilterPath filter : annotationsByType2) &#123; System.out.println("2:"+filter.value()); &#125; &#125; System.out.println("使用getAnnotation的结果:"+clazz.getAnnotation(FilterPath.class)); /** * 执行结果(当前类没有@FilterPath,getAnnotationsByType方法从CC父类寻找) 1:/web/list 1:/web/getList ----------------- 使用getAnnotation的结果:null */ &#125;&#125;注意定义@FilterPath和@FilterPath时必须指明@Inherited，getAnnotationsByType方法否则依旧无法从父类获取@FilterPath注解，这是为什么呢，不妨看看getAnnotationsByType方法的实现源码：123456789101112131415161718//接口默认实现方法default &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) &#123;//先调用getDeclaredAnnotationsByType方法T[] result = getDeclaredAnnotationsByType(annotationClass);//判断当前类获取到的注解数组是否为0if (result.length == 0 &amp;&amp; this instanceof Class &amp;&amp; //判断定义注解上是否使用了@Inherited元注解 AnnotationType.getInstance(annotationClass).isInherited()) &#123; // Inheritable //从父类获取 Class&lt;?&gt; superClass = ((Class&lt;?&gt;) this).getSuperclass(); if (superClass != null) &#123; result = superClass.getAnnotationsByType(annotationClass); &#125; &#125; return result;&#125;新增的两种ElementType在Java8中 ElementType 新增两个枚举成员，TYPE_PARAMETER 和 TYPE_USE ，在Java8前注解只能标注在一个声明(如字段、类、方法)上，Java8后，新增的TYPE_PARAMETER可以用于标注类型参数，而TYPE_USE则可以用于标注任意类型(不包括class)。如下所示1234567891011121314151617181920212223//TYPE_PARAMETER 标注在类型参数上class D&lt;@Parameter T&gt; &#123; &#125;//TYPE_USE则可以用于标注任意类型(不包括class)//用于父类或者接口class Image implements @Rectangular Shape &#123; &#125;//用于构造函数new @Path String("/usr/bin")//用于强制转换和instanceof检查,注意这些注解中用于外部工具，它们不会对类型转换或者instanceof的检查行为带来任何影响。String path=(@Path String)input;if(input instanceof @Path String)//用于指定异常public Person read() throws @Localized IOException.//用于通配符绑定List&lt;@ReadOnly ? extends Person&gt;List&lt;? extends @ReadOnly Person&gt;@NotNull String.class //非法，不能标注classimport java.lang.@NotNull String //非法，不能标注import这里主要说明一下TYPE_USE，类型注解用来支持在Java的程序中做强类型检查，配合第三方插件工具（如Checker Framework），可以在编译期检测出runtime error（如UnsupportedOperationException、NullPointerException异常），避免异常延续到运行期才发现，从而提高代码质量，这就是类型注解的主要作用。总之Java 8 新增加了两个注解的元素类型ElementType.TYPE_USE 和ElementType.TYPE_PARAMETER ，通过它们，我们可以把注解应用到各种新场合中。参考博文：深入理解Java注解类型(@Annotation)（Java8中注解增强）JAVA 注解的基本原理推荐博文：深入浅出Java注解]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE注解</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-代理]]></title>
    <url>%2Fcategory%2FJavaSE-%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java三种代理代理模式介绍代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。通过使用代理，通常有两个优点，并且能够分别与我们提到的微商代理的两个特点对应起来：优点一：可以隐藏委托类的实现;优点二：可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。代理模式：给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。代理模式角色分为 3 种：Subject（抽象主题角色）：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；RealSubject（真实主题角色）：真正实现业务逻辑的类；Proxy（代理主题角色）：用来代理和封装真实主题；代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层代理模式UML类图代理模式按照职责（使用场景）来分类，至少可以分为以下几类：1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理等等。如果根据字节码的创建时机来分类，可以分为静态代理和动态代理：所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了。而动态代理的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件静态代理虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护。编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl12345678910111213public interface UserService &#123; public void select(); public void update();&#125;public class UserServiceImpl implements UserService &#123; public void select() &#123; System.out.println("查询 selectById"); &#125; public void update() &#123; System.out.println("更新 update"); &#125;&#125;我们将通过静态代理对 UserServiceImpl 进行功能增强，在调用 select 和 update 之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService123456789101112131415161718192021222324public class UserServiceProxy implements UserService &#123; private UserService target; // 被代理的对象 public UserServiceProxy(UserService target) &#123; this.target = target; &#125; public void select() &#123; before(); target.select(); // 这里才实际调用真实主题角色的方法 after(); &#125; public void update() &#123; before(); target.update(); // 这里才实际调用真实主题角色的方法 after(); &#125; private void before() &#123; // 在执行方法之前执行 System.out.println(String.format("log start time [%s] ", new Date())); &#125; private void after() &#123; // 在执行方法之后执行 System.out.println(String.format("log end time [%s] ", new Date())); &#125;&#125;客户端测试123456789public class Client1 &#123; public static void main(String[] args) &#123; UserService userServiceImpl = new UserServiceImpl(); UserService proxy = new UserServiceProxy(userServiceImpl); proxy.select(); proxy.update(); &#125;&#125;输出123456log start time [Thu Dec 20 14:13:25 CST 2018] 查询 selectByIdlog end time [Thu Dec 20 14:13:25 CST 2018] log start time [Thu Dec 20 14:13:25 CST 2018] 更新 updatelog end time [Thu Dec 20 14:13:25 CST 2018]通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。动态代理为什么类可以动态的生成？这就涉及到Java虚拟机的类加载机制了，推荐翻看《深入理解Java虚拟机》7.3节 类加载的过程。Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下3件事情：通过一个类的全限定名来获取定义此类的二进制字节流将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，获取类的二进制字节流（class字节码）就有很多途径：从ZIP包获取，这是JAR、EAR、WAR等格式的基础从网络中获取，典型的应用是 Applet运行时计算生成，这种场景使用最多的是动态代理技术，在 java.lang.reflect.Proxy 类中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 *$Proxy 的代理类的二进制字节流由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类从数据库中获取等等所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。常见的字节码操作类库这里有一些介绍：java-source.net/open-source…Apache BCEL (Byte Code Engineering Library)：是Java classworking广泛使用的一种框架，它可以深入到JVM汇编语言进行类操作的细节。ObjectWeb ASM：是一个Java字节码操作框架。它可以用于直接以二进制形式动态生成stub根类或其他代理类，或者在加载时动态修改类。CGLIB(Code Generation Library)：是一个功能强大，高性能和高质量的代码生成库，用于扩展JAVA类并在运行时实现接口。Javassist：是Java的加载时反射系统，它是一个用于在Java中编辑字节码的类库; 它使Java程序能够在运行时定义新类，并在JVM加载之前修改类文件。…实现动态代理的思考方向为了让生成的代理类与目标对象（真实主题角色）保持一致性，从现在开始将介绍以下两种最常见的方式：通过实现接口的方式 -&gt; JDK动态代理通过继承类的方式 -&gt; CGLIB动态代理注：使用ASM对使用者要求比较高，使用Javassist会比较麻烦newProxyInstance在运行时，动态实现一组指定的接口的实现类对象（在运行时，创建实现了指定的一组接口的对象）Object proxyObject = Poxy.newProxyInstance(ClassLoader classLoader,Class[] interfaces,InvocationHandler h)ClassLoader：类加载器用来加载类的，把.class文件加载到内存，形成Class对象Class[] interfaces：指定要实现的接口们InvocationHandler：代理对象的所有方法（个别不执行，getClass()）都会调用InvocationHandler的invoke()方法InvocationHandlerpublic Object invoke(Object proxy,Method method,Object[] args);这个invoke方法在什么时候被调用！在调用代理对象所实现接口中的方法时调用Object proxy：当前对象，在调用谁的方法Method method：当前被调用的方法（目标方法）Object[] args：实参！JDK动态代理JDK动态代理主要涉及两个类：java.lang.reflect.Proxy 和 java.lang.reflect.InvocationHandler，我们仍然通过案例来学习编写一个调用逻辑处理器 LogHandler 类，提供日志增强功能，并实现 InvocationHandler 接口；在 LogHandler 中维护一个目标对象，这个对象是被代理的对象（真实主题角色）；在 invoke 方法中编写方法调用的逻辑处理1234567891011121314151617181920212223242526import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.Date;public class LogHandler implements InvocationHandler &#123; Object target; // 被代理的对象，实际的方法执行者 public LogHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object result = method.invoke(target, args); // 调用 target 的 method 方法 after(); return result; // 返回方法的执行结果 &#125; // 调用invoke方法之前执行 private void before() &#123; System.out.println(String.format("log start time [%s] ", new Date())); &#125; // 调用invoke方法之后执行 private void after() &#123; System.out.println(String.format("log end time [%s] ", new Date())); &#125;&#125;编写客户端，获取动态生成的代理类的对象须借助 Proxy 类的 newProxyInstance 方法，具体步骤可见代码和注释123456789101112131415161718192021222324252627282930313233import proxy.UserService;import proxy.UserServiceImpl;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class Client2 &#123; public static void main(String[] args) throws IllegalAccessException, InstantiationException &#123; // 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名 // System.getProperties().setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true"); // 1. 创建被代理的对象，UserService接口的实现类 UserServiceImpl userServiceImpl = new UserServiceImpl(); // 2. 获取对应的 ClassLoader ClassLoader classLoader = userServiceImpl.getClass().getClassLoader(); // 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService， Class[] interfaces = userServiceImpl.getClass().getInterfaces(); // 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用 // 这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl InvocationHandler logHandler = new LogHandler(userServiceImpl); /* 5.根据上面提供的信息，创建代理对象 在这个过程中， a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码 b.然后根据相应的字节码转换成对应的class， c.然后调用newInstance()创建代理实例 */ UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler); // 调用代理的方法 proxy.select(); proxy.update(); // 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy // ProxyUtils.generateClassFile(userServiceImpl.getClass(), "UserServiceProxy"); &#125;&#125;运行结果123456log start time [Thu Dec 20 16:55:19 CST 2018] 查询 selectByIdlog end time [Thu Dec 20 16:55:19 CST 2018] log start time [Thu Dec 20 16:55:19 CST 2018] 更新 updatelog end time [Thu Dec 20 16:55:19 CST 2018]InvocationHandler 和 Proxy 的主要方法介绍如下：java.lang.reflect.InvocationHandlerObject invoke(Object proxy, Method method, Object[] args) 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用java.lang.reflect.Proxystatic InvocationHandler getInvocationHandler(Object proxy) 用于获取指定代理对象所关联的调用处理器static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) 返回指定接口的代理类static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法static boolean isProxyClass(Class&lt;?&gt; cl) 返回 cl 是否为一个代理类代理类的调用过程生成的代理类到底长什么样子呢？借助下面的工具类，把代理类保存下来再探个究竟（通过设置环境变量sun.misc.ProxyGenerator.saveGeneratedFiles=true也可以保存代理类）1234567891011121314151617181920212223242526272829303132import sun.misc.ProxyGenerator;import java.io.FileOutputStream;import java.io.IOException;public class ProxyUtils &#123; /** * 将根据类信息动态生成的二进制字节码保存到硬盘中，默认的是clazz目录下 * params: clazz 需要生成动态代理类的类 * proxyName: 为动态生成的代理类的名称 */ public static void generateClassFile(Class clazz, String proxyName) &#123; // 根据类信息和提供的代理类名称，生成字节码 byte[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces()); String paths = clazz.getResource(".").getPath(); System.out.println(paths); FileOutputStream out = null; try &#123; //保留到硬盘中 out = new FileOutputStream(paths + proxyName + ".class"); out.write(classFile); out.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;然后在 Client2 测试类的main的最后面加入一行代码12// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxyProxyUtils.generateClassFile(userServiceImpl.getClass(), "UserServiceProxy");IDEA 再次运行之后就可以在 target 的类路径下找到 UserServiceProxy.class，双击后IDEA的反编译插件会将该二进制class文件UserServiceProxy 的代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import proxy.UserService;public final class UserServiceProxy extends Proxy implements UserService &#123; private static Method m1; private static Method m2; private static Method m4; private static Method m0; private static Method m3; public UserServiceProxy(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; // 省略... &#125; public final String toString() throws &#123; // 省略... &#125; public final void select() throws &#123; try &#123; super.h.invoke(this, m4, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; // 省略... &#125; public final void update() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object")); m2 = Class.forName("java.lang.Object").getMethod("toString"); m4 = Class.forName("proxy.UserService").getMethod("select"); m0 = Class.forName("java.lang.Object").getMethod("hashCode"); m3 = Class.forName("proxy.UserService").getMethod("update"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125;从 UserServiceProxy 的代码中我们可以发现：UserServiceProxy 继承了 Proxy 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法由于 UserServiceProxy 继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器类和所有方法都被 public final 修饰，所以代理类只可被使用，不可以再被继承每个方法都有一个 Method 对象来描述，Method 对象在static静态代码块中创建，以 m + 数字 的格式命名调用方法的时候通过 super.h.invoke(this, m1, (Object[])null); 调用，其中的 super.h.invoke 实际上是在创建代理的时候传递给 Proxy.newProxyInstance 的 LogHandler 对象，它继承 InvocationHandler 类，负责实际的调用处理逻辑而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法1234567@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object result = method.invoke(target, args); // 调用 target 的 method 方法 after(); return result; // 返回方法的执行结果&#125;JDK动态代理执行方法调用的过程简图如下：动态代理的秘密一定有同学对于为什么 Proxy 能够动态产生不同接口类型的代理感兴趣，我的猜测是肯定通过传入进去的接口然后通过反射动态生成了一个接口实例。比如 SellWine 是一个接口，那么 Proxy.newProxyInstance() 内部肯定会有1new SellWine();这样相同作用的代码，不过它是通过反射机制创建的。那么事实是不是这样子呢？直接查看它们的源码好了。需要说明的是，我当前查看的源码是 1.8 版本。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125;newProxyInstance 的确创建了一个实例，它是通过 cl 这个 Class 文件的构造方法反射生成。cl 由 getProxyClass0() 方法获取。1234567891011private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException("interface limit exceeded"); &#125; // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces);&#125;直接通过缓存获取，如果获取不到，注释说会通过 ProxyClassFactory 生成。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * A factory function that generates, defines and returns the proxy class given * the ClassLoader and array of interfaces. */ private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123; // Proxy class 的前缀是 “$Proxy”， private static final String proxyClassNamePrefix = "$Proxy"; // next number to use for generation of unique proxy class names private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; /* * Verify that the class loader resolves the name of this * interface to the same Class object. */ Class&lt;?&gt; interfaceClass = null; try &#123; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + " is not visible from class loader"); &#125; /* * Verify that the Class object actually represents an * interface. */ if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + " is not an interface"); &#125; /* * Verify that this interface is not a duplicate. */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( "repeated interface: " + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? "" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( "non-public interfaces from different packages"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY_PACKAGE + "."; &#125; /* * Choose a name for the proxy class to generate. */ long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125; &#125;这个类的注释说，通过指定的 ClassLoader 和 接口数组 用工厂方法生成 proxy class。 然后这个 proxy class 的名字是：1234567// Proxy class 的前缀是 “$Proxy”，private static final String proxyClassNamePrefix = "$Proxy";long num = nextUniqueNumber.getAndIncrement();String proxyName = proxyPkg + proxyClassNamePrefix + num;所以，动态生成的代理类名称是包名+$Proxy+id序号。生成的过程，核心代码如下：123456byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);这两个方法，我没有继续追踪下去，defineClass0() 甚至是一个 native 方法。我们只要知道，动态创建代理这回事就好了。现在我们还需要做一些验证，我要检测一下动态生成的代理类的名字是不是包名+$Proxy+id序号。12345678910111213141516171819202122232425262728293031323334353637public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub MaotaiJiu maotaijiu = new MaotaiJiu(); Wuliangye wu = new Wuliangye(); Furongwang fu = new Furongwang(); InvocationHandler jingxiao1 = new GuitaiA(maotaijiu); InvocationHandler jingxiao2 = new GuitaiA(wu); InvocationHandler jingxiao3 = new GuitaiA(fu); SellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(), MaotaiJiu.class.getInterfaces(), jingxiao1); SellWine dynamicProxy1 = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(), MaotaiJiu.class.getInterfaces(), jingxiao2); dynamicProxy.mainJiu(); dynamicProxy1.mainJiu(); SellCigarette dynamicProxy3 = (SellCigarette) Proxy.newProxyInstance(Furongwang.class.getClassLoader(), Furongwang.class.getInterfaces(), jingxiao3); dynamicProxy3.sell(); System.out.println("dynamicProxy class name:"+dynamicProxy.getClass().getName()); System.out.println("dynamicProxy1 class name:"+dynamicProxy1.getClass().getName()); System.out.println("dynamicProxy3 class name:"+dynamicProxy3.getClass().getName()); &#125;&#125;结果如下：12345678910111213销售开始 柜台是： GuitaiA我卖得是茅台酒。销售结束销售开始 柜台是： GuitaiA我卖得是五粮液。销售结束销售开始 柜台是： GuitaiA售卖的是正宗的芙蓉王，可以扫描条形码查证。销售结束dynamicProxy class name:com.sun.proxy.$Proxy0dynamicProxy1 class name:com.sun.proxy.$Proxy0dynamicProxy3 class name:com.sun.proxy.$Proxy1SellWine 接口的代理类名是：com.sun.proxy.$Proxy0SellCigarette 接口的代理类名是：com.sun.proxy.$Proxy1这说明动态生成的 proxy class 与 Proxy 这个类同一个包。下面用一张图让大家记住动态代理涉及到的角色。红框中 $Proxy0就是通过 Proxy 动态生成的。$Proxy0实现了要代理的接口。$Proxy0通过调用 InvocationHandler来执行任务。cglib代理cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。cglib特点JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。如果想代理没有实现接口的类，就可以使用CGLIB实现。CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉。cglib与动态代理最大的区别就是使用动态代理的对象必须实现一个或多个接口使用cglib代理的对象则无需实现接口，达到代理类无侵入。使用cglib需要引入cglib的jar包，如果你已经有spring-core的jar包，则无需引入，因为spring中包含了cglib。cglib的Maven坐标12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt;&lt;/dependency&gt;maven引入CGLIB包，然后编写一个UserDao类，它没有接口，只有两个方法，select() 和 update()12345678public class UserDao &#123; public void select() &#123; System.out.println("UserDao 查询 selectById"); &#125; public void update() &#123; System.out.println("UserDao 更新 update"); &#125;&#125;编写一个 LogInterceptor ，继承了 MethodInterceptor，用于方法的拦截回调1234567891011121314151617181920212223242526import java.lang.reflect.Method;import java.util.Date;public class LogInterceptor implements MethodInterceptor &#123; /** * @param object 表示要进行增强的对象 * @param method 表示拦截的方法 * @param objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double * @param methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用 * @return 执行结果 * @throws Throwable */ @Override public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; before(); Object result = methodProxy.invokeSuper(object, objects); // 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法 after(); return result; &#125; private void before() &#123; System.out.println(String.format("log start time [%s] ", new Date())); &#125; private void after() &#123; System.out.println(String.format("log end time [%s] ", new Date())); &#125;&#125;测试1234567891011121314import net.sf.cglib.proxy.Enhancer;public class CglibTest &#123; public static void main(String[] args) &#123; DaoProxy daoProxy = new DaoProxy(); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(Dao.class); // 设置超类，cglib是通过继承来实现的 enhancer.setCallback(daoProxy); Dao dao = (Dao)enhancer.create(); // 创建代理类 dao.update(); dao.select(); &#125;&#125;运行结果123456log start time [Fri Dec 21 00:06:40 CST 2018] UserDao 查询 selectByIdlog end time [Fri Dec 21 00:06:40 CST 2018] log start time [Fri Dec 21 00:06:40 CST 2018] UserDao 更新 updatelog end time [Fri Dec 21 00:06:40 CST 2018]还可以进一步多个 MethodInterceptor 进行过滤筛选1234567891011121314151617181920212223242526public class LogInterceptor2 implements MethodInterceptor &#123; @Override public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; before(); Object result = methodProxy.invokeSuper(object, objects); after(); return result; &#125; private void before() &#123; System.out.println(String.format("log2 start time [%s] ", new Date())); &#125; private void after() &#123; System.out.println(String.format("log2 end time [%s] ", new Date())); &#125;&#125;// 回调过滤器: 在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。public class DaoFilter implements CallbackFilter &#123; @Override public int accept(Method method) &#123; if ("select".equals(method.getName())) &#123; return 0; // Callback 列表第1个拦截器 &#125; return 1; // Callback 列表第2个拦截器，return 2 则为第3个，以此类推 &#125;&#125;再次测试1234567891011121314public class CglibTest2 &#123; public static void main(String[] args) &#123; LogInterceptor logInterceptor = new LogInterceptor(); LogInterceptor2 logInterceptor2 = new LogInterceptor2(); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(UserDao.class); // 设置超类，cglib是通过继承来实现的 enhancer.setCallbacks(new Callback[]&#123;logInterceptor, logInterceptor2, NoOp.INSTANCE&#125;); // 设置多个拦截器，NoOp.INSTANCE是一个空拦截器，不做任何处理 enhancer.setCallbackFilter(new DaoFilter()); UserDao proxy = (UserDao) enhancer.create(); // 创建代理类 proxy.select(); proxy.update(); &#125;&#125;运行结果123456log start time [Fri Dec 21 00:22:39 CST 2018] UserDao 查询 selectByIdlog end time [Fri Dec 21 00:22:39 CST 2018] log2 start time [Fri Dec 21 00:22:39 CST 2018] UserDao 更新 updatelog2 end time [Fri Dec 21 00:22:39 CST 2018]CGLIB 创建动态代理类的模式是：查找目标类上的所有非final 的public类型的方法定义；将这些方法的定义转换成字节码；将组成的字节码转换成相应的代理的class对象；实现 MethodInterceptor接口，用来处理对代理类上所有方法的请求JDK动态代理与CGLIB动态代理对比JDK动态代理：基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。cglib动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。JDK Proxy 的优势：最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。代码实现简单。基于类似 cglib 框架的优势：无需实现接口，达到代理类无侵入只操作我们关心的类，而不必为其他相关类增加工作量。高性能面试题描述动态代理的几种实现方式？分别说出相应的优缺点代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK动态代理” 和 “CGLIB动态代理” 实现。静态代理：代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object优点：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。缺点：不同的接口要有不同的代理类实现，会很冗余JDK 动态代理：为了解决静态代理中，生成大量的代理类造成的冗余；JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象jdk动态代理之所以只能代理接口是因为代理类本身已经extends了Proxy，而java是不允许多重继承的，但是允许实现多个接口优点：解决了静态代理中冗余的代理实现类问题。缺点：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。CGLIB 代理：由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。优点：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。缺点：技术实现相对难理解些。CGlib 对接口实现代理？12345678910111213141516171819202122232425262728293031323334353637383940import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import proxy.UserService;import java.lang.reflect.Method;/** * 创建代理类的工厂 该类要实现 MethodInterceptor 接口。 * 该类中完成三样工作： * （1）声明目标类的成员变量，并创建以目标类对象为参数的构造器。用于接收目标对象 * （2）定义代理的生成方法，用于创建代理对象。方法名是任意的。代理对象即目标类的子类 * （3）定义回调接口方法。对目标类的增强这在这里完成 */public class CGLibFactory implements MethodInterceptor &#123; // 声明目标类的成员变量 private UserService target; public CGLibFactory(UserService target) &#123; this.target = target; &#125; // 定义代理的生成方法,用于创建代理对象 public UserService myCGLibCreator() &#123; Enhancer enhancer = new Enhancer(); // 为代理对象设置父类，即指定目标类 enhancer.setSuperclass(UserService.class); /** * 设置回调接口对象 注意，只所以在setCallback()方法中可以写上this， * 是因为MethodIntecepter接口继承自Callback，是其子接口 */ enhancer.setCallback(this); return (UserService) enhancer.create();// create用以生成CGLib代理对象 &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println("start invoke " + method.getName()); Object result = method.invoke(target, args); System.out.println("end invoke " + method.getName()); return result; &#125;&#125;参考：Java 动态代理详解]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE代理</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-反射]]></title>
    <url>%2Fcategory%2FJavaSE-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 .class 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。要想剖析一个类，必须先要获取到该类的字节码文件对象，而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象反射库提供了一个非常丰富且精心设计的工具集，以便编写能够动态操作Java代码的程序.。能够分析类能力的程序称为反射，反射机制的功能极其强大，反射机制可以用来:在运行中分析类的能力在运行中查看对象实现通用的数组操作代码利用Method对象。Class类在程序运行期间，Java运行时系统始终未所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。然后，可以通过专门的Java类访问这些信息。保存这些信息的类被称为Class，这个名字很容易让人混淆。Object类中的getClass()方法将会返回一个Class类型的实例。一个Class对象表示一个特定类的属性，getName()方法返回类的名字。调用forName获得类名对应的Class对象,这个方法在类名保存在字符串中，并可在运行中改变就可以使用，只有在className是类名或接口名时才能够执行。否则将抛出一个checked exception(已检查异常)，所以无论何时使用这个方法，都应该提供一个异常处理器。如果T是任意的Java类型，T.class将代表匹配的类对象，一个Class对象实际表示的是一个类型，而这个类型未必一定是一种类。虚拟机为每个类型管理一个Class对象，因此，可以利用==运算符实现两个类对象比较的操作符。newInstance()可以快速地创建一个类的实例。newInstance方法调用默认的构造器初始化新创建的对象，如果这个类没有默认的构造器，就会抛出一个异常。将forName与newInstance配合起来使用，可以根据存储在字符串中的类名创建一个对象。12String s = “java.util.Date”;Object m = Class.forName(s).newInstance();利用反射分析类的能力检查类的结构:在java.lang.reflect包中有三个类Field、Method和Constructor分别用于描述类的域、方法和构造器。这三个类都有一个叫做getName的方法，用来返回项目的名称。Field类有一个getType方法，用来返回描述域所属类型的Class对象。Method和Constructor类有能够报告参数类型的方法，Method类还有一个可以报告返回类型的方法。这三个类还有一个叫做getModifiers的方法，它将返回一个整形数值，用不同的位开关描述public和static这样的修饰符使用状况。另外还有java.lang.reflect包中的Modifier类的静态方法分析getModifiers返回的整形数值。还可以利用Modifier.toString方法将修饰符打印出来。Class类中的getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员。Class类的getDeclareFields、getDeclareMethods和getDeclaredConstructors方法将分别返回类中生命的全部域、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员。在运行时使用反射分析对象：如果f是一个Field类型的对象，obj是某个包含f域的类的对象，f.get(obj)。将返回一个对象，其值为obj域的当前值。反射机制的默认行为受限于java的访问控制，然而，如果一个java程序没有收到安全管理器的控制，就可以覆盖访问控制，需要调用Field、Method或Construtor对象的setAsseccible方法类的加载和加载时机类的加载当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化加载就是指将class文件读入内存，并为之创建一个Class对象任何类被使用时系统都会建立有个Class对象连接验证：是否有正确的内部结构，并和其它类协调一致准备：负责为类的静态成员分配内存，并设置默认初始化值解析：将类的二进制数据中的符号引用替换为直接引用初始化类初始化时机创建类的实例访问类的静态变量，或者为静态变量赋值掉用类的静态方法使用反射方式来强制创建某个类或接口对应的java.lang.Class对象初始化某个类的子类直接使用java.exe命令来运行某个主类类加载器负责将.class文件加载到内存中，并为之生成对应的Class对象类加载器的组成Bootstrap ClassLoader根类加载器也被称为引导类加载器，负责Java核心类的加载比如System.String等，在JDK中JRE的lib目录下rt.jar文件中Extension ClassLoader扩展类加载器负责JRE的扩展目录中jar包的加载在JDK中JRE的lib目录下的ext目录System CLassLoader系统类加载器负责在JVM启动时加载来自Java命令的class文件，以及classpath环境变量所指定的jar包和类路径反射的基本应用反射可以用于判断任意对象所属的类，获得 Class 对象，构造任意一个对象以及调用一个对象。(反射相关的类一般都在 java.lang.relfect 包里)。获得Class对象使用Class类的forName静态方法：123public static Class&lt;?&gt; forName(String className)//比如在 JDBC 开发中常用此方法加载数据库驱动:Class.forName(driver);直接获取某一个对象的class：12Class&lt;?&gt; klass = int.class;Class&lt;?&gt; classInt = Integer.TYPE;调用某个对象的getClass()方法：12StringBuilder str = new StringBuilder("123");Class&lt;?&gt; klass = str.getClass();判断是否为某个类的实例一般地，我们用 instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的 isInstance() 方法来判断是否为某个类的实例，它是一个 native 方法：1public native boolean isInstance(Object obj);创建实例通过反射来生成对象主要有两种方式。使用Class对象的newInstance()方法来创建Class对象对应类的实例。12Class&lt;?&gt; c = String.class;Object str = c.newInstance();先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。1234567//获取String所对应的Class对象Class&lt;?&gt; c = String.class;//获取String类带一个String参数的构造器Constructor constructor = c.getConstructor(String.class);//根据构造器创建实例Object obj = constructor.newInstance("23333");System.out.println(obj);获取类的构造方法获取无参构造12345678910111213141516171819202122232425Class c = Class.forNmae("cn.goya.Student");//获取构造方法/*public Constructor[] getConstructors();所有公共构造方法public Constructor[] getDeclaredConstructors();所有构造方法Constructor[] cons = c.getDeclaredConstructors();for(Constructor con : cons)&#123; System.out.println(con);&#125;*///获取单个构造方法/*public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)参数表示的是:你要获取的构造方法的构造参数个数及数据类型的class字节码文件对象*/Constructor con = c.getConstructor();//返回的是构造方法对象//Student s = new Student();//System.out.println(s);//public T newInstance(Object... initargs)//使用此Constructor对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例Object obj = con.newInstance();System.out.println(obj);//Student s = (Student)obj;//s.show();获取带参构造1234567891011121314/*public Student(String name,int age,String address)Student s = new Student("张三","18","西安");System.out.println(s);*///获取字节码文件对象Class c = Class.forName("cn.goya.Student");//获取带参构造方法对象//public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)Constructor con = c.getConstructor(String.classs,int.class,String.class);//获取带参构造方法对象创建对象//public T new Instance(Object... initargs);Objec obj = con.newInstance("张三","18","西安");System.out.println(obj);获取私有构造1234567891011121314151617/*private Student(String name)&#123;&#125;Student s = new Student("李四");System.out.println(s);*///获取字节码文件对象Class c = Class.forName("cn.goya.Student");//获取私有构造方法对象//NoSuchMethodException:没有这个方法异常//原因是一开始我们使用的方法只能获取公共的，下面这种方法就可以Constructor con = c.getDeclaredConstructor(String.class);//用该私有构造方法创建对象//IllegalAcessException:非法访问异常//暴力访问con.setAccessible(true);//值为true则指示反射的对象在使用时应该取消Java语言访问检查Object obj = con.newInstance("李四");System.out.println(obj);获取类的成员变量1234567//获取所有成员getFields.getDeclaredFields();//获取单个成员getFields.getDeclaredField();//修改成员的值set(Object obj,Object value);//将指定对象变量上此Field对象表示的字段设置为指定的新值案例123456789101112131415161718192021222324//获取字节码文件对象Class c = Class.forName("cn.goya.Student");//获取所有成员变量/*Field[] fields = c.getFields();Field[] fields = c.getDeclaredFiedls();for(Field field:fields)&#123; System.out.println(field);&#125;*///Student s = new Student();s.address="上海";//通过无参构造方法创建对象Constructor con = c.getConstructor();Object obj = con.newInstance();System.out.println(obj);//获取单个的成员//获取address并对其赋值Field addressField = c.getField("address");//public void set(obj,Object value)//将指定此对象变量上此Field对象表示的字段设置为指定的新值addressField.set(obj,"上海");//给obj对象的addrrssField字段设置值System.out.println(obj);对于基本类型的静态常量，JVM 在编译阶段会把引用此常量的代码替换成具体的常量值。这么说来，在实际开发中，如果我们想修改某个类的常量值，恰好那个常量是基本类型的，岂不是无能为力了？反正我个人认为除非修改源码，否则真没办法！这里所谓的无能为力是指：我们在程序运行时刻依然可以使用反射修改常量的值（后面会代码验证），但是 JVM 在编译阶段得到的 .class 文件已经将常量优化为具体的值，在运行阶段就直接使用具体的值了，所以即使修改了常量的值也已经毫无意义了。获取成员方法获取无参无返回值的成员方法12345678910111213141516171819202122232425//获取字节码文件对象Class c = Class.forName("cn.goya.Student");//获取所有的方法//Method[] methods = c.getMethods();//获取自己的包括父亲的公共方法//Method[] methods = c.getDeclareMethods();//获取自己的所有的方法/*for(Method method:methods)&#123; System.out.println(method);&#125;*/Constructor con = c.getConstructor();Object obj = con.newInstance();/*Student s = new Student(); s.show();*///获取单个方法并使用//public void show()//public Method getMethod(String name,Class&lt;?&gt;... parameterTypes)//第一个参数表示的方法名，第二个参数表示的是方法的参数的class类型Methdo m1 = c.getMethod("show");//public Object invoke(Object obj,Object... args)m1.invole(obj);获取带参带返回值成员的方法1234567891011//public void method(String s)Method m2 = c.getMethod("method",String.class);m2.invoke(obj,"hello");//public String getString(String s,int i)Method m3 = c.getMethod("getString",String.class,int.class);//private void function()Method m3 = c.getDeclaredMethod("function");m4.setAccessible(true);m4.invoke(obj);通过反射越过泛型检查1234ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();Class c = array.getClass();//集合ArrayList的class对象Method m = c.getMethod("add",Object.class);m.invoke(array,"hello");//调用array的add方法，传入的值是hello反射源码解析当我们懂得了如何使用反射后，今天我们就来看看 JDK 源码中是如何实现反射的。或许大家平时没有使用过反射，但是在开发 Web 项目的时候会遇到过下面的异常：1234java.lang.NullPointerException ...sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497)可以看到异常堆栈指出了异常在 Method 的第 497 的 invoke 方法中，其实这里指的 invoke 方法就是我们反射调用方法中的 invoke。12Method method = clz.getMethod("setPrice", int.class); method.invoke(object, 4); //就是这里的invoke方法例如我们经常使用的 Spring 配置中，经常会有相关 Bean 的配置：12&lt;bean class="com.chenshuyi.Apple"&gt;&lt;/bean&gt;当我们在 XML 文件中配置了上面这段配置之后，Spring 便会在启动的时候利用反射去加载对应的 Apple 类。而当 Apple 类不存在或发生启发异常时，异常堆栈便会将异常指向调用的 invoke 方法。从这里可以看出，我们平常很多框架都使用了反射，而反射中最最终的就是 Method 类的 invoke 方法了。下面我们来看看 JDK 的 invoke 方法到底做了些什么。进入 Method 的 invoke 方法我们可以看到，一开始是进行了一些权限的检查，最后是调用了 MethodAccessor 类的 invoke 方法进行进一步处理，如下图红色方框所示。那么 MethodAccessor 又是什么呢？其实 MethodAccessor 是一个接口，定义了方法调用的具体操作，而它有三个具体的实现类：sun.reflect.DelegatingMethodAccessorImplsun.reflect.MethodAccessorImplsun.reflect.NativeMethodAccessorImpl而要看 ma.invoke() 到底调用的是哪个类的 invoke 方法，则需要看看 MethodAccessor 对象返回的到底是哪个类对象，所以我们需要进入 acquireMethodAccessor() 方法中看看。从 acquireMethodAccessor() 方法我们可以看到，代码先判断是否存在对应的 MethodAccessor 对象，如果存在那么就复用之前的 MethodAccessor 对象，否则调用 ReflectionFactory 对象的 newMethodAccessor 方法生成一个 MethodAccessor 对象。在 ReflectionFactory 类的 newMethodAccessor 方法里，我们可以看到首先是生成了一个 NativeMethodAccessorImpl 对象，再这个对象作为参数调用 DelegatingMethodAccessorImpl 类的构造方法。这里的实现是使用了代理模式，将 NativeMethodAccessorImpl 对象交给 DelegatingMethodAccessorImpl 对象代理。我们查看 DelegatingMethodAccessorImpl 类的构造方法可以知道，其实是将 NativeMethodAccessorImpl 对象赋值给 DelegatingMethodAccessorImpl 类的 delegate 属性。所以说ReflectionFactory 类的 newMethodAccessor 方法最终返回 DelegatingMethodAccessorImpl 类对象。所以我们在前面的 ma.invoke() 里，其将会进入 DelegatingMethodAccessorImpl 类的 invoke 方法中。进入 DelegatingMethodAccessorImpl 类的 invoke 方法后，这里调用了 delegate 属性的 invoke 方法，它又有两个实现类，分别是：DelegatingMethodAccessorImpl 和 NativeMethodAccessorImpl。按照我们前面说到的，这里的 delegate 其实是一个 NativeMethodAccessorImpl 对象，所以这里会进入 NativeMethodAccessorImpl 的 invoke 方法。而在 NativeMethodAccessorImpl 的 invoke 方法里，其会判断调用次数是否超过阀值（numInvocations）。如果超过该阀值，那么就会生成另一个MethodAccessor 对象，并将原来 DelegatingMethodAccessorImpl 对象中的 delegate 属性指向最新的 MethodAccessor 对象。到这里，其实我们可以知道 MethodAccessor 对象其实就是具体去生成反射类的入口。通过查看源码上的注释，我们可以了解到 MethodAccessor 对象的一些设计信息。“Inflation” mechanism. Loading bytecodes to implement Method.invoke() and Constructor.newInstance() currently costs 3-4x more than an invocation via native code for the first invocation (though subsequent invocations have been benchmarked to be over 20x faster).Unfortunately this cost increases startup time for certain applications that use reflection intensively (but only once per class) to bootstrap themselves.Inflation 机制。初次加载字节码实现反射，使用 Method.invoke() 和 Constructor.newInstance() 加载花费的时间是使用原生代码加载花费时间的 3 - 4 倍。这使得那些频繁使用反射的应用需要花费更长的启动时间。To avoid this penalty we reuse the existing JVM entry points for the first few invocations of Methods and Constructors and then switch to the bytecode-based implementations. Package-private to be accessible to NativeMethodAccessorImpl and NativeConstructorAccessorImpl.为了避免这种痛苦的加载时间，我们在第一次加载的时候重用了 JVM 的入口，之后切换到字节码实现的实现。就像注释里说的，实际的 MethodAccessor 实现有两个版本，一个是 Native 版本，一个是 Java 版本。Native 版本一开始启动快，但是随着运行时间边长，速度变慢。Java 版本一开始加载慢，但是随着运行时间边长，速度变快。正是因为两种存在这些问题，所以第一次加载的时候我们会发现使用的是 NativeMethodAccessorImpl 的实现，而当反射调用次数超过 15 次之后，则使用 MethodAccessorGenerator 生成的 MethodAccessorImpl 对象去实现反射。Method 类的 invoke 方法整个流程可以表示成如下的时序图： invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能。]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE反射</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-JVM]]></title>
    <url>%2Fcategory%2FJavaSE-jvm%2F</url>
    <content type="text"><![CDATA[JVM推荐周志明的《深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)》推荐：Java 虚拟机底层原理知识总结关于Jvm知识看这一篇就够了]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE-JVM</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-数组]]></title>
    <url>%2Fcategory%2FJavaSE-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组数组是一种数据结构，用来存储同一类型值的集合。通过一个整型下标可以访问数组中的每一个值。int[]a = new int[3];new int[3]:在堆内存空间创建一个int类型数组，数组有三个元素，有一个唯一地址值a:int类型数组，（引用类型），引用int[]a数组在堆内存创建的内存空间的唯一地址值int:指定数组类型数组在定义的时候必须进行初始化（静态初始化或者动态初始化）否则会报错。int类型数组默认初始化值为0String类型数组默认初始化值为nullboolean类型数组默认初始化值为falsedouble类型数组默认初始化值为0.0快速创建数组：int[]a = {1,2,3};数组的定义格式声明数组变量时，需要指出数组类型和数组变量的名字int[] a;数组的初始化动态初始化：初始化时只指定数组长度，由系统为数组分配初始化值静态初始化：初始化时指定每个数组元素的初始化值，由系统决定数组长度动态初始化只给长度，系统给出默认值。int [] arr = new int [3];静态初始化给出值，系统决定长度int[] arr = new int[] {1,2,3};int [] arr = {1,2,3};for each循环Java有一种功能很强的循环结构，可以用来依次处理数组中的每个元素for(variable: collection) statement数组拷贝在Java中允许将一个数组变量拷贝给另一个数组变量。这时两个变量将引用同一个数组int[] luckyNumbers = smallPrimes;luckyNumbers[5] = 12 //smallPrimes[5] = 12如果希望将一个数组的所有值拷贝到一个新的数字组中去，则要使用Arrays类的copyTo方法。int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers.length);第二个参数是新数组的长度。增加数组的大小:luckyNumbers = Arrays.copyOf(luckyNumbers,2 * luckyNumbers.length) ;如果数组元素是数值型，那么多余的元素将被赋值为0，如果数组元素是布尔值，则为false，如果长度小于原始数组的长度，则只拷贝最前 面的数据元素Arrays.copyOf(数组,数组长度);如果数组元素是数值型，那么多余的元素将被赋值为0；如果数组元素是布尔型，则将赋值为false。相反，如果长度小于原始数组的长度，则只拷贝最前面的数据元素.Java的内存分配栈存储局部变量堆存储所有new出来的东西方法区本地方法区（系统相关）寄存器（cpu使用）栈内存和堆内存的区别栈：数据使用完毕就消失堆：每一个new出来的东西都有地址、每一个变量都有默认值数据使用完毕后，在垃圾回收器空闲的时候回收。一个数组内存图数组排序Arrays.sort(数组);优化的快速排序算法static String toString(type[] a):返回包含a中数据元素的字符串，这些数据元素被放在括号内，并用逗号分隔.statictype copyOf(type[] a,int length):static type copyOf(type[] a,int start,int end):返回与a类型相同的一个数组，其长度为length或者end-start，数组元素为a的值拷贝的数据元素长度如果大于原数据元素长度，结果为0或falsestatic void sort(type[] a);static int binarySearch(type[] a,type v):static int binarySearch(type[] a,int start,int end,type v)利用二分搜索算法查找值V，如果查找成功，则返回相应的下标值，否则，返回一个负数rstatic void fill(type[] a,type v):将数组的所有数据元素值设置为vstatic boolean equals(type[] a,type[] b):如果两个数组大小，下标相同的元素都对应相等，返回true.数组常见操作遍历方式一：12345public static void printArray(int[] arr)&#123; for(int x = 0; x&lt;arr.length; x++)&#123; System.out.println(arr[x]); &#125;&#125;方式二：12345678910public static void printArray2(int[] arr)&#123; System.out.println("["); for(int x=0;x&lt;arr.length;x++)&#123; if(x == arr.length-1)&#123; System.out.println(arr[x]+"]"); &#125;else&#123; System.out.println(arr[x]+","); &#125; &#125;&#125;最值最大值：123456789public static int getMax(int[] arr)&#123; int max = arr[0]; for(int x = 1; x &lt; arr.length; x++)&#123; if(arr[x] &gt; max)&#123; max = arr[x]; &#125; &#125; return max;&#125;最小值：123456789public static int getMax(int[] arr)&#123; int max = arr[0]; for(int x =1; x &lt; arr.length;x++)&#123; if(arr[x] &gt; max)&#123; max = arr[x]; &#125; &#125; return max;&#125;逆序12345678public static int reverse(int[] arr)&#123; for(int x = 0; x &lt; arr.length/2; x++)&#123; int temp = arr[x]; arr[x] = arr[arr.length-1-x]; arr[arr.length-1-x] = temp; &#125; return -1;&#125;查表123public static String getString(String[] strArray,int index)&#123; return strArray[index];&#125;基本查找方式一：12345678public static int getIndex(int[] arr,int value)&#123; for(int x = 0;x &lt; arr.length; x++)&#123; if(arr[x] == value)&#123; return x; &#125; &#125; return -1;&#125;方式二：12345678910public static int getIndex2(int[] arr,int value)&#123; int index = -1; for(int x = 0; x&lt; arr.length;x++)&#123; if(arr[x] == value)&#123; index = x; break; &#125; &#125; return idex;&#125;二维数组二维数组是元素是一维数组的数组。格式:1234567数据类型[][] 数组名 = new 数组类型[m][n];数据类型[][] 数组名 = new 数组类型[m][];数据类型[][] 数组名 = new 数组类型[][]&#123;&#123;…&#125;,&#123;…&#125;,&#123;…&#125;&#125;;数据类型[][] 数组名 = &#123;&#123;…&#125;,&#123;…&#125;,&#123;…&#125;&#125;;二维数组的遍历123456public static void printArray3(int[][] arr)&#123; for(int x= 0; x&lt;arr.length;x++)&#123; System.out.println(arr[x][y]+" "); &#125; System.out.println();&#125;二维数组的求和1234567891011int[][] arr = &#123;&#123;22,33,23&#125;,&#123;45,65,85&#125;,&#123;52,77,969&#125;,&#123;55,44,11&#125;&#125;//定义一个求和变量sum，初始化值是0int sum = 0;//通过遍历就可以得到每一个二维数组的元素for(int x= 0;x&lt;arr.length;x++)&#123; for(int y = 0;y&lt;arr[x].length;y++)&#123; sum += arr[x][y]; &#125;&#125;//输出结果System.out.println(sum);杨辉三角12345678910111213141516171819Scanner sc = new Scanner(System.in);System.out.println("请输入一个数据:");int n = sc.nextInt();int[][] arr = new int[n][n];for(int x = 0;x&lt;arr.length;x++)&#123; arr[x][0] =1; arr[x][x] =1;&#125;for(int x =2;x&lt;arr.length;x++)&#123; for(int y =1;y&lt;=x-1;y++)&#123; arr[x][y] = arr[x-1][y-1]+arr[x-1][y]; &#125;&#125;for(int x = 0;x&lt;arr.length;x++)&#123; for(int y = 0;y&lt;arr[x].length;y++)&#123; System.out.println(arr[x][y]+" "); &#125; System.out.println();&#125;注意char类型与其他基本引用类型不同1234567public void println(char x[])&#123; synchronized(this)&#123; print(x); newLine(); &#125;&#125;//println方法会直接输出char数组的值12345678public void println(Object x)&#123; String s = String.valueOf(x); synchronized(this)&#123; print(s); newLine(); &#125;&#125;//其他类型：syste.out.print方法会打印出数组的地址值数组的高级二分查找查找：基本查找：数组元素无序(从头找到尾)二分查找(折半查找)：数组元素有序冒泡排序相邻位置比较，从小到大顺序，如果小就往前放，如果大就往后放外层循环控制轮数for(inti = 0;i&lt;a.length-1;j++)内层循环控制：比大小，换位置for(intj = 0;j&lt;a.length-1-i;j++)12345678910111213public void bubbleTest()&#123; int[] a = &#123;5,456,654,855,1&#125;; for(int i = 0; i &lt; a.length; i++)&#123; for(int j = 0; j &lt; a.length-1-i; j++)&#123; if(a[j] &gt; a[j+1])&#123; int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; &#125; &#125; &#125; System.out.println(Arrays.toString(a));&#125;内层循环控制一个数和几个数比外层循环控制你内层循环循环几次，你比几次i&lt;a.length-1:循环a数组长度-1（元素个数的循环次数，最后一次可以不用比）j&lt;a.length-1-i:循环a数组-1（下标数）-i（最后不用循环多次，次数在递减）new Scanner(System.in).nextInt()nextInt()方法有一个默认值，为10]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE数组</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-java8新特性]]></title>
    <url>%2Fcategory%2FJavaSE-java8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Java8新特性底层数据结构发生改变，更快底层内存结构发生改变：方法区是堆内存中永久区的一部分，1.8之后去掉方法区的永久区，方法区改为元空间。Lambda表达式为什么使用Lambda表达式Lambda 是一个匿名函数，我们可以把 Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。Lambda表达式有一个实现要求:SAM（Single AbstractMethod）只有一个抽象方法，除此之外没有其他方法@FunctionalInterface 函数式接口方法没有参数：（）-&gt;{};方法有参数：（参数，参数）-&gt;{};如果现在只有一行语句返回:(参数，参数)-&gt;语句从匿名类到 Lambda 的转换12345678910//匿名内部类Runnable r1= new Runnable()&#123; @Override public void run()&#123; System.out.println("HelloWorld!"); &#125;&#125;//Lambda表达式Runnable r1 = () -&gt; System.out.println("HelloWorld!");123456789101112//原来使用匿名内部类作为参数传递TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;()&#123; @Override public int compare(String o1,String o2)&#123; return Integer.compare(o1.length().o2.length()); &#125;&#125;);//Lambda表达式作为参数传递TreeSet&lt;String&gt; ts2 = new TreeSet&lt;&gt;( (o1,o2) -&gt; Integer.compare(o1.length(),o2.length()));Lambda表达式语法Lambda 表达式在Java 语言中引入了一个新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符或剪头操作符。它将 Lambda 分为两个部分：左侧：指定了 Lambda 表达式需要的所有参数右侧：指定了 Lambda 体，即 Lambda 表达式要执行的功能。语法格式1：无参，无返回值，Lambda体只需要一条语句1Runnabe r1 = () -&gt; System.out.println("HelloWorld!");语法格式2：Lambda需要一个参数1Consumer&lt;String&gt; fun = (args) -&gt; System.out.println(args);语法格式3：Lambda只需要一个参数时，参数的小括号可以省略1Consumer&lt;String&gt; fun = args -&gt; System.out.println(args);语法格式4：Lambda需要两个参数，并且有返回值1234BinaryOperator&lt;Long&gt; bo = (x,y) -&gt;&#123; System.out.println("实现函数接口方法"); return x + y;&#125;语法格式5：当Lambda体只有一条语句时，return与大括号可以省略1BinaryOperator&lt;Long&gt; bo = (x,y) -&gt; x + y;语法格式6：1234BinaryOperator&lt;Long&gt; bo = (Long x, Long y) -&gt;&#123;//数据类型可以省略，因为可由编译器推断得出，称为"类型推断" System.out.println("实现函数接口方法"); return x + y;&#125;类型推断上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”函数式接口只包含一个抽象方法的接口，称为函数式接口。你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。我们可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。自定义函数式接口12345678910@FunctionInterfacepublic interface MyNumber&#123; public double getValue();&#125;//函数式接口中使用泛型:@FunctionalInterfacepublic interface MyFunc&lt;T&gt;&#123; public T getValue(T t);&#125;作为参数传递Lambda表达式123456789public String toUpperString(MyFunc&lt;String&gt; mf,String str)&#123; return mf.getValue(str);&#125;//作为参数传递Lambda表达式:String newStr = toUpperString( (str) -&gt; str.toUpperCase(),"abcdef");System.out.println(newStr);作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。Java内置四大核心函数式接口函数式接口参数类型返回类型用途Consumer&lt;T&gt;消费型接口Tvoid对类型为T的对象应用操作，包含方法：void accept(T t);Supplier&lt;T&gt;供给型接口无T返回类型为T的对象，包含方法：T get();Function&lt;T,R&gt;TR对类型为T的对象应用操作，并返回结果，结果是R类型的对象，包含方法：R apply(T t);Predicate&lt;T&gt;Tboolean确定类型为T的对象是否满足某约束，并返回boolean值。包含方法：boolean test(T t);函数式接口参数类型返回类型用途BiFunction&lt;T,U,R&gt;T,UR对类型为T,U参数应用操作，返回R类型的结果，包含方法为R apply(T t,U u);UnaryOperator&lt;T&gt;（Function子接口）TT对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为T apply(T t);BinaryOperator&lt;T&gt;(BigFunction子接口)T，TT对类型为T的对象进行二元运算，并返回T类型的结果，包含方法为T apply(T t1,T t2);BigConsumer&lt;T,U&gt;T,Uvoid对类型为T,U参数应用操作，包含方法为void accept(T t,U u)ToIntFunction&lt;T&gt;ToLongFunction&lt;T&gt;ToDoubleFunctionTint,long,double分别计算int,long,double值的函数IntFunction&lt;R&gt;LongFunction&lt;R&gt;DoubleFunctionint,long,doubleR参数分别为int，long，double类型的参数方法引用与构造器引用方法引用当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！（实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致！）方法引用：使用操作符 “::” 将方法名和对象或类的名字分隔开来。如下三种主要使用情况：对象::实例方法类::静态方法类::实例方法例如：123(x) -&gt; System.out.println(x);//等同于：System.out::println;123BinaryOperator&lt;Double&gt; bo = (x,y) -&gt; Math.pow(x,y);//等同于：BinaryOperator&lt;Double&gt; bo = Math::pow;123compare((x,y) -&gt; x.equals(y),"abcdef","abcdef");//等同于：comare(String::equals,"abc","abc");注意：当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引用方法的第二个参数(或无参数)时：ClassName::methodName构造器引用格式： ClassName::new与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，与构造器参数列表要与接口中抽象方法的参数列表一致！例如：123Function&lt;Integer,MyClass&gt; fun = (n) -&gt; new MyClass(n);//等同于Function&lt;Integer,MyClass&gt; fun = MyClass::new;数组引用格式： type[] :: new例如：123Function&lt;Integer,Integer[]&gt; fun = (n) -&gt; new Integer[n];//等同于Function&lt;Integer,Integer[]&gt; fun = Integer[]::new;StreamAPIJava8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API(java.util.stream.*)。Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。流(Stream) 到底是什么呢？是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。“集合讲的是数据，流讲的是计算！”注意：Stream 自己不会存储元素。Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。Strean的操作三个步骤创建Stream一个数据源(如：集合、数组),获取一个流中间操作一个中间操作链，对数据源的数据进行处理终止操作(终端操作)一个终止操作，执行中间操作链，并产生结果创建StreamJava8 中的 Collection 接口被扩展，提供了两个获取流的方法：12default Stream stream(); //返回一个顺序流default Stream parallelStream(); //返回一个并行流由数组创建流Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：1static Stream stream(T[] array);//返回一个流重载形式，能够处理对应基本类型的数组：123public static IntStream stream(int[] array)public static LongStream stream(long[] array)public static DoubleStream stream(double[] array)由值创建流可以使用静态方法 Stream.of(), 通过显示值创建一个流。它可以接收任意数量的参数。1public static&lt;T&gt; Stream&lt;T&gt; of(T... values); //返回一个流由函数创建流：创建无限流可以使用静态方法 Stream.iterate() 和Stream.generate(), 创建无限流。迭代public static Stream iterate(final T seed, finalUnaryOperator f)生成public static Stream generate(Supplier s）Stream的中间操作多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。筛选与切片方法描述filter(Predicate p)接收Lembda，从流中排除某些元素distinct()筛选，通过流所生成元素的hashCode()和equals()去除重复元素limit(long maxSize)截断流，使其元素不超过给定数量skip(long n)跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，则返回一个空流，与limit(n)互补映射方法描述map(Function f)接收一函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素mapToDouble(ToDoubleFunction f)接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStreammapToInt(ToIntFunction f)接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStreammapToLong(ToLongFunction f)接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStreamflatMap(Function f)接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流排序方法描述sorted()产生一个新流，其中按自然顺序排序sorted(Comparator comp)产生一个新流，其中按比较器顺序排序Sream的终止操作终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。查找与匹配方法描述allMath(Predicate p)检查是否匹配所有元素antMath(Predicate p)检查是否至少匹配一个元素noneMath(Predicate p)检查是否没有匹配所有元素findFirst()返回第一个元素findAny()返回当前流中的任意元素count()返回流中元素总数max(Comparator c)返回流中最大值min(Coparator c)返回流中最小值forEach(Consumer c)内部迭代(使用Collection接口需要用户去做迭代，称为外部迭代，相反，StreamAPI使用内部迭代—-它帮你把迭代做了)归约方法描述reduce(T iden,BinaryOperator b)可以将流中元素反复结合起来，得到一个值。返回Treduce(BinaryOperator b)可以将流中元素反复结合起来，得到一个值，返回Optional&lt;T&gt;收集方法描述collect(Collector c)将流转换为其他形式，接收一个Collector接口的实现，用于给Steam中元素做汇总工作Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下：1234567891011121314151617181920212223242526272829303132333435363738394041toList List&lt;T&gt; //把流中元素收集到List List&lt;Employee&gt; emps = list.stream().collect(Collectors.tolist()); toSet Set&lt;T&gt; //把流中元素收集到SetSet&lt;Employee emps = list.stream().collect(Collectors.toSet()); toCollection Collection&lt;T&gt; //把流中元素收集到创建的集合Collection&lt;Employee&gt; empls = list.stream().collect(Collectors.toCollection(ArrayList::new));counting Long //计算流中元素的个数long count = list.stream().collect(Collectors.counting());summingInt Integer //对流中元素的整数属性求和inttotal = list.stream().collect(Collectors.summingInt(Employee::getSalary));averaginInt Double // 计算流中元素Integer属性的平均值doubleavg = list.stream().collect(Collectors.averagingInt(Employee::getSalary));summarrizingInt IntSummartStatistics //收集流中Integer属性的统计值，如平均值IntSummaryStatisticsiss = list.stream().collect(Collectors.summarizingInt(Employee::getSalary));joining String //连接流中每个字符串String str = list.stream().map(Employee::getName).collect(Collectors.joining());maxBy Optional&lt;T&gt; //根据比较器选择最大值Optional&lt;Emp&gt; max = list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));minBy Optional&lt;T&gt; //根据比较器选择最小值Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));reducing 归约产生的类型 //从一个作为累加器的初始值开始，利用BinaryOperator流中元素逐个结合，从而归约成单个值inttotal=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));collectingAndThen 转换函数返回的类型 //包裹另一个收集器，对其结果转换函数inthow= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));groupingBy Map&lt;K, List&lt;T&gt;&gt; //根据某属性值对流分组，属性为K，结果为VMap&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));partitioningBy Map&lt;Boolean, List&lt;T&gt;&gt; //根据true或false进行分区Map&lt;Boolean,List&lt;Emp&gt;&gt;vd=list.stream().collect(Collectors.partitioningBy(Employee::getManage));并行流与串行流并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与sequential() 在并行流与顺序流之间进行切换。Fork/Join 框架Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总.Fork/Join 框架与传统线程池的区别采用 “工作窃取”模式（work-stealing）：当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间,提高了性能.新时间日期API使用 LocalDate、LocalTime、LocalDateTimeLocalDate、LocalTime、LocalDateTime 类的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法Instant 时间戳用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算Duration 和 PeriodDuration:用于计算两个“时间”间隔Period:用于计算两个“日期”间隔日期的操纵TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。TemporalAdjusters : 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现。例如获取下个周日：123LocalDate nextSunday = LocalDate.now().with( TemporalAdjusters.next(DayOfWeek.SUNDAY));解析与格式化java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：预定义的标准格式语言环境相关的格式自定义的格式时区的处理Java8 中加入了对时区的支持，带时区的时间为分别为：ZonedDate、ZonedTime、ZonedDateTime其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式例如 ：Asia/Shanghai 等ZoneId：该类中包含了所有的时区信息getAvailableZoneIds() : 可以获取所有时区时区信息of(id) : 用指定的时区信息获取 ZoneId 对象与传统日期处理的转换接口中的默认方法与静态方法Java 8中允许接口中包含具有具体实现的方法，该方法称为“默认方法”，默认方法使用 default 关键字修饰。例如：1234567interface MyFunc&lt;T&gt;&#123; T func(int a); defalut String getName()&#123; return "Hello Java8"; &#125;&#125;接口默认方法的”类优先”原则若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突1234567891011121314151617interface MyFunc&#123; defalut String getName()&#123; return "Hello Java8"; &#125;&#125;interface Named&#123; defalut String getName()&#123; return "Hello Java"; &#125;&#125;class MyClass implements MyFunc,Named&#123; public String getName()&#123; return Named.super,getName(); &#125;&#125;接口中的静态方法Java8 中，接口中允许添加静态方法。12345678910interface Named&#123; public Integer myFun(); default String getName()&#123; return "Hello java"; &#125; static void show()&#123; System.out.println("Hello World"); &#125;&#125;其他特性Optional类Optional 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。常用方法：Optional.of(T t) : 创建一个 Optional 实例Optional.empty() : 创建一个空的 Optional 实例Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例isPresent() : 判断是否包含值orElse(T t) : 如果调用对象包含值，返回该值，否则返回torElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()flatMap(Function mapper):与 map 类似，要求返回值必须是Optional重复注解与类型注解Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。123456789101112131415161718@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotations&#123; MyAnnotation[] value();&#125;@Repetable(MyAnnotations.class)@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,ElementType.TYPE_PARAMETER&#125;)@Retention(RetemtionPolicy.RUNTIME)public @interface MyAnnotation&#123; String value();&#125;@MyAnnotation("Hello")@MyANnotation("World")public void show(@MyAnnotation("abc")String str)&#123; &#125;JUC在 Java 5.0 提供了 java.util.concurrent （简称JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。提供可调的、灵活的线程池。还提供了设计用于多线程上下文中的 Collection 实现等。volatile关键字 内存可见性内存可见性内存可见性（Memory Visibility）是指当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。可见性错误是指当读操作与写操作在不同的线程中执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。我们可以通过同步来保证对象被安全地发布。除此之外我们也可以使用一种更加轻量级的 volatile 变量。volatile 关键字Java 提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。可以将 volatile 看做一个轻量级的锁，但是又与锁有些不同：对于多线程，不是一种互斥关系不能保证变量状态的“原子性操作”原子变量 CAS算法CAS算法CAS (Compare-And-Swap) 是一种硬件对并发的支持，针对多处理器操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。CAS 是一种无锁的非阻塞算法的实现。CAS 包含了 3 个操作数：需要读写的内存值 V进行比较的值 A拟写入的新值 B当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作。原子变量类的小工具包，支持在单个变量上解除锁的线程安全编程。事实上，此包中的类可将 volatile 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类。类 AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 的实例各自提供对相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray 类进一步扩展了原子操作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方面也引人注目，这对于普通数组来说是不受支持的。核心方法：boolean compareAndSet(expectedValue, updateValue)java.util.concurrent.atomic 包下提供了一些原子操作的常用类:AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReferenceAtomicIntegerArray 、AtomicLongArrayAtomicMarkableReferenceAtomicReferenceArrayAtomicStampedReferenceConcurrentHashMap 锁分段机制ConcurrentHashMapJava 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。ConcurrentHashMap 同步容器类是Java 5 增加的一个线程安全的哈希表。对与多线程的操作，介于 HashMap 与 Hashtable 之间。内部采用“锁分段”机制替代 Hashtable 的独占锁。进而提高性能。此包还提供了设计用于多线程上下文中的 Collection 实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap，ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。CountDownLatch 闭锁Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。CountDownLatch 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行：确保某个计算在其需要的所有资源都被初始化之后才继续执行;确保某个服务在其依赖的所有其他服务都已经启动之后才启动;等待直到某个操作所有参与者都准备就绪再继续执行。实现 Callable 接口Java 5.0 在 java.util.concurrent 提供了一个新的创建执行线程的方式：Callable 接口Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常。Callable 需要依赖FutureTask ，FutureTask 也可以用作闭锁。Lock 同步锁显示锁 Lock在 Java 5.0 之前，协调共享对象的访问时可以使用的机制只有 synchronized 和 volatile 。Java 5.0 后增加了一些新的机制，但并不是一种替代内置锁的方法，而是当内置锁不适用时，作为一种可选择的高级功能。ReentrantLock 实现了 Lock 接口，并提供了与synchronized 相同的互斥性和内存可见性。但相较于synchronized 提供了更高的处理锁的灵活性。Condition 控制线程通信ConditionCondition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是await、signal 和 signalAll。Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得Condition 实例，请使用其 newCondition() 方法。线程按序交替编写一个程序，开启 3 个线程，这三个线程的 ID 分别为A、B、C，每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出的结果必须按顺序显示。如：ABCABCABC…… 依次递归ReadWriteLock 读写锁ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。。ReadWriteLock 读取操作通常不会改变共享资源，但执行写入操作时，必须独占方式来获取锁。对于读取操作占多数的数据结构。 ReadWriteLock 能提供比独占锁更高的并发性。而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作。线程八锁一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法加个普通方法后发现和同步锁无关换成两个对象后，不是同一把锁了，情况立刻变化。都换成静态同步方法后，情况又变化所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！线程池第四种获取线程的方法：线程池，一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 ：Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）Executors.newFixedThreadPool(int)（固定大小线程池）Executors.newSingleThreadExecutor()（单个后台线程）它们均为大多数使用场景预定义了设置。线程调度ScheduledExecutorService一个 ExecutorService，可安排在给定的延迟后运行或定期执行的命令。ForkJoinPool 分支/合并框架 工作窃取Fork/Join 框架Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总。Fork/Join 框架与线程池的区别采用 “工作窃取”模式（work-stealing）：当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间，提高了性能。NIOJava NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。Java NIO 与 IO 的主要区别通道（Channel）与缓冲区（Buffer）Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。简而言之，Channel 负责传输， Buffer 负责存储缓冲区（Buffer）缓冲区（Buffer）：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的。Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类：ByteBufferCharBufferShortBufferIntBufferLongBufferFloatBufferDoubleBuffer上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。都是通过如下方法获取一个 Buffer对象：static XxxBuffer allocate(int capacity) : 创建一个容量为 capacity 的 XxxBuffer 对象缓冲区的基本属性Buffer 中的重要概念：容量 (capacity) ：表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。限制 (limit)：第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量。位置 (position)：下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制标记 (mark)与重置 (reset)：标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position.标记、位置、限制、容量遵守以下不变式： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacityBuffer的常用方法缓冲区的数据操作Buffer 所有子类提供了两个用于数据操作的方法：get()与 put() 方法获取 Buffer 中的数据get() ：读取单个字节get(byte[] dst)：批量读取多个字节到 dst 中get(int index)：读取指定索引位置的字节(不会移动 position)放入数据到 Buffer 中put(byte b)：将给定单个字节写入缓冲区的当前位置put(byte[] src)：将 src 中的字节写入缓冲区的当前位置put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 position)直接与非直接缓冲区字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。直接字节缓冲区可以通过调用此类的 allocateDirect() 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。直接字节缓冲区还可以通过 FileChannel 的 map() 方法 将文件区域直接映射到内存中来创建。该方法返回MappedByteBuffer 。Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。非直接缓冲区直接缓冲区通道（Channel）通道（Channel）：由 java.nio.channels 包定义的。Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据，Channel 只能与Buffer 进行交互。Java 为 Channel 接口提供的最主要实现类如下：FileChannel：用于读取、写入、映射和操作文件的通道。DatagramChannel：通过 UDP 读写网络中的数据通道。SocketChannel：通过 TCP 读写网络中的数据。ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。获取通道获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：FileInputStreamFileOutputStreamRandomAccessFileDatagramSocketSocketServerSocket获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道。通道的数据传输将 Buffer 中数据写入 Channel12//将Buffer中数据写入Channel中int bytesWritten = inChannel.write(buf);从 Channel 读取数据到 Buffer12//从Channel读取数据到Bufferint bytesRead = inChannel.read(buf);分散(Scatter)和聚集(Gather)分散读取（Scattering Reads）是指从 Channel 中读取的数据“分散”到多个 Buffer 中。注意：按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满。聚集写入（Gathering Writes）是指将多个 Buffer 中的数据“聚集”到 Channel。注意：按照缓冲区的顺序，写入 position 和 limit 之间的数据到 Channel 。transferFrom()将数据从源通道传输到其他 Channel 中：123456789101112131415RandomAccessFile fromFile = new RandomAccessFile("data/fromFile.txt","rw");//获取FileChannelFileChannel fromChannel = fromFile.getChannel();RandomAccessFile toFile = new RandomAccessFile("data/toFile.txt","rw");FileChannel toChannel = toFile.getChannel();//定义传输位置long position = 0L;//最多传输的字节数long count = fromChannel.size();//将数据从源通道传输到另一个通道toChannel.transferFrom(fromChannel,count,position);transferTo()将数据从源通道传输到其他 Channel 中：123456789101112131415RandomAccessFile fromFile = new RandomAccessFile("data/fromFile.txt","rw");//获取FileChannelFileChannel fromChannel = fromFile.getChannel();RandomAccessFile toFile = new RandomAccessFile("data/toFile.txt","rw");FileChannel toChannel = toFile.getChannel();//定义传输位置long position = 0L;//最多传输的字节数long count = fromChannel.size();//将数据从源通道传输到另一个通道fromChannel.transferTo(position,count,toChannel);FileChannel 的常用方法NIO 的非阻塞式网络通信阻塞与非阻塞传统的 IO 流都是阻塞式的。也就是说，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行 IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO 可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。选择器（Selector）选择器（Selector） 是 SelectableChannle 对象的多路复用器，Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心。SelectableChannle 的结构如下图：选择器（Selector）的应用创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。12//创建选择器Selector selector = Selector.open();向选择器注册通道：SelectableChannel.register(Selector sel, int ops)1234567891011121314//创建一个Socket套接字Socket socket = new Sokcet(InetAddress.getByName("127.0.0.1"),9898);//获取SocketChannelSocketChannel channel = scoket.getChannel();//创建选择器Selector selector = Selector.open();//将SocketChannel切换到非阻塞模式channel.configureBlocking(false);//向Selector注册ChannelSelectionKey key = channel.register(selector,SelectionKey.OP_READ);SelectionKey当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。可以监听的事件类型（可使用 SelectionKey 的四个常量表示）：读 : SelectionKey.OP_READ （1）写 : SelectionKey.OP_WRITE （4）连接 : SelectionKey.OP_CONNECT （8）接收 : SelectionKey.OP_ACCEPT （16）若注册时不止监听一个事件，则可以使用“位或”操作符连接。12//注册"监听事件"int interestSet = SelectionKey.OP_READ|SelectionKey.OP_WRITE;SelectionKey：表示 SelectableChannel 和 Selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。Selector 的常用方法SocketChannelJava NIO中的SocketChannel是一个连接到TCP网络套接字的通道。操作步骤：打开 SocketChannel读写数据关闭 SocketChannelJava NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道，就像标准IO中的ServerSocket一样。DatagramChannelJava NIO中的DatagramChannel是一个能收发UDP包的通道。操作步骤：打开 DatagramChannel接收/发送数据管道 (Pipe)Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。向管道写数据1234567891011121314151617181920@Testpublic void test1() throws IOException&#123; String str = "测试数据"; //创建管道 Pipe pipe = Pipe.open(); //向管道写输入 Pipe.SinkChannel sinkChannel = pipe.sink(); //通过SinkChannel的write()方法写数据 ByteBuffer buf = ByteBuffer.allocate(1024); buf.clear(); buf.put(str.getBytes()); buf.flip(); while(buf.hasRemaining())&#123; sinkChannel.write(buf); &#125;&#125;从管道读取数据从读取管道的数据，需要访问source通道。12//从管道读取数据Pipe.SourceChannel sourceChannel = pipe.source();调用source通道的read()方法来读取数据123//调用SourceChannel的read()方法读取数据ByteBuffer buf = ByteBuffer.allocate(1024);sourceChannel.read(buf);NIO.2 – Path、Paths、FilesNIO.2随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。Path 与 Pathsjava.nio.file.Path 接口代表一个平台无关的平台路径，描述了目录结构中文件的位置。Paths 提供的 get() 方法用来获取 Path 对象：Path get(String first, String … more) : 用于将多个字符串串连成路径。Path 常用方法：boolean endsWith(String path) : 判断是否以 path 路径结束boolean startsWith(String path) : 判断是否以 path 路径开始boolean isAbsolute() : 判断是否是绝对路径Path getFileName() : 返回与调用 Path 对象关联的文件名Path getName(int idx) : 返回的指定索引位置 idx 的路径名称int getNameCount() : 返回Path 根目录后面元素的数量Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径Path getRoot() ：返回调用 Path 对象的根路径Path resolve(Path p) :将相对路径解析为绝对路径Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象String toString() ： 返回调用 Path 对象的字符串表示形式Files 类java.nio.file.Files 用于操作文件或目录的工具类。Files常用方法：Path copy(Path src, Path dest, CopyOption … how) : 文件的复制Path createDirectory(Path path, FileAttribute … attr) : 创建一个目录Path createFile(Path path, FileAttribute … arr) : 创建一个文件void delete(Path path) : 删除一个文件Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置long size(Path path) : 返回 path 指定文件的大小Files常用方法：用于判断boolean exists(Path path, LinkOption … opts) : 判断文件是否存在boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录boolean isExecutable(Path path) : 判断是否是可执行文件boolean isHidden(Path path) : 判断是否是隐藏文件boolean isReadable(Path path) : 判断文件是否可读boolean isWritable(Path path) : 判断文件是否可写boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在public static &lt;A extends BasicFileAttributes&gt; A readAttributes(Path path,Class&lt;A&gt; type,LinkOption...options) : 获取与 path 指定的文件相关联的属性。Files常用方法：用于操作内容SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式DirectoryStream newDirectoryStream(Path path) : 打开 path 指定的目录InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象]()自动资源管理Java 7 增加了一个新特性，该特性提供了另外一种管理资源的方式，这种方式能自动关闭文件。这个特性有时被称为自动资源管理(Automatic Resource Management, ARM)， 该特性以 try 语句的扩展版为基础。自动资源管理主要用于，当不再需要文件（或其他资源）时，可以防止无意中忘记释放它们。自动资源管理基于 try 语句的扩展形式：12345678910111213141516try(需要关闭的资源声明)&#123;//可能发生异常的语句&#125;catch(异常类型 变量名)&#123;//异常的处理语句&#125;……finally&#123;//一定执行的语句&#125;/*当 try 代码块结束时，自动释放资源。因此不需要显示的调用 close() 方法。该形式也称为“带资源的 try 语句”。注意：1. try 语句中声明的资源被隐式声明为 final ，资源的作用局限于带资源的 try 语句2. 可以在一条 try 语句中管理多个资源，每个资源以“;” 隔开即可。3. 需要关闭的资源，必须实现了 AutoCloseable 接口或其自接口 Closeable*/]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE-java8新特性</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-枚举]]></title>
    <url>%2Fcategory%2FJavaSE-%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[枚举枚举类型是Java 5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。枚举实现原理实际上在使用关键字enum创建枚举类型并编译后，编译器会为我们生成一个相关的类，这个类继承了Java API中的java.lang.Enum类，也就是说通过关键字enum创建枚举类型在编译后事实上也是一个类类型而且该类继承自java.lang.Enum类。下面我们编译前面定义的EnumDemo.java并查看生成的class文件来验证这个结论：12345678//查看目录下的java文件zejian@zejiandeMBP enumdemo$ lsEnumDemo.java//利用javac命令编译EnumDemo.javazejian@zejiandeMBP enumdemo$ javac EnumDemo.java //查看生成的class文件，注意有Day.class和EnumDemo.class 两个zejian@zejiandeMBP enumdemo$ lsDay.class EnumDemo.class EnumDemo.java利用javac编译前面定义的EnumDemo.java文件后分别生成了Day.class和EnumDemo.class文件，而Day.class就是枚举类型，这也就验证前面所说的使用关键字enum定义枚举类型并编译后，编译器会自动帮助我们生成一个与枚举相关的类。我们再来看看反编译Day.class文件：12345678910111213141516171819202122232425262728293031323334353637383940414243//反编译Day.classfinal class Day extends Enum&#123; //编译器为我们添加的静态的values()方法 public static Day[] values() &#123; return (Day[])$VALUES.clone(); &#125; //编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法 public static Day valueOf(String s) &#123; return (Day)Enum.valueOf(com/zejian/enumdemo/Day, s); &#125; //私有构造函数 private Day(String s, int i) &#123; super(s, i); &#125; //前面定义的7种枚举实例 public static final Day MONDAY; public static final Day TUESDAY; public static final Day WEDNESDAY; public static final Day THURSDAY; public static final Day FRIDAY; public static final Day SATURDAY; public static final Day SUNDAY; private static final Day $VALUES[]; static &#123; //实例化枚举实例 MONDAY = new Day("MONDAY", 0); TUESDAY = new Day("TUESDAY", 1); WEDNESDAY = new Day("WEDNESDAY", 2); THURSDAY = new Day("THURSDAY", 3); FRIDAY = new Day("FRIDAY", 4); SATURDAY = new Day("SATURDAY", 5); SUNDAY = new Day("SUNDAY", 6); $VALUES = (new Day[] &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;); &#125;&#125;从反编译的代码可以看出编译器确实帮助我们生成了一个Day类(注意该类是final类型的，将无法被继承)而且该类继承自java.lang.Enum类，该类是一个抽象类(稍后我们会分析该类中的主要方法)，除此之外，编译器还帮助我们生成了7个Day类型的实例对象分别对应枚举中定义的7个日期，这也充分说明了我们前面使用关键字enum定义的Day类型中的每种日期枚举常量也是实实在在的Day实例对象，只不过代表的内容不一样而已。注意编译器还为我们生成了两个静态方法，分别是values()和 valueOf()，稍后会分析它们的用法，到此我们也就明白了，使用关键字enum定义的枚举类型，在编译期后，也将转换成为一个实实在在的类，而在该类中，会存在每个在枚举类型中定义好变量的对应实例对象，如上述的MONDAY枚举类型对应public static final Day MONDAY;，同时编译器会为该类创建两个方法，分别是values()和valueOf()。枚举类在某些情况下，一个类的对象时有限且固定的，如季节类，它只有春夏秋冬4个对象这种实例有限且固定的类，在 Java 中被称为枚举类；在 Java 中使用 enum 关键字来定义枚举类，其地位与 class、interface 相同；枚举类是一种特殊的类，它和普通的类一样，有自己的成员变量、成员方法、构造器 (只能使用 private 访问修饰符，所以无法从外部调用构造器，构造器只在构造枚举值时被调用)；一个 Java 源文件中最多只能有一个 public 类型的枚举类，且该 Java 源文件的名字也必须和该枚举类的类名相同，这点和类是相同的；使用 enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口;所有的枚举值都是 public static final 的，且非抽象的枚举类不能再派生子类；枚举类的所有实例(枚举值)必须在枚举类的第一行显式地列出，否则这个枚举类将永远不能产生实例。列出这些实例(枚举值)时，系统会自动添加 public static final 修饰，无需程序员显式添加。定义枚举类12345// 定义一个星期的枚举类public enum WeekEnum &#123; // 在第一行显式地列出7个枚举实例(枚举值)，系统会自动添加 public static final 修饰 SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY;&#125;枚举类的成员变量、成员方法、构造器123456789101112131415161718192021222324public enum WeekEnum &#123; // 因为已经定义了带参数的构造器，所以在列出枚举值时必须传入对应的参数 SUNDAY("星期日"), MONDAY("星期一"), TUESDAY("星期二"), WEDNESDAY("星期三"), THURSDAY("星期四"), FRIDAY("星期五"), SATURDAY("星期六"); // 定义一个 private 修饰的实例变量 private String date; // 定义一个带参数的构造器，枚举类的构造器只能使用 private 修饰 private WeekEnum(String date) &#123; this.date = date; &#125; // 定义 get set 方法 public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; &#125;枚举的常见方法12345678910111213int compareTo(E o) //比较此枚举与指定对象的顺序,同一个枚举实例只能与相同类型的枚举实例比较。如果该枚举对象位于指定枚举对象之后，则返回正整数；反之返回负整数；否则返回零；boolean equals(Object other) //当指定对象等于此枚举常量时，返回 true。Class&lt;?&gt; getDeclaringClass() //返回与此枚举常量的枚举类型相对应的 Class 对象String name() //返回此枚举常量的名称，在其枚举声明中对其进行声明int ordinal() //返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零）String toString() //返回枚举常量的名称，它包含在声明中static&lt;T extends Enum&lt;T&gt;&gt; T static valueOf(Class&lt;T&gt; enumType, String name) //返回带指定名称的指定枚举类型的枚举常量。这里主要说明一下ordinal()方法，该方法获取的是枚举变量在枚举类中声明的顺序，下标从0开始，如日期中的MONDAY在第一个位置，那么MONDAY的ordinal值就是0，如果MONDAY的声明位置发生变化，那么ordinal方法获取到的值也随之变化，注意在大多数情况下我们都不应该首先使用该方法，毕竟它总是变幻莫测的。compareTo(E o)方法则是比较枚举的大小，注意其内部实现是根据每个枚举的ordinal值大小进行比较的。name()方法与toString()几乎是等同的，都是输出变量的字符串形式。至于valueOf(ClassenumType, String name)方法则是根据枚举类的Class对象和枚举名称获取枚举常量，注意该方法是静态的，12345678910111213public class Test01 &#123; public static void main(String[] args) &#123; System.out.println(WeekEnum.FRIDAY.compareTo(WeekEnum.MONDAY)); System.out.println(WeekEnum.FRIDAY.compareTo(WeekEnum.SUNDAY)); System.out.println(WeekEnum.FRIDAY.compareTo(WeekEnum.SATURDAY)); &#125;&#125;/*运行结果：45-1*/1234567891011121314// 没有重写 toString 方法//static values()： 返回一个包含全部枚举值的数组，可以用来遍历所有枚举值；for (WeekEnum we : WeekEnum.values()) &#123; System.out.println(we); &#125;/*SUNDAYMONDAYTUESDAYWEDNESDAYTHURSDAYFRIDAYSATURDAY*/123456789101112131415161718192021222324252627282930313233343536373839404142434445//String toString()： 返回枚举值的名称，与 name 方法类似，更常用；// 定义一个星期的枚举类public enum WeekEnum &#123; // 因为已经定义了带参数的构造器，所以在列出枚举值时必须传入对应的参数 SUNDAY("星期日"), MONDAY("星期一"), TUESDAY("星期二"), WEDNESDAY("星期三"), THURSDAY("星期四"), FRIDAY("星期五"), SATURDAY("星期六"); // 定义一个 private 修饰的实例变量 private String date; // 定义一个带参数的构造器，枚举类的构造器只能使用 private 修饰 private WeekEnum(String date) &#123; this.date = date; &#125; // 定义 get set 方法 public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; // 重写 toString() 方法 @Override public String toString()&#123; return date; &#125;&#125;// 重写了 toString 方法for (WeekEnum we : WeekEnum.values()) &#123; System.out.println(we); &#125;/*星期日星期一星期二星期三星期四星期五星期六*/1234567//int ordinal()： 返回枚举值在枚举类中的索引值(从0开始)，即枚举值在枚举声明中的顺序，这个顺序根据枚举值声明的顺序而定；System.out.println(WeekEnum.SUNDAY.ordinal());System.out.println(WeekEnum.FRIDAY.ordinal());/*05*/1234567891011121314//static valueOf()： 返回带指定名称的指定枚举类型的枚举常量，名称必须与在此类型中声明枚举常量所用的标识符完全匹配(不允许使用额外的空白字符)。这个方法与toString相对应，因此重写 toString() 方法，一定要重写 valueOf() 方法(我们可以重写 toString() 方法，但不能自己重写 valueOf() 方法，当我们重写 toString() 方法时，valueOf() 方法会自动重写，不用我们理会。)；public class Test01 &#123; public static void main(String[] args) &#123; System.out.println(WeekEnum.valueOf(WeekEnum.class, "MONDAY")); System.out.println(WeekEnum.valueOf(WeekEnum.class, "FRIDAY")); System.out.println(WeekEnum.valueOf(WeekEnum.class, "SUNDAY")); &#125;&#125;/*运行结果MONDAYFRIDAYSUNDAY*/使用枚举类实现接口12345public interface GenderDescription &#123; public void info();&#125;上面定义了一个接口，该接口有一个 info() 方法，凡是实现该接口的类都需要实现该方法。12345678910public enum Gender implements GenderDescription &#123; MALE,FEMALE; @Override public void info() &#123; System.out.println("这是一个用于定义性别的枚举类"); &#125;&#125;12345678910111213public class Test02 &#123; public static void main(String[] args) &#123; Gender.MALE.info(); Gender.FEMALE.info(); &#125; &#125;/*运行结果这是一个用于定义性别的枚举类这是一个用于定义性别的枚举类*/包含抽象方法的枚举类定义一个 Operation 枚举类，有4个枚举值PLUS、MINUS、TIMES、DIVIDE，分别代表加、减、乘、除，该枚举类有一个 calculate() 方法，用于完成计算。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public enum Operation &#123; // 用于执行加法运算 PLUS &#123; // 花括号部分其实是一个匿名内部子类 @Override public double calculate(double x, double y) &#123; return x + y; &#125; &#125;, // 用于执行减法运算 MINUS &#123; // 花括号部分其实是一个匿名内部子类 @Override public double calculate(double x, double y) &#123; // TODO Auto-generated method stub return x - y; &#125; &#125;, // 用于执行乘法运算 TIMES &#123; // 花括号部分其实是一个匿名内部子类 @Override public double calculate(double x, double y) &#123; return x * y; &#125; &#125;, // 用于执行除法运算 DIVIDE &#123; // 花括号部分其实是一个匿名内部子类 @Override public double calculate(double x, double y) &#123; return x / y; &#125; &#125;; //为该枚举类定义一个抽象方法，枚举类中所有的枚举值都必须实现这个方法 public abstract double calculate(double x, double y);&#125;12345678910111213141516public class Test03 &#123; public static void main(String[] args) &#123; System.out.println("6 + 3 = " + Operation.PLUS.calculate(6, 3)); System.out.println("6 - 2 = " + Operation.MINUS.calculate(6, 2)); System.out.println("6 * 2 = " + Operation.TIMES.calculate(6, 2)); System.out.println("6 / 2 = " + Operation.DIVIDE.calculate(6, 2)); &#125;&#125;/*运行结果6+3=9.06-2=4.06*2=12.06/2=3.0编译器生成的Values方法与ValueOf方法values()方法和valueOf(String name)方法是编译器生成的static方法，因此从前面的分析中，在Enum类中并没出现values()方法，但valueOf()方法还是有出现的，只不过编译器生成的valueOf()方法需传递一个name参数，而Enum自带的静态方法valueOf()则需要传递两个方法，从前面反编译后的代码可以看出，编译器生成的valueOf方法最终还是调用了Enum类的valueOf方法，下面通过代码来演示这两个方法的作用：12345678910Day[] days2 = Day.values();System.out.println("day2:"+Arrays.toString(days2));Day day = Day.valueOf("MONDAY");System.out.println("day:"+day);/** 输出结果: day2:[MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY] day:MONDAY */从结果可知道，values()方法的作用就是获取枚举类中的所有变量，并作为数组返回，而valueOf(String name)方法与Enum类中的valueOf方法的作用类似根据名称获取枚举变量，只不过编译器生成的valueOf方法更简洁些只需传递一个参数。这里我们还必须注意到，由于values()方法是由编译器插入到枚举类中的static方法，所以如果我们将枚举实例向上转型为Enum，那么values()方法将无法被调用，因为Enum类中并没有values()方法，valueOf()方法也是同样的道理，注意是一个参数的。123456 //正常使用Day[] ds=Day.values();//向上转型EnumEnum e = Day.MONDAY;//无法调用,没有此方法//e.values();枚举与Class对象上述我们提到当枚举实例向上转型为Enum类型后，values()方法将会失效，也就无法一次性获取所有枚举实例变量，但是由于Class对象的存在，即使不使用values()方法，还是有可能一次获取到所有枚举实例变量的，在Class对象中存在如下方法：12T[] getEnumConstants() //返回该枚举类型的所有元素，如果Class对象不是枚举类型，则返回null。boolean isEnum() //当且仅当该类声明为源代码中的枚举时返回 true因此通过getEnumConstants()方法，同样可以轻而易举地获取所有枚举实例变量下面通过代码来演示这个功能：1234567891011121314151617//正常使用Day[] ds=Day.values();//向上转型EnumEnum e = Day.MONDAY;//无法调用,没有此方法//e.values();//获取class对象引用Class&lt;?&gt; clasz = e.getDeclaringClass();if(clasz.isEnum()) &#123; Day[] dsz = (Day[]) clasz.getEnumConstants(); System.out.println("dsz:"+Arrays.toString(dsz));&#125;/** 输出结果: dsz:[MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY] */枚举的进阶用法在前面的分析中，我们都是基于简单枚举类型的定义，也就是在定义枚举时只定义了枚举实例类型，并没定义方法或者成员变量，实际上使用关键字enum定义的枚举类，除了不能使用继承(因为编译器会自动为我们继承Enum抽象类而Java只支持单继承，因此枚举类是无法手动实现继承的)，可以把enum类当成常规类，也就是说我们可以向enum类中添加方法和变量，甚至是mian方法，下面就来感受一把。向enum类添加方法与自定义构造函数重新定义一个日期枚举类，带有desc成员变量描述该日期的对于中文描述，同时定义一个getDesc方法，返回中文描述内容，自定义私有构造函数，在声明枚举实例时传入对应的中文描述，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.zejian.enumdemo;/** * Created by zejian on 2017/5/8. * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] */public enum Day2 &#123; MONDAY("星期一"), TUESDAY("星期二"), WEDNESDAY("星期三"), THURSDAY("星期四"), FRIDAY("星期五"), SATURDAY("星期六"), SUNDAY("星期日");//记住要用分号结束 private String desc;//中文描述 /** * 私有构造,防止被外部调用 * @param desc */ private Day2(String desc)&#123; this.desc=desc; &#125; /** * 定义方法,返回描述,跟常规类的定义没区别 * @return */ public String getDesc()&#123; return desc; &#125; public static void main(String[] args)&#123; for (Day2 day:Day2.values()) &#123; System.out.println("name:"+day.name()+ ",desc:"+day.getDesc()); &#125; &#125; /** 输出结果: name:MONDAY,desc:星期一 name:TUESDAY,desc:星期二 name:WEDNESDAY,desc:星期三 name:THURSDAY,desc:星期四 name:FRIDAY,desc:星期五 name:SATURDAY,desc:星期六 name:SUNDAY,desc:星期日 */&#125;从上述代码可知，在enum类中确实可以像定义常规类一样声明变量或者成员方法。但是我们必须注意到，如果打算在enum类中定义方法，务必在声明完枚举实例后使用分号分开，倘若在枚举实例前定义任何方法，编译器都将会报错，无法编译通过，同时即使自定义了构造函数且enum的定义结束，我们也永远无法手动调用构造函数创建枚举实例，毕竟这事只能由编译器执行。关于覆盖enum类方法既然enum类跟常规类的定义没什么区别（实际上enum还是有些约束的），那么覆盖父类的方法也不会是什么难说，可惜的是父类Enum中的定义的方法只有toString方法没有使用final修饰，因此只能覆盖toString方法，如下通过覆盖toString省去了getDesc方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.zejian.enumdemo;/** * Created by zejian on 2017/5/8. * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] */public enum Day2 &#123; MONDAY("星期一"), TUESDAY("星期二"), WEDNESDAY("星期三"), THURSDAY("星期四"), FRIDAY("星期五"), SATURDAY("星期六"), SUNDAY("星期日");//记住要用分号结束 private String desc;//中文描述 /** * 私有构造,防止被外部调用 * @param desc */ private Day2(String desc)&#123; this.desc=desc; &#125; /** * 覆盖 * @return */ @Override public String toString() &#123; return desc; &#125; public static void main(String[] args)&#123; for (Day2 day:Day2.values()) &#123; System.out.println("name:"+day.name()+ ",desc:"+day.toString()); &#125; &#125; /** 输出结果: name:MONDAY,desc:星期一 name:TUESDAY,desc:星期二 name:WEDNESDAY,desc:星期三 name:THURSDAY,desc:星期四 name:FRIDAY,desc:星期五 name:SATURDAY,desc:星期六 name:SUNDAY,desc:星期日 */&#125;枚举与单例模式单例模式可以说是最常使用的设计模式了，它的作用是确保某个类只有一个实例，自行实例化并向整个系统提供这个实例。在实际应用中，线程池、缓存、日志对象、对话框对象常被设计成单例，总之，选择单例模式就是为了避免不一致状态，下面我们将会简单说明单例模式的几种主要编写方式，从而对比出使用枚举实现单例模式的优点。首先看看饿汉式的单例模式：123456789101112131415/** * Created by wuzejian on 2017/5/9. * 饿汉式（基于classloder机制避免了多线程的同步问题） */public class SingletonHungry &#123; private static SingletonHungry instance = new SingletonHungry(); private SingletonHungry() &#123; &#125; public static SingletonHungry getInstance() &#123; return instance; &#125;&#125;显然这种写法比较简单，但问题是无法做到延迟创建对象，事实上如果该单例类涉及资源较多，创建比较耗时间时，我们更希望它可以尽可能地延迟加载，从而减小初始化的负载，于是便有了如下的懒汉式单例：123456789101112131415161718/** * Created by wuzejian on 2017/5/9.. * 懒汉式单例模式（适合多线程安全） */public class SingletonLazy &#123; private static volatile SingletonLazy instance; private SingletonLazy() &#123; &#125; public static synchronized SingletonLazy getInstance() &#123; if (instance == null) &#123; instance = new SingletonLazy(); &#125; return instance; &#125;&#125;这种写法能够在多线程中很好的工作避免同步问题，同时也具备lazy loading机制，遗憾的是，由于synchronized的存在，效率很低，在单线程的情景下，完全可以去掉synchronized，为了兼顾效率与性能问题，改进后代码如下：12345678910111213141516public class Singleton &#123; private static volatile Singleton singleton = null; private Singleton()&#123;&#125; public static Singleton getSingleton()&#123; if(singleton == null)&#123; synchronized (Singleton.class)&#123; if(singleton == null)&#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125;这种编写方式被称为“双重检查锁”，主要在getSingleton()方法中，进行两次null检查。这样可以极大提升并发度，进而提升性能。毕竟在单例中new的情况非常少，绝大多数都是可以并行的读操作，因此在加锁前多进行一次null检查就可以减少绝大多数的加锁操作，也就提高了执行效率。但是必须注意的是volatile关键字，该关键字有两层语义。第一层语义是可见性，可见性是指在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以其它线程会马上读取到已修改的值，关于工作内存和主内存可简单理解为高速缓存（直接与CPU打交道）和主存（日常所说的内存条），注意工作内存是线程独享的，主存是线程共享的。volatile的第二层语义是禁止指令重排序优化，我们写的代码（特别是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同，这在单线程并没什么问题，然而一旦引入多线程环境，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题，值得关注的是volatile的禁止指令重排序优化功能在Java 1.5后才得以实现，因此1.5前的版本仍然是不安全的，即使使用了volatile关键字。或许我们可以利用静态内部类来实现更安全的机制，静态内部类单例模式如下：123456789101112131415/** * Created by wuzejian on 2017/5/9. * 静态内部类 */public class SingletonInner &#123; private static class Holder &#123; private static SingletonInner singleton = new SingletonInner(); &#125; private SingletonInner()&#123;&#125; public static SingletonInner getSingleton()&#123; return Holder.singleton; &#125;&#125;正如上述代码所展示的，我们把Singleton实例放到一个静态内部类中，这样可以避免了静态实例在Singleton类的加载阶段（类加载过程的其中一个阶段的，此时只创建了Class对象，关于Class对象可以看博主另外一篇博文， 深入理解Java类型信息(Class对象)与反射机制）就创建对象，毕竟静态变量初始化是在SingletonInner类初始化时触发的，并且由于静态内部类只会被加载一次，所以这种写法也是线程安全的。从上述4种单例模式的写法中，似乎也解决了效率与懒加载的问题，但是它们都有两个共同的缺点：序列化可能会破坏单例模式，比较每次反序列化一个序列化的对象实例时都会创建一个新的实例，解决方案如下：123456789101112//测试例子(四种写解决方式雷同)public class Singleton implements java.io.Serializable &#123; public static Singleton INSTANCE = new Singleton(); protected Singleton() &#123; &#125; //反序列时直接返回当前INSTANCE private Object readResolve() &#123; return INSTANCE; &#125; &#125;使用反射强行调用私有构造器，解决方式可以修改构造器，让它在创建第二个实例的时候抛异常，如下：123456789public static Singleton INSTANCE = new Singleton(); private static volatile boolean flag = true;private Singleton()&#123; if(flag)&#123; flag = false; &#125;else&#123; throw new RuntimeException("The instance already exists ！"); &#125;&#125;如上所述，问题确实也得到了解决，但问题是我们为此付出了不少努力，即添加了不少代码，还应该注意到如果单例类维持了其他对象的状态时还需要使他们成为transient的对象，这种就更复杂了，那有没有更简单更高效的呢？当然是有的，那就是枚举单例了，先来看看如何实现：1234567891011121314/** * Created by wuzejian on 2017/5/9. * 枚举单利 */public enum SingletonEnum &#123; INSTANCE; private String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125;代码相当简洁，我们也可以像常规类一样编写enum类，为其添加变量和方法，访问方式也更简单，使用SingletonEnum.INSTANCE进行访问，这样也就避免调用getInstance方法，更重要的是使用枚举单例的写法，我们完全不用考虑序列化和反射的问题。枚举序列化是由jvm保证的，每一个枚举类型和定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定：在序列化时Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的并禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法，从而保证了枚举实例的唯一性，这里我们不妨再次看看Enum类的valueOf方法：12345678910public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) &#123; T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException("Name is null"); throw new IllegalArgumentException( "No enum constant " + enumType.getCanonicalName() + "." + name); &#125;实际上通过调用enumType(Class对象的引用)的enumConstantDirectory方法获取到的是一个Map集合，在该集合中存放了以枚举name为key和以枚举实例变量为value的Key&amp;Value数据，因此通过name的值就可以获取到枚举实例，看看enumConstantDirectory方法源码：12345678910111213141516Map&lt;String, T&gt; enumConstantDirectory() &#123; if (enumConstantDirectory == null) &#123; //getEnumConstantsShared最终通过反射调用枚举类的values方法 T[] universe = getEnumConstantsShared(); if (universe == null) throw new IllegalArgumentException( getName() + " is not an enum type"); Map&lt;String, T&gt; m = new HashMap&lt;&gt;(2 * universe.length); //map存放了当前enum类的所有枚举实例变量，以name为key值 for (T constant : universe) m.put(((Enum&lt;?&gt;)constant).name(), constant); enumConstantDirectory = m; &#125; return enumConstantDirectory; &#125; private volatile transient Map&lt;String, T&gt; enumConstantDirectory = null;到这里我们也就可以看出枚举序列化确实不会重新创建新实例，jvm保证了每个枚举实例变量的唯一性。再来看看反射到底能不能创建枚举，下面试图通过反射获取构造器并创建枚举1234567public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123; //获取枚举类的构造函数(前面的源码已分析过) Constructor&lt;SingletonEnum&gt; constructor=SingletonEnum.class.getDeclaredConstructor(String.class,int.class); constructor.setAccessible(true); //创建枚举 SingletonEnum singleton=constructor.newInstance("otherInstance",9); &#125;执行报错12345678Exception in thread "main" java.lang.IllegalArgumentException: Cannot reflectively create enum objects at java.lang.reflect.Constructor.newInstance(Constructor.java:417) at zejian.SingletonEnum.main(SingletonEnum.java:38) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)显然告诉我们不能使用反射创建枚举类，这是为什么呢？不妨看看newInstance方法源码：123456789101112131415161718192021public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; if (!override) &#123; if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, null, modifiers); &#125; &#125; //这里判断Modifier.ENUM是不是枚举修饰符，如果是就抛异常 if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0) throw new IllegalArgumentException("Cannot reflectively create enum objects"); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) &#123; ca = acquireConstructorAccessor(); &#125; @SuppressWarnings("unchecked") T inst = (T) ca.newInstance(initargs); return inst; &#125;源码很了然，确实无法使用反射创建枚举实例，也就是说明了创建枚举实例只有编译器能够做到而已。显然枚举单例模式确实是很不错的选择，因此我们推荐使用它。但是这总不是万能的，对于android平台这个可能未必是最好的选择，在android开发中，内存优化是个大块头，而使用枚举时占用的内存常常是静态变量的两倍还多，因此android官方在内存优化方面给出的建议是尽量避免在android中使用enum。但是不管如何，关于单例，我们总是应该记住：线程安全，延迟加载，序列化与反序列化安全，反射安全是很重重要的。参考深入理解Java枚举类型(enum)关于EnumMap与EnumSet也可以看上面的博客]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE枚举</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-泛型]]></title>
    <url>%2Fcategory%2FJavaSE-%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型泛型是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型，参数化类型，把类型当作参数一样的传递。Java容器能够容纳任何类型的对象，这一点表面上是通过泛型机制完成，Java泛型不是什么神奇的东西，只是编译器为我们提供的一个“语法糖”，泛型本身并不需要Java虚拟机的支持，只需要在编译阶段做一下简单的字符串替换即可。实质上Java的单继承机制才是保证这一特性的根本，因为所有的对象都是Object的子类，容器里只要能够存放Object对象就行了。事实上，所有容器的内部存放的都是Object对象，泛型机制只是简化了编程，由编译器自动帮我们完成了强制类型转换而已。JDK 1.4以及之前版本不支持泛型，类型转换需要程序员显式完成。123456789//JDK 1.4 or beforeArrayList list = new ArrayList();list.add(new String("Monday"));list.add(new String("Tuesday"));list.add(new String("Wensday"));for(int i = 0; i &lt; list.size(); i++)&#123; String weekday = (String)list.get(i);//显式类型转换 System.out.println(weekday.toUpperCase());&#125;123456789//JDK 1.5 or latterArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();//参数化类型list.add(new String("Monday"));list.add(new String("Tuesday"));list.add(new String("Wensday"));for(int i = 0; i &lt; list.size(); i++)&#123; String weekday = list.get(i);//隐式类型转换，编译器自动完成 System.out.println(weekday.toUpperCase());&#125;Java泛型类类结构是面向对象中最基本的元素，如果我们的类需要有很好的扩展性，那么我们可以将其设置成泛型的。假设我们需要一个数据的包装类，通过传入不同类型的数据，可以存储相应类型的数据。我们看看这个简单的泛型类的设计：1234567891011class DataHolder&lt;T&gt;&#123; T item; public void setData(T t) &#123; this.item=t; &#125; public T getData() &#123; return this.item; &#125;&#125;泛型类定义时只需要在类名后面加上类型参数即可，当然你也可以添加多个参数，类似于,等。这样我们就可以在类里面使用定义的类型参数。泛型类最常用的使用场景就是“元组”的使用。我们知道方法return返回值只能返回单个对象。如果我们定义一个泛型类，定义2个甚至3个类型参数，这样我们return对象的时候，构建这样一个“元组”数据，通过泛型传入多个对象，这样我们就可以一次性方法多个数据了。Java泛型方法泛型方法既可以存在于泛型类中，也可以存在于普通的类中。如果使用泛型方法可以解决问题，那么应该尽量使用泛型方法。下面我们通过例子来看一下泛型方法的使用：12345678910111213141516171819202122232425class DataHolder&lt;T&gt;&#123; T item; public void setData(T t) &#123; this.item=t; &#125; public T getData() &#123; return this.item; &#125; /** * 泛型方法 * @param e */ public &lt;E&gt; void PrinterInfo(E e) &#123; System.out.println(e); &#125;&#125;/*运行结果1AAAAA8.88*/从上面的例子中，我们看到我们是在一个泛型类里面定义了一个泛型方法printInfo。通过传入不同的数据类型，我们都可以打印出来。在这个方法里面，我们定义了类型参数E。这个E和泛型类里面的T两者之间是没有关系的。哪怕我们将泛型方法设置成这样：123456789//注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。public &lt;T&gt; void PrinterInfo(T e) &#123; System.out.println(e);&#125;//调用方法DataHolder&lt;String&gt; dataHolder=new DataHolder&lt;&gt;();dataHolder.PrinterInfo(1);dataHolder.PrinterInfo("AAAAA");dataHolder.PrinterInfo(8.88f);这个泛型方法依然可以传入Double、Float等类型的数据。泛型方法里面的类型参数T和泛型类里面的类型参数是不一样的类型，从上面的调用方式，我们也可以看出，泛型方法printInfo不受我们DataHolder中泛型类型参数是String的影响。我们来总结下泛型方法的几个基本特征：public与返回值中间非常重要，可以理解为声明此方法为泛型方法。只有声明了的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。Java泛型接口Java泛型接口的定义和Java泛型类基本相同，下面是一个例子：1234//定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125;此处有两点需要注意：泛型接口未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中。例子如下：123456789/* 即：class DataHolder implements Generator&lt;T&gt;&#123; * 如果不声明泛型，如：class DataHolder implements Generator&lt;T&gt;，编译器会报错："Unknown class" */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125;如果泛型接口传入类型参数时，实现该泛型接口的实现类，则所有使用泛型的地方都要替换成传入的实参类型。例子如下：123456class DataHolder implements Generator&lt;String&gt;&#123; @Override public String next() &#123; return null; &#125;&#125;从这个例子我们看到，实现类里面的所有T的地方都需要实现为String。Java泛型擦除及其相关内容我们下面看一个例子：12345Class&lt;?&gt; class1=new ArrayList&lt;String&gt;().getClass();Class&lt;?&gt; class2=new ArrayList&lt;Integer&gt;().getClass();System.out.println(class1); //class java.util.ArrayListSystem.out.println(class2); //class java.util.ArrayListSystem.out.println(class1.equals(class2)); //true我们看输出发现，class1和class2居然是同一个类型ArrayList，在运行时我们传入的类型变量String和Integer都被丢掉了。Java语言泛型在设计的时候为了兼容原来的旧代码，Java的泛型机制使用了“擦除”机制。我们来看一个更彻底的例子：12345678910111213141516171819class Table &#123;&#125;class Room &#123;&#125;class House&lt;Q&gt; &#123;&#125;class Particle&lt;POSITION, MOMENTUM&gt; &#123;&#125;//调用代码及输出List&lt;Table&gt; tableList = new ArrayList&lt;Table&gt;();Map&lt;Room, Table&gt; maps = new HashMap&lt;Room, Table&gt;();House&lt;Room&gt; house = new House&lt;Room&gt;();Particle&lt;Long, Double&gt; particle = new Particle&lt;Long, Double&gt;();System.out.println(Arrays.toString(tableList.getClass().getTypeParameters()));System.out.println(Arrays.toString(maps.getClass().getTypeParameters()));System.out.println(Arrays.toString(house.getClass().getTypeParameters()));System.out.println(Arrays.toString(particle.getClass().getTypeParameters()));/** [E][K, V][Q][POSITION, MOMENTUM] */上面的代码里，我们想在运行时获取类的类型参数，但是我们看到返回的都是“形参”。在运行期我们是获取不到任何已经声明的类型信息的。注意：编译器虽然会在编译过程中移除参数的类型信息，但是会保证类或方法内部参数类型的一致性。泛型参数将会被擦除到它的第一个边界（边界可以有多个，重用 extends 关键字，通过它能给与参数类型添加一个边界）。编译器事实上会把类型参数替换为它的第一个边界的类型。如果没有指明边界，那么类型参数将被擦除到Object。下面的例子中，可以把泛型参数T当作HasF类型来使用。12345678910111213public interface HasF &#123; void f();&#125;public class Manipulator&lt;T extends HasF&gt; &#123; T obj; public T getObj() &#123; return obj; &#125; public void setObj(T obj) &#123; this.obj = obj; &#125;&#125;extend关键字后后面的类型信息决定了泛型参数能保留的信息。Java类型擦除只会擦除到HasF类型。Java泛型擦除的原理我们通过例子来看一下，先看一个非泛型的版本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// SimpleHolder.javapublic class SimpleHolder &#123; private Object obj; public Object getObj() &#123; return obj; &#125; public void setObj(Object obj) &#123; this.obj = obj; &#125; public static void main(String[] args) &#123; SimpleHolder holder = new SimpleHolder(); holder.setObj("Item"); String s = (String) holder.getObj(); &#125;&#125;// SimpleHolder.classpublic class SimpleHolder &#123; public SimpleHolder(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return public java.lang.Object getObj(); Code: 0: aload_0 1: getfield #2 // Field obj:Ljava/lang/Object; 4: areturn public void setObj(java.lang.Object); Code: 0: aload_0 1: aload_1 2: putfield #2 // Field obj:Ljava/lang/Object; 5: return public static void main(java.lang.String[]); Code: 0: new #3 // class SimpleHolder 3: dup 4: invokespecial #4 // Method "&lt;init&gt;":()V 7: astore_1 8: aload_1 9: ldc #5 // String Item 11: invokevirtual #6 // Method setObj:(Ljava/lang/Object;)V 14: aload_1 15: invokevirtual #7 // Method getObj:()Ljava/lang/Object; 18: checkcast #8 // class java/lang/String 21: astore_2 22: return &#125;下面我们给出一个泛型的版本，从字节码的角度来看看:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//GenericHolder.javapublic class GenericHolder&lt;T&gt; &#123; T obj; public T getObj() &#123; return obj; &#125; public void setObj(T obj) &#123; this.obj = obj; &#125; public static void main(String[] args) &#123; GenericHolder&lt;String&gt; holder = new GenericHolder&lt;&gt;(); holder.setObj("Item"); String s = holder.getObj(); &#125;&#125;//GenericHolder.classpublic class GenericHolder&lt;T&gt; &#123; T obj; public GenericHolder(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return public T getObj(); Code: 0: aload_0 1: getfield #2 // Field obj:Ljava/lang/Object; 4: areturn public void setObj(T); Code: 0: aload_0 1: aload_1 2: putfield #2 // Field obj:Ljava/lang/Object; 5: return public static void main(java.lang.String[]); Code: 0: new #3 // class GenericHolder 3: dup 4: invokespecial #4 // Method "&lt;init&gt;":()V 7: astore_1 8: aload_1 9: ldc #5 // String Item 11: invokevirtual #6 // Method setObj:(Ljava/lang/Object;)V 14: aload_1 15: invokevirtual #7 // Method getObj:()Ljava/lang/Object; 18: checkcast #8 // class java/lang/String 21: astore_2 22: return &#125;在编译过程中，类型变量的信息是能拿到的。所以，set方法在编译器可以做类型检查，非法类型不能通过编译。但是对于get方法，由于擦除机制，运行时的实际引用类型为Object类型。为了“还原”返回结果的类型，编译器在get之后添加了类型转换。所以，在GenericHolder.class文件main方法主体第18行有一处类型转换的逻辑。它是编译器自动帮我们加进去的。所以在泛型类对象读取和写入的位置为我们做了处理，为代码添加约束。Java泛型擦除的缺陷及补救措施泛型类型不能显式地运用在运行时类型的操作当中，例如：转型、instanceof 和 new。因为在运行时，所有参数的类型信息都丢失了。类似下面的代码都是无法通过编译的：1234567891011121314public class Erased&lt;T&gt; &#123; private final int SIZE = 100; public static void f(Object arg) &#123; //编译不通过 if (arg instanceof T) &#123; &#125; //编译不通过 T var = new T(); //编译不通过 T[] array = new T[SIZE]; //编译不通过 T[] array = (T) new Object[SIZE]; &#125;&#125;那我们有什么办法来补救呢？下面介绍几种方法来一一解决上面出现的问题。类型判断问题我们可以通过下面的代码来解决泛型的类型信息由于擦除无法进行类型判断的问题：123456789101112131415/** * 泛型类型判断封装类 * @param &lt;T&gt; */class GenericType&lt;T&gt;&#123; Class&lt;?&gt; classType; public GenericType(Class&lt;?&gt; type) &#123; classType=type; &#125; public boolean isInstance(Object object) &#123; return classType.isInstance(object); &#125;&#125;在main方法我们可以这样调用：1234GenericType&lt;A&gt; genericType=new GenericType&lt;&gt;(A.class);System.out.println("------------");System.out.println(genericType.isInstance(new A()));System.out.println(genericType.isInstance(new B()));创建类型实例泛型代码中不能new T()的原因有两个，一是因为擦除，不能确定类型；而是无法确定T是否包含无参构造函数。为了避免这两个问题，我们使用显式的工厂模式：123456789101112131415161718192021222324/** * 使用工厂方法来创建实例 * * @param &lt;T&gt; */interface Factory&lt;T&gt;&#123; T create();&#125;class Creater&lt;T&gt;&#123; T instance; public &lt;F extends Factory&lt;T&gt;&gt; T newInstance(F f) &#123; instance=f.create(); return instance; &#125;&#125;class IntegerFactory implements Factory&lt;Integer&gt;&#123; @Override public Integer create() &#123; Integer integer=new Integer(9); return integer; &#125;&#125;我们通过工厂模式+泛型方法来创建实例对象，上面代码中我们创建了一个IntegerFactory工厂，用来创建Integer实例，以后代码有变动的话，我们可以添加新的工厂类型即可。调用代码如下：12Creater&lt;Integer&gt; creater=new Creater&lt;&gt;();System.out.println(creater.newInstance(new IntegerFactory()));创建泛型数组一般不建议创建泛型数组。尽量使用ArrayList来代替泛型数组。但是在这里还是给出一种创建泛型数组的方法。1234567891011121314151617181920public class GenericArrayWithTypeToken&lt;T&gt; &#123; private T[] array; @SuppressWarnings("unchecked") public GenericArrayWithTypeToken(Class&lt;T&gt; type, int sz) &#123; array = (T[]) Array.newInstance(type, sz); &#125; public void put(int index, T item) &#123; array[index] = item; &#125; public T[] rep() &#123; return array; &#125; public static void main(String[] args) &#123; &#125;&#125;这里我们使用的还是传参数类型，利用类型的newInstance方法创建实例的方式。Java泛型通配符泛型通配符&lt;?&gt;任意类型，如果没有明确，那么就是Objet以及任意的Java类? extends E向下限定，E及其子类? super E向上限定，E及其父类上界通配符&lt;? extends T&gt;我们先来看一个例子：12class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;现在我们定义一个盘子类：1234567891011121314class Plate&lt;T&gt;&#123; T item; public Plate(T t)&#123; item=t; &#125; public void set(T t) &#123; item=t; &#125; public T get() &#123; return item; &#125;&#125;下面，我们定义一个水果盘子，理论上水果盘子里，当然可以存在苹果1Plate&lt;Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple());你会发现这段代码无法进行编译。装苹果的盘子”无法转换成“装水果的盘子：1cannot convert from Plate&lt;Apple&gt; to Plate&lt;Fruit&gt;从上面代码我们知道，就算容器中的类型之间存在继承关系，但是Plate和Plate两个容器之间是不存在继承关系的。 在这种情况下，Java就设计成Plate&lt;? extend Fruit&gt;来让两个容器之间存在继承关系。我们上面的代码就可以进行赋值了1Plate&lt;? extends Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple());Plate&lt;? extend Fruit&gt;是Plate&lt; Fruit &gt;和Plate&lt; Apple &gt;的基类。我们通过一个更加详细的例子来看一下上界的界限：123456789101112class Food&#123;&#125;class Fruit extends Food &#123;&#125;class Meat extends Food &#123;&#125;class Apple extends Fruit &#123;&#125;class Banana extends Fruit &#123;&#125;class Pork extends Meat&#123;&#125;class Beef extends Meat&#123;&#125;class RedApple extends Apple &#123;&#125;class GreenApple extends Apple &#123;&#125;在上面这个类层次中，Plate&lt;? extend Fruit&gt;，覆盖下面的蓝色部分：如果我们往盘子里面添加数据，例如：12p.set(new Fruit());p.set(new Apple());你会发现无法往里面设置数据，按道理说我们将泛型类型设置为? extend Fruit。按理说我们往里面添加Fruit的子类应该是可以的。但是Java编译器不允许这样操作。&lt;? extends Fruit&gt;会使往盘子里放东西的set()方法失效。但取东西get()方法还有效原因是：Java编译期只知道容器里面存放的是Fruit和它的派生类，具体是什么类型不知道，可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在后面看到Plate&lt; Apple &gt;赋值以后，盘子里面没有标记为“苹果”。只是标记了一个占位符“CAP#1”，来表示捕获一个Fruit或者Fruit的派生类，具体是什么类型不知道。所有调用代码无论往容器里面插入Apple或者Meat或者Fruit编译器都不知道能不能和这个“CAP#1”匹配，所以这些操作都不允许。最新理解：一个Plate&lt;? extends Fruit&gt;的引用，指向的可能是一个Plate类型的盘子，要往这个盘子里放Banana当然是不被允许的。我的一个理解是：Plate&lt;? extends Fruit&gt;代表某个只能放某种类型水果的盘子，而不是什么水果都能往里放的盘子但是上界通配符是允许读取操作的。例如代码：12Fruit fruit=p.get();Object object=p.get();这个我们很好理解，由于上界通配符设定容器中只能存放Fruit及其派生类，那么获取出来的我们都可以隐式的转为其基类（或者Object基类）。所以上界描述符Extends适合频繁读取的场景。下界通配符&lt;? super T&gt;下界通配符的意思是容器中只能存放T及其T的基类类型的数据。我们还是以上面类层次的来看，&lt;? super Fruit&gt;覆盖下面的红色部分：下界通配符&lt;? super T&gt;不影响往里面存储，但是读取出来的数据只能是Object类型。原因是：下界通配符规定了元素最小的粒度，必须是T及其基类，那么我往里面存储T及其派生类都是可以的，因为它都可以隐式的转化为T类型。但是往外读就不好控制了，里面存储的都是T及其基类，无法转型为任何一种类型，只有Object基类才能装下。PECS原则最后简单介绍下Effective Java这本书里面介绍的PECS原则。上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。&lt;?&gt;无限通配符无界通配符 意味着可以使用任何对象，因此使用它类似于使用原生类型。但它是有作用的，原生类型可以持有任何类型，而无界通配符修饰的容器持有的是某种具体的类型。举个例子，在List&lt;\?&gt;类型的引用中，不能向其中添加Object, 而List类型的引用就可以添加Object类型的变量。最后提醒一下的就是，List&lt;\Object&gt;与List&lt;?&gt;并不等同，List&lt;\Object&gt;是List&lt;?&gt;的子类。还有不能往List&lt;?&gt; list里添加任意对象，除了null。参考文章：深入理解Java泛型]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE泛型</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-网络编程]]></title>
    <url>%2Fcategory%2FJavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网络编程概述计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议和协调下，实现资源共享和信息传递的计算机系统计算机网络的主要功能：资源共享信息传输与集中处理均衡负荷与分布处理综合信息服务(www/综合业务数字网络 ISDN)网络编程就是用来实现网络互连的不同计算机上运行的程序间可以进行数据交换。Java语言对网络编程提供了良好的支持，通过其提供的接口我们可以很方便地进行网络编程网络什么是网络网络是几乎可以实时相互发送和接收数据的计算机和其他设备的集合。网络通常用线缆连接，数据为转换为电磁波，通过线缆移动。不过，无线网络会通过无线电波传输数据，许多长距离的传输现在会用通过玻璃纤维发送可见光的光纤电缆来完成。网络中的每台机器为一个节点（node）。大多数节点是计算机，但是打印机、路由器、网桥、网关、ATM机也都是节点。每个网络节点都有地址 (address)，这是用于唯一标识节点的一个字节序列。每个地址中的字节越多，可用的地址就越多，就可以有更多的设备同时连入网络。不同的网络会以不同的方式分配地址。以太网（Ethernet）地址与物理以太网硬件关联。以太网硬件的生产厂家使用预分配的厂商编码确保他们的硬件地址或与其他厂家的硬件地址不冲突。每家厂商都要负责保证不会生产出两块地址相同的以太网卡。所有现代计算机网络都是包交换（分组交换）网络：流经网络的数据分割成小块，称为包（packet,也称分组），每个包都单独加以处理。每个包都包含了由谁发送和将发往何处的信息。计算机来回传递数据时还有另一个重要的一个点，那就是协议，协议（protocol）是定义计算机如何通信的一组明确的规则：包括地址格式、数据如何分包等。针对网络通信的不同方面，定义有很多不同的协议。例如：Hypertext Transfer Protocol(HTTP)。网络通信协议及接口网络模型计算机网络之间以何种规则进行通信，就是网络模型研究问题网络模型一般是指：OSI(Open System Interconnection开放系统互连)参考模型TCP/IP参考模型网络通信协议计算机网络中实现通信必须有一些约定，即通信协议；包括对速率，传输代码，代码结构，传输控制步骤，出错控制等制定的标准。网络通信接口：为了使两个节点之间能进行对话，必须在他们之间建立通信工具（即接口），使彼此之间，能进行信息交换。接口包括两部分：硬件装置：实现结点之间的信息传送软件装置：规定双方进行通信的约定协议通信协议分层思想通过网络发送数据是一项复杂的操作，必须仔细地协调网络的物理特性以及所发送数据的路基特征。为了对应用程序开发人员和最终用户隐藏这种复杂性，网络通信的不同方面被分解为多个层。每一层表示为物理硬件（即线缆和电流）与所传输信息之间的不同抽象层次。在理论上，每一层只与紧挨其上和其下的层对话。将网络分层，这样就可以修改甚至替换某一层的软件，只要层与层之间的接口保持不变，就不会影响到其他层。为什么要分层：由于结点之间联系很复杂，在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式就是层次方式，及同层间可以通信，上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。通信协议的分层规定：把用户应用程序作为最高层，把物理通信线路作为最底层，将其间的协议处理分为若干层，规定每层处理的任务，也规定每层的接口标准。上面的图显示了网络中可能存在的协议栈。四层分层有几种不同的分层模型，分别适合特定类型网络的需要。我这边主要介绍适用于Internet的标准TCP/IP四层模型，如下图所示：主机网络层主机网络层定义了一个特定的网络接口（如以太网或WiFi天线）如何通过物理连接向本地网络或世界其他地方发送IP数据报。主机网络层中，由连接不同计算机的硬件（线缆、光纤电缆、无线电波或烟信号）组成的部分有时称为网络的物理层。Java程序员不需要担心这一层，除非出现了问题，比如插头从计算机后面掉了下来，或者有人挖断了你与外部世界之间的T-1线。换句话说，Java从来都看不到物理层。网际层网际层主机网络层的下一层，这也是作为Java程序员需要考虑的第一层，网际层协议定义了数据位和字节如何组织为更大的分组，称为包，还定义了寻址机制，不同计算机要按这个寻址机制查找对方。网际协议（IP）是世界上使用最广泛的网际层协议，也是Java唯一理解的网际层协议。网际协议主要是两个协议：IPV4和IPV6，IPV4使用32位地址，IPV6使用128位地址，另外还增加了一些技术特性来帮助完成路由。这是两个完全不同的网络协议，如果没有特殊的网关/或隧道协议，即使在相同的网络上它们也无法做到互操作，不过Java几乎对你隐藏了所有这些区别。除了路由和寻址，网际层的第二个作用是支持不同类型的主机网络层相互对话。Internet路由器会完成WiFi和Ethernet、Ethernet和DSL、DSL和光纤往返等协议之间的转换。如果没有网际层或类似的分层，则每个计算机只能与同一类网络上的其他计算机对话。网际层负责使用同够协议将异构网络相互连接。传输层原始数据报有一些缺点。最显著的缺点是不能保证可靠传送，即使能传送也可能在传输中遭到破坏。首部校验只能检测首部中的破坏情况，而不能检测数据报中的数据部分。最后即使数据报能到底目的地而未被破坏，也不一定会以发送时的顺序到达。传输层（transport layer）负责确保各包以发送的顺序接收，并保证没有数据丢失或破坏。如果丢包，传输层会请求发送方重传这个包。为实现这个目标，IP网络会给每个数据报添加一个附加首部，其中包含有更多信息。这一层上主要有两个协议。第一个是传输控制协议（Transmission Control Protocol，TCP），这是一个开销很高的协议，支持对丢失或破坏的数据进行重传，并按照发送时的顺序进行传送。第二个协议是用户数据报协议（User Datagram Protocol ，UDP），它允许接收方检测被破坏的包，但不保证这些包以正确的顺序传送（或者包有可能根本未传送）。但是，UDP通常比TCP快。TCP称为可靠（reliable）协议；UDP是不可靠（unreliable）协议。应用层向用户传送数据的层称为应用层（application layer）。它下面的三层共同定义了数据如何从一台计算机传输到另一台计算机。应用层确定了数据传输后的操作。有用户Web的HTTP，还有用户电子邮件的SMTP、POP、IMAP、；用于文件传输的FTP、FSP、TFTP，用于文件访问的NFS；用于文件共享的Gnutella和BitTorrent；用于语音通信的会话启动协议（Session Initiation Protocol，SIP）和Skype等。此外你的程序可以在必要时定义自己的应用层协议。IP、TCP、UDPIP设计为允许任意两点之间有多个路由，可以绕过被破坏的路由器实现数据包的路由。由于两点间存在多个路由，并且两点间的最短路径可能由于网络业务流量或其他因素而随时间改变，所以构成某个特定数据流的包可能不会采用相同的路由。另外，即使它们全部到达，也可能不会以发送的顺序到达。为了改进这种基本机制，将TCP置于IP之上，使连接的两端能够确认接收IP包，以及请求重传丢失或被破坏的包。此外，TCP允许接收端的包按发送时的顺序重新组合在一起。不过，TCP会有很大的开销。因此，如果有些情况丢失个别包不会完全破坏数据的话，也可以使用UDP发送数据包，而不需要TCP提供保证。UDP是不可靠协议，它不能保证包一定会到达目的地，也不保证包会以发送时的相同顺序到达。但是它开销小，速度快，也可以在应用层的UDP数据流中建立纠错码，来解决数据丢失问题。可以在IP之上运行很多其他协议。但是Java支持的协议只有TCP和UDP，以及建立在TCP和UDP之上的应用层协议。所有其他传输层、网际层和更底层的协议，如ICMP、IGMP、ARP、RARP、RSVP和其他洗衣在Java程序中都只能通过连接到原生代码来实现。IP地址和域名IPv4网络中的每台计算机都有一个4字节的数字标识。一般写为点分四段格式，如192.1.32.90，这4个数中，每个数都是一个无符号字节，范围从0到255。IPv4网络中的每台计算机都有一个唯一的4节地址。当数据通过网络传输时，包的首部会包括要发往的机器地址（目的地址）和发送这个包的机器地址（源地址）。沿路的路由器通过检查目的地址来选择发送数据包的最佳路由。包括源地址是为了让接收方知道要向谁回复。虽然计算机可以轻松地处理数字，但人类对于记忆数字却不在行。因此开发了域名系统（Domain Name System，DNS）用来将人类易于记忆的主机名（如www.12345.com）转换为数字Internet地址（如208.201.243.99）。当Java程序访问网络时，他们需要同时处理数字地址和相应的主机名。这些方法由java.net.InetAddress类提供。端口如果每台计算机一次只做一件事情，那么地址可能就足够了。但是，现代计算机同时要做很多不同的事情。电子邮件需要与FTP请求分开，而FTP又要与Web业务流分开。这是通过端口（port）实现的。每台有IP地址的计算机都有几千个逻辑端口（确切地讲，每个传输层协议有65535个端口）。这些只是计算机内存中的抽象，不表示任何物理实物，与USB端口不同。每个端口由1到65535之间的一个数字标识。每个端口可以分配给一个特定的服务。防火墙Internet上有些顽皮的人。为了把他们关在门外，在本地网络建立一个访问点，检查所有进出该访问点的业务流通常很有用。位于Internet和本地网络之间的一些硬件和软件会检查所有进出的数据，以保证其合法性，这就称为防火墙（firewall）。防火墙通常是将本地网络连接到更大的Internet的路由器的一部分，还可以完成其他任务，如网络地址转换。此外，防火墙也可以是单独的机器。防火墙主要还是负责检查传入或传出其网络接口的各个包，根据一组规则接收或拒绝这些包。过滤通常是基于网络地址和端口的。Java与防火墙没有太大关系，除非防火墙总是碍你事。七层模型IP协议IP协议是网络层的主要协议，支持网间互连的数据报通信，它提供主要功能由：无连接数据报传送数据报路由选择和差错控制IP地址每个人的电脑都有一个独一无二的IP地址，这样互相通信时就不会传错信息了。IP地址是用一个点来分成四段的，在计算机内部IP地址是用四个字节来表示的，一个字节代表一段，每一个字节代表的数最大只能到达255。要想让落网中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接受数据的计算机和识别发送的计算机，在TCP/IP协议中，这个标识号就是IP地址IP地址的组成：网络号段+主机号段A类：第一号段为网络号段+后三段的主机号段一个网络号：256256256=16777216B类：前二号段为网络号段+后二段的主机号段一个网络号：256*256=65536C类：前三号段为网络号段+后一段的主机号段一个网络号：256IP地址的分类：A类：1.0.0.1—-127.255.255.254—&gt;(1)10.x.x.x是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)B类：128.0.0.1—-191.255.255.254 172.16.0.0—-172.31.255.255是私有地址。169.254.x.x是保留地址C类：192.0.0.1—-223.255.255.254 192.168.x.x是私有地址D类：224.0.0.1—-239.255.255.254E类：240.0.0.1—-247.255.255.254端口端口号物理端口：网卡口逻辑端口：每个网络都会至少有一个逻辑端口用于标识进程的逻辑地址，不同进程的标识有效端口：0-65535，其中0-1024系统使用或保留端口查看端口用命令提示符cmd查看所有端口：netstat -ano查看具体程序：使用任务管理器查看PIDURLURI=URL+URNURI：Uniform Resource Identifier ，统一资源标志符。URL：Uniform Resource Locator，统一资源定位符。URN：Uniform Resource Name，统一资源命名。网络三大基石：HTML，HTTP，URL在www上，每一信息资源都有统一且唯一的地址，即统一资源定位符。Uniform Resource Locator。如：https://localhost:8080/index.html ，有4部分组成。（协议，主机域名或IP，端口号，资源文件名）URL类构造方法摘要12345678URL(String spec)//根据 String 表示形式创建 URL 对象。URL(String protocol, String host, int port, String file)//根据指定 protocol、host、port 号和 file 创建 URL 对象。URL(String protocol, String host, String file)//根据指定的 protocol 名称、host 名称和 file 名称创建 URL。常用方法摘要1234567891011121314151617181920String getAuthority()//获取此 URL 的授权部分。int getDefaultPort()//获取与此 URL 关联协议的默认端口号。String getFile()//获取此 URL 的文件名。String getHost()//获取此 URL 的主机名（如果适用）。String getPath()//获取此 URL 的路径部分。int getPort()//获取此 URL 的端口号。String getUserInfo()//获取此 URL 的 userInfo 部分。案例：123456789101112131415161718192021222324252627282930import java.net.MalformedURLException;import java.net.URL;public class TestURL &#123; public static void main(String[] args) throws MalformedURLException &#123; URL url2 = new URL("https://www.bilibili.com/"); //获取此的授权部分 URL 。 System.out.println(url2.getAuthority()); //获取此 URL的文件名。 System.out.println(url2.getFile()); //获取端口 System.out.println(url2.getPort()); //获取主机 System.out.println(url2.getHost()); //获得默认端口 System.out.println(url2.getDefaultPort()); //获得路径 System.out.println(url2.getPath()); //获取该 URL的userInfo部分。 System.out.println(url2.getUserInfo()); &#125;&#125;HTTP协议HTTP，超文本传输协议，英文全称是Hypertext Transfer Protocol，它是互联网上应用最为广泛的一种网络协议。HTTP是一种应用层协议，它是基于TCP协议之上的请求/响应式的协议，即一个客户端与服务器建立连接后，向服务器发送一个请求；服务器接到请求后，给予相应的响应信息。HTTP协议默认的端口号为80.现在使用的HTTP协议是HTTP/1.1版本，1997年之前采用的是HTTP1.0版本。HTTP连接在1.0版本中采用非持续连接工作方式，1.1版本采用的是持续连接工作方式，持续连接是指服务器在发送响应后仍然在一段时间内保持这条由TCP运输层协议建立起来的连接，使客户机和服务器可以继续在这条连接上传输HTTP报文。是否采用持续连接工作方式，1.0中默认是关闭的，需要在HTTP头加入”Connection:Keep-Alive”，才能启用Keep-Alive。HTTP1.1中默认启用Keep-Alive，如果加入”Connection:close”，才关闭。目前大部分浏览器都是用HTTP1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。HTTP报文HTTP协议是基于TCP协议之上的请求/响应式协议，下面主要介绍HTTP报文的格式，HTTP报文主要有请求报文和响应报文两种。首先看请求报文的格式：HTTP请求报文由请求行、首部行和实体主体组成，由浏览器发送给服务器。上面这张图中SP表示空格，cr lf表示回车和换行。上面这张图是HTTP响应报文，它由状态行、首部行和实体主体组成。下面两张图是在谷歌浏览器内访问服务器查看的HTTP请求和响应。HTTP请求方法和响应状态码在上面的HTTP请求报文例子中，我们可以看到请求方法是GET，这表示请求读取由URL所标志的信息，除了GET，还有其它几种常用的方法。在HTTP响应报文的例子中，我们可以看到状态码是200，表示响应成功。下表是其它状态码，总共5大类，33种。HTTPS和HTTP的区别HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。HTTPS和HTTP的区别主要为以下四点：1、https协议需要到ca申请证书，一般免费证书很少，需要交费。2、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。TCP协议与UDP协议UDP：UDP，用户数据报协议，英文全称是User Datagram Protocol，它是TCP/IP协议簇中无连接的运输层协议。将数据源和目的封装成数据包中，不需要建立连接，每个数据报的大小在限制在64K，因无连接，是不可靠协议；不需要建立连接，速度快UDP协议格式UDP格式从图中可以看到，UDP协议十分简单，它由两部分组成：首部和数据。其中，首部仅有8个字节，包括源端口和目的端口，长度（UDP用于数据报的长度）、校验和。TCP：TCP（Transmission Control Protocol ，传输控制协议）是面向连接的传输层协议。TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。TCP协议采用字节流传输数据。TCP建立连接，形成传输数据的通道，在连接中进行大数据量传输，通过三次握手完成连接，是可靠协议；必须建立连接，效率会低TCP报文段格式TCP报文段包括协议首部和数据两部分，协议首部的固定部分有20个字节，首部的固定部分后面是选项部分。下面是报文段首部各个字段的含义。源端口号以及目的端口号，各占2个字节，端口是传输层和应用层的服务接口，用于寻找发送端和接收端的进程，一般来讲，通过端口号和IP地址，可以唯一确定一个TCP连接，在网络编程中，通常被称为一个socket接口。序号，占4字节，用来标识从TCP发送端向TCP接收端发送的数据字节流。确认序号，占4字节，包含发送确认的一端所期望收到的下一个序号，因此，确认序号应该是上次已经成功收到数据字节序号加1.数据偏移，占4位，用于指出TCP首部长度，若不存在选项，则这个值为20字节，数据偏移的最大值为60字节。保留字段占6位，暂时可忽略，值全为0标志位URG（紧急） : 为1时表明紧急指针字段有效ACK（确认）：为1时表明确认号字段有效PSH（推送）：为1时接收方应尽快将这个报文段交给应用层RST（复位）：为1时表明TCP连接出现故障必须重建连接SYN（同步）：在连接建立时用来同步序号FIN （终止）： 为1时表明发送端数据发送完毕要求释放连接接收窗口占2个字节，用于流量控制和拥塞控制，表示当前接收缓冲区的大小。在计算机网络中，通常是用接收方的接收能力的大小来控制发送方的数据发送量。TCP连接的一端根据缓冲区大小确定自己的接收窗口值，告诉对方，使对方可以确定发送数据的字节数。校验和占2个字节，范围包括首部和数据两部分。选项是可选的，默认情况是不选。三次握手与四次挥手TCP是面向连接的协议，因此每个TCP连接都有3个阶段：连接建立、数据传送和连接释放。连接建立经历三个步骤，通常称为“三次握手”。TCP三次握手过程如下：第一次握手客户机发送连接请求报文段到服务器，并进入SYN_SENT状态，等待服务器确认。（SYN = 1,seq=x）第二次握手服务器收到连接请求报文，如果同意建立连接，向客户机发回确认报文段，并为该TCP连接分配TCP缓存和变量。(SYN=1,ACK=1,seq=y,ack=x+1)。第三次握手客户机收到服务器的确认报文段后，向服务器给出确认报文段，并且也要给该连接分配缓存和变量。此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。(ACK=1,seq=x+1,ack=y+1)。TCP四次挥手过程如下：由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。服务器关闭客户端的连接，发送一个FIN给客户端。客户端发回ACK报文确认，并将确认序号设置为收到序号加1。总结TCP和UDP位于同一层，都是建立在IP层的基础之上。由于两台电脑之间有不同的IP地址，因此两台电脑就可以区分开来，也就可以互相通话了。通话一般有两种通话方式：第一种是TCP，第二种是UDP。TCP是可靠的连接，TCP就像打电话，需要先打通对方电话，等待对方有回应后才会跟对方继续说话，也就是一定要确认可以发信息以后才会把信息发出去。TCP上传任何东西都是可靠的，只要两台机器上建立起了连接，在本机上发送的数据就一定能传到对方的机器上，UDP就好比发电报，发出去就完事了，对方有没有接收到它都不管，所以UDP是不可靠的。 TCP传送数据虽然可靠，但传送得比较慢，UDP传送数据不可靠，但是传送得快。InetAddress类此类表示互联网协议 (IP) 地址。常用方法摘要1234567891011121314byte[] getAddress();//返回此 InetAddress 对象的原始 IP 地址。 static InetAddress getByName(String host);//在给定主机名的情况下确定主机的 IP 地址。String getHostAddress();//返回 IP 地址字符串（以文本表现形式）。String getHostName();//获取此 IP 地址的主机名。static InetAddress getLocalHost();//返回本地主机。127.0.0.1：本机地址，主要用于测试。别名：Localhost案例：12345678910111213141516import java.net.InetAddress;import java.net.UnknownHostException;public class TestIP &#123; public static void main(String[] args) throws UnknownHostException &#123; //InetAdress类表示IP地址 //获取本机IP InetAddress ip = InetAddress.getLocalHost(); System.out.println(ip); //获得主机名 System.out.println(ip.getHostName()); //获得IP地址 System.out.println(ip.getHostAddress()); &#125;&#125;123456789101112import java.net.InetAddress;import java.net.UnknownHostException;public class TestIP2 &#123; public static void main(String[] args) throws UnknownHostException &#123; InetAddress inetAddress = InetAddress.getByName("www.baidu.com"); // 获取此 IP 地址的主机名。 System.out.println(inetAddress.getHostName()); //返回 IP 地址字符串（以文本表现形式）。 System.out.println(inetAddress.getHostAddress()); &#125;&#125;常见问题OSI参考模型的分为哪几层，每层的功能？OSI，开放系统互连参考模型，它的7个层次自顶到下依次为应用层，表示层，会话层，传输层，网络层，数据链路层和物理层。各层的功能见文章开始。TCP协议和UDP协议的区别？TCP协议是传输控制协议，UDP协议是用户数据报协议，两者都是传输层的协议，主要区别在于前者是可靠的，面向连接的协议，后者是不可靠的，无连接的协议。其它的区别还有，TCP协议传输速度慢，UDP常用于一次性传输比较少量数据的网络应用。TCP三次握手为什么不能是两次?主要是防止两次握手情况下已经失效的连接请求报文段突然又传送到服务端而产生错误。例如，客户机A向服务器B发送TCP连接请求，第一个连接请求报文在网络的某个节点长时间滞留，A超时后认为报文丢失，于是再重传一次连接请求，B收到后建立连接。数据传输完毕后双方断开连接，而这时之前滞留的连接请求到达了服务端B，而B认为A又发来连接请求。如果两次握手建立连接，A并无连接请求，造成B的资源浪费。HTTP请求的GET方法和POST方法的区别？GET和POST是HTTP请求的两种方法，主要区别在于GET方法是请求读取由URL所标志的信息，POST是给服务器添加信息。点击查看更多在浏览器中输入网址到显示出页面的整个过程？(1) 输出包含域名的网址 (2) 浏览器向DNS请求解析域名对应的IP地址 (3) 域名系统DNS解析出域名对应的IP地址 (4) 浏览器与该服务器建立TCP连接 (5) 浏览器发送HTTP请求 (6) 服务器通过HTTP响应把页面文件发送给浏览器 (7) TCP连接释放 (8) 浏览器解释文件，并显示InetSocketAddress类此类实现 IP 套接字地址（IP 地址 + 端口号）构造方法摘要12345678InetSocketAddress(InetAddress addr, int port);//根据 IP 地址和端口号创建套接字地址。InetSocketAddress(int port);//创建套接字地址，其中 IP 地址为通配符地址，端口号为指定值。InetSocketAddress(String hostname, int port);//根据主机名和端口号创建套接字地址。常用方法摘要12345678InetAddress getAddress();//获取 InetAddress。String getHostName();//获取 hostname。int getPort();//获取端口号。案例1234567891011121314import java.net.InetAddress;import java.net.InetSocketAddress;public class TestPort &#123; public static void main(String[] args) &#123; InetSocketAddress inetSocketAddress = new InetSocketAddress("127.0.0.1",8082); System.out.println(inetSocketAddress.getHostName()); //获得InetSocketAddress的端口 System.out.println(inetSocketAddress.getPort()); System.out.println(inetSocketAddress.getHostString()); //返回一个InetAddress对象（IP对象） InetAddress address = inetSocketAddress.getAddress(); &#125;&#125;Socker编程一般的网络编程都称为Socket编程，Socket的英文意思是“插座”。那么什么是Socket呢？简单地说，Socket，套接字，就是两台主机之间逻辑连接的端点。TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。Socket，本质上就是一组接口，是对TCP/IP协议的封装和应用(程序员层面上)。Socket编程主要涉及到客户端和服务器端两个方面，首先是在服务器端创建一个服务器套接字(ServerSocket)，并把它附加到一个端口上，服务器从这个端口监听连接。端口号的范围是0到65536，但是0到1024是为特权服务保留的端口号，我们可以选择任意一个当前没有被其他进程使用的端口。客户端请求与服务器进行连接的时候，根据服务器的域名或者IP地址，加上端口号，打开一个套接字。当服务器接受连接后，服务器和客户端之间的通信就像输入输出流一样进行操作。Socket使用范例服务器端ServerSocket1234567891011121314151617181920212223242526272829303132333435363738import java.net.*;import java.io.*;public class TestServerSocket&#123; public static void main(String args[]) throws Exception&#123; ServerSocket ss = new ServerSocket(6666); /*创建一个ServerSocket对象时往往会给它指定一个端口号 指定端口号的意思是这个new出来的ServerSocket对象要使用的 是哪一个端口号，通过哪一个端口号来监听客户端的连接 因此指定一个端口号的意义就是为了告诉计算机ServerSocket对象 在哪个地方监听客户端的连接*/ /*服务器端接收客户端连接的请求是不间断地接收的，所以服务器端的 编程一般都是死循环，永不休止地运行着。*/ while(true)&#123; Socket s = ss.accept(); /*在服务器端调用accept()方法接受客户端的连接对象,accept()方法是 一个阻塞式方法，一直在傻傻地等待着是否有客户端申请连接上来 然后服务器端的Socket插座就和客户端的Socket插座建立了连接了*/ /*客户端能否连接上服务器端，取决于服务器端是否接受客户端的连接请求 如果接受了客户端的连接请求，那么在服务器端就安装上一个Socket插座 通过这个插座与连接上的客户端就可以建立连接，互相通信了*/ System.out.println("A Client Connected!"); /*使用InputStream流接收从客户端发送过来的信息，使用DataInputStream数据流处理接收到的信息*/ DataInputStream dis = new DataInputStream(s.getInputStream()); /*使用readUTF(方法将接收到的信息全部读取出来，存储到变量str里面 readUTF()方法也是一个阻塞式方法，会傻傻地等待客户端发送信息过来，然后将接收到的信息读取出来 如果客户端不写东西过来，它就一直在服务器端傻傻地等待着，直到客户端写东西过来为止 堵塞式的方法效率往往是不高的,比如说一个客户端连接上来了，但是它迟迟不发送信息， 那么服务器端的程序就阻塞住了，这样另外一个客户端就连接不上来了，因为另外一个客户端要想连接 上服务器端，就必须得在服务器端调用accept()方法，可accept()方法必须得在下一次循环时才能够被 调用，现在服务器端的程序运行到调用readUTF()这个方法时就阻塞住了，它要等待着已经连接上来的 那个客户端发送信息过来后将信息读取出来，如果客户端一直不发信息到服务器端，那么readUTF()方法 就一直无法读取到信息，那么服务器端的程序会阻塞在这里，无法进行下次循环，这样其他的客户端就 无法连接到服务器端了*/ String str = dis.readUTF(); System.out.println(str); &#125; &#125; &#125;客户端Socket123456789101112131415import java.net.*;import java.io.*;public class TestClientSocket&#123; public static void main(String args[]) throws Exception&#123; Socket s = new Socket("127.0.0.1",6666); /*Client申请连接到Server端上*/ /*连接上服务器端以后，就可以向服务器端输出信息和接收从服务器端返回的信息 输出信息和接收返回信息都要使用流式的输入输出原理进行信息的处理*/ /*这里是使用输出流OutputStream向服务器端输出信息*/ OutputStream os = s.getOutputStream(); DataOutputStream dos = new DataOutputStream(os); Thread.sleep(30000);/*客户端睡眠30秒后再向服务器端发送信息*/ dos.writeUTF("Hello Server!"); &#125;&#125;客户端通过端口6666向服务器端请求连接，服务器端接受客户端的连接请求以后，就在服务器端上安装一个Socket，然后让这个Socket与客户端的Socket连接，这样服务器端就可以与客户端互相通信了，当有另外一个客户端申请连接时，服务器端接受了以后，又会安装另外一个Socket与这个客户端的Socket进行连接。UDP与TCP协议编程UDP协议需求：完成在线咨询功能，学生和老师在线一对一交流分析：使用基于UDP协议的Socket网络编程实现不需要利用IO流实现数据的传输每个数据发送单元被统一封装成数据包的方式，发送方将数据包发送到网络中，数据包在网络中去寻找他的目的地，一切以包为中心。UDP基本概念：DatagramSocket：用于发送或接收数据包的套接字DatagramPacket：数据包​实现接收方流程：创建发送端Socket对象创建数据，并把数据打包调用Socket对象的发送方法发送数据包释放资源123456789101112131415161718192021222324252627import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;public class PeopleOne &#123; public static void main(String[] args) throws IOException &#123; //1.开放一个端口 DatagramSocket socket = new DatagramSocket(5051); //2.准备容器接收 byte[] receiveBuf = new byte[100]; //3.等待包裹容器封包 DatagramPacket packet = new DatagramPacket(receiveBuf,receiveBuf.length); System.out.println("等你包裹来。。。。"); while (true)&#123; //4.接收包裹 socket.receive(packet); //5.解析包裹 String receStr = new String(packet.getData(),0,packet.getLength()); System.out.println("我收到了："+receStr); if (receStr.equals("exit"))&#123; break; &#125; &#125; //6.释放资源 socket.close(); &#125;&#125;发送方流程：创建发送端Socket对象创建数据(接收容器)调用Socket对象的接收方法接收数据解析数据包，并显示在控制台释放资源12345678910111213141516171819202122232425262728293031import java.io.IOException;import java.net.*;import java.util.Scanner;public class PeopleTwo &#123; public static void main(String[] args) throws IOException &#123; //1.指定一个端口进行发送 DatagramSocket socket = new DatagramSocket(); //2.指定一个IP InetAddress addr = InetAddress.getByName("127.0.0.1"); int port = 5051; //3.准备一个小容器 byte[] sendBuf; while (true)&#123; Scanner scanner = new Scanner(System.in); System.out.println("你要发什么东西："); String s = scanner.nextLine(); //4.加入要放的数据 sendBuf = s.getBytes(); //5.数据打包 DatagramPacket packet = new DatagramPacket(sendBuf,sendBuf.length,addr,port); //6.发送包 socket.send(packet); if (s.equals("exit"))&#123; break; &#125; &#125; //7.释放资源 socket.close(); &#125;&#125;UDP发送接收图解TCP协议需求：完成网络登录功能用户输入用户名密码，服务器给出登录成功或失败的提示分析：使用基于TCP协议的Socket网络编程实现TCP协议基于请求响应模式在网络通讯中，第一次主动发起通讯的程序被作为客户端程序第一次通讯中等待连接的程序被称作服务器程序利用IO流实现数据的传输实现服务器流程创建发送端的Socket对象获取输出流，写数据释放资源1234567891011121314151617181920212223242526import java.io.DataInputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class TestServer &#123; public static void main(String[] args) throws IOException &#123; //服务器开启了一个监听端口 ServerSocket serverSocket = new ServerSocket(6666); System.out.println("开启了服务器"); while (true)&#123; //等待客户端连接 Socket accept = serverSocket.accept(); System.out.println("有一个人连接过来了"); //获得客户端输入的东西 InputStream inputStream = accept.getInputStream(); //包装成DataInputStream流 DataInputStream dataInputStream = new DataInputStream(inputStream); //通过流流读取消息 String s = dataInputStream.readUTF(); System.out.println(s); &#125; &#125;&#125;客户端流程创建接收端的Socket对象监听客户端连接，返回一个Socket对象获取输入流，读取数据显示在控制台释放资源123456789101112import java.io.DataOutputStream;import java.io.IOException;import java.net.Socket;public class TestClient &#123; public static void main(String[] args) throws IOException &#123; //创建同一连接 Socket s = new Socket("127.0.0.1",6666); DataOutputStream dos = new DataOutputStream(s.getOutputStream()); dos.writeUTF("hello,world！"); &#125;&#125;本博文参考于Java - 网络编程完全总结Java网络编程Java网络编程的基本网络概念]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE网络编程</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-多线程]]></title>
    <url>%2Fcategory%2FJavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多线程多线程引入进程与线程进程正在运行的程序，是系统进行资源分配和调用的独立单位每一个进程都有它自己的内存空间和系统资源通过任务管理器我们就看到了进程的存在所有运行中的任务通常对应一个进程,当一个程序进入内存运行时,即变成一个进程.进程是处于运行过程中的程序,并且具有一定独立的功能,进程是系统进行资源分配和调度的一个独立单位.进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，即进程空间或（虚空间）。进程不依赖于线程而独立存在，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。进程的特性: 独立性 、动态性并发性:多个进程可以在单个处理器上并发执行,多个进程之间不会相互影响.并发和并行的区别并行(parellel)指的是在同一时刻,有多条指令在多个处理器上同时被执行;并发指的是在同一时刻只能有一条指令执行,但多个进程指令被快速轮换执行,使得宏观上具有多个进程同时执行的结果.线程线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。是进程中的单个顺序控制流，是一条执行路径一个进程如果只有一条执行路径，则称为单线程程序一个进程如果由多条执行路径，则称为多线程程序总结进程在执行过程中拥有独立的内存单元，进程有独立的地址空间，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器,一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程包含以下内容：一个指向当前被执行指令的指令指针；一个栈；一个寄存器值的集合，定义了一部分描述正在执行线程的处理器状态的值一个私有的数据区。我们使用Join()方法挂起当前线程，直到调用Join()方法的线程执行完毕。该方法还存在包含参数的重载版本，其中的参数用于指定等待线程结束的最长时间（即超时）所花费的毫秒数。如果线程中的工作在规定的超时时段内结束，该版本的Join()方法将返回一个布尔量True。简而言之：一个程序至少有一个进程，一个进程至少有一个线程。线程的划分尺度小于进程，使得多进程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。在Java中，每次程序运行至少启动2个线程：一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个进程。多线程概念多线程扩展了多进程的概念,使得同一进程可以同时并发处理多个任务.线程也被称为轻量级进程,线程时进程的执行单元.线程在程序中是独立的并发的执行流.当进程被初始化之后,主线程就被创建了.线程是进程的组成部分,一个进程可以有多个线程,但一个线程必须有一个父进程.线程可以拥有自己的栈,自己的程序计数器和自己的局部变量,但不拥有系统资源,它与父进程的其他线程共享该进程所拥有的全部资源.因为多个线程共享父进程的所有资源,因此编程比较方便,但必须更加小心,需要确保线程不会妨碍到同一进程里的其他线程.线程是独立运行的,它并不知道进程中是否还有其他的线程存在.线程的执行是抢占式的:当前运行的线程在任何时候都可能被挂起,以便另一个线程可以运行.一个线程可以创建和撤销另一个线程,同一个进程中的多个线程之间可以并发执行.从逻辑角度来看,多线程存在于一个应用程序中,让一个应用程序可以有多个执行部分同时进行,但操作系统无须将多个线程看做多个独立的应用,对多线程实现调度和管理以及资源分配.线程的调度和管理由进程本身负责完成.总结:操作系统可以同时执行多个任务,每个任务就是进程;进程可以同时执行多个任务,每个任务就是线程.多线程的优势进程之间不能共享内存,但线程之间共享内存很容易系统创建进程需要为该进程重新分配系统资源,但创建线程则代价小得多,因此使用多线程来实现多任务并发比多进程的效率高.Java语言内置了多线程功能支持,而不是单纯地作为底层操作系统的调度方式,从而简化了Java的多线程编程.多线程的应用是很广泛的,比如一个浏览器必须能同时下载多个图片,一个web服务器必须能同时响应多个用户请求;Java虚拟机本身就在后台提供了一个超级线程来进行垃圾回收…..Java程序运行原理Java命令会启动Java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程，该进程会自动启动一个“主线程”，然后主线程去调用某个类的main方法，所以main方法运行在主线程中，在此之前的所有程序都是单线程的。JVM虚拟机的启动是单线程的还是多线程的？多线程的，原因是垃圾回收线程也要先启动，否则很容易出现内存溢出。现在的垃圾回收线程加上前面的主线程，最低启动了两个线程，所以jvm的启动是多线程的实现多线程的程序由于线程是依赖进程而存在的，所以我们应该先创建一个进程出来，而进程是由系统创建的，所以我们应该去调用系统功能创建一个进程。Java是不能直接调用系统功能的，所以我们没有办法直接实现多线程程序，但是，Java可以去调用C/C++写好的程序来实现多线程程序，由C/C++去调用系统功能创建进程，然后由Java去调用这样的东西，然后提供一些类供我们使用，我们就可以实现多线程程序了。Java中的线程在Java中，“线程”指两件不同的事情：java.lang.Thread类的一个实例；线程的执行。在 Java程序中，有两种方法创建线程：一是对 Thread 类进行派生并覆盖 run方法；二是通过实现Runnable接口创建。使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义、实例化和启动新线程。一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。Java中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。一个Java应用总是从main()方法开始运行，main()方法运行在一个线程内，他被称为主线程。一旦创建一个新的线程，就产生一个新的调用栈。线程总体分两类：用户线程和守候线程。当所有用户线程执行完毕的时候，JVM自动关闭。但是守候线程却不独立于JVM，守候线程一般是由操作系统或者用户自己创建的。Java线程：创建与启动定义线程扩展java.lang.Thread类。通过继承Thread类创建线程类的具体步骤和具体代码如下：• 定义一个继承Thread类的子类，并重写该类的run()方法；• 创建Thread子类的实例，即创建了线程对象；• 调用该线程对象的start()方法启动线程。1234567891011class SomeThead extends Thraad &#123; public void run() &#123; //do something here &#125; &#125; public static void main(String[] args)&#123; SomeThread oneThread = new SomeThread(); 步骤3：启动线程： oneThread.start(); &#125;实现java.lang.Runnable接口。通过实现Runnable接口创建线程类的具体步骤和具体代码如下：• 定义Runnable接口的实现类，并重写该接口的run()方法；• 创建Runnable实现类的实例，并以此实例作为Thread的target对象，即该Thread对象才是真正的线程对象。12345678class SomeRunnable implements Runnable &#123; public void run() &#123; //do something here &#125; &#125; Runnable oneRunnable = new SomeRunnable(); Thread oneThread = new Thread(oneRunnable); oneThread.start();通过实现Runnable接口创建多线程时,Thread类的作用就是把run()方法包装成线程执行体.可以看到两个子线程的i变量是连续的这是因为采用Runnable接口的方式创建的多个线程可以共享线程类的实例变量.是因为:程序创建的Runnable对象只是线程的target,而多个线程可以共享一个target,所以多个线程可以共享一个线程类(实际上应该是线程的target类)的实例变量.通过Callable和Future创建线程通过Callable和Future创建线程的具体步骤和具体代码如下：• 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。• 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。• 使用FutureTask对象作为Thread对象的target创建并启动新线程。• 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值其中，Callable接口(也只有一个方法)定义如下：123456789101112131415public interface Callable &#123; V call() throws Exception; &#125; /* 步骤1：创建实现Callable接口的类SomeCallable(略); 步骤2：创建一个类对象： Callable oneCallable = new SomeCallable(); 步骤3：由Callable创建一个FutureTask对象： FutureTask oneTask = new FutureTask(oneCallable); 注释： FutureTask是一个包装器，它通过接受Callable来创建，它同时实现了 Future和Runnable接口。 步骤4：由FutureTask创建一个Thread对象： Thread oneThread = new Thread(oneTask); 步骤5：启动线程： oneThread.start(); */从Java5开始,Java提供了Callable接口,该接口可以理解为是Runnable接口的增强版,Callable接口提供了一个call()方法可以作为线程执行体,但call()方法比run()方法功能更强大,call()方法可以有返回值.call()方法可以声明抛出的异常.但是Callable接口并不是Runnable接口的子接口,所以Callable对象不能直接作为Thread的target.而且call()方法还有一个返回值,call()方法并不是直接调用的,它是作为线程执行体被调用的.好在Java提供了Future接口来代表Callable接口里的Call()方法的返回值,并为Future接口提供了一个FutureTask实现类,该实现类既实现了Future接口,并实现了Runnable接口——可以作为Thread类的target.在Future接口里定义了几个公共方法来控制它关联的Callable任务.Callable接口有泛型限制,并且Callable接口里的泛型形参类型与call()方法返回值类型相同.而且Callable接口是函数式接口,可以用Lambda表达式创建Callable对象创建并启动具有返回值的线程的步骤如下:创建Callable接口的实现类,并实现call()方法,该call()方法将作为线程执行体,且该call()方法有返回值,再创建Callable实现类的实例.使用FutureTask类来包装Callable对象,该FutureTask对象封装了该Callable对象的call()方法的返回值使用FutureTask对象作为Thread对象的target创建并启动新线程调用FutureTask对象的get()方法来获得子线程执行结束后的返回值.获取和设置线程名称获取线程对象的名称1public final String getName();//获取线程的名称注：当实现Runnable接口时，获取线程应该是Thread.currentThread()1public static Thread currentThread();//返回当前正在执行的线程对象设置线程对象的名称1public final void setName(String name);//设置线程名称常见问题线程的名字，一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是mian，非主线程的名字不确定。线程都可以设置名字，也可以获取线程的名字，连主线程也不例外。获取当前线程的对象的方法是：Thread.currentThread()；在上面的代码中，只能保证：每个线程都将启动，每个线程都将运行直到完成。一系列线程以某种顺序启动并不意味着将按该顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。当线程目标run()方法结束时该线程完成。一旦线程启动，它就永远不能再重新启动。只有一个新的线程可以被启动，并且只能一次。一个可运行的线程或死线程可以被重新启动。线程的调度是JVM的一部分，在一个CPU的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的。尽管通常采用队列形式，但这是没有保障的。队列形式是指当一个线程完成“一轮”时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，它才能被再次选中。事实上，我们把它称为可运行池而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列而成一个一个队列的事实。尽管我们没有无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。创建线程的三种方式对比采用实现Runnable,Callable接口的方式创建多线程的优缺点:线程类只是实现了Runnable接口或Callable接口,还可以继承其他类多个线程可以共享同一个target对象,非常适合多个相同线程来处理同一份资源的情况,较好的体现了面向对象的思想需要访问当前线程,则必须使用Thread.currentThread()方法采用继承Thread类的方式创建多线程的优缺点:因为该线程已经继承了Thread类,所以不能在继承其他父类编写简单,如果需要访问当前线程,则无需使用Thread.currentThread()方法,直接使用this即可获得当前线程.run()和start()run()：仅仅是封装被线程执行的代码，直接调用时普通方法start()：首先启动了线程，然后再由jvm去调用该线程的run()方法注意:启动线程使用的是start()方法,而不是run()方法!永远都不要调用线程对象的run()方法!!!调用start()方法来启动线程,系统会把该run()方法当成线程来处理;如果直接调用线程对象的run()方法,系统会把线程对象当做普通对象来处理,而run()方法也是一个普通方法,而不是线程执行体.线程的生命周期1. 新建状态​ 用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）。注意：不能对已经启动的线程再次调用start()方法，否则会出现Java.lang.IllegalThreadStateException异常。2. 就绪状态​ 处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。提示：如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠一伙儿，转去执行子线程。3. 运行状态​ 处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。**处于就绪状态的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。如果该线程失去了cpu资源，就会又从运行状态变为就绪状态。重新等待系统分配资源。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。注： 当发生如下情况是，线程会从运行状态变为阻塞状态：线程调用sleep方法主动放弃所占用的系统资源线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞线程试图获得一个同步监视器，但更改同步监视器正被其他线程所持有线程在等待某个通知（notify）程序调用了线程的suspend方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。当线程的run()方法执行完，或者被强制性地终止，例如出现异常，或者调用了stop()、desyory()方法等等，就会从运行状态转变为死亡状态。4. 阻塞状态线程调用sleep()方法主动放弃所占用的处理器资源线程调用了一个堵塞式IO方法,在该方法返回之前,该线程被堵塞线程试图获得一个同步监视器,但该同步监视器正被其他线程所持有线程在等待某个通知(notify)线程调用了线程的suspend()方法将该线程挂起,这个方法容易引起死锁(要尽量避免!!!)已过时。*该方法已经遭到反对，因为它具有固有的死锁倾向。如果目标线程挂起时在保护关键系统资源的监视器上保持有锁，则在目标线程重新开始以前任何线程都不能访问该资源。如果重新开始目标线程的线程想在调用resume之前锁定该监视器，则会发生死锁。这类死锁通常会证明自己是“冻结”的进程。*如果当前线程被堵塞之后,其他线程就可以获得执行的机会,被堵塞的线程会在合适的时候重新进入就绪状态,注意是就绪状态而不是运行状态.被堵塞线程的堵塞解除后,必须重新等待线程调度器再次调用它.解除上面的堵塞调用sleep()方法的线程经过了指定的时间线程调用的堵塞式IO方法已经返回线程成功地获得了试图取得的同步监视器线程正在等待某个通知时,其他线程发出了一条通知处于挂起状态的线程被调用了resume()恢复方法线程状态转换图不难看出,线程从堵塞状态进入就绪状态,无法直接进入运行状态.而就绪和运行状态之间的转换通常不受程序控制,而是由系统线程调度所决定,当处于就绪状态的线程获取到CPU的资源时,该线程进入运行状态;当处于运行状态的线程失去处理器资源时,该线程进入就绪状态. 有一个方法例外:可以调用yield()方法可以让运行状态的线程转入就绪状态.5. 死亡状态线程会以下列三种方式结束,结束后就处于死亡状态run()或call()方法执行完成,线程正常结束线程抛出一个未捕获的Exception或Error直接调用该线程的stop()方法来结束该线程——-该方法容易引起死锁(不推荐!!!)当主线程结束时,其他线程不受任何影响,并不会随之结束.一旦子线程启动起来,它就拥有和主线程相同的地位,它不会受主线程的影响为了测试某个线程是否已经死亡,可以调用该对象的isAlive()方法,当线程处于就绪,运行,堵塞三种状态时,该方法返回true,当线程处于新建和死亡两种状态时,该方法将返回false不要对一个已经死亡的线程再调用start()方法来让它重新启动,死亡就是死亡,该线程将不可再次作为线程执行.如果依然对一个已经死亡的线程再次调用start()方法来启动该线程,将会引发IllegalThreadStateException异常,这表明处于死亡状态的线程已经无法再次运行了.线程管理/控制线程线程的调度及获取和设置线程优先级假如我们计算机只有一个cpu，那么cpu在某一个时刻只能执行一条指令，线程只有得到cpu时间片，也就是使用权，才可以执行指令，那么java是如何对线程进行调用的呢？线程有两种调度模型：时间调度模型和抢占式调度模型时间调度模型：所有线程轮流使用cpu使用权，平均分配每个线程占用cpu的时间片抢占式调度和协作式调度策略抢占式调度:线代桌面和服务器操作系统一般采取抢占式调度策略,系统会给每个可执行的线程一个小时间段来处理任务;当该时间段用完后,系统就会剥夺该线程所占用的资源,让其他线程获得执行的机会.在选择下一个进程的时候,系统会考虑线程的优先级协作式调度:小型设备如手机则采取协作式调度策略,只有当一个线程调用了它的sleep()或yeid()方法后才会放弃所占用的资源——-即必须由该线程主动放弃所占用的资源Java使用的是抢占式调度模型设置和获取线程优先级每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级。Thread类提供了setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级，其中setPriority方法的参数是一个整数，范围是1~·0之间，也可以使用Thread类提供的三个静态常量：123MAX_PRIORITY =10MIN_PRIORITY =1NORM_PRIORITY =512public final int getPriority();//返回线程对象的优先级public final void setPriority(int newPriority);//更改线程的优先级注意：线程默认的优先级是5线程优先级范围是：1-10线程优先级高仅仅表示线程获取的CPU时间片几率高，但是在次数比较多，或者多次运行的时候才能看到比较好的效果虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。线程睡眠—sleep如果需要让当前正在执行的线程暂停一段时间,并进入堵塞状态,则可以通过调用Thread类的静态sleep()方法来实现.sleep()方法有两种重载形式:1.static void sleep(long millis):让当前正在执行的线程暂停millis毫秒,并进入堵塞状态2.static void sleep(long millis,intnanos):让当前正在执行的线程暂停millis毫秒加nanos毫微秒,并进入堵塞状态(很少用)当当前线程调用sleep()方法进入堵塞状态后,在其睡眠时间段内,该线程不会获得执行的机会,即使系统中没有其他可执行的线程,处于sleep()中的线程也不会执行,因此sleep()方法常用来暂停程序的执行.123456789101112public class Test1 &#123; public static void main(String[] args) throws InterruptedException &#123; System.out.println(Thread.currentThread().getName()); MyThread myThread=new MyThread(); myThread.start(); myThread.sleep(1000);//这里sleep的就是main线程，而非myThread线程 Thread.sleep(10); for(int i=0;i&lt;100;i++)&#123; System.out.println("main"+i); &#125; &#125; &#125;线程让步—yieldyeid()方法也是Thread类提供的一个静态方法,它也可以让当前正在执行的线程暂停,但它不会阻塞该线程,它只是让该线程转入就绪状态.yield()只是让当前线程暂停一下,让系统的线程调度器重新调度一次.完全可能的情况是:当某个线程调用了yield()方法暂停之后,线程调度器又将其调度出来重新执行.当某个线程调用了yield()方法暂停之后,只有优先级与当前线程相同,或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会.1234567891011121314151617181920212223public class Test1 &#123; public static void main(String[] args) throws InterruptedException &#123; new MyThread("低级", 1).start(); new MyThread("中级", 5).start(); new MyThread("高级", 10).start(); &#125; &#125; class MyThread extends Thread &#123; public MyThread(String name, int pro) &#123; super(name);// 设置线程的名称 this.setPriority(pro);// 设置优先级 &#125; @Override public void run() &#123; for (int i = 0; i &lt; 30; i++) &#123; System.out.println(this.getName() + "线程第" + i + "次执行！"); if (i % 5 == 0) Thread.yield(); &#125; &#125; &#125;sleep()和yield()方法的区别1.sleep()方法暂停当前线程后,会给其他线程机会,不会理会其他线程的优先级:但yield()方法只会给优先级相同,或优先级更高的线程执行机会2.sleep()方法会使线程进入堵塞状态,知道经过堵塞时间才会转入就绪状态;而yield()不会将线程转入堵塞状态,它只是强调当前线程进入就绪状态.因此完全有可能某个线程调用yield()方法暂停之后,立即重新获得处理器资源而被执行3.sleep()方法声明抛出了InterruptedException异常,所以调用sleep()方法时要么捕捉该异常,要么显式声明抛出该异常;而yield()方法则没有声明抛出任何异常4.sleep()方法比yield()方法有更好的移植性,通常不建议用yield()方法来控制并发线程的执行.线程加入—joinThread提供了让一个线程等待另一个线程完成的方法———-join()方法.当某个执行流中调用其他线程的join()方法时,调用线程将被堵塞,直到被join()方法加入的join线程执行完为止.比如下面程序中的mian线程即主线程,主线程中调用了其他线程(jt线程)的join()方法,此时调用线程(main线程)将被堵塞,直到被join()方法加入的join线程执行完毕为止.join()方法通常由使用线程的程序调用,目的是:将大问题划分为许多小问题,每个小问题分配一个线程.当所有的小问题都得到解决处理后,再调用主线程来进一步操作.1234567891011121314151617181920212223242526public class JoinThread extends Thread&#123; // 提供一个有参数的构造器，用于设置该线程的名字 public JoinThread(String name)&#123; super(name); &#125; // 重写run()方法，定义线程执行体 public void run()&#123; for(inti =0; i &lt;100; i++ )&#123; System.out.println(getName() +" "+ i); &#125; &#125;public static void main(String[] args) throws Exception&#123; // 启动子线程 newJoinThread("新线程").start(); for(inti =0; i &lt;100; i++ )&#123; if(i ==20) &#123; JoinThread jt =new JoinThread("被Join的线程"); jt.start(); // main线程调用了jt线程的join()方法，main线程 // 必须等jt执行结束才会向下执行 jt.join(); &#125; System.out.println(Thread.currentThread().getName()+" "+ i); &#125;&#125;&#125;上述代码中main线程中调用了jt线程的join()方法,main线程必须要等jt线程执行完毕之后才会向下执行join()方法有如下三种重载的方法:join():等待被join的线程执行完成.join(long millis):等待被join的线程的时间最长为millis毫秒.join(long millis,int nanos):等待被join的线程的事件最长为millis毫秒加nanos毫微秒(这个方法很少用!!!)后台(守护)线程有一种线程,它是在后台运行的,它的任务是为其他的线程提供服务的,这种线程称为后台线程(Daemon Thread).JVM的垃圾回收线程就是典型的后台线程.后台线程的特征:如果所有的前台线程都死亡,后台线程自动死亡.调用Thread对象的setDaemon(true)方法可将指定线程设置成后台线程.守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。守护线程的用途为：​ • 守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。​ • Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。setDaemon方法的详细说明：12345678public final void setDaemon(boolean on);//将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。 //该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。 //参数：// on - 如果为 true，则将该线程标记为守护线程。 // 抛出： //IllegalThreadStateException - 如果该线程处于活动状态。 //SecurityException - 如果当前线程无法修改该线程。注：JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台线程时候一定要注意这个问题。1234567891011121314151617181920public class DaemonThread extends Thread&#123; // 定义后台线程的线程执行体与普通线程没有任何区别 public void run()&#123; for(int i =0; i &lt;1000; i++ )&#123; System.out.println(getName() +" "+ i); &#125; &#125; public static void main(String[] args)&#123; DaemonThread t =new DaemonThread(); // 将此线程设置成后台线程 t.setDaemon(true); // 启动后台线程 t.start(); for(int i =0; i &lt;10; i++ )&#123; System.out.println(Thread.currentThread().getName() +" "+ i); &#125;// -----程序执行到此处，前台线程（main线程）结束------// 后台线程也应该随之结束 &#125;&#125;本来该线程应该执行到i=999才会结束,但运行程序时不难发现该后台线程无法运行到999,因为当主线程也就是程序中唯一的前台线程运行结束后,JVM会主动退出,因而后台线程也就被结束了.Thread类还提供了一个isDaemon()方法来判断当前线程是否为后台线程.上面程序中:主线程默认是前台线程,t线程默认是后台线程.并不是所有的线程默认都是前台线程,有些线程默认就是后台线程—————-前台线程创建的子线程默认是前台线程,后台线程创建的子线程默认是后台线程.前台线程死亡之后,JVM会通知后台线程死亡,但从它接收到指令到做出相应,需要一定时间(这也是为什么上图中:在main线程死亡之后Thread-0还进行了一会才死亡的原因).而且将某个线程设置为后台线程,必须要在该线程启动之前设置,即setDaemon(true)必须在start()方法之前调用,否则会引发IllegalThreadStateException异常正确结束线程Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法：​ • 正常执行完run方法，然后结束掉；​ • 控制循环条件和判断条件的标识符来结束掉线程。12345678910111213class MyThread extends Thread &#123; int i=0; boolean next=true; @Override public void run() &#123; while (next) &#123; if(i==10) next=false; i++; System.out.println(i); &#125; &#125; &#125;线程同步由系统的线程调度具有一定的随机性造成的,不过即使程序偶然出现问题,那也是由于编程不当引起的.当多个线程来访问同一个数据时,很容易”偶然”出现安全性问题.java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。同步代码块因为run()方法的方法体不具有同步安全性———程序中有两个并发线程在同一个对象;而且系统恰好在一个方法内执行线程切换,切换给另一个修改对象的线程,所以就出现了问题.就跟以前讲的文件并发访问,当有两个进程并发修改同一个文件时就有可能造成异常.为了解决上述问题,Java引入了同步监视器来解决这个问题,使用同步监视器的通用方法就是同步代码块synchronized123synchronized(obj)&#123;//括号里的obj就是同步监视器 ......//此处的代码就是同步代码块&#125;上述代码的含义是:在线程开始执行同步代码块之前,必须先获得对同步监视器的锁定.任何时刻只能有一个线程可以获得同步监视器的锁定,当同步代码块执行完成之后,该线程会释放该同步监视器的锁定.同步监视器的目的:阻止两个线程对同一个共享资源进行并发访问,推介使用可能被并发访问的共享资源充当同步监视器1234567891011121314151617181920212223242526272829303132public class DrawThread extends Thread&#123;// 模拟用户账户privateAccount account; // 当前取钱线程所希望取的钱数 private double drawAmount; public DrawThread(String name , Account account,double drawAmount&#123; super(name); this.account = account; this.drawAmount = drawAmount; &#125;// 当多条线程修改同一个共享数据时，将涉及数据安全问题。 public void run()&#123;// 使用account作为同步监视器，任何线程进入下面同步代码块之前，// 必须先获得对account账户的锁定——其他线程无法获得锁，也就无法修改它// 这种做法符合：“加锁 → 修改 → 释放锁”的逻辑 synchronized(account)&#123; // 账户余额大于取钱数目 if(account.getBalance() &gt;= drawAmount)&#123; // 吐出钞票System.out.println(getName() +"取钱成功！吐出钞票:"+drawAmount); try&#123; Thread.sleep(1); &#125;catch(InterruptedException ex)&#123; ex.printStackTrace(); &#125;// 修改余额 account.setBalance(account.getBalance() - drawAmount); System.out.println("\t余额为: "+ account.getBalance()); &#125;else&#123; System.out.println(getName() +"取钱失败！余额不足！"); &#125; &#125; // 同步代码块结束，该线程释放同步锁 &#125;&#125;这种做法符合”加锁—-修改—-释放锁”的逻辑,任何线程在修改指定资源之前,首先对该资源加锁,在加锁期间其他线程无法修改该资源,当线程修改完成后,该线程释放对该资源的锁定.通过这种方式可以保证并发线程在同一时刻只有一个线程可以进入修改共享资源的代码区(也被称为临界区),所以同一时刻最多只有一个线程处于临界区内,从而保证了线程的安全性.同步方法Java多线程还提供了同步方法来和同步代码块相对应,使用synchronized字来修饰某个方法,该方法称为同步方法.对于synchronized关键字修饰的实例方法,无须显式指定同步监视器,同步方法的同步监视器是this,也就是调用该方法的对象.通过同步方法可以非常方便的实现线程安全的类,线程安全的类具有如下特征:1.该类的对象可以被多个线程安全地访问2.每个线程调用该对象的任意方法之后都能得到正确结果3.每个线程调用该对象的任意方法之后,该对象状态依然保持合理的状态不可变类总是线程安全的,因为它的对象时不可变的;但可变对象需要额外的方法来保证其线程安全.由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Account&#123; // 封装账户编号、账户余额两个成员变量 private String accountNo; private double balance; public Account()&#123;&#125;// 构造器 public Account(String accountNo ,doublebalance)&#123; this.accountNo = accountNo; this.balance = balance; &#125; // accountNo的setter和getter方法 public void setAccountNo(String accountNo)&#123; this.accountNo = accountNo; &#125; public String getAccountNo()&#123; returnthis.accountNo; &#125; // 因此账户余额不允许随便修改，所以只为balance提供getter方法， public double getBalance()&#123; returnthis.balance; &#125; // 提供一个线程安全draw()方法来完成取钱操作 public synchronized voidd raw(double drawAmount)&#123; // 账户余额大于取钱数目 if(balance &gt;= drawAmount)&#123; // 吐出钞票 System.out.println(Thread.currentThread().getName()+"取钱成功！吐出钞票:"+ drawAmount); try&#123; Thread.sleep(1); &#125;catch(InterruptedException ex)&#123; ex.printStackTrace(); &#125; // 修改余额 balance -= drawAmount; System.out.println("\t余额为: "+ balance); &#125;else&#123; System.out.println(Thread.currentThread().getName() +"取钱失败！余额不足！"); &#125; &#125; // 下面两个方法根据accountNo来重写hashCode()和equals()方法 public int hashCode()&#123; return accountNo.hashCode(); &#125; public boolean equals(Object obj)&#123; if(this== obj)return true; if(obj !=null&amp;&amp; obj.getClass() == Account.class)&#123; Account target =(Account)obj; return target.getAccountNo().equals(accountNo); &#125; return false; &#125;&#125;增加了一个代表取钱的draw()方法,并使用synchronized关键字来修饰该方法,把该方法编程同步方法,该同步方法的同步监视器是this,对于同一个Account账户而言,任意时刻只能有一个线程获得对Account对象的锁定,然后进入draw()方法执行取钱操作——-这样也可以保证多个线程并发取钱的线程安全.注意:synvhronized关键字可以修饰方法,可以修饰代码块,但不能修饰构造器,成员变量等等.123456789101112131415161718public class DrawThread extends Thread&#123; // 模拟用户账户 private Account account; // 当前取钱线程所希望取的钱数 private double drawAmount; public DrawThread(String name,Account account,doubledrawAmount)&#123; super(name); this.account = account; this.drawAmount = drawAmount; &#125; // 当多条线程修改同一个共享数据时，将涉及数据安全问题。 public void run()&#123; // 直接调用account对象的draw方法来执行取钱 // 同步方法的同步监视器是this，this代表调用draw()方法的对象。 // 也就是说：线程进入draw()方法之前，必须先对account对象的加锁 account.draw(drawAmount); &#125;&#125;在上面的示例中,调用draw()方法的对象是account,多个线程并发修改同一份account之前,必须先对account对象加锁,这也符合”加锁—-修改—-释放锁”的逻辑在上面的示例中,调用draw()方法的对象是account,多个线程并发修改同一份account之前,必须先对account对象加锁,这也符合”加锁—-修改—-释放锁”的逻辑面向对象中的一种流行的设计模式:DDD(领域驱动设计):这种方式认为每个类都应该是完备的领域对象,比如:Account代表用户账户,应该提供用户账户的相关方法;通过draw()方法来执行取钱操作(实际上还应该提供transfer()等方法来完成转账等操作),而不是直接将setBalance()方法暴露出来任人操作,这样才能保证Account对象的完整性和一致性.可变类的线程安全是以降低程序的运行效率作为代价的.不要堆线程安全类的所有方法进行同步,只对那些会改变竞争资源(竞争资源也就是共享资源)的方法进行同步.可变类有两种运行环境:单线程环境和多线程环境,则应该为该可变类提供两种版本,即线程不安全版本和线程安全版本.在单线程环境中使用线程不安全版本以保证性能(StringBuilder);在多线程中使用线程安全的版本(StringBuffer)释放同步监视器的锁定程序无须显式释放对同步监视器的锁定,线程会在如下几种情况下释放对同步监视器的锁定当前线程的同步方法,同步代码块执行结束当前线程在同步代码块,同步方法中遇到break,return终止了代码块导致其异常结束当前线程在同步代码块,同步方法中出现了未处理的Error和Exception当前线程执行同步代码块和同步方法时,程序执行了同步监视器对象的wait()方法,当前线程暂停,并释放同步监视器下面出现的情况,线程不会释放同步监视器当前线程在执行同步代码块,同步方法时,程序调用了Thread.sleep(),Thread.yield()方法来暂停当前线程的执行,当前线程并不会释放同步监视器线程在执行同步代码块时,其他线程调用了该线程的suspend()方法将该线程挂起,该线程不会释放同步监视器.程序应该尽量避免使用suspend()和resume()方法来控制线程.使用特殊域变量(volatile)实现线程同步• volatile关键字为域变量的访问提供了一种免锁机制；• 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新；• 因此每次使用该域就要重新计算，而不是使用寄存器中的值；• volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。volatile关键字表示直接操内存池里的数据不操作副本，直接操作原始空间主要定义在属性上无法描述同步处理，只是一种直接内存的处理，避免了副本的操作，而synchronize是实现同步的public class SynchronizedThread { class Bank { private volatile int account = 100; public int getAccount() { return account; } /** * 用同步方法实现 * * @param money */ public synchronized void save(int money) { account += money; } /** * 用同步代码块实现 * * @param money */ public void save1(int money) { synchronized (this) { account += money; } } }class NewThread implements Runnable {private Bank bank;public NewThread(Bank bank) {this.bank = bank;}@Overridepublic void run() {for (int i = 0; i &lt; 10; i++) {// bank.save1(10);bank.save(10);System.out.println(i + “账户余额为：” +bank.getAccount());}}}/**建立线程，调用内部类*/public void useThread() { Bank bank = new Bank();NewThread new_thread = new NewThread(bank);System.out.println(“线程1”);Thread thread1 = new Thread(new_thread);thread1.start();System.out.println(“线程2”);Thread thread2 = new Thread(new_thread);thread2.start();}public static void main(String[] args) {SynchronizedThread st = new SynchronizedThread();st.useThread();}1234567891011121314151617181920212223**注：**多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用final域，有锁保护的域和volatile域可以避免非同步的问题。### 同步锁通过显式定义同步锁对象来实现同步-----同步锁对象由Lock对象充当.(这是一种更为强大的线程同步机制)Lock是控制多个线程对共享资源进行访问的工具,每次只能有一个线程对Lock对象加锁,程序开始访问共享资源之前首先要先获得Lock对象某些锁可能允许对共享资源并发访问,如ReadWriteLock(读写锁);Lock,ReadWriteLock是Java5提供的两个根接口,并为Lock提供了ReentrantLock(可重入锁)实现类,为ReadWriteLock提供了ReentrantReadWriteLock实现类ReentrantReadWriteLock为读写提供了三种锁模式:Writing,ReadingOptimistic,Reading在实现线程安全的控制中比较常用的是ReentrantLock(可重入锁).使用该Lock对象可以显式地释放锁,加锁.在[Java](http://www.2cto.com/kf/ware/Java/)SE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。ReenreantLock类的常用方法有： ​```java ReentrantLock();// 创建一个ReentrantLock实例 lock();//获得锁 unlock();//释放锁注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用123456789101112131415161718//只给出要修改的代码，其余代码与上同class Bank &#123; private int account = 100; //需要声明这个锁 private Lock lock = new ReentrantLock(); public int getAccount() &#123; return account; &#125; //这里不再需要synchronized public void save(int money) &#123; lock.lock(); try&#123; account += money; &#125;finally&#123; lock.unlock(); &#125; &#125;｝12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.locks.*;public class Account&#123; // 定义锁对象 private final ReentrantLock lock = new ReentrantLock(); //....... // 提供一个线程安全draw()方法来完成取钱操作(定义一个保证线程安全的方法) public void draw(doubledrawAmount)&#123; // 加锁 lock.lock(); try&#123; // 账户余额大于取钱数目 if(balance &gt;= drawAmount)&#123; // 吐出钞票 System.out.println(Thread.currentThread().getName() +"取钱成功！吐出钞票:"+ drawAmount); try&#123; Thread.sleep(1); &#125;catch(InterruptedException ex)&#123; ex.printStackTrace(); &#125; // 修改余额balance -= drawAmount; System.out.println("\t余额为: "+ balance); &#125;else&#123; System.out.println(Thread.currentThread().getName() +"取钱失败！余额不足！"); &#125; &#125;finally&#123; // 修改完成，释放锁 lock.unlock(); &#125; &#125; // 下面两个方法根据accountNo来重写hashCode()和equals()方法 public int hashCode()&#123; return accountNo.hashCode(); &#125; public boolean equals(Object obj)&#123; if(this== obj) return true; if(obj !=null&amp;&amp; obj.getClass() == Account.class)&#123; Account target = (Account)obj; returntarget.getAccountNo().equals(accountNo); &#125; return false; &#125;&#125;使用ReentrantLock对象来进行同步,加锁和释放锁出现在不同的作用范围内时,通常建议使用finally块来确保在必要时释放锁.程序中实现draw()方法时,进入方法开始执行后立即请求对ReentrantLock对象进行加锁,当执行完draw()方法的取钱逻辑后,程序使用finally块确保释放锁.使用Lock时是显式调用Lock对象作为同步锁,而使用同步方法时系统隐式地使用当前对象作为同步监视器,同样都符合”加锁—-修改—-释放锁”的操作模式,而且Lock对象时每个Lock对象都对应一个Account对象,一样可以保证对于同一个Account对象,同一时刻只能有一个线程能进入临界区ReentrantLock锁具有可重入性,一个线程可以对已加锁的ReentrantLock锁再次加锁,ReentrantLock对象会维持一个计数器来追踪lock()方法的嵌套使用,线程在每次调用lock()方法加锁后,必须显式调用unlock()方法来释放锁,所以一段被锁保护的代码可以调用另一个被相同锁保护的方法.死锁当两个线程互相等待对方释放同步监视器时就会发生死锁.产生死锁的四个必要条件如下。当下边的四个条件都满足时即产生死锁，即任意一个条件不满足既不会产生死锁。互斥条件：资源不能被共享，只能被同一个进程使用请求与保持条件：已经得到资源的进程可以申请新的资源非剥夺条件：已经分配的资源不能从相应的进程中被强制剥夺循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程占用的资源举个常见的死锁例子：进程A中包含资源A,进程B中包含资源B，A的下一步需要资源B，B的下一步需要资源A，所以它们就互相等待对方占有的资源释放，所以也就产生了一个循环等待死锁。Java没有提供任何检测措施来处理死锁的情况,所以多线程编程时应该尽量采取措施来避免死锁的出现.一旦出现死锁,整个程序既不会发生任何异常,也不会给出任何提示,只是所有线程处于堵塞状态,无法继续.处理死锁的方法忽略该问题，也即鸵鸟算法。当发生了什么问题时，不管他，直接跳过，无视它；检测死锁并恢复；资源进行动态分配；破除上面的四种死锁条件之一。死锁很容易发生,尤其是在系统中出现多个同步监视器的情况下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354classA &#123; public synchronized void foo( B b )&#123; System.out.println("当前线程名: "+ Thread.currentThread().getName()+" 进入了A实例的foo()方法");// ① try&#123; Thread.sleep(200); &#125;catch(InterruptedException ex)&#123; ex.printStackTrace(); &#125; System.out.println("当前线程名: "+ Thread.currentThread().getName()+" 企图调用B实例的last()方法");// ③ b.last(); &#125;public synchronized void last()&#123; System.out.println("进入了A类的last()方法内部");&#125;&#125;classB &#123; public synchronized voidbar(A a)&#123; System.out.println("当前线程名: "+ Thread.currentThread().getName()+" 进入了B实例的bar()方法");// ② try&#123; Thread.sleep(200); &#125;catch(InterruptedException ex)&#123; ex.printStackTrace(); &#125; System.out.println("当前线程名: "+ Thread.currentThread().getName() +" 企图调用A实例的last()方法"); // ④a.last(); &#125; public synchronized void last()&#123; System.out.println("进入了B类的last()方法内部"); &#125;&#125;public class DeadLock implements Runnable&#123; A a =newA(); B b =newB(); public void init()&#123; Thread.currentThread().setName("主线程"); // 调用a对象的foo方法a.foo(b); System.out.println("进入了主线程之后"); &#125; public void run()&#123; Thread.currentThread().setName("副线程"); // 调用b对象的bar方法b.bar(a); System.out.println("进入了副线程之后"); &#125; public static void main(String[] args)&#123; DeadLock dl =newDeadLock(); // 以dl为target启动新线程 newThread(dl).start(); // 调用init()方法 dl.init(); &#125;&#125;Thread类的suspend()方法也容易导致死锁,Java不推介使用该方法来暂停线程的执行.线程通信程序通常无法准确控制线程的轮换执行,但Java也提供了一些机制来保证线程协调运行.传统的线程通信Object类提供的三个方法(这三个方法必须由同步监视器对象来调用):同步监视器对象可以分为下列两种情况:1.使用synchronized修饰的同步方法,该类的默认实例(this)就是同步监视器.2.使用synchronized修饰的同步代码块,同步监视器是synchronized后括号里的对象这三个方法解释如下:wait():导致当前线程等待,直到其它线程调用该同步监视器的notify()方法或notifyAll()方法来唤醒该线程.调用wait()方法的当前线程会释放对该同步监视器的锁定.notify():唤醒此同步监视器上等待的单个线程.只有当前线程放弃对该同步监视器的锁定后(使用wait()方法),才可以执行被唤醒的线程.notifyAll():唤醒在此同步监视器上等待的所有线程.只有当前线程放弃对该同步监视器的锁定后,才可以执行被唤醒的线程.单个消费者生产者例子如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Resource&#123; //生产者和消费者都要操作的资源 private String name; private int count=1; private boolean flag=false; public synchronized void set(String name)&#123; if(flag) try&#123;wait();&#125;catch(Exception e)&#123;&#125; this.name=name+"---"+count++; System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name); flag=true; this.notify(); &#125; public synchronized void out()&#123; if(!flag) try&#123;wait();&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+"...消费者..."+this.name); flag=false; this.notify(); &#125; &#125; class Producer implements Runnable&#123; private Resource res; Producer(Resource res)&#123; this.res=res; &#125; public void run()&#123; while(true)&#123; res.set("商品"); &#125; &#125; &#125; class Consumer implements Runnable&#123; private Resource res; Consumer(Resource res)&#123; this.res=res; &#125; public void run()&#123; while(true)&#123; res.out(); &#125; &#125; &#125; public class ProducerConsumerDemo&#123; public static void main(String[] args)&#123; Resource r=new Resource(); Producer pro=new Producer(r); Consumer con=new Consumer(r); Thread t1=new Thread(pro); Thread t2=new Thread(con); t1.start(); t2.start(); &#125; &#125;//运行结果正常，生产者生产一个商品，紧接着消费者消费一个商品。但是如果有多个生产者和多个消费者，上面的代码是有问题，比如2个生产者，2个消费者，运行结果就可能出现生产的1个商品生产了一次而被消费了2次，或者连续生产2个商品而只有1个被消费，这是因为此时共有4个线程在操作Resource对象r, 而notify()唤醒的是线程池中第1个wait()的线程，所以生产者执行notify()时，唤醒的线程有可能是另1个生产者线程，这个生产者线程从wait()中醒来后不会再判断flag，而是直接向下运行打印出一个新的商品，这样就出现了连续生产2个商品。为了避免这种情况，修改代码如下：1234567891011121314151617181920212223242526272829303132333435class Resource&#123; private String name; private int count=1; private boolean flag=false; public synchronized void set(String name)&#123; while(flag) /*原先是if,现在改成while，这样生产者线程从冻结状态醒来时，还会再判断flag.*/ try&#123;wait();&#125;catch(Exception e)&#123;&#125; this.name=name+"---"+count++; System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name); flag=true; this.notifyAll();/*原先是notity(), 现在改成notifyAll(),这样生产者线程生产完一个商品后可以将等待中的消费者线程唤醒，否则只将上面改成while后，可能出现所有生产者和消费者都在wait()的情况。*/ &#125; public synchronized void out()&#123; while(!flag) /*原先是if,现在改成while，这样消费者线程从冻结状态醒来时，还会再判断flag.*/ try&#123;wait();&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+"...消费者..."+this.name); flag=false; this.notifyAll(); /*原先是notity(), 现在改成notifyAll(),这样消费者线程消费完一个商品后可以将等待中的生产者线程唤醒，否则只将上面改成while后，可能出现所有生产者和消费者都在wait()的情况。*/ &#125; &#125; public class ProducerConsumerDemo&#123; public static void main(String[] args)&#123; Resource r=new Resource(); Producer pro=new Producer(r); Consumer con=new Consumer(r); Thread t1=new Thread(pro); Thread t2=new Thread(con); Thread t3=new Thread(pro); Thread t4=new Thread(con); t1.start(); t2.start(); t3.start(); t4.start(); &#125; &#125;使用Condition控制线程通信如果程序使用Lock对象保证同步,则系统中不存在隐式地同步监视器,也就不能用wait(),notify(),notifyAll()方法进行线程通信了.当使用Lock对象来保证同步时,Java提供了一个Condition类来保持协调,使用Conditon可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象,Conditon对象也可以唤醒其它处于等待的线程.Conditon将同步监视器方法(wait(),notify(),notifyAll())分解成不同的对象,以便通过将这些对象和Lock对象组合使用,为每个对象提供多个等待集(wait-set).Lock替代了同步方法或同步代码块,Conditon替代了同步监视器的功能.Conditon实例绑定在一个Lock对象上,要获得特定Lock实例的Conditon实例,调用Lock对象的newConditon()方法即可.Conditon类提供了如下三个方法:await():类似于隐式同步器上的wait()方法,导致当前线程等待,直到其它线程调用该Conditon的signal()方法或signalAll()方法来唤醒线程.signal():唤醒在此Lock对象上等待的单个线程.只有当前线程放弃对该Lock对象的锁定后(使用await()方法),才可以执行被唤醒线程signalAll():唤醒在此Lock对象上等待的所有线程.只有当前线程放弃对该Lock对象的锁定后(使用await()方法),才可以执行被唤醒线程123456789101112131415161718192021222324252627282930313233343536class Resource&#123; private String name; private int count=1; private boolean flag=false; private Lock lock = new ReentrantLock();/*Lock是一个接口，ReentrantLock是该接口的一个直接子类。*/ private Condition condition_pro=lock.newCondition(); /*创建代表生产者方面的Condition对象*/ private Condition condition_con=lock.newCondition(); /*使用同一个锁，创建代表消费者方面的Condition对象*/ public void set(String name)&#123; lock.lock();//锁住此语句与lock.unlock()之间的代码 try&#123; while(flag) condition_pro.await(); //生产者线程在conndition_pro对象上等待 this.name=name+"---"+count++; System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name); flag=true; condition_con.signalAll(); &#125; finally&#123; lock.unlock(); //unlock()要放在finally块中。 &#125; &#125; public void out()&#123; lock.lock(); //锁住此语句与lock.unlock()之间的代码 try&#123; while(!flag) condition_con.await(); //消费者线程在conndition_con对象上等待 System.out.println(Thread.currentThread().getName()+"...消费者..."+this.name); flag=false; condition_pro.signqlAll(); /*唤醒所有在condition_pro对象下等待的线程，也就是唤醒所有生产者线程*/ &#125; finally&#123; lock.unlock(); &#125; &#125; &#125;使用堵塞队列(BlockingQueue)控制线程通信Java5提供了一个BlockingQueue接口,虽然BlockingQueue也是Queue的子接口,但它的主要作用不是作为容器,而是作为线程同步的工具.BlockingQueue具有一个特征:当生产者线程试图向BlockingQueue中放入元素时,如果该队列已满,则线程堵塞;当消费者线程试图从BlockingQueue中取出元素时,如果该队列已经已空,则该线程堵塞.程序中两个线程通过交替向BlockingQueue中放入元素取出元素,即可实现控制线程通信.BlockingQueue提供下面两个支持堵塞的方法:put(E e):尝试把e元素放入BlockingQueue中,如果该队列的元素已满,则堵塞线程take():尝试从BlockingQueue的头部取出元素,如果该队列的元素已空,则堵塞该线程.BlockingQueue继承了Queue接口,当然也可以使用Queue接口中的方法在队列尾部插入元素:add(E e),offer(E e)和put(E e)方法,当该队列已满时,这三个方法分别抛出异常,返回false,堵塞队列.在队列头部删除并返回删除的元素:remove(),poll(),和take()方法.当该队列已空时,这三个方法分别会抛出异常,返回false,堵塞队列.在队列头部取出但不删除元素:包括element()和peek()方法,当队列已空时,这两个方法分别抛出异常,返回false.BlockingQueue包含如下5个实现类:1234567891011ArrayBlockingQueue ：基于数组实现的BlockingQueue队列。LinkedBlockingQueue：基于链表实现的BlockingQueue队列。PriorityBlockingQueue：它并不是保准的阻塞队列，该队列调用remove（）、poll（）、take（）等方法提取出元素时，并不是取出队列中存在时间最长的元素，而是队列中最小的元素。 它判断元素的大小即可根据元素（实现Comparable接口）的本身大小来自然排序，也可使用Comparator进行定制排序。SynchronousQueue：同步队列。对该队列的存、取操作必须交替进行。DelayQueue：它是一个特殊的BlockingQueue，底层基于PriorityBlockingQueue实现，不过，DelayQueue要求集合元素都实现Delay接口（该接口里只有一个long getDelay（）方法）， DelayQueue根据集合元素的getDalay（）方法的返回值进行排序。下面使用ArrayBlockingQueue为例来介绍堵塞队列的功能和用法.12345678910111213141516import java.util.concurrent.*;public class BlockingQueueTest &#123; public static void main(String[] args) throws Exception&#123; // 定义一个长度为2的阻塞队列 BlockingQueue bq =newArrayBlockingQueue&lt;&gt;(2); bq.put("Java"); // 与bq.add("Java"、bq.offer("Java")相同 bq.put("Java"); // 与bq.add("Java"、bq.offer("Java")相同 bq.put("Java"); // ① 阻塞线程。 //bq.add("Java"); //抛出异常//bq.offer("Java"); //返回false,元素不会被放入 &#125;&#125;与此类似的是:BlockingQueue已空的情况下:使用take()方法取出元素会堵塞线程;使用remove()方法尝试取出元素将引发异常;使用poll()方法取出元素将会返回false,元素不会被删除.示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;public class BlockingQueueTest&#123; public static void main(String[] args)throws Exception&#123; //创建一个容量为1的BlockingQueue BlockingQueue&lt;String&gt; b=new ArrayBlockingQueue&lt;&gt;(1); //启动3个生产者线程 new Producer(b).start(); new Producer(b).start(); new Producer(b).start(); //启动一个消费者线程 new Consumer(b).start(); &#125;&#125;class Producer extends Thread&#123; private BlockingQueue&lt;String&gt; b; public Producer(BlockingQueue&lt;String&gt; b)&#123; this.b=b; &#125; public synchronized void run()&#123; String [] str=new String[]&#123; "java", "struts", "Spring" &#125;; for(int i=0;i&lt;9999999;i++)&#123; System.out.println(getName()+"生产者准备生产集合元素！"); try&#123; b.put(str[i%3]); sleep(1000); //尝试放入元素，如果队列已满，则线程被阻塞 &#125;catch(Exception e)&#123;System.out.println(e);&#125; System.out.println(getName()+"生产完成："+b); &#125; &#125;&#125;class Consumer extends Thread&#123; private BlockingQueue&lt;String&gt; b; public Consumer(BlockingQueue&lt;String&gt; b)&#123; this.b=b; &#125; public synchronized void run()&#123; while(true)&#123; System.out.println(getName()+"消费者准备消费集合元素！"); try&#123; sleep(1000); //尝试取出元素，如果队列已空，则线程被阻塞 b.take(); &#125;catch(Exception e)&#123;System.out.println(e);&#125; System.out.println(getName()+"消费完："+b); &#125; &#125;&#125;线程组和未处理异常线程组Java使用ThreadGroup来表示线程组,它可以对一批线程进行分类管理.Java允许程序直接对线程组进行控制.对线程组的控制相当于同时控制这批线程.用户创建的所有线程都属于指定线程组,如果程序没有显示指定线程属于哪个线程组,那么该线程属于默认线程组.在默认情况下,子线程和创建它的父线程都处于同一线程组内,比如:A线程创建了B线程,并且没有指定B线程属于哪一个线程组,那么B线程属于A线程所在的那个线程组.一旦某个线程加入了指定的线程组之后,该线程将一直属于该线程组,直到该线程死亡.线程运行中途不能改变它所属的线程组.Thread类提供了几个构造器来设置新创建的线程属于哪个线程组Thread(ThreadGroup group, Runnable target):以target的run()方法作为线程执行体创建新线程,属于group线程组.Thread(ThreadGroup group, Runnable target,String name):以target的run()方法作为线程执行体创建新线程,该线程属于group线程组,且线程名为nameThread(ThreadGroup group, String name):创建新线程,新线程名字为name,属于group线程组.Thread类提供了一个getThreadGroup()方法来返回线程所属的线程组,getThreadGroup()方法的返回值是ThreadGroup对象,表示一个线程组.ThreadGroup类提供了下面两个简单的构造器来创建实例:ThreadGroup(String name):以指定的线程组名字来创建新的线程组ThreadGroup(ThreadGroup parent,String name):以指定的名字,指定的父线程组创建一个新线程组.线程组总会有一个名字字符串类型的名字,该名字可以通过ThreadGroup的getName()方法来获取,但是不允许改变线程组名字.ThreadGroup类提供了如下几个常用的方法来操作整个线程组里的所有线程:int activeCount():返回此线程组中活动线程总数interrupt():中断此线程组中所有线程isDaemon():判断该线程组是否是后台线程组setDaemon(boolean daemon):把该线程组设置成后台线程组.setMaxPriority(int pri):设置线程组的最高优先级1234567891011121314151617181920212223242526272829class MyThread extends Thread&#123; // 提供指定线程名的构造器 public MyThread(String name)&#123; super(name); &#125; // 提供指定线程名、线程组的构造器 public MyThread(ThreadGroup group , String name)&#123; super(group, name); &#125; public void run()&#123; for(inti =0; i &lt;20; i++ )&#123; System.out.println(getName() +" 线程的i变量"+ i); &#125; &#125;&#125;public class ThreadGroupTest&#123; public static void main(String[] args)&#123; // 获取主线程所在的线程组，这是所有线程默认的线程组 ThreadGroup mainGroup = Thread.currentThread().getThreadGroup(); System.out.println("主线程组的名字："+ mainGroup.getName()); System.out.println("主线程组是否是后台线程组："+ mainGroup.isDaemon()); newMyThread("主线程组的线程").start(); ThreadGroup tg =newThreadGroup("新线程组"); tg.setDaemon(true); System.out.println("tg线程组是否是后台线程组："+ tg.isDaemon()); MyThread tt =newMyThread(tg ,"tg组的线程甲"); tt.start();newMyThread(tg ,"tg组的线程乙").start(); &#125;&#125;异常ThreadGroup内还定义了一个void uncaughtException(Thread t,Throwable e):该方法可以处理该线程组内的任意线程所抛出的未处理异常.该方法中的t代表出现异常的线程,e代表该线程抛出的异常.void uncaughtException(Thread t,Throwable e)该方法属于Thread.UncaughtExceptionHandler接口里唯一的一个方法,该接口是Thread类的一个静态内部接口Thread类提供如下两个方法来设置异常处理器:static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh):为该线程类的所有线程实例设置默认的异常处理器.setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh):为指定的线程实例设置异常处理器ThreadGroup类实现了Thread.UncaughtExceptionHandler接口,所以每个线程所属的线程组都会作为默认的异常处理器.当一个线程抛出未处理的异常时,JVM会首先查找该异常所对应的异常处理器(setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)方法设置的异常处理器),如果找到该异常处理器,则将调用该异常处理器处理该异常;否则JVM将会调用该线程所属的线程组对象的uncaughtExceptio()方法来处理该异常.线程组处理异常的默认流程如下:如果该线程组有父线程组,则调用父线程组的uncaughtException()方法来处理该异常如果该线程实例所属的线程类有默认的异常处理器(由setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)方法设置的异常处理器),那么就调用该异常处理器来处理该异常.如果该异常对象是ThreadDeath的对象,则不做任何处理;否则,将异常跟踪栈的信息打印到System.err错误输出流,并结束该线程下面程序为主线程设置了异常处理器,当主线程运行抛出未处理的异常时,该异常处理器会起作用.123456789101112131415class MyExHandler implements Thread.UncaughtExceptionHandler&#123; // 实现uncaughtException方法，该方法将处理线程的未处理异常 public void uncaughtException(Thread t, Throwable e)&#123; System.out.println(t +" 线程出现了异常："+ e); &#125;&#125;public class ExHandler &#123; public static void main(String[] args)&#123; // 设置主线程的异常处理器 Thread.currentThread().setUncaughtExceptionHandler(newMyExHandler()); inta =5/0;// ①System.out.println("程序正常结束！"); &#125;&#125;//结果为://Thread[main,5,main] 线程出现了异常：java.lang.ArithmeticException: / by zero说明异常处理器与通过catch捕捉异常是不同的,当使用catch捕捉异常时,通常不会向上传播给上一级调用者;但使用异常处理器对异常进行处理之后,异常依然会传播给上一级调用者.线程池系统启动一个新线程的成本是比价高的,因为涉及到与操作系统交互,在这种情况下,使用线程池可以很好的提高性能,尤其是当程序中需要创建大量生存期很短的线程时,更应该考虑使用线程池线程池在系统启动时即创建大量空闲的线程,程序将一个Runnable对象或Callable对象传给线程池,线程池就会启动一个线程来执行它们的run()或call()方法,当run()或call()方法执行结束后,该线程并不会死亡,而是再次返回线程池中称为空闲状态,等待执行下一个Runnable对象的run()或call()方法.使用线程池可以有效控制系统中并发线程的数量,当系统中包含大量并发线程时,会导致系统性能剧烈下降,甚至JVM崩溃,而线程池的最大线程数参数可以控制系统中并发线程数不超过此数.合理利用线程池能够带来三个好处：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。Java5新增了一个Executors工厂类来产生线程池,该工厂类提供了如下几个静态工厂方法来创建线程池使用线程池来执行线程任务的步骤如下:调用Executor类的静态工厂方法创建一个ExecutorService对象,该对象代表一个线程池.创建Runnable实现类或Callable实现类的实例,作为线程执行任务.调用ExecutorService对象的submit()方法提交Runnable实例或Callable实例当不想提交任何任务时,调用ExecutorService对象的shutdown()方法来关闭线程池.使用Executors工厂类产生线程池Executor线程池框架的最大优点是把任务的提交和执行解耦。客户端将要执行的任务封装成Task，然后提交即可。而Task如何执行客户端则是透明的。具体点讲，提交一个Callable对象给ExecutorService（如最常用的线程池ThreadPoolExecutor），将得到一个Future对象，调用Future对象的get方法等待执行结果。线程池实现原理类结构图如下：ExecutorService是Java中对线程池定义的一个接口，它java.util.concurrent包中。Java API对ExecutorService接口的实现有两个，所以这两个即是Java线程池具体实现类如下：12除此之外，ExecutorService还继承了Executor接口（注意区分Executor接口和Executors工厂类），这个接口只有一个execute()方法，最后我们看一下整个继承树：​ 使用Executors执行多线程任务的步骤如下：• 调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池；• 创建Runnable实现类或Callable实现类的实例，作为线程执行任务；• 调用ExecutorService对象的submit()方法来提交Runnable实例或Callable实例；• 当不想提交任务时，调用ExecutorService对象的shutdown()方法来关闭线程池。使用Executors的静态工厂类创建线程池的方法如下：newFixedThreadPool() ：​ 作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按FIFO方式处理任务队列中的任务。newCachedThreadPool() ：​ 作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。newSingleThreadExecutor() ：​ 作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。newScheduledThreadPool() ：​ 作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。newSingleThreadScheduledExecutor() ：​ 作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。注：Executors只是一个工厂类，它所有的方法返回的都是ThreadPoolExecutor、ScheduledThreadPoolExecutor这两个类的实例。ExecutorService有如下几个执行方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//execute(Runnable);//这个方法接收一个Runnable实例，并且异步的执行，请看下面的实例：ExecutorService executorService = Executors.newSingleThreadExecutor();executorService.execute(new Runnable() &#123;public void run() &#123; System.out.println("Asynchronous task");&#125;&#125;);executorService.shutdown();//--------------------------//submit(Runnable);//submit(Runnable)和execute(Runnable)区别是前者可以返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完毕，请看下面执行的例子：Future future = executorService.submit(new Runnable() &#123;public void run() &#123; System.out.println("Asynchronous task");&#125;&#125;);future.get(); //returns null if the task has finished correctly.//如果任务执行完成，future.get()方法会返回一个null。注意，future.get()方法会产生阻塞。//--------------------------//submit(Callable);//submit(Callable)和submit(Runnable)类似，也会返回一个Future对象，但是除此之外，submit(Callable)接收的是一个Callable的实现，Callable接口中的call()方法有一个返回值，可以返回任务的执行结果，而Runnable接口中的run()方法是void的，没有返回值。请看下面实例：Future future = executorService.submit(new Callable()&#123;public Object call() throws Exception &#123; System.out.println("Asynchronous Callable"); return "Callable Result";&#125;&#125;);System.out.println("future.get() = " + future.get());//如果任务执行完成，future.get()方法会返回Callable任务的执行结果。另外，future.get()方法会产生阻塞。//--------------------------//invokeAny(...)//invokeAny(...)方法接收的是一个Callable的集合，执行这个方法不会返回Future，但是会返回所有Callable任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果，反正是其中的某一个。请看下面实例：ExecutorService executorService = Executors.newSingleThreadExecutor();Set&lt;Callable&lt;String&gt;&gt; callables = new HashSet&lt;Callable&lt;String&gt;&gt;();callables.add(new Callable&lt;String&gt;() &#123;public String call() throws Exception &#123; return "Task 1";&#125;&#125;);callables.add(new Callable&lt;String&gt;() &#123;public String call() throws Exception &#123; return "Task 2";&#125;&#125;);callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return "Task 3";&#125;&#125;);String result = executorService.invokeAny(callables);System.out.println("result = " + result);executorService.shutdown();//每次执行都会返回一个结果，并且返回的结果是变化的，可能会返回“Task2”也可是“Task1”或者其它。//--------------------------//invokeAll(...)// invokeAll(...)与 invokeAny(...)类似也是接收一个Callable集合，但是前者执行之后会返回一个Future的List，其中对应着每个Callable任务执行后的Future对象。情况下面这个实例：ExecutorService executorService = Executors.newSingleThreadExecutor();Set&lt;Callable&lt;String&gt;&gt; callables = new HashSet&lt;Callable&lt;String&gt;&gt;();callables.add(new Callable&lt;String&gt;() &#123;public String call() throws Exception &#123; return "Task 1";&#125;&#125;);callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return "Task 2";&#125;&#125;);callables.add(new Callable&lt;String&gt;() &#123;public String call() throws Exception &#123; return "Task 3";&#125;&#125;);List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callables);for(Future&lt;String&gt; future : futures)&#123; System.out.println("future.get = " + future.get());&#125;executorService.shutdown();ExecutorService关闭方法当我们使用完成ExecutorService之后应该关闭它，否则它里面的线程会一直处于运行状态。举个例子，如果的应用程序是通过main()方法启动的，在这个main()退出之后，如果应用程序中的ExecutorService没有关闭，这个应用将一直运行。之所以会出现这种情况，是因为ExecutorService中运行的线程会阻止JVM关闭。要关闭ExecutorService中执行的线程，我们可以调用ExecutorService.shutdown()方法。在调用shutdown()方法之后，ExecutorService不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在shutdown()执行之前提交的任务都会被执行。如果想立即关闭ExecutorService，我们可以调用ExecutorService.shutdownNow()方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。使用Java8增强的ForkJoinPool产生线程池Java8增强的ForkJoinPoolJava7提供了ForkJoinPool来支持将一个任务分解为多个”小任务”并行计算,再把多个”小任务”的结果合并成总的计算结果.ForkJoinPool是ExecutorService的实现类,因此是一种特殊的线程池.ForkJoinPool提供如下两个常用的构造器:ForkJoinPool(int parallelism):创建一个包含parallelism个并行线程的ForkJoinPool.ForkJoinPool():以Runtime.availableProcessors()方法的返回值作为parallelism参数来创建ForkJoinPoolJava8为ForkJoinPool增加了通用池功能.ForkJoinPool类通过如下两个静态方法提供通用池功能:ForkJoinPool commonPool():该方法返回一个通用池,通用池的运行状态不会受shutdown()或shutdownNow()方法的影响.如果程序直接执行System.exit(0)来终止虚拟机,通用池以及通用池中正在执行的任务都会被自动终止.int getCommonPoolParallelism():该方法返回通用池的并行级别.创建了ForkJoinPool实例之后,就可以调用ForkJoinPool的submit(ForkJoinTask task)或invoke(ForkJoinTask task)方法来执行指定的任务了.其中ForkJoinTask代表一个可以并行,合并的任务.ForkJoinTask是一个抽象类,它有两个抽象子类:RecursiveAction和RecursiveTask.其中RecursiveAction代表有返回值的任务,RecursiveTask代表没有返回值的任务.在Java 8中，引入了自动并行化的概念。它能够让一部分Java代码自动地以并行的方式执行，前提是使用了ForkJoinPool。ForkJoinPool同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。ForkJoinPool主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题。典型的应用比如快速排序算法。这里的要点在于，ForkJoinPool需要使用相对少的线程来处理大量的任务。比如要对1000万个数据进行排序，那么会将这个任务分割成两个500万的排序任务和一个针对这两组500万数据的合并任务。以此类推，对于500万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于10时，会停止分割，转而使用插入排序对它们进行排序。那么到最后，所有的任务加起来会有大概2000000+个。问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。所以当使用ThreadPoolExecutor时，使用分治法会存在问题，因为ThreadPoolExecutor中的线程无法像任务队列中再添加一个任务并且在等待该任务完成之后再继续执行。而使用ForkJoinPool时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。比如，我们需要统计一个double数组中小于0.5的元素的个数，那么可以使用ForkJoinPool进行实现如下：12345678910111213141516171819202122232425262728293031323334353637public class ForkJoinTest &#123; private double[] d; private class ForkJoinTask extends RecursiveTask &#123; private int first; private int last; public ForkJoinTask(int first, int last) &#123; this.first = first; this.last = last; &#125; protected Integer compute() &#123; int subCount; if (last - first &lt; 10) &#123; subCount = 0; for (int i = first; i &lt;= last; i++) &#123; if (d[i] &lt; 0.5)&#123; subCount++; &#125; &#125; &#125;else &#123; int mid = (first + last) /2; ForkJoinTask left = new ForkJoinTask(first, mid); left.fork(); ForkJoinTask right = new ForkJoinTask(mid + 1, last); right.fork(); subCount = left.join(); subCount += right.join(); &#125; return subCount; &#125; &#125; public static void main(String[] args) &#123; ForkJoinPool pool=new ForkJoinPool(); pool.submit(new ForkJoinTask(0, 9999999)); pool.awaitTermination(2,TimeUnit.SECONDS); System.out.println("Found " + n + " values"); &#125;&#125;以上的关键是fork()和join()方法。在ForkJoinPool使用的线程中，会使用一个内部队列来对需要执行的任务以及子任务进行操作来保证它们的执行顺序。注：使用ThreadPoolExecutor和ForkJoinPool的性能差异：首先，使用ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用4个线程来完成超过200万个任务。但是，使用ThreadPoolExecutor时，是不可能完成的，因为ThreadPoolExecutor中的Thread无法选择优先执行子任务，需要完成200万个具有父子关系的任务时，也需要200万个线程，显然这是不可行的。ForkJoinPool能够实现工作窃取(Work Stealing)，在该线程池的每个线程中会维护一个队列来存放需要被执行的任务。当线程自身队列中的任务都执行完毕后，它会从别的线程中拿到未被执行的任务并帮助它执行。因此，提高了线程的利用率，从而提高了整体性能。对于ForkJoinPool，还有一个因素会影响它的性能，就是停止进行任务分割的那个阈值。比如在之前的快速排序中，当剩下的元素数量小于10的时候，就会停止子任务的创建。结论：当需要处理递归分治算法时，考虑使用ForkJoinPool；仔细设置不再进行任务划分的阈值，这个阈值对性能有影响；Java 8中的一些特性会使用到ForkJoinPool中的通用线程池。在某些场合下，需要调整该线程池的默认的线程数量。线程相关类ThreadLocalThreadLocal它并不是一个线程，而是一个可以在每个线程中存储数据的数据存储类，通过它可以在指定的线程中存储数据，数据存储之后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到该线程的数据。 即多个线程通过同一个ThreadLocal获取到的东西是不一样的，就算有的时候出现的结果是一样的（偶然性，两个线程里分别存了两份相同的东西），但他们获取的本质是不同的。使用这个工具类可以简化多线程编程时的并发访问，很简洁的隔离多线程程序的竞争资源。它代表一个线程局部变量,通过把数据放在ThreadLocal中就可以让每个线程创建一个该变量的副本,从而避免并发访问的线程安全问题.ThreadLocal类支持泛型支持.通过使用ThreadLocal类可以简化多线程编程中的并发访问,使用这个工具类可以简捷地隔离多线程程序的竞争资源.线程局部变量(ThreadLocal)的功用非常简单,就是为每一个使用该变量的线程都提供一个变量值的副本,使每一个使用该变量的线程都提供一个变量值的副本,使每一个线程都可以独立地改变自己的副本,而不会和其他线程的副本冲突.对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。ThreadLocal类提供了如下的三个public方法：123ThreadLocal();//创建一个线程本地变量。T get();//返回此线程局部变量的当前线程副本中的值，如果这是线程第一次调用该方法，则创建并初始化此副本。protected T initialValue();//返回此线程局部变量的当前线程的初始值。下面通过系统源码来分析出现这个结果的原因。 在ThreadLocal中存在着两个很重要的方法，get()和set()方法，一个读取一个设置。123456789101112131415161718192021222324252627282930313233343536373839/** * Returns the value of this variable for the current thread. If an entry * doesn't yet exist for this variable on this thread, this method will * create an entry, populating the value with the result of * &#123;@link #initialValue()&#125;. * * @return the current value of the variable for the calling thread. */ @SuppressWarnings("unchecked") public T get() &#123; // Optimized for the fast path. Thread currentThread = Thread.currentThread(); Values values = values(currentThread); if (values != null) &#123; Object[] table = values.table; int index = hash &amp; values.mask; if (this.reference == table[index]) &#123; return (T) table[index + 1]; &#125; &#125; else &#123; values = initializeValues(currentThread); &#125; return (T) values.getAfterMiss(this); &#125; /** * Sets the value of this variable for the current thread. If set to * &#123;@code null&#125;, the value will be set to null and the underlying entry will * still be present. * * @param value the new value of the variable for the caller thread. */ public void set(T value) &#123; Thread currentThread = Thread.currentThread(); Values values = values(currentThread); if (values == null) &#123; values = initializeValues(currentThread); &#125; values.put(this, value); &#125;从注释上可以看出，get方法会返回一个当前线程的变量值，如果数组不存在就会创建一个新的。另外，对于“当前线程”和“数组”，数组对于每个线程来说都是不同的 values.table。而values是通过当前线程获取到的一个Values对象，因此这个数组是每个线程唯一的，不能共用，而下面的几句话也更直接了，获取一个索引，再返回通过这个索引找到数组中对应的值。这也就解释了为什么多个线程通过同一个ThreadLocal返回的是不同的东西。​ Java中为什么要这么设置呢？ThreadLocal在日常开发中使用到的地方较少，但是在某些特殊的场景下，通过ThreadLocal可以轻松实现一些看起来很复杂的功能。一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑使用ThreadLocal。例如在Handler和Looper中。对于Handler来说，它需要获取当前线程的Looper，很显然Looper的作用域就是线程并且不同的线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松的实现Looper在线程中的存取。如果不采用ThreadLocal，那么系统就必须提供一个全局的哈希表供Handler查找指定的Looper，这样就比较麻烦了，还需要一个管理类。ThreadLocal的另一个使用场景是复杂逻辑下的对象传递，比如监听器的传递，有些时候一个线程中的任务过于复杂，就可能表现为函数调用栈比较深以及代码入口的多样性，这种情况下，我们又需要监听器能够贯穿整个线程的执行过程。这个时候就可以使用到ThreadLocal，通过ThreadLocal可以让监听器作为线程内的全局对象存在，在线程内通过get方法就可以获取到监听器。如果不采用的话，可以使用参数传递，但是这种方式在设计上不是特别好，当调用栈很深的时候，通过参数来传递监听器这个设计太糟糕。而另外一种方式就是使用static静态变量的方式，但是这种方式存在一定的局限性，拓展性并不是特别的强。比如有10个线程在执行，就需要提供10个监听器对象。注：ThreadLocal和其他所有的同步机制一样，都是为了解决多线程中对于同一变量的访问冲突。值普通的同步机制中，通过对象加锁来实现多线程对同一变量的安全访问，且该变量是多线程共享的，所有需要使用这种同步机制来明确分开是在什么时候对变量进行读写，在什么时候需要锁定该对象。此种情况下，系统并没有将这个资源复制多份，而是采取安全机制来控制访问而已。ThreadLocal只是从另一个角度解决多线程的并发访问，即将需要并发访问的资源复制多份，每个线程拥有一份资源，每个线程都有自己的资源副本。ThreadLocal并不能代替同步机制,同步机制是为了同步多个线程对相同资源的并发访问,是多个线程之间进行通信的有效方式,而ThreadLocal是为了隔离多个线程的数据共享,从根本上上避免多个线程之间对共享资源(变量)的竞争,也就不需要对多个线程进行同步了.总结：若多个线程之间需要共享资源，以达到线程间的通信时，就使用同步机制；若仅仅需要隔离多线程之间的关系资源，则可以使用ThreadLocal。包装线程不安全的集合前面提到了ArrayList,LinkedList,HashSet,TreeSet,HashMap,TreeMap都是线程不安全的集合,当多个并发线程访问这些集合存取元素时,就可能会破坏这些集合的数据完整性.可以使用Collections提供的类方法把这些集合编程线性安全的集合.如果需要把某个集合包装成线性安全的集合,应该在创建之后立即包装//使用Collections的synchronizedMap方法将一个普通的HashMap包装成一个线程安全的类HashMap m=Collections.synchronizedMap(newHashMap());线程安全的集合类定时器定时器是一个应用十分广泛的线程工具，可用于调度多个定时任务以后台线程的方式执行，在Java中，可以通过Timer和TimerTask类来实现定义调度的功能1234567//Timerpublic Timer();public void schedule(TimerTask task,long delay);public void schedule(TimerTask task,long delay,long period);//TimerTaskpublic abstract void run();public boolean cancel();开发中：Quartz是一个完全由Java编写的开源调度框架本文转载编辑于Java多线程Java多线程详解推荐博文：Java中的多线程你只要看这一篇就够了]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE多线程</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-API]]></title>
    <url>%2Fcategory%2FJavaSE-API%2F</url>
    <content type="text"><![CDATA[JavaSE-常用APIGregorianCalendar类Date类用来表示时间点，并且官方目前推荐用GregorianCalendar类GregorianCalendar类用来表示更为通用的日历表示法GregorianCalendar类扩展一个更通用的Calendar类，这个类描述了日历的一般属性构造器new GregorianCalendar():构造一个新对象，用于表示对象构造时的日期和时间。new GregorianCalendar(1999，11，31):用给定日期和时间构造一个Gregorian日历对象要想查询某个时间点的年月日等信息，应该使用GregorianCalendar类的get方法，为了表达希望得到的项，需要借助于Calendar类中定义的一些常量，比如Calendar.Month或Calendar.DAY_OF_WEEK;还有设置年月日的set方法。get方法和set、add方法在概念上有区别，get方法仅仅查看并返回对象的状态，而set和add方法却对对象的状态进行修改。对实例域做出修改的方法称为更改器方法，仅访问实例域而不进行修改的方法称为访问其方法。常用方法void add(int field, int amount):对给定的时间域增加指定数量的时间int getFirstDayOfWeek():获得当前用户所在地区，一个星期中的第一天。void setTime(Date time):将日历设置为指定的时间点.Date getTime():获得这个日历对象当前值所表达的时间点String[]getShortWeekdays()String[]getShortMonths ()String[]getWeekdays()String[]getMonths ()获得当前地区的星期几或几月份的名称，利用Calendar的星期和月份常量作为数组索引值.Calendar类它为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段123public int get (int field)://返回给定日历字段的值，日历类中的每个日历字段都是静态的成员变量，并且时int类型public void add(int field,int amount)://根据给定的日历字段和对应的时间，来对当前的日历进行操作public final void set(int year,int month,int date)://设置当前日历的年月日Object类可以使用Object类型的变量引用任何类型的对象，Object类型的变量只能用于作为各种值得通用持有者。要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的类型转换。在Java中，只有基本类型不是对象。所有的数组类型都属于Object类。构造方法：public Object()hashCode()方法散列码(hash code)是由对象导出的一个整数值,散列码是没有规律的。hashCode方法定义在Object类中，每个对象都有一个默认的散列码,其值为对象的存储地址.int hash(Object…objects):返回一个散列码，由提供的所有对象的散列码组合而得到。12345678910public class ObjectDemo&#123; public void main(String[] args)&#123; Phone p = new Phone(); System.out.println(p.hashCode());//11299397 Phone p2 = new Phone(); System.out.println(p2.hashCode());//24446859 Phone p3 = p1; System.out.println(p3.hashCode());//11299397 &#125;&#125;getClass()方法1public final Class &lt;？&gt; getClass（）返回此运行时类Object返回的 Class对象是由static synchronized所表示的类的方法锁定的对象。实际结果的类型是Class&lt;? extends |X|&gt; 其中|X|是静态类型上其表达的擦除getClass被调用。例如，此代码片段中不需要强制转换：Number n = 0;Class&lt;? extends Number&gt; c = n.getClass();返回：在Class表示运行时类此对象的对象。在Class表示运行时类此对象的对象。toString()方法返回对象的字符串表示，默认是由类的全路径+’@’+哈希值的十六进制表示1public String toString()返回对象的字符串表示形式。通常，该 toString方法返回一个“文本表示”此对象的字符串。结果应该是一个简洁但信息丰富的表示，便于人们阅读。建议所有子类都重写此方法。toString类 的方法Object返回一个字符串，该字符串由对象为实例的类的名称，符号字符“ @`”和对象的哈希码的无符号十六进制表示组成。换句话说，此方法返回一个等于值的字符串：1getClass().getName()+'@'+ Integer.toHexString(hashCode())返回：对象的字符串表示形式。12//Integer类下的一个静态方法public static String toHexString(int i);//把一个整数转成一个十六进制表示的字符串一般toString()方法返回的值是没有意义的，所以我们需要对其重写，一般在子类重写该方法建议把该类的所有成员变量值组成返回即可，也可以根据自己需求equals()方法1public boolean equals（Object obj）指示某个其他对象是否“等于”此对象。该equals方法在非null对象引用上实现等价关系：它是自反的：对于任何非空引用值 x，x.equals(x)应该返回 true。它是对称的：对于任何非空引用值 x和y，x.equals(y)应该返回true当且仅当 y.equals(x)回报true。它是传递性：对于任何非空的参考值 x，y以及z，如果 x.equals(y)回报率true和 y.equals(z)回报率true，那么 x.equals(z)应该返回true。它是一致的：对于任何非空引用值 x以及一致返回 或一致返回的y多次调用 ，前提是不修改在对象比较中使用的信息。 x.equals(y) true false equals对于任何非空引用值x， x.equals(null)应返回false。equals类 的方法Object实现了对象上最具辨别力的等价关系; 即，对于任何非空的参考值x和 y，该方法返回true当且仅当x和y指代相同的对象（x == y具有值true）。请注意，通常需要在重写此hashCode方法时覆盖该方法，以便维护该hashCode方法的常规协定，该协定声明相等的对象必须具有相等的哈希代码。equals方法的常用格式：显示参数命名为otherObject，稍后需要将他转换成另一个叫做other的变量。检测this与otherObject是否引用同一个对象:if(otherObject== null) return false;比较this与otherObject是否属于同一个类，如果equals的语义在每个子类中有所改变，就是用getClass检测:if(getClass()!=otherObject.getClass())return false;如果所有子类都拥有统一的语义，就使用instanceof检测:if(!otherObjectinstanceof ClassName)) return false;将otherObject转换为相应的类型变量:ClassNameother = (ClassName)otherObject使用==比较基本类型域，使用equals比较对象域，如果都匹配，返回true，否则返回falsereturnfield1 == other.field1&amp;&amp;Object.equals(field2,other.field2)&amp;&amp;.. .;如果在子类中重新定义equals，就要在其中包含调用super.equals(other)equals方法指示其他某个对象是否与此对象”相等”.这个方法默认情况下比较的是地址值，比较地址值一般来说意义不大，所以需要重写该方法，一般用来比较对象的成员变量值是否相同==：基本类型：比较的就是值是否相同引用类型：比较的就是地址值是否相同demo:12345678910111213public boolean equals(Object obj)&#123; //return true //这里改进phone的equals方法，根据这里比较的成员变量决定返回true或false //因为name是String类型，所以不能用==比较，应该用equals //String类的equals方法是重写Object类的，比较的是字符串内容是否相同 //我们比较的是手机类的成员变量，所以要向下转型 Phone p = (Phone)obj; if(this.name.equals(p.name) &amp;&amp; this.size == p.size)&#123; return true; &#125;else&#123; return false; &#125;&#125;finalize()方法确定不存在对该对象的更多引用时，由于对象的垃圾回收器调用此方法。用于垃圾回收，但是什么时候回收不知道当垃圾回收器protected void finalize（）throw Throwable当垃圾收集确定没有对该对象的更多引用时，由对象上的垃圾收集器调用。子类重写finalize处置系统资源或执行其他清理的方法。一般合同finalize是，如果Java TM虚拟机确定不再有任何方法可以通过任何尚未死亡的线程访问此对象，则会调用它，除非采取了一些操作通过最终确定一些其他准备完成的对象或类。该finalize方法可以采取任何动作，包括使该对象再次可用于其他线程; finalize然而，通常的目的是在对象被不可撤销地丢弃之前执行清理操作。例如，表示输入/输出连接的对象的finalize方法可能会执行显式I / O事务，以在永久丢弃对象之前断开连接。finalize类 的方法不Object执行特殊操作; 它只是正常返回。子类 Object可以覆盖此定义。Java编程语言不保证哪个线程将为finalize任何给定对象调用该方法。但是，可以保证，调用finalize时，调用finalize的线程不会持有任何用户可见的同步锁。如果finalize方法抛出未捕获的异常，则忽略该异常并终止该对象的终止。在finalize为一个对象调用该方法之后，在Java虚拟机再次确定不再有任何方法可以通过任何尚未死亡的线程访问该对象之前不再采取任何操作，包括可能的操作准备好最终确定的其他对象或类，此时可以丢弃该对象。finalize对于任何给定对象，Java虚拟机永远不会多次调用该方法。该finalize方法抛出的任何异常都会导致暂停此对象的终结，但会被忽略。抛出：Throwable- Exception通过这种方法提出的clone()方法protected Object clone（）throw CloneNotSupportedExceptionCloneable:此类实现了Cloneable接口，以指示Object.clone()方法可以合法的对该类实例进行按字段赋值，这个接口是个标记接口，告诉我们实现该接口就可以实现对象的复制了创建并返回此对象的副本。“复制”的确切含义可能取决于对象的类别。一般意图是，对于任何对象x，表达式：x.clone（）！= x将是真的，那表达式：x.clone（）。getClass（）== x.getClass（）会true，但这些不是绝对的要求。通常情况是：x.clone（）。等于（x）的将是true，这不是一个绝对的要求。按照惯例，返回的对象应该通过调用获得 super.clone。如果一个类及其所有超类（除了 Object）遵守这个约定，那将是这种情况 x.clone().getClass() == x.getClass()。按照惯例，此方法返回的对象应独立于此对象（正在克隆）。要实现此独立性，可能需要在返回super.clone之前修改返回的对象的一个​​或多个字段。通常，这意味着复制包含被克隆对象的内部“深层结构”的任何可变对象，并使用对副本的引用替换对这些对象的引用。如果一个类只包含原始字段或对不可变对象的引用，那么通常情况下super.clone 不需要修改返回的对象中的任何字段。clone类 的方法Object执行特定的克隆操作。首先，如果此对象的类未实现接口Cloneable，则 CloneNotSupportedException抛出a。请注意，所有数组都被认为是实现接口，Cloneable并且clone数组类型方法的返回类型T[] 是T[]T是任何引用或基本类型。否则，此方法创建此对象的类的新实例，并使用该对象的相应字段的内容初始化其所有字段，就像通过赋值一样; 这些字段的内容本身不会被克隆。因此，该方法执行该对象的“浅拷贝”，而不是“深拷贝”操作。该类Object本身并不实现接口 Cloneable，因此clone在类的对象上调用该方法Object将导致在运行时抛出异常。返回：这个实例的克隆。抛出：CloneNotSupportedException- 如果对象的类不支持该Cloneable接口。覆盖该clone方法的子类也可以抛出此异常以指示无法克隆实例。要想实现对象克隆，那么对象所在的类需要实现一个Cloneable接口Scanner类System类下有一个静态的字段public static final InputStream in;标准的输入流，对应着键盘输入InputStream is = System.in1234567891011Class Demo&#123; public static final int x = 10; public static final Phone p = new Phone();&#125;int y = Demo.x;Phone p = Demo.p;//构造方法Scanner(InputStream source);//基本用法Scanner sc = new Scanner(System.in);int x = sc.nexInt();Scanner类的成员方法基本格式:hasNextXxx()：判断是否还有下一个输入项，其中Xxx可以是Int，Double等，如果需要判断是否包含下一个字符串则可以省略XxxnextXxx()：获取下一个输入想，Xxx和上面的方法中Xxx相同默认情况下，Scanner使用空格，回车等作为分隔符常用方法public int nextInt()public String nextLine()String 类字符串是由多个字符组成的一串数据，也可以看成是一个字符数组。字符串字面值“abc“也可以看成是一个字符串对象字符串是常量，一旦被赋值，就不能被改变字符串的内容不能改变，而不是引用不能改变1234567String a = "123";String b = "123";a == b ;true//因为引用的是同一个123堆内存里有个字符串常量池-&gt;本质是一个数组String s = &quot;123&quot;;池中没有新的数据则添加数据，如果有，则指向在采用直接赋值过程中，对于字符串而言可以实现池数据的自动保存，这样如果再有相同数据定义时，减少想通过对象产生，提升操作性能String s = new String(&quot;123&quot;);开辟两块堆内存空间，而只会使用一块，而另外一个由于字符串常量所定义的匿名对象会成为垃圾空间实际上是属于一种自己专用的内存空间，但是在String类里面也提供有帮助开发者实现手工入池两种方法的区别:1-&gt;只会产生一个实例化对象，并且可以自动保存到对象池中，以实现该字符串实例的重用2-&gt;会产生两个实例化对象，并且不会自动入池，无法对对象重用，但是可以利用intern()方法手工入池String对象(常量)池对象池的主要目的是实现数据的共享处理，以Spring对象池为例，里面的内容主要就是为了重用，重用就是为了共享设计，但是在在Java之中对象（常量）池实际上可分为两种静态常量池：指的是程序(.*class)在加载时候会自动将此程序之中保存的字符串、普通的常量、类和方法的信息等等，全部进行分配;运行时常量池：指的是程序(.*class)加载之后，里面可能有一些变量，这个时候提供的常量池。空串和Null串:空串有自己的串长度和内容，String变量可以存放一个特殊的值，名为null，有时候要检查一个字符串既不是null也不为空串，需要使用if(str !=null &amp;&amp;str.length()!= 0)构造方法123456public String()://空构造public String(byte[] bytes)://把字节数组转成在字符串public String(byte[] bytes,int index,int length)://把字节数组的一部分转成字符串public String(char[] value)://把字符数组转成字符串public String(char[] value,int index,int count)://把字符数组的一部分转成字符串public String(String original)://把字符串常量值转成字符串面试题1234567891011//看程序写结果//字符串如果是变量相加，先开空间，再拼接//字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则就创建String s1 = "hello";String s2 = "world";String s3 = "helloworld";System.out.println(s3 == s1+s2);//falseSystem.out.println(s3.equals(s1+s2));//true//通过反编译可知，这里已经做了处理System.out.println(s3 =="hello"+"world");//true--&gt;s3=="helloworld"System.out.println(s3.equals("hello"+"world"));//true--&gt;s3.equals("helloworld")String类的判断功能123456789boolean equals(Object obj)://比较字符串的内容是否相同，区分大小写boolean equalsIgnoreCase(String str)://比较字符串的内容是否相同，忽略大小写boolean contains(String str)://判断大字符串中是否包含小字符串boolean startWith(String str)://判断字符串是否以某个指定的字符串开头boolean endsWith(String str)://判断字符串是否以某个指定的字符串结尾boolean isEmpty()://判断字符串是否为空//注意：字符串内容为空和字符串对象为空String s = "";String s = null;String类的获取功能123456789int length()://获取字符串的长度char charAt(int index)://获取指定索引位置的字符int indexOf(int ch)://返回指定字符在此字符串中第一次出现处的索引//在这里是int类型而不是char类型，是因为'a'和97都可以代表'a'int indexOf(Stirng str)://返回指定字符出中第一次出现处的索引int indexOf(int ch,int fromIndex)://返回指定字符串在此字符串中从指定位置后第一次出现处的索引int indexOf(String str,int fromIndex)://返回指定字符串在此字符串中从中指定位置后第一次出现处的索引String substring(int start)://从指定位置开始截取字符串，默认到末尾String substring(int start,int end)://从指定位置开始到指定位置结束截取字符串字符串的遍历123for(int x = 0;x&lt;s.length();x++)&#123; System.out.println(s.charAt(x));&#125;统计大小写个数案例12345678910111213141516171819202122//定义一个字符串String s = "Hello123World";//定义三个统计变量int bigCount = 0;int smallCount = 0;int numberCount = 0;//遍历字符串，得到每一个字符for(int x = 0;x&lt;s.length();x++)&#123; char ch = s.charAt(x); //判断该字符到底属于那种类型 if(ch&gt;='a' &amp;&amp; ch&lt;='z')&#123; smallCount++; &#125;else if(ch&gt;='A' &amp;&amp; ch&lt;='Z')&#123; bigCount++; &#125;else if(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123; numberCount++; &#125;&#125;//输出结果System.out.println("大写字母"+bigCount+"个");System.out.println("小写字母"+smallCount+"个");System.out.println("数字"+numberCount+"个");String类的转换功能1234567byte[] getBytes()://把字符串转换为字节数组char[] toCharArray()://把字符串转换为字符数组static String valueOf(char[] chs)://把字符数组转成字符串static String valueOf(int i)://把int类型的数组转成字符串,注意：String类的valueOf()方法可以把任意类型的数据转成字符串String toLowerCase()://把字符串转成小写String toUpperCase()://把字符串转成大写String concat(String str)://把字符串拼接字符串首字母大写，其他转小写1String result = s.substring(0,1).toUpperCase().concat(s.substring(1).toLowerCase());String类的其他功能String类的替换功能12String replace(char old,char new);String replace(String old,String new);去除字符串两空格1String trim();按字典顺序比较两个字符串123456789int compareTo(String str);int compareToIgnoreCase(String str);String s1 = "hello";String s2 = "hello";String s3 = "abc";String s4 = "xyz";System.out.println(s1.compareTo(s2));//0System.out.println(s1.compareTo(s3));//7System.out.println(s1.compareTo(s4));//-16至于这里为什么是-16，可以想想int数组拼接成字符串案例123456789101112131415161718192021//两个明确：返回值类型：String 参数列表：int[] arrpublic static String arrayToString(int[] arr)&#123; //定义一个字符串 String s = ""; //先把字符串拼接一个"[" s += "["; //遍历int数组，得到每一个元素 for(int x = 0; x &lt; arr.length;x++)&#123; //先判断该元素是否是最后一个 if(x==arr.length-1)&#123; //是就直接拼接元素和"]" s +=arr[x]; s += "]"; &#125;else&#123; //拼接元素和逗号以及空格 s += arr[x]; s += ", "; &#125; &#125; return s;&#125;字符反转12345678910111213//两个明确，返回值类型：String 参数列表：Stringpublic static String myReverse(String s)&#123; //定义一个新字符串 String result = ""; //把字符串转成字符数组 char[] chs = line.toCharArray(); //倒着遍历字符串，得到每一个字符 for(int x = chs.length-1;x&gt;=0;x--)&#123; //用新字符串把每一个字符拼接起来 result += chs[x]; &#125; return result;&#125;在大串中查找小串出现的次数案例1234567891011121314151617181920public static void main(String[] args)&#123; //定义大串 String maxString="woaijavazhenaijavawoaizhavazhenaijava"; //定义小串 String minString="java"; //功能实现 int count = getCount(maxString,minString); System.out.println("java在大串中出现了"+count+"次");&#125;private static int getCount(String maxString,String minString)&#123; //定义一个统计变量，初始值是0 int count = 0; int index; //先查，赋值，判断 while((index = maxString.indexOf(minStirng))!=-1)&#123; count++; maxString = maxString.subString(index+minString.length()); &#125; return count;&#125;格式化字符串字符串 -&gt; %s字 符 -&gt; %c整 数 -&gt; %d小 数 -&gt; %fStringBuffer类线程安全的可变字符串StringBuffer和String的区别StringBuffer长度和内容可变，String不可变如果使用StringBuffer做字符串的拼接，不会浪费太多的资源StringBuffer类的构造方法1234567public StringBuffer()://无参构造方法public StringBuffer(int capacity)://指定容量的字符串缓冲区对象public StringBuffer(String str)://指定字符串内容的字符串缓冲区对象//StringBuffer的方法public int capacity()://返回当前容量，理论值public int length()://返回长度(字符数)，实际值StringBuffer的添加功能12public StringBuffer append(String str)://可以把任意类型数据添加到字符串缓冲区里面，并返回字符串缓冲区本身public StringBuffer insert(int offset,String str)://在指定位置把任意类型的数据插入到字符串缓冲区里面，并返回字符串缓冲区本身StringBuffer的删除功能12public StringBuffer deleteCharAt(int index)://删除指定位置的字符，并返回本身public StringBuffer delete(int start,int end)://删除从指定位置开始指定位置结束的内容，并返回本身StringBuffer的替换功能1public StringBuffer replace(int start,int end,String str)://从start开始到end用str替换StringBuffer的反转功能1public StringBuffer reverse()StringBuffer的截取功能123//在这里返回值类型是Stringpublic String substring(int start);public String substring(int start,int end);String和StringBuffer的相互转换1234567891011121314//String --&gt; StringBufferString s = "hello";//方法1，通过构造方法StringBuffer sb = new StringBuffer(s);//方法2，通过append方法String Buffer sb2 = new StringBuffer();sb2.append(s);//StringBuffer --&gt; StringStringBuffer buffer = new StringBuffer("java");//方法1，通过构造方法String str = new String(buffer);//方法2，通过toString()方法String str2 = buffer.toString();用StringBuffer做数组拼接指定格式字符串12345678910111213public static String arrToString2(int[] arr)&#123; StringBuffer sb = new StringBuffer(); sb.append("[")； for(int x = 0;x&lt;arr.length;x++)&#123; if(x == arr.length-1)&#123; sb.apend(arr[x]); &#125;else&#123; sb.append(arr[x]).append(", "); &#125; &#125; sb.append("]"); return sb.toString();&#125;字符串反转功能123public static String myReverse2(String s)&#123; return new StringBuffer(s).reverse().toString();&#125;判断一个字符串是否对称1234567891011public static boolean isSame(String s)&#123; boolean flag = true; //把字符串转成字符数组 char[] chs = s.toCharArray(); for(int start = 0,end = chs.length-1;start&lt;=end;start++,end--)&#123; if(chas[start]!=chs[end])&#123; return false; &#125; &#125; return true;&#125;String,StringBuffer,StringBuilder的区别String是内容不可变的，StringBuffer，StringBuilder是内容可变的StringBuffer是同步的，数据安全，效率低，StringBuilder是不同步的，数据不安全，效率高String作为参数传递，效果和基本类型作为参数传递是一样的，形式参数的改变不影响实际参数StringBuffer和数组的区别？二者都可以看出是一个容器，装其他的数据但是，StringBuffer的数据最终是一个字符串数据而数组可以放置多种数据，但必须是同一种数据类型Arrays类Arrays：针对数组进行操作的工具类，比如说排序和查找123public static String toString(int[] a)://把数组转成字符串public static void sort(int[] a)://对数组进行排序public static int binarySearch(int[] a,int key)://二分查找基本包装类所有的基本类型都有一个与之对应的类，这些类称为包装器:Integer、Long、Double、Short、Byte、Character、Void、Boolean。前六个类派生于公共的超类Number。对象包装器类是不可变的，一旦构造了包装器，就不允许更改包装在其中的值，同时，包装器类还是final，因此不能定义它们的子类。自动装箱: list.add(3);list.add(Integer.valueOf(3));自动拆箱: int n = list.gei(i);Int n = list.gei(i).intValue();参数数量可变的方法:123public static void double max(double… values)&#123;…&#125;为了对基本数据类型进行更多的操作，更方便的操作，Java就针对每一种基本数据类型提供了对应的类类型，包装类类型byte —&gt;Byteshort —&gt; Shortint —&gt; Integerlong —&gt; Longfloat —&gt; Floatdouble —&gt; Doublechar —&gt; Characterboolean —&gt; BooleanInteger的构造方法123public Integer (int value)public Integer(String s)//这里这个字符出啊必须是由数字字符组成String和int类型的相互转换1234int --&gt; StringString.valueOf(number)String --&gt; intInteger.parseInt(s)Integer中进制转换的操作123456789//常用的基本进制转换public static String toBinaryString(int i);public static String toOctalString(int i);public static String toHexString(int i);//十进制到其他进制public static String toString(int i,int radix);//其他进制到十进制public static int parseInt(String s,int radix);JDK5自动装箱和拆箱自动装箱：把基本类型转换为包装类类型自动拆箱：把包装类类型转换为基本类型注意：在使用Integer x = null;代码机会出现NullPointerException，建议先判断是否为null，然后再使用Integer的数据直接赋值，如果在-128到127之间，会直接从缓冲池里获取数据CharacterCharacter类在对象中包装一个基本类型char的值该类提供了几种方法，以确定字符的类型（小写字母，数字，等等），并将字符从大写转换成小写，反之亦然构造方法：Character(char value)12345public static boolean isUpperCase(char ch)://判断给定的字符是否是大写字符public static boolean isLowerCase(char ch)://判断给定的字符是否是小写字符public static boolean isDigit(char ch)://判断给定的字符是否是数字字符public static char toUpperCase(char ch)://把给定的字符转换为大写字符public static char toLowerCase(char ch)://把给定的字符转换为小写字符Math类用于数学运算的类123456789101112//成员变量public static final double PIpublic static final double E//成员方法public static int abs(int a)://绝对值public static double ceil(double a)://向上取整public static double floor(double a)://向下取整public static int max(int a,int b)://最大值public static double pow(double a,double b)://a的b次幂public static double random()://随机数[0.0,1.0)public static int round(float a)://四舍五入public static double sqrt(double a)://正平方根获取任意范围内的随机数123456789101112131415161718192021public class MathDemo&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); System.out.println("请输入开始数:"); int start = sc.nextInt(); System.out.println("请输入结束数:"); int end = sc.nextInt(); for(int x = 0;x&lt;100;x++)&#123; //调用功能 int num = getRandom(start,end); //输出结果 System.out.println(num); &#125; &#125; //返回值类型：int 参数列表int start，int end public static int getRandom(int start,int end)&#123; int number = (int)(Math.random()*end)+start; return number; &#125;&#125;Random类产生随机数的类1234567//构造方法public Random()://没有给种子，用的是默认种子，是当前时间的毫秒值public Random(long seed)://给出指定的种子//给定种子后，每次得到的随机数是相同的//成员方法public int nextInt()://返回的是int范围内的随机数public int nextInt(int n)://返回的是[0,n)范围内的随机数System类System类包含一些有用的类字段和方法，它不能被实例化12345//方法public static void gc()://运行垃圾回收器，等同于调用了Runtime里的gc()public static void exit(int status)://终止当前正在运行的Java虚拟机，参数用作状态码；根据惯例，非0的状态码表示异常终止public static long currentTimeMillis()://返回以毫秒为单位的当前时间public static arraycopy(Object src,int srcPos,Object dest,int destPos,int length)://从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束BigInteger类可以让超过Integer范围内的数据进行运算12345678//构造方法BigInteger(String val);//方法public BigInteger add(BigInteger val)://加public BigInteger subtract(BigInteger val)://减public BigInteger multiply(BigInteger val)://乘public BigInteger divide(BigInteger val)://除public BigInteger[] divideAndRemainder(BigInteger val)://返回商和余数的数组BigDecimal类不可变的、任意精度的有符号十进制数，可以解决数据丢失问题12345678//构造方法public BigDecimal(String val);//方法public BigDecimal add(BigDecimal val)://加public BigDecimal subtract(BigDecimal augend)://减public BigDecimal multiply(BigDecimal subtrahend)://乘public BigDecimal divide(BigDecimal multipicand)://除public BigDecimal[] divide(BigDecimal divisor,int scale,int roundingMode)://返回商和余数的数组Date类表示特定的瞬间，精确到毫秒123456789101112//构造方法Date()://根据当前的默认毫秒值创建日期对象Date(long date)://根据给定的毫秒值创建日期对象//方法public long getTime()://获取时间，以毫秒为单位public void setTime(long time)://设置时间//从Date得到一个毫秒值 //getTime()//把一个毫秒值转换为Date //构造方法 //setTime(long time)DateFormat类实现日期和字符串的相互转换12345678910//Date --&gt; String(格式化)public final String format(Date date);//String --&gt;Date(解析)public Date parse(String source);//DateFormat:可以进行日期和字符串的格式化和解析，但是由于是抽象类，所以使用具体子类SimpleDateFormat//SimpleDateFormat的构造方法SimpleDateFormat()://默认模式SimpleDateFormat(String pattern)://给定的模式//这个模式的字符串(年-y，月-M，日-d，时-H，分-m，秒-s)1234Date date = new Date();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);String str = sdf.format(date);System.out.println(str);parse():解析字符串UUID类是一种生成无重复字符串的一种程序类，这种程序类的主要功能是根据时间戳实现一个自动的无重复的字符串定义UUID.randomUUID();Optional类进行null的相关处理，在以前进行程序开发的时候，如果为了防止程序中出现空指向的异常，可以以追加有null的验证。在引用接受的一方往往都是被动的进行判断，在Java中提供Optional这个类，可以实现null的处理操作12345public static &lt;T&gt; Optional&lt;T&gt;empty(); //返回空数据public T get();//获取数据public static &lt;T&gt; Optional&lt;T&gt; of(T value); //保存数据，但是不允许出现null.如果在保存数据时候存在null，则会抛出NullPointerException异常public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value); //保存数据，允许为空public T orElse(T other); //空的时候返回其它数据ThreadLocal类解决线程同步问题在ThreadLocal类里面存放两个对象，一个线程对象，一个数据对象12345//操作数据对象：public ThreadLocal();//构造方法public void set(T value);//设置数据public T get();//取出数据public void remove();//删除数据每一个线程通过ThreadLocal只允许保存一个数据Base64加密与解密Base64类里面有两个内部类:1234//Base64.Encoder:进行加密处理public byte[] encode(byte[] src);//Base64.Decoder:进行解密处理public byte[] decode(String src);比较器Comparable比较器public int ComparTo();Comparator挽救型比较器CharSequence接口三个常用子类String StringBuffer StringBuilder描述的是一个字符串AutoCloseable接口日资源开发的处理，以实现资源的自动关闭（释放资源)jdk1.7后，该接口只有一个方法:public void close() throws Exception除了实现这个接口，还得实现异常处理，要跟异常捆绑在一起Runtime类描述运行时状态，是唯一一个与JVM运行状态有关的类，并且都会默认提供有一个该类的实例化对象构造方法私有，单类设计模式，getRuntime() 获取实例化对象availableProcessors() 方法可以获取本机的CPU内核数maxMermory() 获取最大内存空间，默认配置本机系统内存的四分之一totalMemory() 获取可用内存空间，默认配置本机系统内存六十四分之一freeMemory() 获取空闲内存空间gc() 手工进行GC处理垃圾收集器，是可以由系统自动调用垃圾释放功能，也可以自己手工调用Cleanner类进行finialize()方法替代在新一代的清除回收处理的过程之中，更多情况下考虑的是多线程的使用，即，为了防止有可能造成的延迟处理，许多对象回收前的处理都是单独通过一个线程完成的]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE常用API</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-IO流]]></title>
    <url>%2Fcategory%2FJavaSE-IO%2F</url>
    <content type="text"><![CDATA[File类我们要想实现IO的操作，就必须知道硬盘上文件的表现形式而Java提供了一个类File供我们使用File：文件和目录（文件夹）路径名的抽象表示形式构造方法：123File(String pathname);//根据一个路径得到File对象File(String parent,String child);//根据一个目录和一个子文件/目录得到File对象File(File parent,String child);//根据一个父File对象和一个子文件/目录得到File对象12345678public class FileDemo&#123; public static void main(String[] args)&#123; File file = new File("E:\\demo\\a.txt"); File file2 = new File("E:\\demo","a.txt"); File file3 = new File("E:\\demo"); File file4 = new File(file3,"a.txt"); &#125;&#125;File类的方法1234567891011121314151617181920212223242526272829303132333435363738//创建功能public boolean createNewFile();//创建文件，如果存在这样的文件，就不创建了public boolean mkdir();//创建文件夹，如果存在这样的文件，就不创建了public boolean mkdirs();//创建文件夹，如果父文件夹不存在，会帮你创建出来//删除功能public boolean delete();//如果创建文件或则文件夹忘了写盘符路径，默认在项目路径下//Java中的删除不走回收站//要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹//重命名功能public boolean renameTo(File dest);//如果路径名相同，就是改名//如果路径名不同，就是改名并剪切//路径以盘符开始：绝对路径 C:\\a.txt//路径不以盘符开始：相对路径 a.txt//判断功能public boolean isDirectory();//判断是否是目录public boolean isFile();//判断是否是文件public boolean exists();//判断是否存在public boolean canRead();//判断是否可读public boolean canWrite();//判断是否可写public boolean isHidden();//判断是否隐藏//获取功能public String getAbsolutePath();//获取绝对路径public String getPath();//获取相对路径public String getName();//获取名称public long length();//获取长度，字节数public long lastModified();//获取最后一次的修改时间，毫秒值public String[] list();//获取指定目录下的所有文件或者文件夹的名称数组public File[] listFiles();//获取指定目录下的所有文件或者文件夹的File数组//要想实现这个效果，就必须学习一个接口：文件过滤器public String[] list(FilenameFilter filter);public File[] listFiles(FilenameFilter filter);递归方法定义中调用方法本身的现象程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调；用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过；程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。递归是一种应用非常广泛的算法（或者编程技巧）。递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。递归需要满足的三个条件：1. 一个问题的解可以分解为几个子问题的解；2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样；3. 存在递归终止条件。递归的三个条件：边界条件递归前进段递归返回段当边界条件不满足时，递归前进；当边界条件满足时，递归返回。递归注意实现要有出口，否则就是死递归次数不能太多，否则就内存溢出构造方法不能递归使用递归5的阶乘递归问题问题：N级台阶（比如100级），每次可走1步或者2步，求总共有多少种走法？分析：如果有大于2级的n级台阶，那么假如第一次跳一级台阶，剩下还有n-1级台阶，有f(n-1)种跳法，假如第一次条2级台阶，剩下n-2级台阶，有f(n-2)种跳法。这就表示f(n)=f(n-1)+f(n-2)，即斐波那契数列。假设只有一个台阶，那么只有一种跳法，那就是一次跳一级，f(1)=1；如果有两个台阶，那么有两种跳法，第一种跳法是一次跳一级，第二种跳法是一次跳两级，f(2)=2。1234567//费波纳契数列变形，求n个台阶的走法，递归方式public int f(int n)&#123; if(n&lt;=2)&#123; return n; &#125; return f(n-1)+f(n+2);&#125;编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。递归代码要警惕重复计算为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。123456789101112131415//费波纳契数列变形，求n个台阶的走法，递归方式public int f(int n)&#123; //新建一个HashMap，用来保存已经求过的f(n)，避免重复计算 HashMap&lt;Integer,Integer&gt; hashMap = new HashMap&lt;&gt;(); if(n&lt;=2)&#123; return n; &#125; //求f(n)时，先判断map中是否已经存在，如果存在直接取值 if(hashMap.containsKey(n))&#123; return hashMap.get(n); &#125; int ret = f(n-1)+f(n+2); hashMap.put(n,ret);//将f(n)存进map中 return ret;&#125;递归代码要警惕堆栈溢出我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题，递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接抛出异常。1234567891011121314151617181920int depth = 0;//全局变量，表示递归的深度//费波纳契数列变形，求n个台阶的走法，递归方式public int f(int n)&#123; ++depth; if(depth&gt;1000)&#123; System.out.println("超过设定深度了"); &#125; //新建一个HashMap，用来保存已经求过的f(n)，避免重复计算 HashMap&lt;Integer,Integer&gt; hashMap = new HashMap&lt;&gt;(); if(n&lt;=2)&#123; return n; &#125; //求f(n)时，先判断map中是否已经存在，如果存在直接取值 if(hashMap.containsKey(n))&#123; return hashMap.get(n); &#125; int ret = f(n-1)+f(n+2); hashMap.put(n,ret);//将f(n)存进map中 return ret;&#125;怎么将递归代码改写为非递归代码？递归本身就是借助栈来实现的，如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，便可以将递归改成非递归。1234567891011121314151617//费波纳契数列变形，求n个台阶的走法，非递归方式public int f(int n)&#123; //n = 1或n = 2,直接返回f(1) = 1,f(2) = 2 if(n&lt;2)&#123; return n; &#125; int ret = 0;//ret中存储的结果f(n) int prepre = 1;//prepre存储的值是f(n-2),初始值是f(1)=1 int pre = 2;//pre存储的值是f(n-1),f(2)=2 for(int i = 3;i&lt;n;i++)&#123; //手动模拟栈的过程 ret = prepre + pre; prepre = pre; pre = pre; &#125; return ret;&#125;递归:文件目录12345678910111213141516171819202122232425262728293031323334import java.io.File;/** * 任务：计算一个文件夹大小：累加文件的大小 * @author gyf * */public class Demo01 &#123; public static void main(String[] args) &#123; //递归:文件目录 /**打印出a目录所有文件名称，包括子文件夹的文件*/ //1.创建目录对象 File dir = new File("C:/Users/10301/Desktop/a"); //2.打印目录的子文件 printSubFile(dir); &#125; public static void printSubFile(File dir)&#123; //打印目录的子文件 File[] subfiles = dir.listFiles(); for(File f : subfiles)&#123; if(f.isDirectory())&#123;//文件夹 printSubFile(f); &#125;else&#123;//文件 System.out.println(f.getAbsolutePath()); &#125; &#125; &#125;&#125;练习:从键盘输入接收一个文件夹路径,打印出该文件夹下所有的.jpg文件名123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.File;import java.util.Scanner;public class Demo02 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub //练习:从键盘输入接收一个文件夹路径,打印出该文件夹下所有的.jpg文件名 //1.获取文件路径 Scanner scanner = new Scanner(System.in); System.out.println("请输入一个文件夹路径..."); String path = scanner.nextLine(); //2.把路径封装成File对象 File file = new File(path); if(!file.exists())&#123; System.out.println("此路径对应的文件不存在"); return; &#125; if(!file.isDirectory())&#123; System.out.println("请输入文件夹路径，而不文件路径"); return; &#125; //3.遍历文件夹下的子文件 printSubFile(file); &#125; public static void printSubFile(File dir)&#123; //打印目录的子文件 File[] subfiles = dir.listFiles(); for(File f : subfiles)&#123; if(f.isDirectory())&#123;//文件夹 printSubFile(f); &#125;else&#123;//文件 if(f.getName().endsWith(".jpg"))&#123; System.out.println(f.getAbsolutePath()); &#125; &#125; &#125; &#125;&#125;IO流IO流用来处理设备之间的数据传输,Java对数据的操作是通过流的方式Java用于操作流的类都在IO包中，上传文件和下载文件Java对数据的操作是通过流的方式Java用于操作流的对象都在IO包中Stream是java的一个类，专门用于处理程序个外部设备的输入输出（简称IO），这里的外部设备可以是文件、键盘或者网络。基本所有的流都在这个包中。实际上流就是数据在程序和外部设备之间的管道，而类的方法则是管道上的各种按钮。所以为什么需要流呢？在数据量很大的情况下，节省时间内存有限，需要“分时分步”进行传输带宽有限而stream可以分次传输数据，一点一点传，这就是Stream存在的意义。这里可以参照腾X的下载软件，每次下载一个文件都是在本地建一个cache文件，然后把文件分成很多个部分缓存到本地，等缓存完毕再以.qlv形式的文件保存在硬盘中。流的重要性：流是java的一个类，但类并不是流流是单向的，要么input，要么output。流不会改变原数据，也不能存储数据Java的Stream有很多个子类，可以划分为若干类按流向分为两种：输入流（读取数据）输出流（写数据）Java流的传输只有一个方向，所以我们把从外部设备流向程序的数据流称为输入流。反之，把程序数据流向外部设备的流称为输出流。流按操作类型分为两种:字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的字符流 : 字符流只能操作纯字符数据，比较方便。四大基本StreamJava流有很多种，但是基本都是继承自四个基本流（这四个类是抽象类，不能直接实例化new）：InputStream：输入字节流OutputStream：输出字节流Reader：输入字符流Writer：输出字符流字节流字节流以字节（8bit）为单位，字节流能处理所有类型的数据（如图片、avi等）InputStream字节输入流InputStream 是所有的输入字节流的父类，它是一个抽象类。用来读取数据。ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）字节输入流操作步骤:创建字节输出流对象调用read()方法读取数据，并把数据显示在控制台释放资源计算机如何识别什么时候把两个字节转换为一个中文？第一个字节肯定是负数第二个字节常见的是负数，可能有正数当看到负数就把两个字节拼在一起FileInputStream文件输入流FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream 用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用 FileReader构造方法：12FileInputStream(File file)FileInputStream(String name)成员方法：1int read() 从此输入流中读取一个数据字节。案例:读取一个txt文件数据(方法一)1.FileInputStream用于读取文件数据，在构造方法中传入文件对象2.构造方法，有可能抛出文件找不到的异常3.read方法是每次读取一个字节的数据,把字节转成int返回读取数据也会抛出异常，比如突然文件某部份数据损坏了读取的数据是文件编码的表值(ascii,GBK,unicode)ascii是包含在GBK或者unicode中的如果读取数据到最后，会返回一个-1（代表读完数据了）4.文件不用后，要关闭输入流，避免占用资源123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;/** * 读取txt文件内容 * 1.通过FileInputStream来读取txt文件内容 * 2.读取内容通过read方法， * 》read方法每次读文件1个字节(byte),把byte转成int返回 》当读到后的时候，返回-1，-1表示读取文件结束 3.当读完文件后，这个输入流要关闭，释放资源 * */public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //FileNotFoundException fnfe; //案例：读取txt文件内容 //1.创建一个文件对象 File file = new File("a.txt"); //2.创建一个文件输入流【读取文件数据】对象 FileInputStream fis1 = new FileInputStream(file); //再创建一个文件输入 流对象 FileInputStream fis2 = new FileInputStream("b.txt"); //3.读取a.txt的数据 /** * 1.read方法每次读文件1个字节(byte),把byte转成int返回 * 2.当读到后的时候，返回-1，-1读取文件结束 */ System.out.println(fis1.read()); System.out.println(fis1.read()); System.out.println(fis1.read()); System.out.println(fis1.read()); //4.关闭流 fis1.close(); fis2.close(); &#125;&#125;案例:读取一个txt文件数据(方法二)123456789101112//1.创建一个文件对象File file = new File("abc.txt");System.out.println(file.getAbsolutePath()); //2.创建一个文件输入流FileInputStream inputStream = new FileInputStream(file); int b;//while循环里，每次读取字节赋值给bwhile((b = inputStream.read()) != -1)&#123;System.out.println(b);&#125;面试题:read()方法读取的是一个字节,为什么返回是int,而不是byte ？因为字节输入流可以操作任意类型的文件,比如图片音频等,这些文件底层都是以二进制形式的存储的,如果每次读取都返回byte,有可能在读到中间的时候遇到111111111 那么这11111111是byte类型的-1,我们的程序是遇到-1就会停止不读了,后面的数据就读不到了,所以在读取的时候用int类型接收,如果11111111会在其前面补上 24个0凑足4个字节,那么byte类型的-1就变成int类型的255了这样可以保证整个数据读完,而结束标记的-1就是int类型123456789101112131415161718192021222324252627public class Demo01 &#123; public static void main(String[] args) &#123; //面试题:read()方法读取的是一个字节,为什么返回是int,而不是byte ？ //如果使用FileInputStream读取图片数据 /** * 00010111 00010111 00010111 00010111 * 00010111 11111111 00010111 00010111 * * byte:11111111 表示的-1 * int:00000000 00000000 00000000 11111111 byte转成int 补0 了不是-1 因此往后读数据 * * 为什么11111111是表示-1？ * 因为计算机是以补码的方式计算 * 补码： 11111111 （-1） * 反码： 11111110 * 原码: 10000001 * * 假如使用FileInputStream读取图片的时候， * 图片中间有一段数据刚好是 11111111，这八个一表示的-1，用byte接收 * java程序如果读取的是-1，后面的数据就不读取 * 如果把8个1转成int,那就是00000000 00000000 00000000 11111111,这个表示255， * 就不是-1，归避后面数据没有读取问题 * */ &#125;&#125;DataInputSteam数据输入流操作基本数据类型ByteArrayInputStream内存输入流操作字节数组SequenceInputStream 序列流什么是序列流序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推.案例：使用字节流把两个件数据写到另一个文件案例：使用序列流把两个件数据写到另一个文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.SequenceInputStream;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //SequenceInputStream 序列流 /** * InputStream:输入流 * Sequence:序列 连续 * * 序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, * 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推. */ test2(); &#125; public static void test2() throws FileNotFoundException, IOException &#123; //需求：a.txt,b.txt 依次写c.txt //创建序列流 FileInputStream fis1 = new FileInputStream("a.txt"); FileInputStream fis2 = new FileInputStream("b.txt"); SequenceInputStream sis = new SequenceInputStream(fis1, fis2); //创建输出流 FileOutputStream fos = new FileOutputStream("c.txt"); //读写 int b = 0; while((b = sis.read()) != -1)&#123; fos.write(b); &#125; fis2.close(); sis.close(); fos.close(); &#125; public static void test1() throws FileNotFoundException, IOException &#123; //需求：a.txt,b.txt 依次写c.txt //1.创建两个输入流 FileInputStream fis1 = new FileInputStream("a.txt"); FileInputStream fis2 = new FileInputStream("b.txt"); //2.创建一个输出流 FileOutputStream fos = new FileOutputStream("c.txt"); //3.先把a文件的内容写到c.txt int b = 0; while((b=fis1.read()) != -1)&#123; fos.write(b); &#125; fos.write("\r\n".getBytes());//换行 //4.再把b文件内容写到c.txt while((b=fis2.read()) != -1)&#123; fos.write(b); &#125; //5.关流 fis1.close(); fis2.close(); fos.close(); &#125;&#125;序列流整合多个字节流（了解）1234567891011121314151617181920212223242526272829303132333435363738import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.InputStream;import java.io.SequenceInputStream;import java.util.Enumeration;import java.util.Vector;public class Demo01 &#123; public static void main(String[] args) throws Exception &#123; //SequenceInputStream序列流使用二 //需求，把a.txt b.txt c.txt 的内容拷贝到d.txt //1.Vector是集合 Vector&lt;InputStream&gt; vector = new Vector&lt;InputStream&gt;(); vector.add(new FileInputStream("a.txt")); vector.add(new FileInputStream("b.txt")); vector.add(new FileInputStream("c.txt")); //2.Enumeration枚举 Enumeration&lt;InputStream&gt; e = vector.elements(); //3.序列流 SequenceInputStream sis = new SequenceInputStream(e); //4.创建输出流 FileOutputStream fos = new FileOutputStream("d.txt"); //读写 int b = 0; while((b = sis.read()) != -1)&#123; fos.write(b); &#125; sis.close(); fos.close(); &#125;&#125;OutputStreamOutputStream 是所有的输出字节流的父类，它是一个抽象类。ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。PipedOutputStream 是向与其它线程共用的管道中写入数据，ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。字节输出流操作步骤:创建字节输出流对象写数据释放资源write(int b):写一个字节write(byte[] b):写一个字节数组write(byte[] b,int off,int len):写一个字节数组的一部分如何实现数据的换行？实现换行不同操作系统换行符号识别不一样Windows:\r\nLinux:\nMac:\rFileInputStream文件输出流是用于将数据写入 File 的输出流。FileOutputStream 用于写入诸如图像数据之类的原始字节的流。查看文档的构造方法和成员方法创建字节输出流做了几件事情：调用系统功能去创建文件创建fos对象把fos对象指向这个文件//关闭此文件输出流并释放与此流有关的系统资源//让流对象变成垃圾，这样就可以被垃圾回收器回收//通知系统去释放跟该文件相关的资源fos.close();如何实现数据的追加写入？FileOutPutStream构造方法的第二个参数:true写在末尾处可以实现追加案例:往一个abc.txt文件写数据（知识点）new FileOutputStream(file)这种构造方法，会把以前的内容都删除new FileOutputStream(file,true);这种构造方法能追加内容FileNotFoundException是IOException的子类write(int b)，写数据123456789101112131415161718192021222324252627282930313233343536373839import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub/* FileOutputStream:表示文件输出流，用于往文件写内容 * * 构造方法 * FileOutputStream(String name) * FileOutputStream(File file) * * 方法 * write(int b);//每次写一个字节 * write(byte[] b) ;//一次写多个字节 * */ //案例：往b.txt 写个内容 //1.创建文件输出流对象 //FileOutputStream fos = new FileOutputStream("b.txt"); OutputStream fos = new FileOutputStream("b.txt");//多态写法 //2.写数据 // fos.write(97);//a// fos.write(98);//b// fos.write(99);//c //一次性写多个字节 byte[] bytes = &#123;97,98,99,100,101&#125;; fos.write(bytes); //3.关闭流 fos.close(); &#125;&#125;案例:拷贝图片和音频原理，使用输入流读取数据，使用输出流写数据画图讲原理和性能每次都读一次字节，太慢，效率太低123456789101112131415161718192021222324252627282930313233import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //案例:拷贝图片 /** * 目的：结合输入流和输出流使用 * * 图片路径：C:\Users\10301\Desktop\a\cm.jpg */ //1.先创建输入流对象和输出流对象 FileInputStream fis = new FileInputStream("C:/Users/10301/Desktop/a/cm.jpg"); FileOutputStream fos = new FileOutputStream("C:/Users/10301/Desktop/a/cm2.jpg"); //2.通过输入流读取图片的数据 int b = 0; while( (b = fis.read()) != -1)&#123; //3.通过输出流写入图片数据 fos.write(b); &#125; //4.关闭流 fos.close(); fis.close(); System.out.println("图片拷贝成功"); &#125;&#125;字节数组拷贝之available()方法1234567891011121314151617181920212223242526272829303132333435363738import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //案例:拷贝图片【优化一、这种方式在大文件下不建议使用】 /** * 前面拷贝图片问题：每次只读一个字节，写入的时候也是一个字节一个字节写 * 如果有10W个字节，就要读10W次，写10W次 * * 字节数组拷贝之available()方法 */ //1.文件输入流 FileInputStream fis = new FileInputStream("C:/Users/10301/Desktop/a/cm.jpg"); int size = fis.available();//是返回文件的长度【字节为单位】 System.out.println("文件的大小:" + size); //2.现在一次读文件大小的字节 //2.1定义一个字节数组 byte[] bytes = new byte[size];//相当于现在是一个空杯子 //2.2 把数据读到字节数组中 int r = fis.read(bytes);//这个方法的返回值读取到的实际长度 System.out.println("r:" + r); //3.把字节数组一次性写入到文件 //3.1 输出流 FileOutputStream fos = new FileOutputStream("C:/Users/10301/Desktop/a/cm-副本.jpg"); //3.2 写数据 fos.write(bytes); //4.关闭流 fis.close(); fos.close(); &#125;&#125;案例:正确的拷贝文件的方法（杯子思想、缓冲思想）输入流读取数据的方法:read(byte[] b) 读取指定字节数的数据输出流写数据的方法:write(byte[] b)write(byte[] b, int off, int len)写出有效的字节个数123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/** * 杯子思想,缓冲思想 * @author gyf * */public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //案例:拷贝图片【优化二、这种方式开发中建议经常使用】 /** * 1.每次只读一个字节，又觉得太慢 * 2.一次性读一个文件的所有数据，又怕内存装不下 * 内存只有2G,视频3G,这样就会内存溢出 * * 3.最终解决方法：折中，定义每次读8KB * */ //1.输入流 FileInputStream fis = new FileInputStream("C:/Users/10301/Desktop/a/cm.jpg"); //2.输出流 FileOutputStream fos = new FileOutputStream("C:/Users/10301/Desktop/a/cm-副本2.jpg"); //3.定义个8kb字节数组，也叫缓冲区流 byte[] bytes = new byte[1024 * 8]; int len = 0; int i = 0; while( (len = fis.read(bytes)) != -1)&#123; i++; //4.写入文件 fos.write(bytes,0,len); &#125; System.out.println("读取的次数:" + i); //5.关闭流 fis.close(); fos.close(); &#125;&#125;DataOutputSteam数据输出流操作基本数据类型什么是数据输入输出流DataInputStream, DataOutputStream可以按照基本数据类型大小读写数据例如:按Long大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub //DataOutputStream&amp;DataInputStream 数据输入输出流/* DataInputStream, DataOutputStream可以按照基本数据类型大小读写数据 例如按Long大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节.*/ //读3个long数据 DataInputStream dis = new DataInputStream(new FileInputStream("a.txt")); System.out.println(dis.readLong());//读8个字节 System.out.println(dis.readLong());//读8个字节 System.out.println(dis.readLong());//读8个字节 &#125; public static void test1() throws FileNotFoundException, IOException &#123; long a = 997; long b = 998; long c = 999; //使用FileOutputStream没法写入long类型数据 FileOutputStream fos = new FileOutputStream("a.txt"); //byte -128~127 0~255/* fos.write(997);只会写一个字节，不会写4个字节 fos.write(998); fos.write(999);*/ //fos.wr DataOutputStream dos = new DataOutputStream(fos); dos.writeLong(a);//写4个字节 dos.writeLong(b); dos.writeLong(c); dos.close(); &#125;&#125;ByteArrayOutputStream内存输出流操作字节数组此类实现了一个输出流，其中的数据被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.IOException;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //ByteArrayOutputStream 字节数组输出流 /** * 1.前面学习的流-必需关于一个文件 * FileOutputStream fos = new FileOutputStream("a.txt") * * 2.ByteArrayOutputStream 不需要关联文件 * * 3.此类实现了一个输出流，其中的数据被写入一个 byte 数组。 * 缓冲区会随着数据的不断写入而自动增长。 * 可使用 toByteArray() 和 toString() 获取数据。 */ //1.创建字节数组输出流对象 ByteArrayOutputStream baos = new ByteArrayOutputStream(); //2.输入流 FileInputStream fis = new FileInputStream("a.txt"); //3.写入输出流 int b = 0; while((b = fis.read()) != -1)&#123; baos.write(b); &#125; //自动把字节数组 转成 字符串 System.out.println(baos.toString()); System.out.println(baos.toString("UTF-8"));//指定编码格式的字符串 //获取文件数据 byte[] bytes = baos.toByteArray(); System.out.println(new String(bytes)); System.out.println(new String(bytes, "UTF-8"));//指定编码格式的字符串 //4.关流 fis.close(); &#125;&#125;面试题：找bug定义一个文件输入流,调用read(byte[] b)方法,将a.txt文件中的内容打印出来(byte数组大小限制为5)123456789101112131415161718192021222324252627282930313233343536373839import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub/* 面试题：找bug 定义一个文件输入流,调用read(byte[] b)方法, 将a.txt文件中的内容打印出来(byte数组大小限制为5)*/ //1.文件输入流 FileInputStream fis = new FileInputStream("a.txt"); //2.字节数组输出流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); //3.字节数组【缓冲区思想，杯子思想】 byte[] arr = new byte[5]; int len; while((len = fis.read(arr)) != -1) &#123; //通过字节缓冲数组写入 baos.write(arr, 0, len); //把字节转成字符串 /** * 中文乱码问题 */ System.out.println(new String(arr,0,len)); &#125; //内部会调用toString方法,把字节数组转成字符串 System.out.println(baos); fis.close(); &#125;&#125;对象操作流ObjecOutputStream&amp; ObjecInputStream （了解）什么是对象操作流该流可以将一个对象写出, 或者读取一个对象到程序中. 也就是执行了序列化和反序列化的操作.归档（序列化） ：将对象存在一个文件解归档=反序列化：把一个文件解析出对象ObjecOutputStream对象输出流，把一个对象存储起来，存储的对象必须实现Serializable接口ObjecInputStream对象输入流，把存的数据还原成一个对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.io.EOFException;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class Demo01 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; // TODO Auto-generated method stub //对象操作流ObjectOutputStream&amp; ObjectInputStream /** * 一、ObjectOutputStream：将一个对象写入文件 * 1.如果使用这个类写入对象，这个对象需要序列化 * 2.序列化就是让这个对象实现一个Serializable接口 * 3.如果没实现Serializable接口，会抛异常NotSerializableException * 二、ObjectInputStream：从文件中读一个对象 */ //案例：从文件中取出女朋友对象 //1.创建一个对象输入流 FileInputStream fis = new FileInputStream("gf.data"); ObjectInputStream ois = new ObjectInputStream(fis); //2.读数据 GirlFriend gf1 = (GirlFriend) ois.readObject(); System.out.println(gf1); GirlFriend gf2 = (GirlFriend) ois.readObject(); System.out.println(gf2); /** * 如果没有数据可读了，强制读的时候报错了EOFException， */ System.out.println(ois.readObject()); &#125; public static void test1() throws FileNotFoundException, IOException &#123; //案例：将对象直接存入文件 //1.创建女朋友对象 GirlFriend gf1 = new GirlFriend("林志玲", 1.78); GirlFriend gf2 = new GirlFriend("林心如", 1.68); //2.创建对象输出流 FileOutputStream fos = new FileOutputStream("gf.data"); ObjectOutputStream oos = new ObjectOutputStream(fos); //3.往文件存入对象 oos.writeObject(gf1); oos.writeObject(gf2); //4.关流 oos.close(); &#125;&#125;class GirlFriend implements Serializable&#123; String name; double height; public GirlFriend(String name, double height) &#123; super(); this.name = name; this.height = height; &#125; @Override public String toString() &#123; return "GirlFriend [name=" + name + ", height=" + height + "]"; &#125;&#125;对象操作流优化为了方便读取多个对象建立把将对象存储在集合中，然后将集合对象存入取出123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.io.Serializable;import java.util.ArrayList;import java.util.List;public class Demo01 &#123; public static void main(String[] args) throws IOException, IOException &#123; //对象操作流优化-思路，存多个对象时，把对象存在list里面 //把女朋友对象存在List中，再把List写入文件【序列化/归档】 //1.创建集合 List&lt;GirlFriend&gt; list = new ArrayList&lt;GirlFriend&gt;(); //2.添加女朋友 list.add(new GirlFriend("林志玲", 1.78)); list.add(new GirlFriend("林心如", 1.68)); list.add(new GirlFriend("林嘉欣", 1.58)); //3.把list存入文件 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("list.data")); oos.writeObject(list); //4.关流 oos.close(); &#125;&#125;class GirlFriend implements Serializable&#123; String name; double height; public GirlFriend(String name, double height) &#123; super(); this.name = name; this.height = height; &#125; @Override public String toString() &#123; return "GirlFriend [name=" + name + ", height=" + height + "]"; &#125;&#125;12345678910111213141516171819202122232425262728293031323334import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectInputStream;import java.util.List;public class Demo02 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; // TODO Auto-generated method stub //案例：从list.data 读取所有的女朋友对象【反序列化、解归档】 //1.创建对象输入流 ObjectInputStream ois = new ObjectInputStream(new FileInputStream("list.data")); //2.读取List对象 Object obj = ois.readObject(); //把obj转list @SuppressWarnings("unchecked") List&lt;GirlFriend&gt; list = (List&lt;GirlFriend&gt;)obj; System.out.println(obj.getClass()); //遍历 for(GirlFriend gf : list)&#123; System.out.println(gf); &#125; ois.close(); &#125;&#125;序列化序列化流：ObjectOutputStream反序列化流：ObjectInputStream序列化数据后，再次修改类文件，读取数据会出现问题，如何解决？使用transient关键字声明不需要序列化的成员变量NotSerializableException：未序列化异常类通过实现java.io.Serializable接口以启用其序列化功能，未实现此接口的类将无法使其任何状态序列化或反序列化，该接口没有任何方法，类似这种没有方法的接口被称为标记接口Serializable接口的ID要归档或者序列化的对象必须实现Serializable接口才能被序列化Serializable 中有个id，但ID不是一定有加的SerialVersionUid，简言之，其目的是序列化对象版本控制，有关各版本反序列化时是否兼容。如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常。如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class Demo01 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException&#123; // TODO Auto-generated method stub /* Serializable接口的ID 1.要归档或者序列化的对象必须实现Serializable接口才能被序列化 2.Serializable 中有个id，但ID不是一定要加的 3.SerialVersionUid，简言之，其目的是以序列化对象进行版本控制，有关各版本 反序列化时是否兼容。 4.如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常。 5.如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本 的数据都能保留，那就不用修改； 6.如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据， 这时就应该手动更新版本号，即SerialVersionUid。 7.一般不会添加ID,就算添加了ID,版本号最好不要修改*/ //save(); //取学生 ObjectInputStream ois = new ObjectInputStream(new FileInputStream("stu.data")); Student stu = (Student) ois.readObject(); System.out.println(stu); &#125; public static void save() throws IOException, FileNotFoundException &#123; //1.创建学生对象 Student stu = new Student("霍建华"); //2.把学生存入文件 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("stu.data")); /** * 存的学生的版本号是1 */ oos.writeObject(stu); //3.关流 oos.close(); &#125;&#125;class Student implements Serializable&#123; /** * 序列化版本ID */ private static final long serialVersionUID = 1L; private String name; private String hometown; public Student(String name) &#123; super(); this.name = name; &#125; @Override public String toString() &#123; return "Student [name=" + name + "]"; &#125; &#125;IO-编码表12String (byte[] bytes,String charsetName);//通过指定的字符集编码字节数组byte[] getBytes(String charsetName);//使用指定的字符集合把字符串编码为字节数组BufferedInputStream和BufferOutputStream这两个流是内置了缓冲区流,也就是说内部有一个 字节数组缓冲思想字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，java本身在设计的时候,加入了数组这样的缓冲区效果，也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流BufferedInputStreamBufferedInputStream内置了一个缓冲区(数组)从BufferedInputStream中读取一个字节时BufferedInputStream会一次性从文件中读取8192个(8Kb), 存在缓冲区中, 返回给程序程序再次读取时, 就不用找文件了, 直接从缓冲区中获取直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个BufferedOutputStreamBufferedOutputStream也内置了一个缓冲区(数组)程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里案例:使用缓冲输入输出流拷贝文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub //1.创建文件输入流 FileInputStream fis = new FileInputStream("C:/Users/10301/Desktop/a/ghsy.mp3"); //2.创建文件输出流 FileOutputStream fos = new FileOutputStream("C:/Users/10301/Desktop/a/ghsy-副本.mp3"); //3.输入流读数据、输出流写数据 int b = 0; while( (b = fis.read()) != -1)&#123; fos.write(b); &#125; //4.关流 fis.close(); fos.close(); System.out.println("音频拷贝完成..."); &#125; private static void test1() throws FileNotFoundException, IOException &#123; /* BufferedInputStream和BufferedOutputStream &gt;这两个流是内置了缓冲区流,也就是说内部有一个字节数组 &gt;这个两个类没有前面我们写的好用，因为它内部每次读8kb字节，如果想读80kb,没办法 */ //案例：拷贝音频文件 //1.创建缓冲输入流 FileInputStream fis = new FileInputStream("C:/Users/10301/Desktop/a/ghsy.mp3"); BufferedInputStream bis = new BufferedInputStream(fis); //2.创建缓冲输出流 FileOutputStream fos = new FileOutputStream("C:/Users/10301/Desktop/a/ghsy-副本.mp3"); BufferedOutputStream bos =new BufferedOutputStream(fos); //3.输入流读数据、输出流写数据 int b = 0; // bis.read()方法，内部会读8kb数据 while( (b = bis.read()) != -1)&#123; bos.write(b);//内部会写8kb数据 &#125; //4.关流,只需要关缓冲流，文件流不用关 bis.close();//【内部会关文件流输入流】 bos.close();//【内部会关文件流输出流】 System.out.println("音频拷贝完成..."); &#125;&#125;带Buffered的流和自己写的数组缓冲对比自己写的数组的读写和带Buffered的读取哪个更快?自己写数组会略胜一筹,因为读和写操作的是同一个数组而Buffered操作的是两个数组BufferOutputStream的flush和close方法的区别flush()方法用来刷新缓冲区的,刷新后可以再次写出close()方法用来关闭流释放资源的的,如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出1234567891011121314151617181920212223242526272829303132333435import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //BufferedOutputStream的flush和close方法的区别 /* flush()方法 1.用来刷新缓冲区的,刷新后可以再次写出 close()方法 2.用来关闭流释放资源的 3.如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出 */ //案例：把a文件的内容拷贝到b文件 //1.输入流 FileInputStream fis = new FileInputStream("a.txt"); BufferedInputStream bis = new BufferedInputStream(fis); //2.输出流 FileOutputStream fos = new FileOutputStream("b.txt"); BufferedOutputStream bos = new BufferedOutputStream(fos); //3.读写操作 int b = 0; while( (b = bis.read()) != -1)&#123; bos.write(b); &#125; bos.flush(); bos.write(97); //bos.flush(); //4.关闭流 bis.close(); bos.close(); &#125; &#125;字节流读写中文乱码问题字节流读取中文:字节流读取中文的问题字节流在读中文的时候有可能会读到半个中文,造成乱码12345678910111213141516171819202122232425import java.io.FileInputStream;import java.io.IOException;public class Demo06 &#123; public static void main(String[] args) throws IOException &#123; //字节流读写中文乱码问题 //1.读数据 //创建文件输入流 FileInputStream fis = new FileInputStream("a.txt"); //读 //定义字节数组[杯子思想，缓冲区思想] /** * 在UTF-8编码表中，一个中文占3个字节,一个英文占1个字节 * 在GBK编译中，一个中文占2个字节 */ byte buf[] = new byte[3]; int len = 0; while( (len = fis.read(buf)) != -1)&#123; System.out.println("len:" + len ); //把字节转成字符串 String s = new String(buf, 0, len); System.out.println("s:" + s); &#125; &#125;&#125;字节流写入中文的问题字节流直接操作的字节,所以写出中文必须将字符串转换成字节数组写出回车换行 write(“\r\n”.getBytes());123456789101112131415161718192021import java.io.FileOutputStream;import java.io.IOException;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //案例：往a.txt文件写中文 //1.输出流 FileOutputStream fos = new FileOutputStream("a.txt"); //2.写中文 String s = "你好，Gosling最近好吗？"; //把字符转成字节数组 //byte[] bytes = s.getBytes(); /** * charsetName 字符编码 UTF-8(Unicode),GBK,ASCII */ byte[] bytes = s.getBytes("UTF-8"); fos.write(bytes); //3.关流 fos.close(); &#125;&#125;流的标准处理代码流的标准处理异常代码1.6版本及其以前12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class Demo01 &#123; public static void main(String[] args) throws IOException&#123; //流的标准处理异常代码-jdk1.6版本及其以前 //案例：a.txt的内容拷贝到b.txt FileInputStream fis = new FileInputStream("a.txt"); FileOutputStream fos = new FileOutputStream("b.txt"); try &#123; //读写数据会抛出 int b = 0; while((b = fis.read()) != -1)&#123; fos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //关流 try &#123; fis.close(); &#125;finally &#123; fos.close(); &#125; &#125; &#125; public static void test1() throws FileNotFoundException &#123; FileInputStream fis = new FileInputStream("a.txt"); FileOutputStream fos = new FileOutputStream("b.txt"); try &#123; //读写数据会抛出 int b = 0; while((b = fis.read()) != -1)&#123; fos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //关流 try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;流的标准处理异常代码1.7以上版本原理：在try()中创建的流对象必须实现了AutoCloseable这个接口,如果实现了,在try后面的{}(读写代码)执行后就会自动调用,流对象的close方法将流关掉12345678910111213141516171819202122232425262728293031323334353637import java.io.FileInputStream;import java.io.FileOutputStream;public class Demo01 &#123; public static void main(String[] args)throws Exception &#123; //流的标准处理异常代码1.7版本 /** * 1.把流对象的声明放在try() 括号里面 * 2.操作流【读写数据】的代码放在花括号里面 * 3.这样写不用关闭流，java自动关闭流 * 4.在try的括号里的对象，必须是实现AutoCloseable的接口 */ try( FileInputStream fis = new FileInputStream("a.txt"); FileOutputStream fos = new FileOutputStream("b.txt"); //Person p = new Person(); //声明一个自己输入流 MyInputStream myis = new MyInputStream(); )&#123; int b = 0; while((b = fis.read()) != -1)&#123; fos.write(b); &#125; &#125; &#125;&#125;class Person&#123;&#125;class MyInputStream implements AutoCloseable&#123; @Override public void close() throws Exception &#123; System.out.println("我的输入流关闭了..."); &#125;&#125;练习练习:图片加密1234567891011121314151617181920212223242526272829303132import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class Demo01 &#123; public static void main(String[] args)throws IOException &#123; // TODO Auto-generated method stub //练习:图片加密 //1.输入输出流 FileInputStream fis = new FileInputStream("C:/Users/10301/Desktop/a/cm2.jpg"); FileOutputStream fos = new FileOutputStream("C:/Users/10301/Desktop/a/cm.jpg"); //2.读写数据 /** * 加密操作 * 解密操作 * * 一个数异或2次，数据不变 */ int b = 0; while((b = fis.read()) != -1)&#123; fos.write(b ^ 5); &#125; //3.关流 fis.close(); fos.close(); System.out.println("图片加密完成"); &#125;&#125;练习:根据用户输入的文件拷贝文件到当前项目目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.Scanner;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //练习:根据用户输入的文件[图片]拷贝文件到当前项目目录 //C:/Users/10301/Desktop/a/cm2.jpg //1.获取用户输入的文件路径 Scanner scanner = new Scanner(System.in); System.out.println("请输入一个文件的路径[请不要输入文件夹路径]:"); String path = scanner.nextLine(); //2.判断这个路径是否为文件 File file = new File(path); if(file.isDirectory())&#123; System.out.println("您输入的路径不是一个文件"); return; &#125; //3.如果是文件就拷贝 //3.1 输入流 FileInputStream fis = new FileInputStream(path); //3.2输出流 FileOutputStream fos = new FileOutputStream(file.getName()); //3.3读写【性能】 byte[] buf = new byte[8 * 1024]; int len = 0; while((len = fis.read(buf)) != -1)&#123; fos.write(buf, 0, len); &#125; //3.4关流 fis.close(); fos.close(); System.out.println("文件拷贝完成..."); &#125;&#125;练习:录入数据拷贝到文件123456789101112131415161718192021222324252627282930313233343536import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.Scanner;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //练习:录入数据拷贝到文件 //1.创建一个文件输出流 FileOutputStream fos = new FileOutputStream("new.txt"); //2.创建一个Scanner对象 Scanner scanner = new Scanner(System.in); System.out.println("请输入需要录入内容...输入quit代表退出"); //3.通过死循环来获取用户输入【当输入quit，代表不录入】 while(true)&#123; //获取用户的输入 String line = scanner.nextLine(); //退出循环 if(line.equals("quit"))&#123; break; &#125; //写入文件 fos.write(line.getBytes()); //换行 fos.write("\r\n".getBytes()); &#125; //4.关流 fos.close(); &#125;&#125;字符流字符流以字符为单位，根据码表映射字符，一次可能读多个字节，字符流只能处理字符类型的数据字符流是可以直接读写字符的IO流字符流读取字符, 就要先读取到字节数据, 然后转为字符.写入字符, 需要把字符转为字节再写出字符流=字节流+编码表InputStreamReaderInputStreamReader(InputStream is);//用默认的编码读取数据InputStreamReader(InputStream is,String charsetName);//用指定的编码读取数据123//InputStreamReader的方法int read();//一次读取一个字符int read(char[] chs);//一次读取一个字符数组OutputStreamWriterOutputStreamWriter(OutputStream out);//根据默认编码把字节流的数据转换为字符流OutputStreamWriter(OutputStream out,String charsetName);//根据指定编码把字节流数据转换为字符流123456//OutputStreamWriter的方法public void write(int c);//写一个字符public void write(char[] cbuf);//写一个字符数组public void write(char[] cbuf,int off,int len);//写一个字符数组的一部分public void write(String str);//写一个字符串public void write(String str,int off,int len);//写一个字符串的一部分由于我们常见的操作都是使用本地默认编码，所以不用指定编码而转换流的名称有点长，所以Java就提供了其子类供我们使用12345OutputStreamWriter = FileOutputStream + 编码表(GBK);FileWriter = FileOutputStream + 编码表(GBK);InputStreamReader = FileInputStream + 编码表(GBK);FileReader = FileInputStream + 编码表(GBK)close()和flush()的区别？close()：关闭流对象，但是先刷新一次缓冲区，关闭之后，流对象不可与再继续使用flush()：仅仅刷新缓冲区，刷新之后，流对象还可以继续使用ReaderReader 是所有的输入字符流的父类，它是一个抽象类。CharReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。WriterWriter 是所有的输出字符流的父类，它是一个抽象类。CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据，BufferedWriter 是一个装饰器为Writer 提供缓冲功能。PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。OutputStreamWriter 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。​FileReader读取字符流查看API的方法案例:使用FileReader 读取一个文本数据（知识点):1、read方法是读取字符char2、一个字符可能占用1个字节，2个字节，或者3个字节3、占用字节个的数根据码表决定(ASCII:1字节，GBK:2字节 unicode:3个字节)4、用int表示字节，假如读取到2个字节，int有4个字节，前个两个字节可以补05、GBK,unicode中，中文的字符的第一个字节都是负数，所以知道怎么去读取6、读取的方式与FileInputStream字节流差不多，会用FileInputStream，就会用 FileReader123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;/** * 以后读纯文本文件，使用FileReader这个类，为什么？因为我们不用考虑乱码问题 */public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //读字节 FileInputStream fis = new FileInputStream("a.txt"); //int 00000000 00000000 00000000 11111111 System.out.println((byte)fis.read()); System.out.println((byte)fis.read()); System.out.println((byte)fis.read()); System.out.println((byte)fis.read()); System.out.println((byte)fis.read()); System.out.println((byte)fis.read()); System.out.println((byte)fis.read()); &#125; public static void test1() throws FileNotFoundException, IOException &#123; //FileReader /** * FileReader 用于读取字符 */ //1.创建对象 FileReader reader = new FileReader("a.txt"); //2.读取数据 /** * reader.read() : 先读取到字节数据, 然后转为字符 */ System.out.println((char)reader.read()); System.out.println((char)reader.read()); System.out.println((char)reader.read()); System.out.println((char)reader.read()); System.out.println((char)reader.read()); System.out.println(reader.read()); int c; while((c = reader.read()) != -1)&#123; System.out.println((char)c); &#125; //3.关闭流 reader.close(); &#125;&#125;FileWiter 写入字符流查看API中FileWriter的方法案例:使用FileWrite写入数据（知识点）1.其实内部是通过一个字符数组缓冲区写入文件2.内部方法，创建一个字符串长度的字符数组缓存区123456789101112131415161718192021222324252627282930313233import java.io.FileWriter;import java.io.IOException;/** * FileWiter: * 掌握： * 1.write方法使用 * 2.write方法内部实现，内部是通过一个字符数组缓冲区写入文件 * */public class Demo01 &#123; public static void main(String[] args) throws Exception &#123; //FileWiter 文件写入流、文件写入字符流 //案例：使用FileWiter往一个文件a.txt写内容 //1.创建writer对象 FileWriter writer = new FileWriter("a.txt"); //2.写内容 writer.write("你好!"); writer.write("\r\n"); writer.write("你好!"); writer.write("\r\n"); writer.write("你好!"); writer.write("\r\n"); writer.write("你好!"); //3.关闭 writer.close(); &#125;&#125;案例:字符流的拷贝//案例:字符流的拷贝//思路：用FileReader读字符,用FileWriter写字符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //案例:字符流的拷贝 //思路：用FileReader读字符,用FileWriter写字符 //1.创建 “读取流” 对象 FileReader reader = new FileReader("a.txt"); //2.创建 "写入流" 对象 FileWriter writer = new FileWriter("b.txt"); //3.读取和写入【缓冲思想】 char[] buf = new char[8 * 1024]; int len = 0; while( (len = reader.read(buf)) != -1)&#123; writer.write(buf, 0, len); &#125; //4.关闭流 reader.close(); writer.close(); &#125; public static void test1() throws FileNotFoundException, IOException &#123; //1.创建 “读取流” 对象 FileReader reader = new FileReader("a.txt"); //2.创建 "写入流" 对象 FileWriter writer = new FileWriter("b.txt"); //3.读取和写入 int c = 0; while((c = reader.read()) != -1)&#123; writer.write(c); &#125; //4.关闭流 reader.close(); writer.close(); &#125;&#125;使用字符流的场景12345678910111213141516171819import java.io.FileWriter;public class Demo01 &#123; public static void main(String[] args) &#123; //使用字符流的场景 /** * 1.使用FileReader读取字符 * 原理：先读字节，把字节转成字符（byte -&gt; char） * 2.使用FileWriter写入字符 * 原理：writer(String str),str 转成 字符数组 再转成 字节写入文件 * (string -&gt; char[] -&gt; char -&gt; byte) * 如果是读取文本文件，使用FileReader比较好,不考虑乱码问题 * 如果是写入文本文件，不建议使用FileWriter,直接使用FileOutputStream好一点 */ &#125;&#125;带缓冲的字符流 BufferedReader/BufferedWriterBufferedReaderread()方法读取字符时会一次读取若干字符到缓冲区,然后逐个返回给程序, 降低读取文件的次数, 提高效率BufferedWriterwrite()方法写出字符时会先写到缓冲区缓冲区写满时才会写到文件, 降低写文件的次数, 提高效率查看源码:字符缓冲区的大小是819212345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub /** * 带缓冲的字符流 BufferedReader/BufferedWriter * 1.这两个类，内部都一个缓冲区，字符数组 * 2.br.read()方法，内部会读8192（8*1024）个字符 * 3.bw.write(),内部会写8192（8*1024）个字符 * * 回顾：带缓冲的字节流,BufferedInputStream/BufferedOutputStream * 1.这两个类，内部都一个缓冲区，字节数组 */ //需求：拷贝文件,a.txt -&gt; b.txt //1.创建Reader FileReader fr = new FileReader("a.txt"); BufferedReader br = new BufferedReader(fr); //2.创建Writer FileWriter fw =new FileWriter("b.txt"); BufferedWriter bw = new BufferedWriter(fw); //3.读写 int c = 0; while( (c = br.read()) != -1)&#123; bw.write(c); &#125; //4.关流 br.close();//内部关闭FileReader bw.close();//内部关闭FileWriter &#125;&#125;BufferedReader的readLine()&amp;BufferedWriter的newLine()方法12345678910111213141516171819202122232425262728293031323334import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //BufferedReader的readLine()&amp;BufferedWriter的newLine()方法 /** * 1.readLine()，每次读取一行数据 */ //1.创建Reader FileReader fr = new FileReader("a.txt"); BufferedReader br = new BufferedReader(fr); //2.读一行数据/* System.out.println(br.readLine()); System.out.println(br.readLine()); System.out.println(br.readLine()); System.out.println(br.readLine()); System.out.println(br.readLine()); System.out.println(br.readLine());*/ String line = null; while((line = br.readLine()) != null)&#123; System.out.println(line); &#125; //3.关流 br.close(); &#125;&#125;BufferedWriter的newLine()方法1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //BufferedWriter的newLine()方法 // newLine()换行 //往b.txt写a.txt文件的内容【一行一行拷贝,读一行写一行】 //1.创建Reader FileReader fr = new FileReader("a.txt"); BufferedReader br = new BufferedReader(fr); //2.创建writer FileWriter fw = new FileWriter("b.txt"); BufferedWriter bw = new BufferedWriter(fw); //3.读一行写一行 String line = null; while((line = br.readLine()) != null)&#123; bw.write(line); /** * 当使用readline读取一行数据时，不会读回车换行"\r\n"字符 */ //bw.write("\r\n"); bw.newLine();//换行 &#125; //4.关流 br.close(); bw.close(); &#125;&#125;案例:使用带缓冲的字符流拷贝文件BufferedReader的readLine()&amp;BufferedWriter的newLine()方法BufferedReader的readLine()方法可以读取一行字符(不包含换行符号)BufferedWriter的newLine()可以输出一个跨平台的换行符号”\r\n”案例:将文本反转一个文本文档上的文本反转,第一行和倒数第一行交换,第二行和倒数第二行交换1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * 掌握思想： * 1.for循环的倒序遍历 */public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //案例:将文本反转写入另一个文件 //1.把文本每一行内容读取出来存在List&lt;String&gt; 集合 //1.1 集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //1.2一行行读取文件 BufferedReader br = new BufferedReader(new FileReader("a.txt")); String line = null; while((line = br.readLine()) != null)&#123; list.add(line); &#125; System.out.println(list); //2.当我们要写入文件时，倒序保存List集合中的内容到文件中 BufferedWriter bw = new BufferedWriter(new FileWriter("b.txt")); for(int i = list.size() - 1 ; i&gt;=0; i--)&#123; bw.write(list.get(i)); bw.newLine();//换行 &#125; //3.关闭流 br.close(); bw.close(); System.out.println("finish...."); &#125;&#125;装饰(Decorator)设计模式装饰模式的概念:动态的给一个对象添加一些额外的功能，就增加功能来说，装饰模式比生成子类更为灵活。在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。它是创建一个包装对象，也就是使用装饰来包裹真实的对象。适用性需要扩展一个类的功能，或给一个类添加附加职责。当不能采用生成子类来实现，比如final类装饰模式的实现方式装饰对象和真实对象有相同的接口。装饰对象包含一个真实对象的引用（reference）装饰对象的所有方法，内部实现都是通过真实对象的引用来调用，然后实现自己的功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//案例1public class Demo01 &#123; public static void main(String[] args) &#123; // /** * 一、设计模式【一种固定代码风格】 * 面试题：Java中有哪些设计模式 * 常用设计模式：装饰模式、单例模式、模版模式、适配器模式、代理模式、工厂模式... * * 二、装饰(Decorator)设计模式 * 1.装饰模式的概念: 装饰模式是动态的给一个对象添加一些额外的功能，就增加功能来说，装饰模式比生成子类更为灵活。 装饰模式是在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。 装饰模式是创建一个包装对象，也就是使用装饰来包裹真实的对象。 2.装饰模式的实现方式 1. 装饰对象和真实对象有相同的接口/抽象类。 2. 装饰对象包含一个真实对象的引用（reference） 3. 装饰对象的所有方法，内部实现都是通过真实对象的引用来调用，然后实现自己的功能 3.适用性 1. 需要扩展一个类的功能，或给一个类添加附加职责。 2. 当不能采用生成子类来实现，比如final类 */ /* BufferedInputStream bis = new BufferedInputStream(new FileInputStream("a.txt")); BufferedOutputStream bos; BufferedReader br; BufferedWriter bw;*/ /*GYFStudent stu = new GYFStudent(); stu.code();*/ GYFStudent stu = new GYFStudent(new UniversityStudent()); stu.code(); &#125;&#125;//1.接口interface Person&#123; public void code();&#125;//2.接口实现类final class UniversityStudent implements Person&#123; @Override public void code() &#123; // TODO Auto-generated method stub System.out.println("在大学期间学了一点点C语言..."); &#125;&#125;/*class GYFStudent extends UniversityStudent&#123; @Override public void code() &#123; // TODO Auto-generated method stub super.code(); System.out.println("在GYF IT EDU 学习Java语言..."); &#125;&#125;*/class GYFStudent implements Person&#123; private UniversityStudent us; public GYFStudent(UniversityStudent us)&#123; this.us = us; &#125; //装饰对象的所有方法，内部实现都是通过真实对象的引用来调用，然后实现自己的功能 @Override public void code() &#123; us.code(); System.out.println("在GYF IT EDU 学习Java语言..."); &#125; &#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//案例2public class Demo &#123; public static void main(String[] args) &#123; GYFStudent stu = new GYFStudent(); stu.coding(); &#125;&#125;interface Person &#123; //人可以具备编码的功能 public void coding();&#125;//大学生class UniversityStudent implements Person&#123; @Override public void coding() &#123; System.out.println("我会一点c基础编程..."); &#125; public void piano()&#123; System.out.println("我会钢琴..."); &#125;&#125;//第一种继承类的写法class GYFStudent extends UniversityStudent&#123; @Override public void coding() &#123; // TODO Auto-generated method stub super.coding(); System.out.println("我会java基础编程了..."); &#125;&#125;//class GYFStudent implements Person&#123;// // private UniversityStudent uStu;// // public GYFStudent(UniversityStudent uStu) &#123;// super();// this.uStu = uStu;// &#125;////// @Override// public void coding() &#123;// // TODO Auto-generated method stub// uStu.coding();// System.out.println("我会java基础编程了...");// &#125;//&#125;InputStreamReader&amp;OutputStreamWriter这两个类用于使用指定的码表读写字符FileReader是使用默认码表读取文件, 如果需要使用指定码表读取请使用InputStreamReader(字符流,编码表)FileWriter是使用默认码表写出文件, 如果需要使用指定码表写入请使用OutputStreamWriter(字符流,编码表)12345678910111213141516171819202122232425262728293031import java.io.BufferedReader;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123;/* InputStreamReader&amp;OutputStreamWriter 1&gt;这两个类用于使用指定的码表读写字符*/ //案例1：使用指定 “码表UTF-8&amp;GBK” 读取字符 /** * charsetName：字符编码的名称 */ FileInputStream fis = new FileInputStream("a.txt"); InputStreamReader isr = new InputStreamReader(fis, "UTF-8"); //读一个字符 /* System.out.println((char)isr.read()); System.out.println((char)isr.read());*/ //读一行 BufferedReader br = new BufferedReader(isr); System.out.println(br.readLine()); br.close(); &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637//案例2import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;/** * 掌握： * 1.当读取文件内容，还有写入文件，可以指定编码格式 * 2.使用InputStreamReader&amp;OutputStreamWriter这个类 * @author gyf * */public class Demo02 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub /* OutputStreamWriter 1&gt;使用指定的编码 写入文件 */ //1.创建Writer FileOutputStream fos = new FileOutputStream("c.txt"); OutputStreamWriter osw = new OutputStreamWriter(fos, "GBK"); BufferedWriter bw = new BufferedWriter(osw); //2.写 bw.write("你好，IO流...搞的我有点晕..."); bw.newLine(); bw.write("你好，IO流...搞的我有点晕..."); bw.newLine(); //3.关流 bw.close(); &#125;&#125;练习:获取文本上字符出现的次数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.Map.Entry;/** * 掌握:当键盘敲 enter键，两个字符\r\n : 回车换行 * */public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //练习:获取文本上字符出现的次数,把数据写入文件/* 思路： 1.遍历文本每一个字符 2.字符出现的次数存在Map中 *//** * Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); * map.put('a',18); * map.put('你',2); *//* 3.把map中的数据写入文件*/ //================================== //1.创建Map集合 Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); //System.out.println(map.get('a')); //2.遍历每一个字符,每一个字符出现的次数放到map中 FileReader reader = new FileReader("a.txt"); int c = 0; while((c = reader.read()) != -1)&#123; //int 还原 char char ch = (char)c; // 判断char是否在map中第一次出现 if(map.get(ch) == null)&#123; map.put(ch, 1); &#125;else&#123; map.put(ch, map.get(ch) + 1); &#125; &#125; //3.把map中数据存在文件count.txt //3.1 创建Writer BufferedWriter bw = new BufferedWriter(new FileWriter("count.txt")); //3.2 遍历map,再写入数据 for(Entry&lt;Character, Integer&gt; entry :map.entrySet())&#123; switch (entry.getKey()) &#123; case ' ': bw.write("空格=" + entry.getValue()); break; case '\t'://\t表示tab 键字符 bw.write("tab键=" + entry.getValue()); break; case '\r':// bw.write("回车=" + entry.getValue()); break; case '\n':// bw.write("换行=" + entry.getValue()); break; default: bw.write(entry.getKey() + "=" + entry.getValue()); break; &#125; bw.newLine(); &#125; //4.关流 reader.close(); bw.close(); &#125;&#125;打印流的概述和特点 (掌握)什么是打印流该流可以很方便的将对象的toString()结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式System.out就是一个PrintStream, 其默认向控制台输出信息PrintStream和PrintWriter分别是打印的字节流和字符流打印流的特点只有写数据的，没有读数据，只能操作目的地，不能操作数据源可以操作任意类型的数据如果启动了自动刷新，能够自动刷新该流是可以直接操作文本文件的启动自动刷新1PrintWriter pw = new PrintWriter(new FileWriter("pw2.txt"), true);123456789101112131415161718192021222324252627282930313233343536import java.io.FileNotFoundException;import java.io.IOException;import java.io.PrintStream;import java.io.PrintWriter;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub //打印流的概述和特点 (掌握) /* 什么是打印流 1.该流可以很方便的将对象的toString()结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式 2.System.out就是一个PrintStream, 其默认向控制台输出信息 3.PrintStream和PrintWriter分别是打印的字节流和字符流*/ //1.打印的字节流【打印到控制台】 PrintStream ps = System.out; ps.println("你好，元宵节快乐");//打印字符串 ps.println(19.6); //2.打印的字符流 /** * 1.PrintWriter调用打印方法，控制台是没有内容，它是把内容写到文件中 * 2.如果打印了内容，没有调用flush或者close，内容在文件中也不存在 */ PrintWriter pw = new PrintWriter("test.txt"); pw.println("吃汤圆了..."); pw.print("超市一包汤圆10几块钱"); pw.print(13.01); //pw.flush(); pw.close(); &#125;&#125;标准输入输出流概述和输出语句(了解)System.in是InputStream, 标准输入流, 默认可以从键盘输入读取字节数据System.out是PrintStream, 标准输出流, 默认可以向Console中输出字符和字节数据1234567891011121314public class Demo01 &#123; public static void main(String[] args) &#123; //标准输入输出流概述和输出语句(了解)/* System.in是InputStream, 标准输入流, 默认可以从键盘输入读取字节数据 System.out是PrintStream, 标准输出流, 默认可以向Console中输出字符和字节数据*/ InputStream is = System.in;//标准输入流 PrintStream ps = System.out;//标准输出流 &#125;&#125;随机访问流概述和读写数据随机访问流概述RandomAccessFile概述RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。支持对随机访问文件的读取和写入。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.FileNotFoundException;import java.io.IOException;import java.io.RandomAccessFile;/** * RandomAccessFile这个类用于文件断点下载 * @author gyf * */public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; //随机访问流概述和读写数据/* 随机访问流概述 RandomAccessFile概述 RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。 支持对随机访问文件的读取和写入。*/ /** * 构造方法两个参数： * name:文件名称、路径 * mode:模式 ，r=read 只读、 w=write */ //1.创建一个随机访问流对象，以读写的方式打开文件 RandomAccessFile raf = new RandomAccessFile("a.txt", "rw"); //2.读字符 /** * 使用RandomAccessFile的readChar/readLine方法读文件有乱码问题 *//* System.out.println(raf.readChar()); System.out.println(raf.readChar()); System.out.println(raf.readChar()); System.out.println(raf.readLine());*/ //使用字节数组来读比较好/* byte[] buf = new byte[1024]; int len; while((len = raf.read(buf)) != -1)&#123; System.out.println(new String(buf,0,len)); &#125;*/ //3.写数据 //raf.writeChars("abc"); //raf.writeBytes("abc"); raf.seek(4);//指定位置 raf.write(97); raf.write(98); raf.write(99); &#125;&#125;Properties的概述和作为Map集合的使用Properties的概述Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。是Hashtable的子类，说明是一个map集合方法Properties的load()和store()12public void load(Reader reader);//把文件中的数据读取到集合中public void store(Writer writer,String comments);//把集合中的数据存储到文件public Object setProperty(String key,String value)public String getProperty(String key)public EnumerationstringPropertyNames()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.time.Period;import java.util.Map.Entry;import java.util.Properties;import java.util.Set;public class Demo01 &#123; public static void main(String[] args) throws IOException, IOException &#123; //Properties的概述和作为Map集合的使用【掌握-经常用】 /** * Properties:属性 1.Properties 类表示了一个持久的属性集。 2.Properties 可保存在流中或从流中加载。 3.属性列表中每个键及其对应值都是一个字符串。 */ //遍历properties所有属性key和值value //1.创建属性对象 Properties p = new Properties(); //2.关联文件 p.load(new FileInputStream("info.properties")); //3.遍历一 Set&lt;Object&gt; keys = p.keySet(); for(Object key : keys)&#123; System.out.println(key + "=" + p.get(key)); &#125; //System.out.println(keys); //4.遍历二 System.out.println("====================="); //p.entrySet(); for(Entry&lt;Object, Object&gt; entry :p.entrySet())&#123; System.out.println(entry.getKey() + "=" + entry.getValue()); &#125; &#125; public static void test2() throws IOException, FileNotFoundException &#123; //使用Properties读取数据 //1.创建属性对象 Properties p = new Properties(); //2.关联文件 p.load(new FileInputStream("info.properties")); //3.通过key读数据 String name = p.getProperty("name"); String city = p.getProperty("city"); String hometown = p.getProperty("hometown"); System.out.println(name); System.out.println(city); System.out.println(hometown); &#125; /** * 使用Properties来存储数据 */ public static void test1() throws IOException, FileNotFoundException &#123; //1.创建属性对象 Properties p = new Properties(); //2.存数据 p.setProperty("name", "gyf"); p.setProperty("city", "广州"); p.setProperty("hometown", "梅州"); //3.关联文件 /** * 当Properties把key和value存入文件，把中文转成unicode编码 */ p.store(new FileOutputStream("info.properties"), null); &#125;&#125;小结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Demo01 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub //捋一捋IO流 /** * 一、IO流-输入输出流 * I:input * O:out * IO流 操作文件，读取文件内容，往文件写内容 * * 二、字节流 * * &gt;InputStream * -FileInputStream 文件输入流，读的单位是字节 * -BufferedInputStream 缓冲输入流，内部有个byte[]字节数组 * -SequenceInputStream 序列流，把多个字节流整合成一个流 * -ObjectInputStream 对象输入流，直接从文件中读取一个对象,这个对象要实现serilazable接口 * -Sytem.in 标准输入流-指键盘 * -DataInputStream 数据输入流，按基本数据类型的大小(long) 读取文件 * * &gt;OutputStream * -FileOutputStream 文件输出流，写的单位是字节 * -BufferedOutputStream 缓冲输出流，内部有个byte[]字节数组 * -ByteArrayOutputStream 字节数组输出流，把数据读取到内存中，这个类不需要关联文件 * -ObjectOutputStream 对象输出流，直接把一个对象存入文件， * -PrintStream 打印流，把内容打印到控制台 * -System.out 标准输出流-指控制台 * -DataOutputStream 数据输出流，按基本数据类型的大小(long) 写入文件 * * 三、字符流 * &gt;Reader * -FileReader 文件读取流，读取的单位是字符 * -BufferedReader 缓冲读取流，内部有个char[] 字符数组 * -InputStreamReader 指定字符编码读取文件 * * &gt;Writer * -FileWriter 文件写入流,写入的单位是字符 * -BufferedWriter,缓冲写入流，内部有个char[] 字符数组 * -OutputStreamWriter 指定字符编码写入文件 * -PrintWriter 打印流，把内容打印一个文件 * * * RandomAccessFile 随机访问流，特点：读和写都在一个类中 * * Properties 相当于Map一样使用，这个类把数据存在一个后缀名为.properties文件 */ &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE流</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-异常]]></title>
    <url>%2Fcategory%2FJavaSE-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。Throwable 类是 Java 语言中所有错误或异常的超类。只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。类似地，只有此类或其子类之一才可以是 catch 子句中的参数类型。Throwable 包含了其线程创建时线程执行堆栈的快照。它还包含了给出有关错误更多信息的消息字符串。最后，它还可以包含 cause（原因）：另一个导致此 throwable 抛出的 throwable。此 cause 设施在 1.4 版本中首次出现。它也称为异常链 设施，因为 cause 自身也会有 cause，依此类推，就形成了异常链，每个异常都是由另一个异常引起的。上图可以看到Java异常体系层次结构图在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。异常对象都是派生于Throwable类的一个实例，如果Java中内置的异常类不能满足需求，可以创建者自己的异常类。在 Java 中一个异常的产生，主要有如下三种原因：Java 内部错误发生异常，Java 虚拟机产生的异常。编写的程序代码中的错误所产生的异常，例如空指针异常、数组越界异常等。这种异常称为未检査的异常，一般需要在某些类中集中处理这些异常。通过 throw 语句手动生成的异常，这种异常称为检査的异常，一般用来告知该方法的调用者一些必要的信息。Java 通过面向对象的方法来处理异常。在一个方法的运行过程中，如果发生了异常，则这个方法会产生代表该异常的一个对象，并把它交给运行时的系统，运行时系统寻找相应的代码来处理这一异常。我们把生成异常对象，并把它提交给运行时系统的过程称为拋出（throw）异常。运行时系统在方法的调用栈中查找，直到找到能够处理该类型异常的对象，这一个过程称为捕获（catch）异常。Throwable： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。检查与非检查注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。通常，Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。派生于Error类或RuntimeException类的所有异常称为未检查异常，所有其他的异常称为已检查异常。编译器将核查是否为所有的已检查异常提供类了异常处理器。可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。 不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。 ### 常见的非检查性异常： 常见的检查性异常：ErrorError（错误）：Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。Error 是 Throwable 的子类，用于指示合理的应用程序不应该试图捕获的严重问题。大多数这样的错误都是异常条件。虽然 ThreadDeath 错误是一个“正规”的条件，但它也是 Error 的子类，因为大多数应用程序都不应该试图捕获它。在执行该方法期间，无需在其 throws 子句中声明可能抛出但是未能捕获的 Error 的任何子类，因为这些错误可能是再也不会发生的异常条件。Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。ExceptionException（异常）： 是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。Exception 常用异常主要分为两类非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。IOException（I/O 输入输出异常），其中 IOException 及其子类异常又被称作「受查异常」，程序本身没有问题，由于向I/O错误这类问题属于其他异常、试图在文件尾部后面读取数据、试图打开一个不存在的文件、试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在。另一类是 RuntimeException（运行时异常），RuntimeException 被称作「非受查异常」。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。错误的类型转换、数组访问越界、访问空指针、如果出现RuntimeException异常，那就一定是你的问题。受查异常就是指，编译器在编译期间要求必须得到处理的那些异常，你必须在编译期处理了。异常处理机制在 Java 应用程序中，异常处理机制为：抛出异常，捕捉异常。对于运行时异常、错误或可查异常，Java技术所要求的异常处理方式有所不同。由于运行时异常的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数Error异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。对于所有的可查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常。能够捕捉异常的方法，需要提供相符类型的异常处理器。所捕捉的异常，可能是由于自身语句所引发并抛出的异常，也可能是由某个调用的方法或者Java运行时 系统等抛出的异常。也就是说，一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常。从方法中抛出的任何异常都必须使用throws子句。捕捉异常通过try-catch语句或者try-catch-finally语句实现。总体来说，Java规定：对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。抛出异常当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。什么时候使用throws子句声明异常，什么异常必须使用throws子句声明:调用一个抛出已检查异常的方法程序运行过程中发现错误，并且利用throw语句抛出一个已检查异常程序出现错误Java虚拟机和运行时库出现的内部错误对于那些可能被他人使用的Java方法，应该根据异常规范，在方法的首部声明这个方法可能抛出异常，如果一个方法有可能抛出多个已检查异常，那么就必须在方法的首部列出所有的异常类，每个异常类之间用逗号隔开。但是不需要声明Java内部错误，即从Error继承的错误。任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常。从方法中抛出的任何异常都必须使用throws子句。throws抛出异常如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用throws子句来声明抛出异常。例如汽车在运行时可能会出现故障，汽车本身没办法处理这个故障，那就让开车的人来处理。throws语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是Exception异常类型，则该方法被声明为抛出所有的异常。多个异常可使用逗号分割。throws语句的语法格式为：throws 异常类名123methodname throws Exception1,Exception2,..,ExceptionN&#123;&#125;方法名后的throws Exception1,Exception2,…,ExceptionN 为声明要抛出的异常列表。当方法抛出异常列表的异常时，方法将不对这些类型及其子类类型的异常作处理，而抛向调用该方法的方法，由他去处理。例如：12345678910111213141516import java.lang.Exception;public class TestException &#123; static void pop() throws NegativeArraySizeException &#123; // 定义方法并抛出NegativeArraySizeException异常 int[] arr = new int[-3]; // 创建数组 &#125; public static void main(String[] args) &#123; // 主方法 try &#123; // try语句处理异常信息 pop(); // 调用pop()方法 &#125; catch (NegativeArraySizeException e) &#123; System.out.println("pop()方法抛出的异常");// 输出异常信息 &#125; &#125; &#125;使用throws关键字将异常抛给调用者后，如果调用者不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的调用者。pop方法没有处理异常NegativeArraySizeException，而是由main函数来处理。Throws抛出异常的规则：1) 如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。 2）必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误 3)仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。 4）调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。 12345678910111213141516171819202122232425262728293031323334353637void method1() throws IOException&#123;&#125; //合法 //编译错误，必须捕获或声明抛出IOException void method2()&#123; method1(); &#125; //合法，声明抛出IOException void method3()throws IOException &#123; method1(); &#125; //合法，声明抛出Exception，IOException是Exception的子类 void method4()throws Exception &#123; method1(); &#125; //合法，捕获IOException void method5()&#123; try&#123; method1(); &#125;catch(IOException e)&#123;…&#125; &#125; //编译错误，必须捕获或声明抛出Exception void method6()&#123; try&#123; method1(); &#125;catch(IOException e)&#123;throw new Exception();&#125; &#125; //合法，声明抛出Exception void method7()throws Exception&#123; try&#123; method1(); &#125;catch(IOException e)&#123;throw new Exception();&#125; &#125;判断一个方法可能会出现异常的依据如下： 1. 方法中有throw语句。例如，以上method7()方法的catch代码块有throw语句。 2. 调用了其他方法，其他方法用throws子句声明抛出某种异常。例如，method3()方法调用了method1()方法，method1()方法声明抛出IOException，因此，在method3()方法中可能会出现IOException。 使用throw抛出异常throw总是出现在函数体中，用来抛出一个Throwable类型的异常。程序会在throw语句后立即终止，它后面的语句执行不到，然后在包含它的所有try块中（可能在上层调用函数中）从里向外寻找含有与其匹配的catch子句的try块。我们知道，异常是异常类的实例对象，我们可以创建异常类的实例对象通过throw语句抛出。如果出现了异常情况，我们可以把该异常抛出，这个时候抛出的应该是异常的对象。该语句的语法格式为：throw new exceptionname;例如抛出一个IOException类的异常对象：throw new IOException;要注意的是，throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象。下面的操作是错误的：throw new String(“exception”);这是因为String 不是Throwable 类的子类。如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常。123456789101112131415161718192021222324252627282930313233package Test;import java.lang.Exception;public class TestException &#123; static int quotient(int x, int y) throws MyException &#123; // 定义方法抛出异常 if (y &lt; 0) &#123; // 判断参数是否小于0 throw new MyException("除数不能是负数"); // 异常信息 &#125; return x/y; // 返回值 &#125; public static void main(String args[]) &#123; // 主方法 int a =3; int b =0; try &#123; // try语句包含可能发生异常的语句 int result = quotient(a, b); // 调用方法quotient() &#125; catch (MyException e) &#123; // 处理自定义异常 System.out.println(e.getMessage()); // 输出异常信息 &#125; catch (ArithmeticException e) &#123; // 处理ArithmeticException异常 System.out.println("除数不能为0"); // 输出提示信息 &#125; catch (Exception e) &#123; // 处理其他异常 System.out.println("程序发生了其他的异常"); // 输出提示信息 &#125; &#125;&#125;class MyException extends Exception &#123; // 创建自定义异常类 String message; // 定义String类型变量 public MyException(String ErrorMessagr) &#123; // 父类方法 message = ErrorMessagr; &#125; public String getMessage() &#123; // 覆盖getMessage()方法 return message; &#125;&#125;throws和throw的区别throws：用在方法声明后面，跟的是异常类名可以跟多个异常类名，用逗号隔开表示抛出异常，由该方法的调用者来处理throws表示出现异常的一种可能性，并不一定会发生这些异常throw：用在方法体内，跟的是异常对象名只能抛出一个异常对象名表示抛出异常，由方法体内的语句处理throw则是抛出了异常，执行throw则一定抛出了某种异常捕获异常在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。try…catch语句其基本格式为：12345678910111213141516try&#123; //可能出现问题的代码&#125;catch(异常名 变量)&#123; //针对问题的处理&#125;/*try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;*/关键词try后的一对大括号将一块可能发生异常的代码包起来，称为监控区域。Java方法在运行过程中出现异常，则创建异常对象。将异常抛出监控区域之 外，由Java运行时系统试图寻找匹配的catch子句以捕获异常。若有匹配的catch子句，则运行其异常处理代码，try-catch语句结束。try后可以有多个catch匹配的原则是：如果抛出的异常对象属于catch子句的异常类，或者属于该异常类的子类，则认为生成的异常对象与catch块捕获的异常类型相匹配。1234567891011121314151617181920//捕捉throw语句抛出的“除数为0”异常public class TestException &#123; public static void main(String[] args) &#123; int a = 6; int b = 0; try &#123; // try监控区域 if (b == 0) throw new ArithmeticException(); // 通过throw语句抛出异常 System.out.println("a/b的值是：" + a / b); &#125; catch (ArithmeticException e) &#123; // catch捕捉异常 System.out.println("程序出现异常，变量b不能为0。"); &#125; System.out.println("程序正常结束。"); &#125;&#125;//运行结果：程序出现异常，变量b不能为0。//程序正常结束。//在try监控区域通过if语句进行判断，当“除数为0”的错误条件成立时引发ArithmeticException异常，创建 ArithmeticException异常对象，并由throw语句将异常抛给Java运行时系统，由系统寻找匹配的异常处理器catch并运行相应异 常处理代码，打印输出“程序出现异常，变量b不能为0。”try-catch语句结束，继续程序流程。//事实上，“除数为0”等ArithmeticException，是RuntimException的子类。而运行时异常将由运行时系统自动抛出，不需要使用throw语句。12345678910111213141516171819//捕捉运行时系统自动抛出“除数为0”引发的ArithmeticException异常。 public static void main(String[] args) &#123; int a = 6; int b = 0; try &#123; System.out.println("a/b的值是：" + a / b); &#125; catch (ArithmeticException e) &#123; System.out.println("程序出现异常，变量b不能为0。"); &#125; System.out.println("程序正常结束。"); &#125;&#125;//运行结果：程序出现异常，变量b不能为0。//程序正常结束。/*System.out.println("a/b的值是：" + a/b);在运行中出现“除数为0”错误，引发ArithmeticException异常。运行时系统创建异常对象并抛出监控区域，转而匹配合适的异常处理器catch，并执行相应的异常处理代码。由于检查运行时异常的代价远大于捕捉异常所带来的益处，运行时异常不可查。Java编译器允许忽略运行时异常，一个方法可以既不捕捉，也不声明抛出运行时异常。*/1234567891011121314//不捕捉、也不声明抛出运行时异常。public class TestException &#123; public static void main(String[] args) &#123; int a, b; a = 6; b = 0; // 除数b 的值为0 System.out.println(a / b); &#125;&#125;/*运行结果：Exception in thread "main" java.lang.ArithmeticException: / by zeroat Test.TestException.main(TestException.java:8)*/12345678910111213141516171819202122232425262728293031323334353637//程序可能存在除数为0异常和数组下标越界异常。public class TestException &#123; public static void main(String[] args) &#123; int[] intArray = new int[3]; try &#123; for (int i = 0; i &lt;= intArray.length; i++) &#123; intArray[i] = i; System.out.println("intArray[" + i + "] = " + intArray[i]); System.out.println("intArray[" + i + "]模 " + (i - 2) + "的值: " + intArray[i] % (i - 2)); &#125; &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println("intArray数组下标越界异常。"); &#125; catch (ArithmeticException e) &#123; System.out.println("除数为0异常。"); &#125; System.out.println("程序正常结束。"); &#125;&#125;/*运行结果：intArray[0] = 0intArray[0]模 -2的值: 0intArray[1] = 1intArray[1]模 -1的值: 0intArray[2] = 2除数为0异常。程序正常结束。程序可能会出现除数为0异常，还可能会出现数组下标越界异常。程序运行过程中ArithmeticException异常类型是先行匹配的，因此执行相匹配的catch语句：*/需要注意的是，一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。Java通过异常类描述异常类型，异常类的层次结构如图1所示。对于有多个catch子句的异常程序而言，应该尽量将捕获底层异常类的catch子 句放在前面，同时尽量将捕获相对高层的异常类的catch子句放在后面。否则，捕获底层异常类的catch子句将可能会被屏蔽。RuntimeException异常类包括运行时各种常见的异常，ArithmeticException类和ArrayIndexOutOfBoundsException类都是它的子类。因此，RuntimeException异常类的catch子句应该放在 最后面，否则可能会屏蔽其后的特定异常处理或引起编译错误。try…catch…finall语句try-catch语句还可以包括第三部分，就是finally子句。它表示无论是否出现异常，都应当执行的内容。finally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。try-catch-finally语句的一般语法形式为：123456789try &#123; // 可能会发生异常的程序代码&#125; catch (Type1 id1) &#123; // 捕获并处理try抛出的异常类型Type1&#125; catch (Type2 id2) &#123; // 捕获并处理try抛出的异常类型Type2&#125; finally &#123; // 无论是否发生异常，都将执行的语句块&#125;12345678910111213141516171819202122232425262728public class TestException &#123; public static void main(String args[]) &#123; int i = 0; String greetings[] = &#123; " Hello world !", " Hello World !! ", " HELLO WORLD !!!" &#125;; while (i &lt; 4) &#123; try &#123; // 特别注意循环控制变量i的设计，避免造成无限循环 System.out.println(greetings[i++]); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println("数组下标越界异常"); &#125; finally &#123; System.out.println("--------------------------"); &#125; &#125; &#125;&#125;/*运行结果：Hello world !--------------------------Hello World !!--------------------------HELLO WORLD !!!--------------------------数组下标越界异常--------------------------*/try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。catch 块：用于处理try捕获到的异常。finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。在以下4种特殊情况下，finally块不会被执行：在finally语句块中发生了异常。在前面的代码中用了System.exit()退出程序。程序所在的线程死亡。关闭CPU。123456789//JDK7出现了新的异常处理方案try&#123; ...&#125;catch(异常名1|异常名2|... 变量)&#123; ...&#125;//这个方法虽然简洁，但是也不够好//处理方式是一致的(实际开发中，好多时候可能就是针对同类型的问题，给出同一个处理)//多个异常之间必须是平级关系try里面发现问题后，jvm会帮我们生成一个异常对象，然后把这个对象抛出，和catch里面的类进行匹配，如果该对象是某个类型的，就会执行该catch里面的处理信息异常中要了解的几个方法：123456public String getMessage();//异常的消息字符串public String toString();//返回异常的简单信息描述//此对象的类的name(全路径名)//":"(冒号和一个空格)//调用此对象getLocalizeMessage()方法的结果(默认返回的是getMessage()的内容)printStackTrace();//获取异常类名和异常的信息，以及异常出现在程序中的位置，返回值void，把信息输出在控制台finally关键字被finally控制的语句体一定会执行(特殊情况：在执行到finally之前jvm退出了(比如System.exit(0))finally的作用：用于释放资源，在IO流操作和数据库操作中会见到面试题：final,finally,和finalize的区别？final：最终的意思，可以修饰类，成员变量，成员方法finally：是异常处理的一部分，用于释放资源finalize：是Object类的一个方法，用于垃圾回收如果catch里面有return语句，请问finally里面的代码还会执行吗？如果会，请问是在return前还是return后？会，前。准确的说应该是中间12345678910111213141516171819202122public class FinallyDemo&#123; public static void main(String[] args)&#123; System.out.println(getInt()); &#125; public static int getInt()&#123; int a = 10; try&#123; System.out.println(a/0); a = 20; &#125;catch(ArithmeticException e)&#123; a = 30; return a; /* return a 在程序执行到这一步的时候，这里不是return a而是return 30;这个返回路径就形成了，但是呢，他发现后面还有finally，所以继续执行finally的内容，a=40.再次回到以前的返回路径，继续走return 30; */ &#125;finally&#123; a = 40; return a;//如果这样结果就是40了 &#125; //return a; &#125;&#125;try..carch…finally语句的执行顺序当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；我们应该如何处理异常以及异常注意事项原则：如果该功能内部可以将问题处理，用try，如果处理不了，交由调用者处理，用throws区别：后续程需要继续运行就try，后续程序不需要继续运行就throws举例：感冒了就自己吃点药 try吃了好几天药没得结果得了H7N9，那就得throws如果医院没有特效药就变成Error异常注意事项子类覆盖父类的方法时，子类的方法必须抛出相同的异常或父类。如果父类抛出了多个异常，子类覆盖父类时，只能抛出相同的异常或者时他的子集，子类不能抛出父类没有的异常如果被覆盖的方法没有异常抛出，那么子类的方法绝对不可以抛出异常，如果子类方法内由异常发生，那么子类只能try，不能throws自定义异常java不可能所有的情况都考虑到，所以在实际的开发中，我们可能需要自己定义异常而我们自己随意的写一个类，是不能作为异常类来看的，要想你的类是一个异常类就必须继承自Exception或者RuntimeException：两种方式：继承Exception继承RuntimeException异常链 1. 如果调用quotient(3,-1)，将发生MyException异常，程序调转到catch (MyException e)代码块中执行； 2. 如果调用quotient(5,0)，将会因“除数为0”错误引发ArithmeticException异常，属于运行时异常类，由Java运行时系统自动抛出。quotient（）方法没有捕捉ArithmeticException异常，Java运行时系统将沿方法调用栈查到main方法，将抛出的异常上传至quotient（）方法的调用者： int result = quotient(a, b); // 调用方法quotient() 由于该语句在try监控区域内，因此传回的“除数为0”的ArithmeticException异常由Java运行时系统抛出，并匹配catch子句： catch (ArithmeticException e) { // 处理ArithmeticException异常 System.out.println(“除数不能为0”); // 输出提示信息} 处理结果是输出“除数不能为0”。Java这种向上传递异常信息的处理机制，形成异常链。 Java方法抛出的可查异常将依据调用栈、沿着方法调用的层次结构一直传递到具备处理能力的调用方法，最高层次到main方法为止。如果异常传递到main方法，而main不具备处理能力，也没有通过throws声明抛出该异常，将可能出现编译错误。 3. 如还有其他异常发生，将使用catch (Exception e)捕捉异常。由于Exception是所有异常类的父类，如果将catch (Exception e)代码块放在其他两个代码块的前面，后面的代码块将永远得不到执行，就没有什么意义了，所以catch语句的顺序不可掉换。 Throwable类中的常用方法注意：catch关键字后面括号中的Exception类型的参数e。Exception就是try代码块传递给catch代码块的变量类型，e就是变量名。catch代码块中语句”e.getMessage();”用于输出错误性质。通常异常处理常用3个函数来获取异常的有关信息: getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。 getMeage()：返回异常的消息信息。printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。 有时为了简单会忽略掉catch语句后的代码，这样try-catch语句就成了一种摆设，一旦程序在运行过程中出现了异常，就会忽略处理异常，而错误发生的原因很难查找。 Java常见异常在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:runtimeException子类:java.lang.ArrayIndexOutOfBoundsException数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。java.lang.ArithmeticException算术条件异常。譬如：整数除零等。java.lang.NullPointerException空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等java.lang.ClassNotFoundException找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。java.lang.NegativeArraySizeException 数组长度为负异常java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常java.lang.SecurityException 安全性异常java.lang.IllegalArgumentException 非法参数异常IOExceptionIOException：操作输入流和输出流时可能出现的异常。EOFException 文件已结束异常FileNotFoundException 文件未找到异常其他ClassCastException 类型转换异常类ArrayStoreException 数组中包含不兼容的值抛出的异常SQLException 操作数据库异常类NoSuchFieldException 字段未找到异常NoSuchMethodException 方法未找到抛出的异常NumberFormatException 字符串转换为数字抛出的异常StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常IllegalAccessException 不允许访问某类异常InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常分析堆栈跟踪元素：堆栈跟踪是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。可以调用Throwable类的printStackTrace方法访问堆栈跟踪的文本描述信息。还可以使用getStackTrace方法，它会得到StackTraceElement对象的一个数组。StackTraceElement类含有能够获得文件名和当前执行的代码号的方法，还含有能够获得类名和方法名的方法。toString方法将产生一个格式化字符串，其中包含所获得的信息。静态的Thread.getAllStackTrace方法，它可以产生所有线程的堆栈跟踪。断言断言机制允许在测试期间向代码插入一些检查语句，当代码发布时，这些插入的检测语句将会被自动的移走Java语言引入关键字assert。这个关键字有两种形式:assert 条件;assert 条件:表达式;要想断言x是一个非负数值:assert &gt;= 0;或者将x的实际值传递给AssertionError对象Assert x &gt;= 0 : x;在默认情况下，断言被禁用。可以在运行程序时用 –enableassertions或-ea选项启用它: java –enableassertions Myapp。在启动或禁用断言时不必重新编译程序。启用或禁用断言是类加载器的功能。当断言被禁用时，类加载器将跳过断言代码，因此不会降低程序运行速度。也可以在某个类或某个包中使用断言:Java –ea:MyClass –ea:com.mycompany.mylib… MyApp这条命令将开启MyClass类在com.mycompany.mylib包和它的子包中的所有类的断言。记录日志日志系统管理着一个名为Logger.global的默认日志记录器，可以用System.out替换它，并通过调用info方法记录日志信息:Logger.getGlobal().info日志记录器级别:SEVERE,WARNING,INFO,CONFIG,FINE,FINER,FINERST.logger.setlevel(level.FINE);]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE异常</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-Map容器]]></title>
    <url>%2Fcategory%2FJavaSE-%E9%9B%86%E5%90%882%2F</url>
    <content type="text"><![CDATA[Map接口Map，图，是一种存储键值对映射的容器类，在Map中键可以是任意类型的对象，但不能有重复的键，每个键都对应一个值，真正存储在图中的是键值构成的条目。Map和Collection集合的区别：Map容器存储元素是成对出现的，Map集合的键是唯一的，值是可重复的Collection集合存储元素是单独出现的，Set是唯一的，List是可重复的Map容器的数据结构值针对键有效，跟值无关Collection集合的数据结构是针对元素有效下面是接口Map的类结构。从上面这张图中我们可以看到接口Map提供了很多查询、更新和获取存储的键值对的方法，更新包括方法clear()、put()、putAll()、remove()等等，查询方法包括containsKey、containsValue等等。Map接口常用的有三个具体实现类，分别是HashMap、LinkedHashMap、TreeMap。Map的遍历键找值获取所有的键的集合遍历键的集合，得到每一个键根据键到集合中去找值键值对对象找键和值获取所有键值对对象的集合遍历键值对对象的集合，获取每一个键值对对象根据键值对对象去获取键和值。12345678910111213Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();//创建元素并添加集合map.put("a","A");map.put("b","B");map.put("c","C");//遍历Set&lt;String&gt; set = map.keySet();//遍历键的集合，获取得到每一个键for(String key:set)&#123; //根据键去找值 String value = map.get(key); System.out.println(key+"---"+value);&#125;123456789101112131415//Set&lt;map.Entry&lt;K,V&gt;&gt; entrySet():返回的是键值对对象的集合//创建集合对象Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();map.put("a","A");map.put("b","B");map.put("c","C");//获取所有键值对对象的集合Set&lt;Map.Entry&lt;String,String&gt;&gt; set = map.entrySet();//遍历键值对对象的集合，得到每一个键值对对象for(Map.Entry&lt;Stirng,String&gt; me :set)&#123; //根据键值对对象获取键和值 String key = me.getKey(); String value = me.getValue(); System.out.println(key+"---"+value);&#125;HashMapHashMap是基于哈希表的Map接口的非同步实现，继承自AbstractMap，AbstractMap是部分实现Map接口的抽象类。在平时的开发中，HashMap的使用还是比较多的。HashSet和HashMap,二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说HashSet里面有一个HashMap（适配器模式）。HashMap实现了Map接口，允许放入null元素，除该类未实现同步外，其余跟Hashtable大致相同，跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。Java HashMap采用的是冲突链表方式。从上图容易看出，如果选择合适的哈希函数，put()和get()方法可以在常数时间内完成。但在对HashMap进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。有两个参数可以影响HashMap的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。在之前的版本中，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当链表中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。哈希表内部使用Entry[]数组存放数据(Entry是封装键值对的对象)数组默认的初始容量是16(可以通过构造方法参数指定)数组容量会翻倍增长—StringBuilder翻倍+2将对向放入到HashMap或HashSet中时，有两个方法需要特别关心：hashCode()和equals()。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要@Override hashCode()和equals()方法。12345678910111213141516171819202122232425262728293031323334353637383940static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; //构造函数 ( Hash值键值下一个节点 ) Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125;Key.hashCode() 获得键的哈希值使用哈希值和数组长度，来计算下标把键值对封装成Entry实例把Entry实例放入i 位置空位置，直接放入有数据，依次使用equals()进行比较是否相等如果有相等的，覆盖值如果没有相等的，链表连接在一起，放在链表头部，后进先出（碰撞）负载率，加载因子到0.75(数据数量/容量)新建翻倍容量的新数组所有数据重新执行哈希运算，放入新数组问题：如果碰撞过多会造成效率低，所以尽可能要去避免。所以hashcode方法和equals重写的时候尽量严谨一些，并且尽量保持一致（对象一样，生成的hashcode值一样）Jdk1.8之后链表长度到8，会转成红黑树（平衡的二叉树）树上的数据减少到6，会转回成链表hashCode()Object()方法默认实现，使用内存地址作为哈希值，可以重写hashCode()方法，使用属性数据来计算产生哈希值HashSet底层如何优化：尽可能让对象的哈希值不通过方法：基本类型可以加值引用类型就加哈希值//哈希值尽量的分散int p = 31; //固定int r =1; //可以改变r= r * p + x;r= r * p + y;returnr;方法剖析get()get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.getValue()。因此getEntry()是算法的核心。算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过key.equals(k)方法来判断是否是要找的那个entry。上图中hash(k)&amp;(table.length-1)等价于hash(k)%table.length，原因是HashMap要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。1234567891011121314//getEntry()方法final Entry&lt;K,V&gt; getEntry(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-1)];//得到冲突链表 e != null; e = e.next) &#123;//依次遍历冲突链表中的每个entry Object k; //依据equals()方法判断是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125;put()put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry，插入方式为头插法。123456789101112//addEntry()void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//自动扩容，并重新哈希 hash = (null != key) ? hash(key) : 0; bucketIndex = hash &amp; (table.length-1);//hash%table.length &#125; //在冲突链表头部插入新的entry Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125;remove()remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry（修改链表的相应指针）。查找过程跟getEntry()过程类似。123456789101112131415161718192021//removeEntryForKey()final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length);//hash&amp;(table.length-1) Entry&lt;K,V&gt; prev = table[i];//得到冲突链表 Entry&lt;K,V&gt; e = prev; while (e != null) &#123;//遍历冲突链表 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;//找到要删除的entry modCount++; size--; if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry else prev.next = next; return e; &#125; prev = e; e = next; &#125; return e;&#125;HashSet前面已经说过HashSet是对HashMap的简单包装，对HashSet的函数调用都会转换成合适的HashMap方法，因此HashSet的实现非常简单，只有不到300行代码。这里不再赘述。12345678910111213141516//HashSet是对HashMap的简单包装public class HashSet&lt;E&gt;&#123; ...... private transient HashMap&lt;E,Object&gt; map;//HashSet里面有一个HashMap // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; ...... public boolean add(E e) &#123;//简单的方法转换 return map.put(e, PRESENT)==null; &#125; ......&#125;在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用hash(int h)方法所计算得到的hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中，(n - 1) &amp; hash用于计算对象应该保存在table数组的哪个索引处。HashMap底层数组的长度总是2的n次方，当数组长度为2的n次幂的时候，(n - 1) &amp; hash 算得的index相同的几率较小，数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。LinkedHashMapLinkedHashMap继承自HashMap，它主要是用链表实现来扩展HashMap类，HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们插入图的顺序排序，也可以按它们最后一次被访问的顺序排序。LinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap（适配器模式）。LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将LinkedHashMap看作采用linked list增强的HashMap。事实上LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表（doubly-linked list）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部（是一个哑元），该双向链表的迭代顺序就是entry的插入顺序。除了可以保迭代历顺序，这种结构还有一个好处：迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说LinkedHashMap的迭代时间就只跟entry的个数相关，而跟table的大小无关。有两个参数可以影响LinkedHashMap的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。将对象放入到LinkedHashMap或LinkedHashSet中时，有两个方法需要特别关心：hashCode()和equals()。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要@Override hashCode()和equals()方法。通过如下方式可以得到一个跟源Map迭代顺序一样的LinkedHashMap：1234void foo(Map m) &#123; Map copy = new LinkedHashMap(m); ...&#125;出于性能原因，LinkedHashMap是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将LinkedHashMap包装成（wrapped）同步的：1Map m = Collections.synchronizedMap(new LinkedHashMap(...));get()get(Object key)方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样put()put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于get()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry。注意，这里的插入有两重含义：从table的角度看，新的entry需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的entry插入到冲突链表的头部。从header的角度看，新的entry需要插入到双向链表的尾部。addEntry()代码如下：123456789101112131415// LinkedHashMap.addEntry()void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);// 自动扩容，并重新哈希 hash = (null != key) ? hash(key) : 0; bucketIndex = hash &amp; (table.length-1);// hash%table.length &#125; // 1.在冲突链表头部插入新的entry HashMap.Entry&lt;K,V&gt; old = table[bucketIndex]; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(hash, key, value, old); table[bucketIndex] = e; // 2.在双向链表的尾部插入新的entry e.addBefore(header); size++;&#125;上述代码中用到了addBefore()方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。addBefore()的代码如下：1234567// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this;&#125;上述代码只是简单修改相关entry的引用而已。remove()remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry（修改链表的相应引用）。查找过程跟get()方法类似。注意，这里的删除也有两重含义：从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。removeEntryForKey()对应的代码如下：12345678910111213141516171819202122232425// LinkedHashMap.removeEntryForKey()，删除key值对应的entryfinal Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length);// hash&amp;(table.length-1) Entry&lt;K,V&gt; prev = table[i];// 得到冲突链表 Entry&lt;K,V&gt; e = prev; while (e != null) &#123;// 遍历冲突链表 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;// 找到要删除的entry modCount++; size--; // 1. 将e从对应bucket的冲突链表中删除 if (prev == e) table[i] = next; else prev.next = next; // 2. 将e从双向链表中删除 e.before.after = e.after; e.after.before = e.before; return e; &#125; prev = e; e = next; &#125; return e;&#125;LinkedHashSet前面已经说过LinkedHashSet是对LinkedHashMap的简单包装，对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法，因此LinkedHashSet的实现非常简单，这里不再赘述。1234567891011121314public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; ...... // LinkedHashSet里面有一个LinkedHashMap public LinkedHashSet(int initialCapacity, float loadFactor) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; ...... public boolean add(E e) &#123;//简单的方法转换 return map.put(e, PRESENT)==null; &#125; ......&#125;TreeMapTreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的。在实际使用中，如果更新图时不需要保持图中元素的顺序，就使用HashMap，如果需要保持图中元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap。WeakHashMapWeakHashMap，从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使程序员没有调用remove()或者clear()方法。更直观的说，当使用 WeakHashMap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况：调用两次size()方法返回不同的值；两次调用isEmpty()方法，第一次返回false，第二次返回true；两次调用containsKey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉？其实不然，WeekHashMap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。要明白 WeekHashMap 的工作原理，还需要引入一个概念：弱引用（WeakReference）。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象（基本意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的“有效引用”并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。WeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。具体实现WeakHashMap的存储结构类似于HashMapWeak HashSet?既然有 WeekHashMap，是否有 WeekHashSet 呢？答案是没有:( 。不过Java Collections工具类给出了解决方案，Collections.newSetFromMap(Mapmap)方法可以将任何 Map包装成一个Set。通过如下方式可以快速得到一个 Weak HashSet：123// 将WeakHashMap包装成一个SetSet&lt;Object&gt; weakHashSet = Collections.newSetFromMap( new WeakHashMap&lt;Object, Boolean&gt;());不出你所料，newSetFromMap()方法只是对传入的 Map做了简单包装：12345678910111213141516171819202122232425262728293031323334// Collections.newSetFromMap()用于将任何Map包装成一个Setpublic static &lt;E&gt; Set&lt;E&gt; newSetFromMap(Map&lt;E, Boolean&gt; map) &#123; return new SetFromMap&lt;&gt;(map);&#125;private static class SetFromMap&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Serializable&#123; private final Map&lt;E, Boolean&gt; m; // The backing map private transient Set&lt;E&gt; s; // Its keySet SetFromMap(Map&lt;E, Boolean&gt; map) &#123; if (!map.isEmpty()) throw new IllegalArgumentException("Map is non-empty"); m = map; s = map.keySet(); &#125; public void clear() &#123; m.clear(); &#125; public int size() &#123; return m.size(); &#125; public boolean isEmpty() &#123; return m.isEmpty(); &#125; public boolean contains(Object o) &#123; return m.containsKey(o); &#125; public boolean remove(Object o) &#123; return m.remove(o) != null; &#125; public boolean add(E e) &#123; return m.put(e, Boolean.TRUE) == null; &#125; public Iterator&lt;E&gt; iterator() &#123; return s.iterator(); &#125; public Object[] toArray() &#123; return s.toArray(); &#125; public &lt;T&gt; T[] toArray(T[] a) &#123; return s.toArray(a); &#125; public String toString() &#123; return s.toString(); &#125; public int hashCode() &#123; return s.hashCode(); &#125; public boolean equals(Object o) &#123; return o == this || s.equals(o); &#125; public boolean containsAll(Collection&lt;?&gt; c) &#123;return s.containsAll(c);&#125; public boolean removeAll(Collection&lt;?&gt; c) &#123;return s.removeAll(c);&#125; public boolean retainAll(Collection&lt;?&gt; c) &#123;return s.retainAll(c);&#125; // addAll is the only inherited implementation ......&#125;HashtableHashtable和前面介绍的HashMap很类似，它也是一个散列表，存储的内容是键值对映射，不同之处在于，Hashtable是继承自Dictionary的，Hashtable中的函数都是同步的，这意味着它也是线程安全的，另外，Hashtable中key和value都不可以为null。上面的三个集合类都是在Java2之前推出的容器类，可以看到，尽管在使用中效率比较低，但是它们都是线程安全的。下面介绍两个特殊的集合类。Map总结MapMap集合的数据结构仅仅针对键有效，与值无关。存储的键值对形式的元素，键唯一，值可重复。HashMap底层数据结构是哈希表哈希表依赖两个方法：hashCode()和equals()执行顺序：首先判断hashCode()值是否相同是：继续执行equals(),看其返回值是true：说明元素重复，不添加是false：就直接添加到集合否：就直接添加到集合最终：自动生成hashCode()和equals()即可LinkedHashSet底层数据结构由链表和哈希表组成由链表保证元素有序由哈希表保证元素唯一Hashtable底层数据结构是哈希表.线程安全，效率低哈希表依赖两个方法：hashCode()和equals()执行顺序：首先判断hashCode()值是否相同是：继续执行equals(),看其返回值是true：说明元素重复，不添加是false：就直接添加到集合否：就直接添加到集合最终：自动生成hashCode()和equals()即可TreeMap底层数据结构是红黑树（是一种平衡的二叉树）如何保证元素唯一性呢？根据比较的返回值是否是0来确定如何保证元素的排序呢？两种方式自然排序（元素具备比较性）让元素所属的类实现Comparable接口比较器排序（集合具备比较性）让集合接受一个Comparator的实现类对象集合的常见方法及遍历方式Collection：add()remove()contains()iterator()size()遍历：增强for迭代器Listget（）遍历：普通forSetMap：put()remove()containskey(),containsValue()keySet()get()value()entrySet()size()遍历：根据键找值根据键值对对象分别找键和值Collections工具类针对集合操作的工具类，有对集合进行排序和二分查找的方法1234public static &lt;T&gt; void sort(List&lt;T&gt; list);//排序，默认情况下是自然排序public static &lt;T&gt; void binarySearch(List&lt;?&gt; list,T key);//二分查找public static void reverse(List&lt;T&gt; list);//反转public static void shuffle(List&lt;?&gt; list);//随机置换红黑树体介绍Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator）。TreeMap底层通过红黑树（Red-Black tree）实现，也就意味着containsKey(), get(), put(), remove()都有着log(n)的时间复杂度。其具体算法实现参照了《算法导论》。出于性能原因，TreeMap是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成（wrapped）同步的：SortedMap m = Collections.synchronizedSortedMap(new TreeMap(…));红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一陪。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）：每个节点要么是红色，要么是黑色。根节点必须是黑色红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的条件。预备知识前文说到当查找树的结构发生改变时，红黑树的条件可能被破坏，需要通过调整使得查找树重新满足红黑树的条件。调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：左旋（Rotate Left），右旋（RotateRight）。左旋左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。TreeMap中左旋代码如下：123456789101112131415161718//Rotate Leftprivate void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125;&#125;右旋右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。TreeMap中右旋代码如下：12345678910111213141516//Rotate Rightprivate void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125;&#125;方法剖析get()get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.value。因此getEntry()是算法的核心。算法思想是根据key的自然顺序（或者比较器顺序）对二叉查找树进行查找，直到找到满足k.compareTo(p.key) == 0的entry。具体代码如下：123456789101112131415161718//getEntry()方法final Entry&lt;K,V&gt; getEntry(Object key) &#123; ...... if (key == null)//不允许key值为null throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0)//向左找 p = p.left; else if (cmp &gt; 0)//向右找 p = p.right; else return p; &#125; return null;&#125;put()put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束，还需要进行调整（旋转，改变某些节点的颜色）。123456789101112131415161718192021public V put(K key, V value) &#123; ...... int cmp; Entry&lt;K,V&gt; parent; if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left;//向左找 else if (cmp &gt; 0) t = t.right;//向右找 else return t.setValue(value); &#125; while (t != null); Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);//创建并插入新的entry if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e);//调整 size++; return null;&#125;上述代码的插入部分并不难理解：首先在红黑树上找到合适的位置，然后创建新的entry并插入（当然，新插入的节点一定是树的叶子）。难点是调整函数fixAfterInsertion()，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。调整函数fixAfterInsertion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。12345678910111213141516171819202122232425262728293031323334353637383940//红黑树调整函数fixAfterInsertion()private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123;//如果y为null，则视为BLACK setColor(parentOf(x), BLACK); // 情况1 setColor(y, BLACK); // 情况1 setColor(parentOf(parentOf(x)), RED); // 情况1 x = parentOf(parentOf(x)); // 情况1 &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); // 情况2 rotateLeft(x); // 情况2 &#125; setColor(parentOf(x), BLACK); // 情况3 setColor(parentOf(parentOf(x)), RED); // 情况3 rotateRight(parentOf(parentOf(x))); // 情况3 &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); // 情况4 setColor(y, BLACK); // 情况4 setColor(parentOf(parentOf(x)), RED); // 情况4 x = parentOf(parentOf(x)); // 情况4 &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); // 情况5 rotateRight(x); // 情况5 &#125; setColor(parentOf(x), BLACK); // 情况6 setColor(parentOf(parentOf(x)), RED); // 情况6 rotateLeft(parentOf(parentOf(x))); // 情况6 &#125; &#125; &#125; root.color = BLACK;&#125;remove()remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entryentry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束，因此有可能要进行调整。寻找节点后继对于一棵二叉查找树，给定节点t，其后继（树种比大于t的最小的那个元素）可以通过如下方式找到：t的右子树不空，则t的后继是其右子树中最小的那个元素。t的右孩子为空，则t的后继是其第一个向左走的祖先。后继节点在红黑树的删除操作中将会用到。TreeMap中寻找节点后继的代码如下：12345678910111213141516171819// 寻找节点后继函数successor()static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.right != null) &#123;// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素 Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123;// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先 Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125;&#125;remove()remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entryentry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。getEntry()函数前面已经讲解过，这里重点放deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixAfterDeletion(Entryx)进行调整。由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况：删除点p的左右子树都为空，或者只有一棵子树非空。删除点p的左右子树都非空。对于上述情况1，处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）；对于情况2，可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1，可以画画看）。基于以上逻辑，红黑树的节点删除函数deleteEntry()代码如下：123456789101112131415161718192021222324252627282930313233343536// 红黑树entry删除函数deleteEntry()private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; if (p.left != null &amp;&amp; p.right != null) &#123;// 2. 删除点p的左右子树都非空。 Entry&lt;K,V&gt; s = successor(p);// 后继 p.key = s.key; p.value = s.value; p = s; &#125; Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123;// 1. 删除点p只有一棵子树非空。 replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; p.left = p.right = p.parent = null; if (p.color == BLACK) fixAfterDeletion(replacement);// 调整 &#125; else if (p.parent == null) &#123; root = null; &#125; else &#123; // 1. 删除点p的左右子树都为空 if (p.color == BLACK) fixAfterDeletion(p);// 调整 if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125;&#125;上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数fixAfterDeletion()。首先请思考一下，删除了哪些点才会导致调整？只有删除点是BLACK的时候，才会触发调整函数，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。跟上文中讲过的fixAfterInsertion()函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种：1.改变某些节点的颜色，2.对某些节点进行旋转。上述图解的总体思想是：将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则：a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环（因为x为红色）；b).一旦进入情况3和情况4，一定会退出循环（因为x为root）。删除后调整函数fixAfterDeletion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); // 情况1 setColor(parentOf(x), RED); // 情况1 rotateLeft(parentOf(x)); // 情况1 sib = rightOf(parentOf(x)); // 情况1 &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); // 情况2 x = parentOf(x); // 情况2 &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); // 情况3 setColor(sib, RED); // 情况3 rotateRight(sib); // 情况3 sib = rightOf(parentOf(x)); // 情况3 &#125; setColor(sib, colorOf(parentOf(x))); // 情况4 setColor(parentOf(x), BLACK); // 情况4 setColor(rightOf(sib), BLACK); // 情况4 rotateLeft(parentOf(x)); // 情况4 x = root; // 情况4 &#125; &#125; else &#123; // 跟前四种情况对称 Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); // 情况5 setColor(parentOf(x), RED); // 情况5 rotateRight(parentOf(x)); // 情况5 sib = leftOf(parentOf(x)); // 情况5 &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); // 情况6 x = parentOf(x); // 情况6 &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); // 情况7 setColor(sib, RED); // 情况7 rotateLeft(sib); // 情况7 sib = leftOf(parentOf(x)); // 情况7 &#125; setColor(sib, colorOf(parentOf(x))); // 情况8 setColor(parentOf(x), BLACK); // 情况8 setColor(leftOf(sib), BLACK); // 情况8 rotateRight(parentOf(x)); // 情况8 x = root; // 情况8 &#125; &#125; &#125; setColor(x, BLACK);&#125;TreeSet前面已经说过TreeSet是对TeeMap的简单包装，对TreeSet的函数调用都会转换成合适的TeeMap方法，因此TreeSet的实现非常简单。这里不再赘述。1234567891011121314151617// TreeSet是对TreeMap的简单包装public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123; ...... private transient NavigableMap&lt;E,Object&gt; m; // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public TreeSet() &#123; this.m = new TreeMap&lt;E,Object&gt;();// TreeSet里面有一个TreeMap &#125; ...... public boolean add(E e) &#123; return m.put(e, PRESENT)==null; &#125; ......&#125;]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE集合框架</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-Collection集合]]></title>
    <url>%2Fcategory%2FJavaSE-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合框架对象数组数据既可以存储基本数据类型，也可以存储引用类型，它存储引用类型的时候的数组就叫对象数组假如有一个学生类1234567891011121314151617181920212223242526272829303132333435363738394041424344class Student&#123; private String name; private int age; public Student()&#123; &#125; public Student(String name,int age)&#123; this.name = name; this.age = age; &#125; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getAge()&#123; return age; &#125; public void setName(int age)&#123; this.age = age; &#125;&#125;class StudentTest&#123; public static vodi main(String[] args)&#123; //创建学生数组(对象数组) Student[] students = new Student(5); //创建5个学生对象并赋值 Student s1 = new Student("张三",18); Student s2 = new Student("李四",19); Student s3 = new Student("王五",20); Student s4 = new Student("赵六",21); Student s5 = new Student("陈七",22); //把学生对象放到数组中 student[0] = s1; student[1] = s2; student[2] = s3; student[3] = s4; student[4] = s5; for(int x = 0; x&lt;student.length;x++)&#123; Student s = student[x]; System.out.println(s.getName()+"---"+s.getAge); &#125; &#125;&#125;可变参数定义方法时候不知道定义多少个参数123//格式修饰符 返回值类型 方法名(数据类型... 变量名)&#123;&#125;//这里的变量其实是一个数组，如果一个方法有可变参数，并且有多个参数，那么可变参数肯定是最后一个集合在面向对象的语言中，对事务的描述都是通过对象体现的，为了方便多个对象进行操作，我们就必须把这多个对象进行存储，而不能是一个基本的变量，应该是一个容器类型的变量。而学过的容器类型的有数组和StringBuffer，StringBuffer的结果是一个字符串，不能满足要求。当选择数组作为容器，这就是对象数组，然而对象数组长度是固定的，不能满足变化的需求，这就产生了集合容器。数据结构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。Java提供了几个能有效地组织和操作数据的数据结构，这些数据结构通常称为Java集合框架。Java容器里只能放对象，对于基本类型（int, long, float, double等），需要将其包装成对象类型后（Integer, Long, Float, Double等）才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。由于Java里对象都在堆上，且对象只能通过引用访问，容器里放的其实是对象的引用而不是对象本身数组和集合的区别？长度区别数组的长度固定集合长度可变内容不同数组存储的是同一种类型的元素集合可以存储不同类型的元素元素的数据类型问题数组可以存储基本数据类型，也可以存储引用数据类型集合只能存储引用类型集合继承体系Map接口没有继承自Collection接口，因为Map表示的是关联式容器而不是集合。但Java为我们提供了从Map转换到Collection的方法，可以方便的将Map切换到集合视图。上图中提供了Queue接口，却没有Stack，这是因为Stack的功能已被JDK 1.6引入的Deque取代Collection集合功能概述在这里可以看到Collection接口所提供的所有方法：其中，有几个比较常用的方法，比如方法add()添加一个元素到集合中，addAll()将指定集合中的所有元素添加到集合中，contains()方法检测集合中是否包含指定的元素，toArray()方法返回一个表示集合的数组。1234567891011121314151617181920//Collection接口//1、添加功能boolean add(Object obj);//添加一个元素boolean addAll(Collection c);//添加一个集合的元素//2、删除功能void clear();//移除所有元素boolean remove(Object o);//移除一个元素boolean removeAll(Collection c);//移除一个集合的元素//3、判断功能boolean contains(Object o);//判断集合中是否包含指定的元素boolean containsAll(Collection c);//判断集合中是否包含指定的集合元素boolean isEmpty();//判断集合是否为空//4、获取功能Iterator&lt;E&gt; iterator();//5、长度功能 int size();//元素的个数//6、交集功能boolean retainAll(Collection c);//两个集合都有的元素//7、把集合转为数组Object[] toArray();同时我们看方法列表有一个特别有意思的方法boolean removeIf(Predicate&lt;? super E&gt;)这是Java8新特性里加的方法，下面是他的源码：12345678910111213141516171819202122232425262728293031323334/** * Removes all of the elements of this collection that satisfy the given * predicate. Errors or runtime exceptions thrown during iteration or by * the predicate are relayed to the caller. * * @implSpec * The default implementation traverses all elements of the collection using * its &#123;@link #iterator&#125;. Each matching element is removed using * &#123;@link Iterator#remove()&#125;. If the collection's iterator does not * support removal then an &#123;@code UnsupportedOperationException&#125; will be * thrown on the first matching element. * * @param filter a predicate which returns &#123;@code true&#125; for elements to be * removed * @return &#123;@code true&#125; if any elements were removed * @throws NullPointerException if the specified filter is null * @throws UnsupportedOperationException if elements cannot be removed * from this collection. Implementations may throw this exception if a * matching element cannot be removed or if, in general, removal is not * supported. * @since 1.8 */ default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed; &#125;我们可以看到，这就是一个添加了判断的移除，并且可以实现自定义过滤器，并且是public default，并且这个方法在接口里，实际调用则是接口的实现类提供的。12345678910111213141516171819public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.removeIf(s -&gt; s%2==0); // 过滤掉模2等于0的数 list.forEach(s -&gt; System.out.println(s)); // 输出 1 3 List&lt;String&gt; strings = new ArrayList&lt;&gt;(); strings.add("ab"); strings.add("ac"); strings.add("bc"); strings.add("cd"); Predicate&lt;String&gt; predicate = (s) -&gt; s.startsWith("a"); // 这里单独定义了过滤器 strings.removeIf(predicate); // 过滤掉以"a"开头的元素 strings.forEach(s -&gt; System.out.println(s)); // 输出 bc cd&#125;Collection集合继承体系可以看到Collection接口有四个子接口BeanContext、Set、List、Queue。集合的遍历增强for12345//for循环的一种for(元素数据类型 变量:数组或者Collection集合)&#123; 使用变量即可，该变量就是元素&#125;//简化数组和集合的遍历，增强for目标不能为null，所以最好使用前对其做非null判断123456ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();array.add("hello");array.add("world");for(String s : array)&#123; System.out.println(s);&#125;迭代器迭代器是遍历集合的一种方式，是以来集合存在的123456789Collection c = new ArrayList();c.add("hello");c.add("world");//通过集合获取迭代器对象Iterator it = c.iterator();while(it.hasNext())&#123; String s = (String)it.next(); System.out.println(s);&#125;迭代器为什么不定义一个类而是一个接口？假设迭代器定义的是一个类，这样我们就可以创建该类的对象，调用该类的方法实现集合的遍历，但是，Java中提供了很多的集合类，而这些集合类的数据结构是不同的，所以，存储的方式和遍历的方式应该是不同的，进而他们的遍历方式也应该是不一样的，最终就没有定义迭代器类。而无论是哪种集合，都应该具备获取元素的操作，并且最好在辅助于判断功能。再提取这两个功能就是接口那么在真正具体的实现类在哪里呢？再真正具体的子类中，以内部类的方式体现的。迭代器源码：BeanContext提供与 bean 上下文有关的类和接口。bean 上下文是一个 bean 的容器，它定义所包含 bean 的执行环境。但单个 bean 上下文中可能有几个 bean，一个 bean 上下文可以嵌套在另一个 bean 上下文中。List(重点)List接口扩展自Collection，它可以定义一个允许重复的有序集合（也称序列）。从List接口中的方法来看，List接口主要是增加了面向位置的操作，允许在指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器ListIterator，通常允许重复的元素。List集合的特有功能：12345678910//添加功能void add(int index,Object element);//在指定位置添加元素//获取功能Object get(int index);//获取指定位置的元素//列表迭代器ListIterator listIterator();//:List集合特有的迭代器//删除功能Object remove(int index);//根据索引删除元素，返回被删除的元素//修改功能Object set(int index,Object element);//根据索引修改元素，返回被修饰的元素数据结构简单分析数据结构之栈和队列：栈：先进后出队列：先进先出数组：查询快，增删慢链表：查询慢，增删快我们说的链表是单向链表，其实如果把头元素的地址给了最后一个元素的地址位置，就是循环列表，如果每个结点有3部分组成，就可以组成双向链表，如果再把前后的对应也连接起来，就成了双向循环链表。ArrayListArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。除该类未实现同步外，其余跟Vector大致相同。每个ArrayList都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//Set()方法//既然底层是一个数组ArrayList的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。 /** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E set(int index, E element) &#123; rangeCheck(index);//下标越界检查 /* private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; */ E oldValue = elementData(index); elementData[index] = element;//赋值到指定位置，复制的仅仅是引用 return oldValue; &#125;//get()方法//get()方法唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; rangeCheck(index);//下标越界检查 return elementData(index);//返回下标元素 &#125;//add()//ArrayList方法是add(E e)，add(int index, E e)。这两个方法都是向容器中添加新元素，这可能会导致capacity不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。 /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//扩容到原来的1.5倍 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);//扩展空间并复制 &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125;由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。空间的问题解决后，插入过程就显得非常简单。add(int index, E e)需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//addAll() /** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; /** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125;//addAll()方法能够一次添加多个元素，根据位置不同也有两个把本，一个是在末尾添加的addAll(Collection&lt;? extends E&gt; c)方法，一个是从指定位置开始插入的addAll(int index, Collection&lt;? extends E&gt; c)方法。跟add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。//addAll()的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//remove()//remove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。 /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work:清除该位置的引用，让GC起作用 return oldValue; &#125; /** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125;//关于Java GC这里需要特别说明一下，有了垃圾收集器并不意味着一定不会有内存泄漏。对象能否被GC的依据是是否还有引用指向它，上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。LinkedListLinkedList同时实现了List接口和Deque接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（Queue），同时又可以看作一个栈（Stack）。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue的类（它是个接口名字）。关于栈或队列，现在的首选是ArrayDeque，它有着比LinkedList（当作栈或队列使用时）有着更好的性能。123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.SerializableLinkedList底层通过双向链表实现，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟List接口相关的函数，双向链表的每个节点用内部类Node表示。LinkedList通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。1234567891011//Node内部类private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用Collections.synchronizedList()方法对其进行包装。12//add()//add()方法有两个版本，一个是add(E e)，该方法在LinkedList的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是add(int index, E element)，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。结合上图，可以看出add(E e)的逻辑非常简单。123456789101112//add(E e)public boolean add(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode;//原来链表为空，这是插入的第一个元素 else l.next = newNode; size++; return true;&#125;add(int index, E element)的逻辑稍显复杂，可以分成两部，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。123456789101112131415161718//add(int index, E element)public void add(int index, E element) &#123; checkPositionIndex(index);//index &gt;= 0 &amp;&amp; index &lt;= size; if (index == size)//插入位置是末尾，包括列表为空的情况 add(element); else&#123; Node&lt;E&gt; succ = node(index);//1.先根据index找到要插入的位置 //2.修改引用，完成插入操作。 final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null)//插入位置为0 first = newNode; else pred.next = newNode; size++; &#125;&#125;上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件index &lt; (size &gt;&gt; 1)，也即是index是靠近前端还是后端。12//remove()//remove()方法也有两个版本，一个是删除跟指定元素相等的第一个元素remove(Object o)，另一个是删除指定下标处的元素remove(int index)。两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候remove(Object o)调用的是元素的equals方法，而remove(int index)使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个revome()方法都是通过unlink(Nodex)方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。123456789101112131415161718192021//unlink(Node&lt;E&gt; x)，删除一个NodeE unlink(Node&lt;E&gt; x) &#123; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123;//删除的是第一个元素 first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123;//删除的是最后一个元素 last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null;//let GC work size--; return element;&#125;123456//get()//get(int index)得到指定下标处元素的引用，通过调用上文中提到的node(int index)方法实现。public E get(int index) &#123; checkElementIndex(index);//index &gt;= 0 &amp;&amp; index &lt; size; return node(index).item;&#125;123456789//set()//set(int index, E element)方法将指定下标处的元素修改成指定值，也是先通过node(int index)找到对应下表元素的引用，然后修改Node中item的值。public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element;//替换新值 return oldVal;&#125;自定义栈集合123456789101112131415public class MyStack&#123; private LinkedList link; public MyStack()&#123; link = new LinkedList(); &#125; public void add(Object obj)&#123; link.addFirst(obj); &#125; public Object get()&#123; return link.removeFirst(); &#125; public boolean isEmpty()&#123; return link.isEmpty(); &#125;&#125;LinkList的特有功能123456789//添加功能public void addFirst(Object e);public void addLast(Object e);//获取功能public Object getFirst();public Object getLast();//删除功能public Object removeFirst();public Object removeLst();VectorVector的特有功能1234567//添加功能public void addElement(Object obj);//获取功能public Object elementAt(int index);public Enumeration elements(); boolean hasMoreElements(); Object nextElement();Vector的遍历123456789101112131415Vector v = new Vector();v.addElement("hello");v.addElement("world");v.addElement("java");//遍历for(int x = 0; x &lt; v.size(); x++)&#123; String s = (String)v.elementAt(x); System.out.println(s);&#125; System.out.println("------------");Enumeration en = v.elements();//返回的是实现类的对象while(en.hasMoreElements())&#123; String s = (String)en.nextElement(); System.out.println(s);&#125;Set(重点)Set接口扩展自Collection，它与List的不同之处在于，规定Set的实例不包含重复的元素。AbstractSet是一个实现Set接口的抽象类，Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。HashSet散列集HashSet是一个用于实现Set接口的具体类，可以使用它的无参构造方法来创建空的散列集，也可以由一个现有的集合创建散列集。在散列集中，有两个名词需要关注，初始容量和客座率。实际上HashSet就是基于后面介绍的HashMap而实现的，客座率是确定在增加规则集之前，该规则集的饱满程度，当元素个数超过了容量与客座率的乘积时，容量就会自动翻倍。1234567891011121314public class TestHashSet &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add("11111"); set.add("22222"); set.add("33333"); set.add("44444"); set.add("22222"); System.out.println(set.size()); for (String e : set) &#123; System.out.println(e); &#125; &#125;&#125;从输出结果我们可以看到，规则集里最后有4个元素，而且在输出时元素还是无序的。查看散列集HashSet的源码实现可以看到它内部是使用一个HashMap来存放元素的，因为HashSet的元素就是其内部HashMap的键集合，所以HashSet可以做到元素不重复。HashSet如何保证元素唯一性？底层数据结构是哈希表（元素是链表的数组）哈希表依赖于哈希值存储添加功能依赖两个方法：int hashCode();boolean equals(Object obj);在这里，首先比较哈希值hashCode()是否相同，如果相同，元素重复，不添加。比较地址值或者走equals()，如果不同就直接添加到集合中。如果类没有重写这两个方法，默认使用的Object()，一般来说不相同，而String类重写了hashCode()和equals()方法，所以他就可以把内容相同的字符串去掉，只留下一个。LinkHashSetLinkedHashSet是继承自HashSet的，支持对规则集内的元素排序。HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。底层数据结构由哈希表和链表组成TreeSetTreeSet扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。使用元素的自然顺序对元素进行排序，或者根据创建set时提供的Comparator进行排序，具体取决于使用的构造方法TreeSet如何保证元素的排序和唯一性？底层数据结构是一种自平衡的二叉树（红黑树）ComparableCompar to自然排序真正的比较是依赖于元素的compare to 方法，而这个方定义在comparable里要重写该方法，就必须先实现comparable接口元素的唯一性和如何存储第一个元素存储的时候，直接作为根节点存储从第二个元素开始，每个元素从根节点开始比较大就作为右孩子小作为左孩子相等不搭理元素是如何取出来的从根节点开始，按照左中右的原则依次取出元素即可保证元素的排序方式自然排序让元素所属的类实现Comparable接口比较器排序让集合构造方法接收Comparator的实现类对象Queue队列队列与栈是相对的一种数据结构。只允许在一端进行插入操作，而在另一端进行删除操作的线性表。栈的特点是后进先出，而队列的特点是先进先出。队列的用处很大，但大多都是在其他的数据结构中，比如，树的按层遍历，图的广度优先搜索等都需要使用队列做为辅助数据结构。单向队列单向队列比较简单，只能向队尾添加元素，从队头删除元素。比如最典型的排队买票例子，新来的人只能在队列后面，排到最前边的人才可以买票，买完了以后，离开队伍。这个过程是一个非常典型的队列。定义队列的接口：1234public interface Queue &#123; public boolean add(Object elem); // 将一个元素放到队尾，如果成功，返回true public Object remove(); // 将一个元素从队头删除，如果成功，返回true&#125;一个队列只要能入队，和出队就可以了。这个队列的接口就定义好了，具体的实现有很多种办法，例如，可以使用数组做存储，可以使用链表做存储。其实大家页可以看一下JDK源码，在java.util.Queue中，可以看到队列的定义。只是它是泛型的。基本上，Queue.java中定义的接口都是进队，出队。只是行为有所不同。例如，remove如果失败，会抛出异常，而poll失败则返回null,但它俩其实都是从队头删除元素。单向队列如果一个队列的头和尾都支持元素入队，出队，那么这种队列就称为双向队列，英文是Deque。大家可以通过java.util.Deque来查看Deque的接口定义，这里节选一部分：12345678910111213141516171819202122232425262728public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123; /** * Inserts the specified element at the front of this deque if it is * possible to do so immediately without violating capacity restrictions, * throwing an &#123;@code IllegalStateException&#125; if no space is currently * available. When using a capacity-restricted deque, it is generally * preferable to use method &#123;@link #offerFirst&#125;. * * @param e the element to add * @throws IllegalStateException if the element cannot be added at this * time due to capacity restrictions * @throws ClassCastException if the class of the specified element * prevents it from being added to this deque * @throws NullPointerException if the specified element is null and this * deque does not permit null elements * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this deque */ void addFirst(E e); void addLast(E e); E removeFirst(); E removeLast();&#125;最重要的也就是这4个，一大段英文，没啥意思，其实就是说，addFirst是向队头添加元素，如果不满足条件就会抛异常，然后定义了各种情况下抛出的异常类型。只要记住队列是先进先出的数据结构就好了，今天不必要把这些东西都掌握，一步步来。QueueQueue也继承自Collection，用来存放等待处理的集合，这种场景一般用于缓冲、并发访问。Queue是用于在处理之前保存元素的集合。除了基本的集合操作，队列提供了额外的插入、提取和检查操作。每个方法都有两种形式:一种是在操作失败时抛出一个异常，另一个则返回一个特殊值(根据操作的不同)(返回null或false)。插入操作的后一种形式是专门为有容量限制的队列实现而设计的;在大多数实现中，插入操作不会失败。1234567891011121314public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; //插入（抛出异常） boolean add(E e); //插入（返回特殊值） boolean offer(E e); //移除（抛出异常） E remove(); //移除（返回特殊值） E poll(); //检查（抛出异常） E element(); //检查（返回特殊值） E peek();&#125;可以看出Queue接口没有什么神秘面纱，都不需要揭开。不存在花里胡哨，就只有这6个方法。额外的添加、删除、查询操作。值得一提的是，Queue是个接口，它提供的add，offer方法初衷是希望子类能够禁止添加元素为null，这样可以避免在查询时返回null究竟是正确还是错误。实际上大多数Queue的实现类的确响应了Queue接口的规定，比如ArrayBlockingQueue，PriorityBlockingQueue等等。但还是有一些实现类没有这样要求，比如LinkedList。虽然 LinkedList 没有禁止添加 null，但是一般情况下 Queue 的实现类都不允许添加 null 元素，为啥呢？因为poll(),peek()方法在异常的时候会返回 null，你添加了null 以后，当获取时不好分辨究竟是否正确返回。PriorityQueuePriorityQueue又叫做优先级队列，保存队列元素的顺序不是按照及加入队列的顺序，而是按照队列元素的大小进行重新排序。因此当调用peek()或pool()方法取出队列中头部的元素时，并不是取出最先进入队列的元素，而是取出队列的最小元素。基于优先级堆的无界的优先级队列。PriorityQueue的元素根据自然排序进行排序，或者按队列构建时提供的 Comparator进行排序，具体取决于使用的构造方法。优先队列不允许 null 元素。通过自然排序的PriorityQueue不允许插入不可比较的对象。该队列的头是根据指定排序的最小元素。如果多个元素都是最小值，则头部是其中的一个元素——任意选取一个。队列检索操作poll、remove、peek和element访问队列头部的元素。优先队列是无界的，但有一个内部容量，用于管理用于存储队列中元素的数组的大小。基本上它的大小至少和队列大小一样大。当元素被添加到优先队列时，它的容量会自动增长。增长策略的细节没有指定。一句话概括，PriorityQueue使用了一个高效的数据结构：堆。底层是使用数组保存数据。还会进行排序，优先将元素的最小值存到队头。PriorityQueue的排序方式PriorityQueue中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化时指定的排序方式进行排序。需要注意的是，当PriorityQueue中没有指定的Comparator时，加入PriorityQueue的元素必须实现了Comparable接口（元素是可以进行比较的），否则会导致 ClassCastException。PriorityQueue本质Java中PriorityQueue实现了Queue接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树（complete binary tree）实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为PriorityQueue的底层实现。上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：leftNo = parentNo*2+1rightNo = parentNo*2+2parentNo = (nodeNo-1)/2通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。PriorityQueue的peek()和element操作是常数时间，add(), offer(), 无参数的remove()以及poll()方法的时间复杂度都是log(N)。PriorityQueue 本质也是一个动态数组，在这一方面与ArrayList是一致的。看一下它的构造方法：1234567891011121314151617 public PriorityQueue(int initialCapacity) &#123; this(initialCapacity, null); &#125;public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123; this(DEFAULT_INITIAL_CAPACITY, comparator); &#125;public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator; &#125;PriorityQueue调用默认的构造方法时，使用默认的初始容量（DEFAULT_IITIAL_CAPACITY = 11）创建一个PriorityQueue，并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的Comparable）。当使用指定容量的构造方法时，使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的Comparable）当使用指定的初始容量创建一个 PriorityQueue，并根据指定的比较器comparator来排序其元素。当添加元素到集合时，会先检查数组是否还有余量，有余量则把新元素加入集合，没余量则调用 grow()方法增加容量，然后调用siftUp将新加入的元素排序插入对应位置。除了这些，还要注意的是：PriorityQueue不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue 实例，这时请使用线程安全的PriorityBlockingQueue 类。不允许插入 null 元素。PriorityQueue实现插入方法（offer、poll、remove() 和 add 方法） 的时间复杂度是O(log(n)) ；实现 remove(Object) 和 contains(Object) 方法的时间复杂度是O(n) ；实现检索方法（peek、element 和 size）的时间复杂度是O(1)。所以在遍历时，若不需要删除元素，则以peek的方式遍历每个元素。方法iterator()中提供的迭代器并不保证以有序的方式遍历PriorityQueue中的元素。方法剖析add()和offer()add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于PriorityQueue这两个方法其实没什么差别。新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。123456789101112131415//offer(E e)public boolean offer(E e) &#123; if (e == null)//不允许放入null元素 throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1);//自动扩容 size = i + 1; if (i == 0)//队列原来为空，这是插入的第一个元素 queue[0] = e; else siftUp(i, e);//调整 return true;&#125;上述代码中，扩容函数grow()类似于ArrayList里的grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是siftUp(int k, E x)方法，该方法用于插入元素x并维持堆的特性。123456789101112//siftUp()private void siftUp(int k, E x) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1;//parentNo = (nodeNo-1)/2 Object e = queue[parent]; if (comparator.compare(x, (E) e) &gt;= 0)//调用比较器的比较方法 break; queue[k] = e; k = parent; &#125; queue[k] = x;&#125;新加入的元素x可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x &gt;= queue[parent]为止。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。element()和peek()element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。代码也就非常简洁：123456//peek()public E peek() &#123; if (size == 0) return null; return (E) queue[0];//0下标处的那个元素就是最小的那个&#125;remove()和poll()remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。代码如下：123456789101112public E poll() &#123; if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0];//0下标处的那个元素就是最小的那个 E x = (E) queue[s]; queue[s] = null; if (s != 0) siftDown(0, x);//调整 return result;&#125;上述代码首先记录0下标处的元素，并用最后一个元素替换0下标位置的元素，之后调用siftDown()方法对堆进行调整，最后返回原来0下标处的那个元素（也就是最小的那个元素）。重点是siftDown(int k, E x)方法，该方法的作用是从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止。123456789101112131415161718//siftDown()private void siftDown(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; //首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标 int child = (k &lt;&lt; 1) + 1;//leftNo = parentNo*2+1 Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c;//然后用c取代原来的值 k = child; &#125; queue[k] = x;&#125;remove(Object o)remove(Object o)方法用于删除队列中跟o相等的某一个元素（如果有多个相等，只删除一个），该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，remove(Object o)可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。具体代码如下：1234567891011121314151617//remove(Object o)public boolean remove(Object o) &#123; //通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标 int i = indexOf(o); if (i == -1) return false; int s = --size; if (s == i) //情况1 queue[i] = null; else &#123; E moved = (E) queue[s]; queue[s] = null; siftDown(i, moved);//情况2 ...... &#125; return true;&#125;ArrayDequeJava里有一个叫做Stack的类，却没有叫做Queue的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了（次选是LinkedList）。要讲栈和队列，首先要讲Deque接口。Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口：下表列出了Deque与Stack对应的接口：上面两个表共定义了Deque的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（false或null）。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。虽然Deque的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看。明白了这一点讲解起来就会非常简单。ArrayDeque和LinkedList是Deque的两个通用实现，由于官方更推荐使用AarryDeque用作栈和队列，加之上一篇已经讲解过LinkedList，本文将着重讲解ArrayDeque的具体实现。从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。上图中我们看到，head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。方法剖析addFirst()addFirst(E e)的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[—head] = e即可。实际需要考虑：空间是否够用，以及下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题。12345678//addFirst(E e)public void addFirst(E e) &#123; if (e == null)//不允许放入null throw new NullPointerException(); elements[head = (head - 1) &amp; (elements.length - 1)] = e;//2.下标是否越界 if (head == tail)//1.空间是否够用 doubleCapacity();//扩容&#125;上述代码我们看到，空间问题是在插入之后解决的，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。下标越界的处理解决起来非常简单，head = (head - 1) &amp; (elements.length - 1)就可以了，这段代码相当于取余，同时解决了head为负值的情况。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数（其实只可能是-1），则相当于对其取相对于elements.length的补码。下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。12345678910111213141516//doubleCapacity()private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; int r = n - p; // head右边元素的个数 int newCapacity = n &lt;&lt; 1;//原空间的2倍 if (newCapacity &lt; 0) throw new IllegalStateException("Sorry, deque too big"); Object[] a = new Object[newCapacity]; System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分 System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分 elements = (E[])a; head = 0; tail = n;&#125;addLast()addLast(E e)的作用是在Deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要elements[tail] = e;即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。1234567public void addLast(E e) &#123; if (e == null)//不允许放入null throw new NullPointerException(); elements[tail] = e;//赋值 if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)//下标越界处理 doubleCapacity();//扩容&#125;下标越界处理方式addFirt()中已经讲过，不再赘述。pollFirst()pollFirst()的作用是删除并返回Deque首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回elements[head]即可，当然还需要处理下标的问题。由于ArrayDeque中不允许放入null，当elements[head] == null时，意味着容器为空。12345678public E pollFirst() &#123; E result = elements[head]; if (result == null)//null值意味着deque为空 return null; elements[h] = null;//let GC work head = (head + 1) &amp; (elements.length - 1);//下标越界处理 return result;&#125;pollLast()pollLast()的作用是删除并返回Deque尾端元素，也即是tail位置前面的那个元素。123456789public E pollLast() &#123; int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置是最后一个元素 E result = elements[t]; if (result == null)//null值意味着deque为空 return null; elements[t] = null;//let GC work tail = t; return result;&#125;peekFirst()peekFirst()的作用是返回但不删除Deque首端元素，也即是head位置处的元素，直接返回elements[head]即可。123public E peekFirst() &#123; return elements[head]; // elements[head] is null if deque empty&#125;peekLast()peekLast()的作用是返回但不删除Deque尾端元素，也即是tail位置前面的那个元素。123public E peekLast() &#123; return elements[(tail - 1) &amp; (elements.length - 1)];&#125;Collection集合总结List 有序，可重复ArrayList底层数据结构是数组，查询快，增删慢线程不安全Vector底层数据结构是数组，查询快，增删慢线程安全，效率低LinkedList底层数据结构是链表，查询慢，增删快线程不安全，效率高Set 无序，唯一HashSet底层数据结构是哈希表如何保证元素的唯一性的呢？依赖两个方法：hashCode(),equals()开发中自动生成这个两个方法即可LinkedHashSet底层数据结构是链表和哈希表由链表保证元素有序有哈希表保证元素唯一TreeSet底层数据结构是红黑树如何保证元素排序的呢？自然排序比较器排序如何保证元素的唯一性的呢？根据比较的返回值是否是0来决定针对Collection集合我们到底使用谁呢？唯一吗？是：Set排序吗？是：TreeSet否：HashSet如果你知道是Set，但不知道是哪个Set，就用HashSet否：List要安全吗？是：Vector否：ArrayList或者LinkedList查询多：ArrayList增删多：LinkedList如果你知道是List，但不知道是哪个List，就用ArrayList如果你知道是Collection集合，但不知道使用谁，就用ArrayList如果你知道用集合，就用ArrayList在集合中常见的数据结构ArrayXxx：底层数据结构是数据，查询快，增删慢LinkedXxx：底层数据结构是链表，查询慢，增删快HashXxx：底层数据结构是哈希表，依赖两个方法：hashCode()和equals()TreeXxx：底层数据结构是二叉树，两种排序方法：自然排序和比较器排序]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE集合框架</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-面向对象2]]></title>
    <url>%2Fcategory%2FJavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12%2F</url>
    <content type="text"><![CDATA[面向对象2继承关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为超类，基类或父类，新类称为子类。派生类等。子类比超类拥有的功能更加丰富。在通过扩展父类定义子类的时候，仅需要指出子类与超类的不同之处。因为在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。由于子类的构造器不能访问父类的私有域，所以必须利用父类的构造器对这部分私有域进行初始化，我们可以通过super实现对父类构造器的调用，使用super调用构造器的语句必须是子类构造器的第一条语句。如果子类的构造器没有显示的调用父类构造器，则将自动的调用超类默认的构造器，如果超类没有不带参数的构造器，并且子类的构造器中又没有显示的调用超类其他的构造器，则Java编译器将报告错误。由一个公共超类派生出来的所有类的集合被称为继承层次，从某个特定的类到其祖先的路径称为该类的继承链。把多个类中相同的内容给提取出来定义到一个类中例如1234567891011121314151617181920class dog&#123; String name; int age; public void eat(String name)&#123; System.out.println(name+"吃饭"); &#125; public void sleep(String name)&#123; System.out.println(name+"睡觉"); &#125;&#125;class cat&#123; String name; int age; public void eat(String name)&#123; System.out.println(name+"吃饭"); &#125; public void sleep(String name)&#123; System.out.println(name+"睡觉"); &#125;&#125;像这种情况，可以把公共的提取出来，然后去继承提取的那个类，也就是父类123456789101112131415161718class animal&#123; //animal类可以看作所有动物类的父类，任何动物都可以有名字，年龄，都会吃饭睡觉，所以将这些公共的提取出来，那么子类只需要继承这个类便拥有这些方法以及成员变量 String name; int age; public void eat(String name)&#123; System.out.println(name+"吃饭"); &#125; public void sleep(String name)&#123; System.out.println(name+"睡觉"); &#125;&#125;class dog extends animal()&#123; //这里子类dog就拥有父类animal的成员变量以及方法，可以对其赋值或者方法的重写&#125;class cat extends animal()&#123; &#125;像这样的extends关系就叫做继承，但是继承中子类不能继承父类的私有成员，构造方法(但可以通过super去访问)，继承体现的是is a的关系，在java中只支持单继承，但可以多层继承(继承体系)继承的标准格式就是：class 子类名 extends 父类名{}使用了继承有什么好处呢？提高了代码的复用性提高了代码的维护性让类与类之间产生了关系，是多态的前提(同时这一点也是弊端，当类与类之间产生了关系，就不可避免的会有耦合，然而在开发原则里明确表示：低耦合高内聚，当耦合度高了可以这么形容，”牵一发而动全身“)假设我们有这么一个需求，有一家做信息检索的公司，他们需要对手机的各个品牌做一个统计以及对比，现在需要开发一个软件，需要编写entity，在使用继承并且掌握现有知识的前提下如何去设计呢？首先我们应该分析一下，这家公司对产品内不同品牌进行对比，那么主题是手机，手机下有不同的品牌123456789101112131415161718192021222324252627//假设我们手机有这些功能以及参数class Phone()&#123; double size; String color; String name; String cpu_id; int ram_size; int rom_size; int camera_pixel;//摄像头像素 ... public void takePhone()&#123; System.out.println("打电话"); &#125; public void takePhoto()&#123; System.out.println("拍照"); &#125; ...&#125;//我现在有一个华为手机，那么我定义一个类HuaweiPhone继承Phoneclass HuaweiPhone extends Phone&#123; //在这里我就不用每添加一个品牌再去写那些共有的特性，而是去继承父类，如果功能有特殊的那么重写或新加 int camera_num; //摄像头数量 public void takeMaxPhoto()&#123; System.out.println("夜拍，徕卡相机拍更厉害的照片"); &#125;&#125;//同样小米手机，等其他手机也是类似，当我们新加一个手机品牌那么只需要继承这个类即可，再去写我们特有的功能在上述代码中可能会好奇，为什么只是写了一个关键字extends，子类便可以使用父类的成员变量，成员方法。继承中构造方法：在继承体系中，子类会继承父类中的数据，可能还会使用父类的数据。那么我们知道，在一个类中，给成员变量赋值有两种方法，一种是用方法赋值，一种是构造方法赋值。用构造方法赋值在new一个对象时需要对有参的构造方法传入值。而构造方法当自己没有声明，java会帮你写一个无参的构造方法。但是当你写了一个有参的构造方法如果还要使用无参的构造方法必须声名一个。系统不会再帮你生成无参构造方法。在这里，子类的构造方法默认访问了父类中空参数的构造方法，从而构造出父类对象。构造方法用于初始化一个实例对象，所以static修饰是没有任何意义的;多个线程不会同时创建内存地址相同的同一个对象，所以synchronized修饰没有意义;构造方法不能被子类继承，所以final和abstract修饰没有意义构造方法是没有返回类型的，void也不行。当用户没有给java类定义明确的构造方法的时候,java为我们提供了一个默认的构造方法,这个构造方法没有参数,修饰符是public并且方法体为空。如果用户有定义构造方法，就不会有默认构造方法！！！其实默认的构造方法还分为两种,一种就是刚刚说过的隐藏的构造方法,另一种就是显示定义的默认构造方法.如果一个类中定义了一个或者多个构造方法,并且每一个构造方法都是带有参数形式的,那么这个类就没有默认的构造方法（需要显示的声明无参构造方法）this与super：“this”的用法：实例方法中可以使用this关键字,它指向正在执行方法的类的实例对象,当然static方法中是不可以使用this对象的,因为静态方法不属于类的实例对象;而构造方法中同样可以使用this关键字,构造器中的this是指向同一个对象中不同参数的另一个构造器。构造方法中通过this关键字调用其他构造方法时,那么这句代码必须放在第一行,否则会编译错误。构造方法中只能通过this调用一次其他的构造方法。“super”的用法：实例方法和构造方法中的super关键字都用于去指向父类,实例方法中的super关键字是去调用父类当中的某个方法构造器中使用super关键字调用父类中的构造器在实例化子类对象时,程序会先调用父类的默认构造方法,然后再执行子类的构造方法。在实例化类的对象时,类中的成员变量会首先进行初始化,如果其中的成员变量有对象，那么它们也会按照顺序执行初始化工作。在所有类成员初始化完成后，才调用对象所在类的构造方法创建对象。构造方法作用就是初始化。如果一个类中有静态对象,那么他会在非静态对象初始化前进行初始化,但只初始化一次。而非静态对象每次调用时都要初始化。程序中主类的静态变量会在main()方法执行前初始化一个类初始化顺序：父类的静态成员—&gt;子类的静态成员—&gt;父类的非静态成员—&gt;父类的默认构造函数被调用—&gt;子类的非静态对象（变量）—&gt; 子类的构造函数。继承中成员方法的关系子类中的方法和父类中的方法声明不一样 直接调用子类中的方法和父类中的方法声明一样：通过子类调用方法：先找子类中看有没有这个方法，有就使用再看父类有没有这个方法，有就使用如果没有就报错方法重写与方法重载方法重写（Override）：子类中出现了和父类中方法声明一模一样的方法方法重载（Overload）：本类中出现的方法名一样，参数列表不同的方法。与返回值无关子类对象调用方法的时候：先找子类本身，再找父类方法重写的应用：当子类需要父类的功能，而功能主体子类有自己的特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。注意事项：父类中私有的方法不能被重写子类重写父类方法是，访问权限不能更低父类静态方法，子类必须通过静态方法进行重写子类重写父类方法的时候，最好声明一模一样多态同一个对象（事务），在不同时刻体现出来的不同状态比如小米手机是小米手机同样也是手机在上面的例子中当Phone p = new XiaomiPhone()可以看作是多态多态的前提：要有继承关系，要有方法重写（也可以没有，但是没有这个就没有意义）要有父类引用子类对象fu f = new zi()多态中成员访问特点：成员变量编译看左边，运行看左边构造方法创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化成员方法编译看左边，运行看右边静态方法编译看左边，运行看左边（静态和类相关，算不上重写，所以访问还是左边的）由于成员方法存在方法重写，所以它运行看右边。多态的好处提高了代码的维护性（继承保证）提高了代码的扩展性（多态保证）多态的弊端不能使用子类的特有功能。父类使用子类特有功能创建子类对象调用方法即可（可以，但是很多时候不合理，而且太占内存）把父类的引用强制转换为子类的引用（向下转型）12345//对象间转型问题//向上转型Fu f = new Zi();//向下转型Zi z = new (Zi)f;//要求该f必须能够转换为Zi的多态中的内存图解：对象变化内存图解：封装封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。使用封装有三大好处：良好的封装能够减少耦合。类内部的结构可以自由修改。可以对成员进行更精确的控制。隐藏信息，实现细节。所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。可以对成员变量进行更精确的控制Package关键字包的概述：其实就是文件夹作用：把对相同的类名放到不同的包中对类进行分类管理包的定义：Package 包名；多级包用.分开注意事项：package语句必须是程序的第一条可执行的代码package语句在一个java文件中只能有一个如果没有package，默认表示无包名带包的编译和运行：手动式编写一个带包的Java文件通过Javac命令编译该Java文件手动创建包名把b步骤的class文件放到c步骤的最低层包回到和包根目录在同一个目录的地方，然后运行带包运行自动式编写一个带包的java文件javac编译的时候带上-d即可Javac -d .HelloWorld.java回到和包根目录在同一个目录的地方，然后运行带包运行import关键字的概述和使用导包：格式：import 包名；这种方式导入是到类的名称。注意：我们用谁就导谁面试题：package，import，class有没有顺序关系？有package&gt;import&gt;classpackage：只能有一个import：可以有多个class：可以有多个，建议是一个四种权限修饰符本类同一个包下（子类和无关类）不同包下（子类）不同包下（无关类）privateY默认（default）YYprotectedYYYpublicYYYY类及其组成所使用的常见修饰符修饰符：权限修饰符：private，默认修饰符，protected，public状态修饰符：static，final抽象修饰符：abstract类：权限修饰符：默认修饰符，public状态修饰符：final抽象修饰符：abstract用的最多的就是public成员变量：权限修饰符：private，默认修饰符，protected，public状态修饰符：static，final用的最多的就是，private构造方法：权限修饰符：private，默认修饰符，protected，public用的最多的就是public成员方法：权限修饰符：private，默认修饰符，protected，public状态修饰符：static，final抽象修饰符：abstract用的最多的就是public除此以外的组合规则：成员变量：public static final成员方法：public staticpublic abstractpublic final类初始化过程类初始化过程加载class文件进内存在栈内存开辟空间在对内存为类对象开辟空间对对象的成员变量进行默认初始化对对象的成员变量进行显示初始化通过构造方法对对象的成员变量赋值对象初始化完毕，吧对象地址复制给变量对象析构与finalize方法：在析构器中最常见的操作是回收分配给对象的存储空间，但Java不支持析构器，可以为任何一个类添加finalize方法，将在垃圾回收器清除对象之前调用。动态绑定：调用对象方法的执行过程：编译器查看对象的声明类型和方法名编译器查看调用方法时提供的参数类型如果是private方法、static方法、final方法、或者构造器，那么编译器将准备的知道该调用哪个方法，这种调用方式为静态绑定。调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。当程序运行时，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。虚拟机为了节省开销和时间，为每个类预先创建了一个方法表。内部类把类定义在其他类的内部，这个类就被称为内部类1234class Outer&#123; class Inner&#123; &#125;&#125;内部类的访问特点内部类可以直接访问外部类的成员，包括私有外部类要访问内部类的成员，必须创建对象123456789101112class Outer&#123; private int num = 10; class Inner&#123; public void show()&#123; System.out.println(num); &#125; public void method()&#123; Inner i = new Inner(); i.show(); &#125; &#125;&#125;内部类位置：成员位置：在成员位置定义的类，称为成员内部类。局部位置：在局部位置定义的类，称为局部内部类成员内部类：如何直接访问内部类的成员：外部类名.内部类名 对象名 = 外部类对象.内部类对象123456789101112class Outer&#123; private int num = 10; class Inner&#123; public void show()&#123; System.out.println(num); &#125;&#125; class InnerClassDemo&#123; public static void main(Stringp[] args)&#123; Outer.Inner oi = new Outer().new Inner(); &#125; &#125;成员内部类的修饰符：private 为了保证数据的安全性static 为了方便访问数据注意：静态内部类访问的外部类数据必须用静态修饰成员内部类被静态修饰后的访问方式是：格式：外部类名.内部类名 对象名 = new 外部类名.内部类名();12345678910111213141516171819202122class Outer&#123; private int num = 10; private static int num2 = 100; public static class Inner&#123; public void show()&#123; System.out.println(num2); &#125; public static void show2()&#123; System.out.println(num2); &#125; &#125;&#125;class InnerClassDemo&#123; public static void main(String[] args)&#123; Outer.Inner oi = new Outer.Inner(); oi.show(); oi.show2(); //show2另一种调用方式 Outer.Inner.show2(); &#125;&#125;局部内部类：可以直接访问外部类的成员在局部位置，可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能面试题：局部内部类访问局部变量的注意事项？局部内部类访问局部变量必须用final修饰为什么呢？局部变量是随着方法的额调用而调用，随着调用完毕而消失。而堆内存的内容并不会立即消失，所以我们加final修饰。加入final修饰后，这个变量就常量。123456789101112class Outer&#123; private int num = 10; public void method()&#123; class Inner&#123; public void show()&#123; System.out.println(num); &#125; &#125; Inner i = new Inner() i.show(); &#125;&#125;匿名内部类就是内部类的简化写法前提：存在一个类或者接口这里的类可以是具体类也可以是抽象类格式：123new 类名或者接口名()&#123;重写方法;&#125;本质是什么呢？是一个继承了该类或者实现了该接口的子类匿名对象123456789101112interface Inter&#123; public abstract void show();&#125;class Outer&#123; public void method()&#123; new Inter()&#123; public void show()&#123; System.out.println("show"); &#125; &#125;; &#125;&#125;匿名内部类的方法调用调用一个方法：123456789101112interface Inter&#123; public abstract void show();&#125;class Outer&#123; public void method()&#123; new Inter()&#123; public void show()&#123; System.out.println("show"); &#125; &#125;.show(); &#125;&#125;调用多个方法：12345678910Inter i = new Inter()&#123;//多态 public void show()&#123; System.out.println("show"); &#125; public void show2()&#123; System.out.println("show2"); &#125;&#125;;i.show();i.show2();匿名内部类在开发中的应用：1234567891011121314151617181920212223242526272829303132333435interface Person&#123; public abstract void study();&#125;class PersonDemo&#123; //接口名作为形式参数 //这里需要的不是接口，而是接口的实现类的对象 public void method(Person p)&#123; p.study(); &#125;&#125;//实现类class Student implements Person&#123; public void study()&#123; System.out.println("好好学习，天天向上"); &#125;&#125;class InnerClassDemo&#123; public static void main(String[] args)&#123; //测试 PersonDemo pd = new PersonDemo(); Person p = new Person(); pd.method(p); Systemout.println("------"); //匿名内部类在开发中的使用 //匿名内部类的本质是继承类或者实现了接口的子类匿名对象 pd.method(new Person()&#123; public void study()&#123; System.out.println("好好学习，天天向上"); &#125; &#125;); &#125;&#125;内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据内部类可以对同一个包中的其他类隐藏起来当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷内部类可以直接访问外部类的成员，包括私有外部类要访问内部类的成员，必须创建对象内部类的位置:成员位置:成员内部类外部类名.内部类名 对象名 = 外部类对象.内部类对象private:私有。 外部类创建方法，方法内创建对象，调用内部类方法。Static(为了方便访问数据)内部类用静态修饰是因为内部类可以看出是外部类的成员,内部类被静态修饰后，访问外部类数据必须用静态修饰局部位置:局部内部类使用内部类访问对象状态:内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。内部类的特殊语法规则:OuterClass.this:表示外围类引用OuterClass.InnerClass:在外围类的作用域之后，引用内部类局部内部类:局部类不能用public或private访问说明符进行声明。它的作用域被限定在声明这个具备类的块中。局部类有一个优势，即对外部世界可以完全的隐藏起来。可以直接访问外部类成员在局部位置，可以创建内部类对象，通过内部类对象，通过对象内部类方法，来使用局部内部类功能匿名内部类:假如只创建这个类的一个对象，就不必命名，这种类被称为匿名内部类new SuperType(construction parameters){Inner class methods and data}由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器，取而代之的是，将构造器参数传递给超类构造器，尤其是内部类实现接口的时候，不能有任何构造参数。前提:存在一个类或者接口，这里的类可以是具体类也可以是抽象类new 类名或者接口名(){重写方法;}本质是一个继承了该类或者实现了该接口的子类匿名对象静态内部类:有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象，为此，可以将内部类声明为static，以便取消产生的引用抽象类我们把一个不是具体的功能成为抽象的功能，而一个类中如果有抽象的功能，该类必须是抽象类。抽象类的特点抽象类和抽象方法必须用abstract关键字修饰抽象类中不一定有抽象方法，但是有抽象方法的类必须定义为抽象类抽象类不能实例化因为它不是具体的抽象类有构造方法，但是不能实例化？构造方法的作用是什么呢？用于子类访问父类数据的初始化抽象的子类如果不想重写抽象方法，该子类是一个抽象类重写所有的抽象方法，这个时候子类是一个具体的类抽象类的实例化其实是靠具体的子类实现的。是多态的方式Phone p = new HuaweiPhone();12345678910111213141516171819202122abstract class Phone&#123; //没有方法体&#123;&#125;，抽象方法不能有具体实现，空方法体也会报错 public abstract void takePhone(); public Phone()&#123;&#125;&#125;//子类是抽象类abstract class HuaweiPhone extends Phone&#123; &#125;//子类是具体类，重写抽象方法class XiaomiPhone extends phone&#123; pulic void takePhone()&#123; System.out.println("打电话"); &#125;&#125;public class AbstractDemo&#123; public static void main(String[] args)&#123; //创建对象，Phone是抽象的，无法实例化，通过多态方式 Phone p = new XiaomiPhone(); p.takePhone(); &#125;&#125;抽象类的成员特点成员变量：既可以是变量，也可以是常量。构造方法：有用于子类访问父类数据的初始化成员方法：既可以是抽象的，也可以是非抽象的抽象类的成员方法特性：一个类如果没有抽象方法，可不可以定义为抽象类？如果可以，有什么意义可以不让创建对象abstract不能和哪些关键字共存private 冲突final 冲突static 无意义接口接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。接口中的所有方法属于public，因此在声明方法时，不必提供关键字public。接口中不能含有实例域，也不能在接口中实现方法。提供实例域和方法的任务应该由实现接口的那个类完成，因此，可以将接口看成是没有实例域的抽象类，但概念有一定区别。定义接口 public interface 类名类实现接口 class 类名 implements 接口名接口中的域将被自动设为public static final接口不能实例化，可以按照多态的方式来实例化接口的子类:可以使抽象类，意义不大可以是具体类，要重写接口中的所有抽象方法(推荐)接口的成员特点:成员变量: 只能是常量，并且是静态的默认修饰符:public static final构造方法:接口没有构造方法成员方法:只能是抽象方法默认修饰符:public abstract具体类多态（几乎没有）抽象类多态（常用）接口多态（最常用）接口与回调:回掉是一种常见的程序设计模式，在这种模式中，可以指出某个特定事件发生时应该采取的动作。12345678910111213141516171819interface Phone5G&#123; public abstract void fast();&#125;//抽象类实现接口abstract class HuaweiPhone implements Phone5G&#123; &#125;//具体类实现接口class XiaomiPhone implements Phone5G&#123; public void fast()&#123; System.out.println("实现5G更快了"); &#125; class InterfaceDemo&#123; public static void main(String[] args)&#123; Phone5G p = new XiaomiPhone(); p.fast(); &#125; &#125;&#125;接口的成员特点成员变量：只能是常量，并且是静态的。默认修饰符：public static final构造方法：接口中没有构造方法成员方法：只能是抽象方法默认修饰符： public abstract类与类，类与接口，接口与接口之间的关系类与类：继承关系，只能单继承，可以多层继承类与接口：实现关系，可以单实线，也可以多实现并且还可以再继承一个类的同时实现多个接口接口与接口：继承关系，可以单继承，也可以多继承抽象类与接口的区别成员区别抽象类：成员变量可以变量可以常量构造方法有成员方法可以抽象可以非抽象接口：成员变量只可以常量成员方法只可以抽象关系区别类与类继承，单继承类与接口实现，单实现，多实现接口与接口继承，单继承，多继承设计理念区别抽象类被继承体现的是：“is a“的关系。抽象类中定义的是该继承体系的共性功能接口被实现体现的是：“like a”的关系。接口中定义的是该继承体系的扩展功能对象克隆当拷贝一个变量时，原始变量与拷贝变量引用同一个对象，改变一个变量所引用的对象将会对另一个变量产生影响。如果创建一个对象的新的copy，它的最初状态与原始对象一样，但以后将可以各自改变各自的状态，那就需要使用clone方法。Clone方法是Object类的一个proteced方法克隆需要实现Cloneable接口（标记接口），使用public访问修饰符重新定义clone方法]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE面向对象</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-基础语法]]></title>
    <url>%2Fcategory%2FJavaSE-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaSE-基础语法关键字被Java语言赋予特定含义的单词特点：全部小写，goto和const作为保留字存在abstractassertbooleanbreakbytecasecatchcharclassconstcontinuedefaultdodoubleelseenumextendsfinalfinallyfloatforgotoifimplementsimportinstanceofintinterfacelongnativenewpackageprivateprotectedpublicreturnstrictfpshortstaticsuperswitchsynchronizedthisthrowthrowstransienttryvoidvolatilewhile标识符给类、接口、方法、变量等起名的字符序列组成规则：数字、字母、下划线和$（见名知意），不能以数字开头，不能是java中的关键字，区分大小写1234int count = 10;float size01 = 25.0F;double size_02 = 30.23;char size$03 = 'a';常量字面值常量在程序执行过程中，其值不发生改变的量，常量在编译阶段会存入到调用这个常量的方法所在类的常量池中。并且调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。字符串常量“a”、”hello”、等双引号括起来的常量12String s = "a";String s2 = "hello";整数常量1、2、123等数值类型常量12int a = 1;int b = 2;小数常量12.345等小数形式常量1float f = 12.32F;字符常量‘a’、’A’、’0’等用单引号括起来的常量可与是英文字母、数字、标点符号以及由转义序列来表示的特殊字符。’\u0000’表示一个空白字符，即在单引号之间没有任何字符，之所以能这样表示，是因为Java采用Unicode字符集，Unicode字符以\u开头，空白字符在Unicode码表中对应的值为’\u0000’12char c = 'a';char c1 = 'A';布尔常量只有两种值类型的常量：true/false12boolean b = true;boolean b1 = false;自定义常量利用关键字final指示常量，表示这个变量只能被赋值一次，且常量名建议使用全大写1final int MAX_SIZE = 10;变量变量就是程序运行中可变的量，定义格式：数据类型 变量名 = 初始化值;1int a = 10;在Java中，每一个变量属于一种数据类型，在生命变量时，变量所属的类型位于变量之前，变量就是指在程序执行过程中值在某个范围内可以发生改变的量。声明一个变量后，必须使用赋值语句对变量进行显示初始化，变量的声明尽可能靠近变量第一次使用的地方。数据类型1、基本数据类型Java种基本数据类型有4类8种分别为：整数类型数据类型默认值大小取值范围byte08bit == 1byte-128~127short016bit == 2byte-32768~32767int032bit == 4byte-2147483648~2147483647long0L64bit == 8byte-9223372036854775808~9223372036854775807123456789101112//整数byte b = 1;short s = 2;int i = 4;long l = 8L;byte b4 = 3 + 4;/* 这里不报错是因为右边先进行计算，得到数值然后进行判断，是否在byte的范围内， 如果在就不报错，如果不在就报错*///byte b5 = 100+150; 报错浮点数类型数据类型默认值大小取值范围float0.0f32bit == 4byte1.4E-45~3.4028235E38double0.064bit == 8byte4.9E-324~1.7976931348623157E308123456789101112131415//浮点数float f = 4.0F;double d = 8.0;//float f2 = 3.14; 报错/* 可以看到这里会报错，是因为在定义浮点类型数据的时候如果不加修饰符默认是double类型 当double赋值给float，大类型转小类型则会报错*/float f3 = 3.1415F;float f4 = (float) 3.1415; //这里加了强制类型转换，所以也不报错/* 那f3、f4有什么区别吗？ f3定义的是一个float类型，f4最初定义的是一个double类型，然后强制转换成float类型*/字符类型数据类型默认值大小取值范围char‘\u0000’16bit == 2byte0~655312//字符类型char c = 'a';布尔类型数据类型默认值大小取值范围布尔类型false8bit == 1bytetrue/false12//布尔类型boolean bool = false;数据类型转换数据类型转换:(隐式转换)byte、short、char —&gt; int —&gt; long —&gt; float —&gt; doublebyte、short、char之间不参与相互转换，直接转换成int类型参与运算强制类型转换:(强制转换)格式:目标数据类型 变量名 = (目标数据类型) (被转换的数据)强制类型转换会损失精度。2、引用类型底层结构和基本类型差别较大类类型当传入的值是一个类类型时，需要传入的是该类的对象接口类型当传入值是一个接口类型时，需要传入的是该接口的实现类对象数组类型枚举注解运算符算数运算符+、-、*、/、%、++、—++在前，先自增再运算，++在后先运算再自增—同理12345678910a = 3；b = 4；b = a++;//在这里，++在后，先赋值再自增System.out.println("a: "+ a+"b: "+b);//a = 4 , b = 4c = a;c = ++b;System.out.println("b: "+ b+"c: "+c);//b = 5 , c = 5d = c;d = --a + b--;System.out.println("a: "+ a+"b: "+b+"d "+d);//a = 3 , b = 4 , d = 8赋值运算符=、+=、-=、*=、/=、%==代表赋值运算符，将右边的值赋给左边在这里需要注意+=、-=、=、/=、%=。这代表的是一个运算符，相对于+、-、、/，如果在等号两边数据类型不一致时，+=会进行自动类型转换1234byte a = 1;byte b = 2;a = a + b; //这里会报错，因为a和b是byte类型，执行完相加赋值给a时会自动转为int类型，而a是byte类型，就会出现类型不匹配问题这里相当于 a = (int) a + b;a += b; //这里不会报错，+=在运算时会自动进行类型转换总结：+ 、+=举例+：在编译将右边表达式结果计算出来后，和左边的变量类型比较精度，如果左边的精度低于右边的结果的精度，编译器会显式的报错，告诉程序员去强制转型。所以（a = a+b;）会报错，最后将表达式的结果复制到变量所在的内存区+=：编译器自动隐式直接将+=运算符后面的操作数强制装换为前面变量的类型，然后在变量所在的内存区上直接根据右边的操作数修改左边变量内存存储的二进制数值所以 （a += b;）不报错最后达到和赋值运算符相同的目的。与前者相比，由于后者是位操作，效率也较前者高。比较运算符==、！=、&gt;、&lt;、&gt;=、&lt;===代表判断是否相等，比较运算符返回值都是boolean类型在这里需要注意的是，==比较基本数据类型时比较的是值，比较引用类型时比较的是两个对象的地址值逻辑运算符&amp;、|、^、!、&amp;&amp;、||逻辑运算符用来连接boolean类型的表达式&amp;(逻辑与)：有false则false|(逻辑或)：有true则true^(异或)：相同则false，不同则true!(非)：非true则false，非false则true&amp;&amp;(短路与)：和&amp;相同，不过有短路效果，左边是false，右边不执行||(短路或)：和|相同，有短路效果，左边是true，右边不执行位运算符操作二进制&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;、&amp;、|、^、~&lt;&lt;：左移，空位补0，被移除的最高位丢弃3 &lt;&lt; 2 = 12 ——- 3 2 2 = 12.&gt;&gt;：右移，被移位的二进制最高位是0，右移后，空缺位补0，最高位是1.最高位补13 &gt;&gt; 1 = 1 ——- 3/2=1.&gt;&gt;&gt;：无符号右移，被移位二进制最高位无论是0或者是1，空缺位都用0补3 &gt;&gt;&gt; 1 = 1 ——- 3/2=1&amp;：与运算，任何二进制位和0进行&amp;运算，结果是0，和1进行&amp;运算结果是原值6&amp;3=2|：或运算，任何二进制位和0进行|运算，结果是原值，和1进行|运算结果是16|3=7^：异或运算，任何相同二进制位进行^运算，结果是0，不相同二进制位^运算结果是16^3=5一个数据对另外一个数据异或两次，该数不变~：反码~6=-7三元运算符格式：比较表达式?表达式1:表达式2;执行流程：首先计算比较表达式的值，是true就执行表达式1，是false就执行表达式2123int a = 3;int b = 4;a &gt; b ? ++a : ++b;控制流条件语句If(condition) statement这里的条件必须用括号括起来If(condition) statement1 else statement21234567891011public static void main(String[] args)&#123; int a = 3; int b = 4; if(a&gt;b)&#123; a++; &#125;else if(a == b)&#123; a--; &#125;else&#123; b++ &#125;&#125;循环while循环当条件是true时，while循环执行一条语句。While(condition) statement12345public static void main(String[] args)&#123; while(true)&#123; System.out.println("这是一个死循环"); &#125;&#125;do-while循环先执行语句，再检测循环条件Do statement while (condition);123456public static void main(String[] args)&#123; int n = 1; do&#123; System.out.println("我数到第"+n+"个数了"); &#125;while(n&gt;0);&#125;确定循环for(初始化语句;判断条件语句;控制条件语句){循环体语句;}1234567//九九乘法表for (int x = 1; x &lt;= 9; x++) &#123; for (int y = 1; y &lt;= x; y++) &#123; System.out.println(x + "*" + y + "=" + x * y + "\t"); &#125; System.out.println();&#125;for each循环Java有一种功能很强的循环结构，可以用来依次处理数组中的每个元素for(variable: collection) statement多重选择123456789101112131415Switch (chioce)//这里可选择数据类型有：基本数据类型，引用类型String，以及枚举和基本类型的封装类型&#123;case 1:…break;case 2:…break;...defalut:…break;&#125;在这里简单说一下break、continue、return三者的区别？break语句的使用场合主要是switch语句和循环结构。在循环结构中使用break语句，如果执行了break语句，那么就退出循环，接着执行循环结构下面的第一条语句。如果在多重嵌套循环中使用break语句，当执行break语句的时候，退出的是它所在的循环结构，对外层循环没有任何影响。如果循环结构里有switch语句，并且在switch语句中使用了break语句，当执行switch语句中的break语句时，仅退出switch语句，不会退出外面的循环结构。break可以跳出单层循环，也可以跳出多层循环（需要标签语句配合）123456789101112131415161718int n = 1;do&#123; System.out.println("我数到第"+n+"个数了"); break;//这里可以看到，break跳出do-while循环，接着执行while循环&#125;while(n&gt;0);while(n&lt;100)&#123; System.out.println("这是一个循环"); n++;&#125;//输出结果/*我数到第1个数了这是一个循环这是一个循环这是一个循环...*/continue语句是最特殊的，因为它并没有真的退出循环，而是只结束本次循环体的执行，所以在使用continue的时候要注意这一点。在for循环中，首先执行表达式1（注意表达式1在整个循环中仅执行一次），接着执行表达式2，如果满足条件，那么执行循环体，如果在循环体中执行了continue语句，那么就跳转到表达式3处执行，接下进行下一次循环，执行表达式2，看是否满足条件；在while循环中，如果执行了continue语句，那么就直接跳转到表达式处，开始下一次的循环判断；在do while循环体中如果执行了continue语句，那么就跳转到表达式处进行下一次的循环判断，return语句，如果在程序中遇到return语句，那么代码就退出该函数的执行，返回到函数的调用处，如果是main()函数，那么结束整个程序的运行。JavaSE12扩展Switch语句大数值如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类:BigInteger和BigDecimal。前者实现了任意精度的整数运算，后者实现了任意精度的浮点数运算。使用静态的valueOf方法可以将普通的数值转换为大数值处理大数值用大数值类中的add和multiply方法。123BigInteger a = BigInteger.valueOf(100);BigInteger c = a.add(b); //c=a+b;BigInteger d = c.multiply(b.add(BigInteger.valueOf(2)));//d=c*(b+2)BigInteger：任意精度的整数运算BigDecimal：任意精度的浮点数运算12345678910111213141516171819202122232425262728293031/*** 下面的方法都来自：java.math.BigInteger 包*/BigInteger add(BigInteger other)BigInteger subtract(BigInteger other)BigInteger multiply(BigInteger other)BigInteger divide(BigInteger other)BigInteger mod(BigInteger other)/* 返回这个大整数和另一个大整数 other 的和、差、积、商以及余数 */int compareTo(BigInteger other)/* 如果这个大整数与另一个大整数 other 相等，返回 0；如果这个大整数小于另一个大整数 other，返回负数；否则，返回正数 */static BigInteger valueOf(long x)/* 返回值等于 x 的大整数 */BigDecimal add(BigDecimal other)BigDecimal subtract(BigDecimal other)BigDecimal multiply(BigDecimal other)BigDecimal divide(BigDecimal other)/* 返回这个大实数和另一个大实数 other 的和、差、积、商。在此，需要注意的是：想要计算商，必须给出舍入方式，例如 RoundingModel.HALF_UP */int compareTo(BigDecimal other)/* 如果这个大实数与另一个大实数 other 相等，返回 0；如果这个大实数小于另一个大实数 other，返回负数；否则，返回正数 */static BigDecimal valueOf(long x)static BigDecimal valueOf(long x, int scale)/* 返回值等于 x 或者 x/10^(scale) 的大实数 */进制进制也就是进位制，是人们规定的一种进位方法。对于任何一种进制—-X进制，就表示某一位置上的数运算时是逢X进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x进制就是逢x进位。二进制用8个这样的信号来表示一个数据，这个数据的单位叫做：字节1 byte = 8 bit1k = 1024byte1m = 1024k通过数字1,0来表示开关，这样由1,0组成的数据就是二进制数据二进制数有两个特点：它由两个基本数字0，1组成，二进制数运算规律是逢二进一。为区别于其它进制数，二进制数的书写通常在数的右下方注上基数2，或加后面加B表示。例如：二进制数10110011可以写成（10110011）2，或写成10110011B八进制把二进制的数据，从右开始，每三位一组合，最左边不够的时候，补0。然后分别计算出对应的十进制数值，最后，再把每个十进制数据组合起来，就是一个八进制数据。十进制人们通常使用的是十进制。它的特点有两个：有0，1，2….9十个基本数字组成，十进制数运算是按“逢十进一”的规则进行的.十六进制把二进制的数据从右开始，每四位一组合，最左边不够的时候补0.然后分别进算出对应的的十进制数值，最后，再把每个十进制数据组合起来，就是一个十六进制数据。不同进制的组成二进制由0,1组成，以0b开头八进制由0,1…7组成，以0开头十进制由0,1…9组成，整数默认是十进制十六进制由0,1…9,a,b,c,d,e,f(大小均可)组成，以0x开头进制转换其他进制到十进制的转换十进制到其他进制的转换8421码（进制的快速转换）有符号数据表示在计算机内，有符号数由3种表示法：原码、反码和补码。所有的数据的运算都是采用补码进行的。原码就是二进制定点表示法，即最高位为符号位，”0“表示正，”1“表示负，其余位表示数值大小。反码正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。补码正数的补码与其原码相同；负数的补码是在其反码的末位+1。+7、-7的原码反码补码表示：]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE基础语法</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-面向对象]]></title>
    <url>%2Fcategory%2FJavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象对象与类类类是构造对象的模板或蓝图，类可以看作是一组对象的集合。一类事物的抽象。举个很简单的例子，经常会听到很多人说：“我不是那类人”。比如那一类就可以理解为“类”。那对象呢，对象就是”我“。在类与类之间，最常见的关系有：依赖（uses-a）、聚合（has-a）、继承（is-a）对象由类构造对象的过程称为创建类的实例，而这个示例就是对象，对于每个特定的类实例（对象）都有一组特定的实例域值，这些值的集合就是这个对象的当前状态。对象中的数据称为实例域，操作数据的过程称为方法。对象的三个主要特征：对象的行为，对象的状态，对象标识对象状态的改变必须通过调用方法实现作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。要想使用对象，必须首先构造对象，并指定其初始状态，然后对对象应用方法。在Java中，使用构造器构造新实例。构造器是一种特殊的方法，用来构造并初始化对象，构造器的名字应该与类名相同。一个对象变量并没有实际包含一个对象，而仅仅引用一个对象，任何对象变量的值都是对存储在另外一个地方的一个对象的引用，new操作符的返回值也是一个引用。如果将一个方法应用于一个值为null的对象上，就会产生错误。局部变量不会自动初始化为null，必须通过调用new或将他们呢设置为null进行初始化对象内存图在Java1.8之后永久区（PremGen）没有，方法区改为MetaSpace物理内存具体可以看这篇文章：Java内存区域与Java对象成员变量与局部变量定义这个对象的信息成员变量与局部变量的区别在类中位置在内存中位置生命周期初始化值成员变量在类中方法外在堆内存随着对象创建而存在，随着对象消失而消失有默认初始化值局部变量在方法内或者方法声明上在栈内存随着方法调用而存在，随着方法调用完毕而消失没有默认初始化值，必须先定义赋值再使用注意：当局部变量名称和成员变量名称一致时，采用就近原则1234567891011121314public class Cat &#123; String name;//默认值为null int age;//默认值为0 int num;//默认值为0 public static void main(String[] args) &#123; int num = 3;//局部变量 System.out.println("这里有"+num+"只小猫");//输出为3 Cat c = new Cat();//创建Cat对象 c.name="大大"; c.age=18; System.out.println(c.name+c.age);//大大18 &#125;&#125;方法方法就是函数，函数在Java中被称为方法。方法是完成特定功能的代码块方法在内存中位于方法区方法是随着调用才会加载方法与方法是平级关系，不能嵌套定义方法定义时候参数之间用逗号隔开方法调用升级后不用再传递数据类型如果方法有明确返回值，一定要有return带回一个值格式：修饰符 返回值类型 方法名 (参数类型 参数名1,参数类型 参数名2…){函数体; return 返回值;}1234567public void eat(String name,Date date)&#123; System.out.println(date+"吃了"+name);&#125;public String MyName(String firstName,String lastName)&#123; String myname = firstName+lastName; return myname;&#125;方法的重载在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可特点：与返回值类型无关，只看方法名和参数列表，在调用时虚拟机通过参数列表的不同来区分同名方法1234567891011public class Cat &#123; String name; int age; int num; public void eat()&#123; System.out.println("猫吃鱼"); &#125; public void eat(String name)&#123; System.out.println("猫吃"+name); &#125;&#125;形参与实参形参：方法被调用时需要传递进来的参数，如：show(int a)中的a，它只有在show被调用期间a才有意义，也就是会被分配内存空间，在方法show执行完成后，a就会被销毁释放空间，也就是不存在了实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。12345678public static void show(int a) &#123; a = 20; System.out.println(a);&#125;public static void main(String[] args) &#123; int a = 10;//实参 show(a);&#125;int a=10;中的a在被调用之前就已经创建并初始化，在调用show方法时，他被当做参数传入，所以这个a是实参。而show(int a)中的a只有在show被调用时它的生命周期才开始，而在show调用结束之后，它也随之被JVM释放掉，，所以这个a是形参。当形式参数和返回值类型是引用类型时会和基本类型不同：形参和返回值是类类型：实际传入的是该类对象形参和返回值是抽象类：实际传入的是该抽象类的子类对象形参和返回值是接口：需要的是该接口的实现类对象Java到底是值传递还是传引用？首先在Java里面有两种数据类型，基本数据类型与引用类型。基本类型直接保存在变量中，引用类型变量保存的只是实际对象的地址，一般这种变量为”引用“，引用指向实际对象，实际对象中保存着内容。按值调用(call by value):表示方法接收的是调用者提供的值按引用调用(call byreference):表示方法接收的是调用者提供的变量地址一个方法不能修改一个基本数据类型的参数（数值型和布尔型）一个方法可以改变一个对象参数的状态一个方法不能让对象参数引用一个新的对象一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。Java语言总是采用按值调用，也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。按引用调用，方法得到是对象引用及其他的拷贝同时引用同一个对象。12int num = 1;//变量num保存着1这个值int[] arr = new int[5];//变量arr在栈内存保存的是这个数组在堆内存的地址值，这个地址值引用堆内存的数组实际值=：表示赋值运算符，对于基本数据类型，赋值运算符会直接改变变量的值，原本的值被覆盖，对于引用类型，赋值运算符改变引用中的地址值，而不是在堆内存的实际值。1int[] arr = new int[3];//这里并不会改变原本数组的值，而只是把新数组的引用赋值给arr局部变量和方法参数在jvm中的储存方法是相同的，都是在栈上开辟空间来储存的，随着进入方法开辟，退出方法回收。以32位JVM为例，boolean/byte/short/char/int/float以及引用都是分配4字节空间，long/double分配8字节空间。对于每个方法来说，最多占用多少空间是一定的，这在编译时就可以计算好。我们都知道JVM内存模型中有，stack和heap的存在，但是更准确的说，是每个线程都分配一个独享的stack，所有线程共享一个heap。对于每个方法的局部变量来说，是绝对无法被其他方法，甚至其他线程的同一方法所访问到的，更别说修改。当我们在方法中声明一个 int i = 0，或者 Object obj = null 时，仅仅涉及stack，不影响到heap，当我们 new Object() 时，会在heap中开辟一段内存并初始化Object对象。当我们将这个对象赋予obj变量时，仅仅是stack中代表obj的那4个字节变更为这个对象的地址。当我们声明一个数组时，如int[] arr = new int[10]，因为数组也是对象，arr实际上是引用，stack上仅仅占用4字节空间，new int[10]会在heap中开辟一个数组对象，然后arr指向它。当我们声明一个二维数组时，如 int[][] arr2 = new int[2]4]，arr2同样仅在stack中占用4个字节，会在内存中开辟一个长度为2的，类型为int[]的数组，然后arr2指向这个数组。这个数组内部有两个引用（大小为4字节），分别指向两个长度为4的类型为int的数组。所以当我们传递一个数组引用给一个方法时，数组的元素是可以被改变的，但是无法让数组引用指向新的数组。那Java是如何存储各种类型的数据呢？Java语言并不能操纵内存，一切都是由JVM来管理控制的，因此Java内存区域的划分也就是JVM的区域划分。详细底层可以参考：Java的值传递和引用传递匿名对象匿名对象就是没有名字的对象（是对象的一种简化表示形式）匿名对象调用完毕就是垃圾，可以被垃圾回收器回收。匿名对象可以作为实际参数传递对象调用方法仅仅一次的时候：12345678910//带名字的调用Student s = new Student();s.show();s.show();System.out.println("-------");//匿名对象调用方法new Student().show();new Student().show();//不同的是，这里是创建了一个新的对象，并不是一个对象调用两次//对于匿名对象，任何时候使用==比较，返回值是falseSystem.out.println("-------")作为实际参数传递：123StudentDemo sd = new StudentDemo();sd.method(new Student());//这里是method方法参数是一个学生类对象，这里使用匿名对象传入new StudentDemo().method(new Student());//链式编程，等同于上面this关键字代表所在类的对象引用方法被哪个对象调用，this就代表哪个对象当局部变量隐藏成员变量，可以使用thisthis可以看作是一个变量，它的值是当前对象的引用12345678910111213141516171819202122public class Dog &#123; int age; public Dog(int age) &#123; this.age = age;//这个age是形参age，就近原则 /* 这里的this是区分局部的形参age和成员变量this， 这个this.age相当于Dog d = new Dog;d.age; */ &#125; public Dog growDog()&#123;//这个方法需要一个Dog对象的返回值 age++; return this;//this相当于Dog类的对象 &#125; public void ageNow()&#123; System.out.println("今年我"+age+"岁了"); &#125; public static void main(String[] args) &#123; Dog d = new Dog(3); d.growDog().ageNow(); //这里可以说是一个链式编程，创建dog类对象调用growDog方法，返回dog类对象再调用ageNow方法 &#125;&#125;这个程序执行流程详解：由上可以看出来，this一般出现在方法里，代表调用者，一开始this并不确定是谁，只有当谁调用了这个方法或者谁创建了这个对象，那么this就代表谁。final关键字final：最终的意思。常见的是它可以修饰类，方法，变量。特点：final可以修饰类，该类不能被继承。final可以修饰方法，该方法不能被重写。（覆盖，复写）final可以修饰变量，该变量不能被重新赋值，因为这个变量其实是常量。当final修饰局部变量的问题：基本类型：基本类型的值不能发生改变引用类型：引用类型的地址值不能发生改变，但是该对象堆内存的值可以改变123456789101112131415public static void main (String[] args)&#123; int x = 100; x = 200; System.out.println("x:"+x);//x:200 final int y = 300; //y = 400; 报错，无法为最终变量赋值 Student s = new Student();//Student类里有一个final int age = 10; System.out.println(s.age); //s.age = 20;报错 final Student ss = new Student();//final修饰引用类型，去掉Student上age的final ss.age = 100; //重新分配内存空间 //ss = new Student(); 报错&#125;final修饰变量的初始化时机：被final修饰的变量只能赋值一次在构造方法完毕前(非静态常量)1234567891011class finalDemo()&#123; int num; final int num2; &#123; //num2 = 20;报错 &#125; public finalDemo()&#123; num = 10; //num2 = 20;报错 &#125;&#125;由于继承中方法有一个现象：方法重写所以父类的功能就会被子类给覆盖掉。有时候我们不想让子类去覆盖掉父类的功能，只能让他使用。这个时候，针对这种情况，Java就提供了一个关键字：finalstatic关键字针对多个对象有共同的相同的成员变量值的时候，Java就提供了一个关键字来修饰：staticstatic的特点：（可以修饰成员变量、成员方法）随着类的加载而加载优先于对象存在被类的所有对象共享可以通过类名调用（也可以通过对象名-一般不选择这种）静态修饰的内容一般我们称其为：与类相关的，类成员static关键字注意事项：在静态方法中是没有this关键字的静态是随着类的加载而加载，this是随着对象的创建而存在。静态比对象先存在静态方法只能访问静态的成员变量和静态的成员方法静态方法：成员变量：只能访问静态变量成员方法：只能访问静态成员方法非静态方法：成员变量：可以是静态的，也可以是非静态的成员方法：可以是静态的成员方法，也可以是非静态的成员方法静态只能访问静态静态变量和成员变量的区别：所属不同静态变量属于类，所以也称为类变量成员变量属于对象，所以也称为实例变量（对象变量）内存中位置不同静态变量存储于方法区的静态区成与变量存储于堆内存内存出现时间不同静态变量随着类的加载而加载，随着类的消失而消失成员变量随着对象的创建而存在，也可以通过对象调用调用不同静态变量可以通过类名调用，也可以通过对象调用成员变量只能通过对象名调用构造方法给对象的数据进行初始化格式：方法名与类名相同没有返回值类型，连void都没有没有具体的返回值构造方法的注意事项：如果我们没有给出构造方法，系统将自动提供一个无参构造方法如果我们给出了构造方法，系统将不再提供默认的无参构造方法如果我们还想使用无参构造方法，就必须自己给出。建议永远给出给成员变量赋值有两种方式：setXxx()构造方法类的组成成员变量构造方法成员方法：根据返回值：void与非void根据形式参数列表：空参与非空参Student类初始化过程：类初始化过程：加载class文件进内存在栈内存开辟空间在对内存为类对象开辟空间对对象的成员变量进行默认初始化对对象的成员变量进行显示初始化通过构造方法对对象的成员变量赋值对象初始化完毕，吧对象地址复制给变量对象析构与finalize方法：在析构器中最常见的操作是回收分配给对象的存储空间，但Java不支持析构器，可以为任何一个类添加finalize方法，将在垃圾回收器清除对象之前调用。动态绑定：调用对象方法的执行过程：编译器查看对象的声明类型和方法名编译器查看调用方法时提供的参数类型如果是private方法、static方法、final方法、或者构造器，那么编译器将准备的知道该调用哪个方法，这种调用方式为静态绑定。调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。当程序运行时，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。虚拟机为了节省开销和时间，为每个类预先创建了一个方法表。什么时候定义成员变量：如果这个变量是用来描述这个类的信息的，那么该变量就应该定义为成员变量变量的范围越小越好，因为能及时收回main方法格式：代码块在Java中，使用{ }括起来的代码被称为代码块根据其位置和声明不同，可以分为局部代码块：局部位置，用于限定变量的生命周期，及早释放，提高内存利用率构造代码块在类中的成员位置，用{ }括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。作用：可以把多个构造方法中的共同代码放到一起，对对象进行初始化。静态代码块：在类中的成员位置，用{ }括起来的代码，只不过它用static修饰了对类的数据进行初始化，仅仅只执行一次作用：一般是对类进行初始化面试题：静态代码块，构造代码块，构造方法的执行顺序？静态代码块 — 构造代码块 — 构造方法静态代码块：只执行一次构造代码块：每次调用构造方法都执行]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JavaSE面向对象</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloJava]]></title>
    <url>%2Fcategory%2FHelloJava%2F</url>
    <content type="text"><![CDATA[-&gt;HelloJava!Goya：Java是一门伟大的艺术，至少在我看来是的了，也许如果没有Java出现会出现别的类似编程语言，但是因为它的存在，促进了互联网的&gt;发展。当我第一次接触Java是在初中，那时候有的塞班系统的手机上会出现一个Java的一些小游戏或者小应用，回忆中的样子应该是如此。到了大学，大二开始学习Java知道了这门著名的编程语言。那时候老师也不会将很多学习Java先要了解的一些知识，只是告诉你James Gosling发明了Java，并且在Sun公司，之后Sun被Oracle收购等等一些常识。然后便开始了Java语言的学习，那时候只知道按部就班的安装那些必备软件，然后开始敲。学习Java我认为首先需要了解一下什么是Java？它用来干什么？它怎么实现的？它发展是什么？我想在这个大时代背景下，程序员，编程，代码几乎人人皆知。而退十年来讲，都是陌生的。随着时代的发展，让这些一部分人知道的事务变成众人皆知的事务，这就是互联网的进步以及大时代的笼罩下造成的氛围。你离开了这些就仿佛一个原始人，这么说也许太片面，但离了这些产品那真的会回退一个时代。很多人都说互联网时代已经告去，大数据人工智能时代来临并飞速发展，那么怎么来，靠什么发展。我想这就是为什么电子信息专业的火爆以及许多人认为的“高薪资”。那什么是Java在1990年代之前，比较熟知的C、C++、SQL等著名语言被开发在1990年代，推动编程语言发展的思想则是“提升程序员的生产力”，出现了很多快速应用程序开发，这些语言大都有相应的集成开发环境，也大多是面向对象的编程语言。像Java、Python、Ruby、Visual Basic、JavaScript、PHP等。而Java的出现则更加保守。所以Java的产生可以理解为一门可以提高程序员生产力的语言。而那时候的Java叫Oak，是为了服务家用电器等小型系统的编程语言。但那时候这种智能化电器则不像现在般火爆。于是Sun便开始改造。摘自维基百科：Java编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在Java SE 1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装/拆箱特性。Sun对Java语言的解释是：“Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”Java不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了Java程序的运行效率。但在J2SE1.4.2发布后，Java的运行速度有了大幅提升。与传统类型不同，Sun公司在推出Java时就将其作为开放的技术。全球的Java开发公司被要求所设计的Java软件必须相互兼容。“Java语言靠群体的力量而非公司的力量”是Sun公司的口号之一，并获得了广大软件开发商的认同。这与微软公司所倡导的注重精英和封闭式的模式完全不同，此外，微软公司后来推出了与之竞争的.NET平台以及模仿Java的C#语言。后来Sun公司被甲骨文公司并购，Java也随之成为甲骨文公司的产品。总结下来就是Java是一个面向对象的拥有“简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”这些特点的语言。并且是一门开源语言（开放源代码全世界人学习或者修改加入自己的想法，但是Sun公司拥有Java的一部分权力）那么首先我们可以分析一下，什么是编程语言：编程语言是用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。所以Java就是一门我们可以根据Java的语法规则写出来的代码，它来编译成计算机识别的指令来操作计算机或者其他设备的语言。那么Java如何识别我们写的代码再编译成计算机识别的指令呢？举一个例子：我们写一个HelloWorld.java这个时候可以不用纠结这些看不懂12345class HelloWorld&#123; public static void main (String[] args)&#123; System.out.println("HelloWorld!"); &#125;&#125;然后通过控制台执行javac可以看到在HelloWorld.java同级目录生成一个.class文件接着执行java命令可以看到我们写的代码被计算机所解释编译执行，输出HelloWorld那么这个javac是什么呢？当安装好jdk后可以在jdk安装目录bin文件夹下看到这个脚本。它是用来编译java程序的源代码，但是它本质是基于jdk标准类库中的javac类库实现，所以java的编译器实质是一个java程序javac又被称为前端编译器，仅负责源代码与字节码之间的转换，而在jvm内部还存在一个后置编译器（根据热点探测技术，可以将最有价值的字节码转换为机器码执行从而提升java程序的运行效率）javac 的意义就在于 将源码编译为字节码，同时做一些词法，语法，语义上的检查，最后生成可供jvm运行的字节码文件。可以在lib中的tools jar包中sun.tools.javac;包下管理者java前端编译器的class文件，Main类中的main方法执行的是javac程序的执行入口。同时在bin目录下可以看到很多脚本文件，比如java、javaw等那这个.class文件又是什么呢？.class文件又称字节码文件，它就是java帮我们进行的第一道翻译工作后的结果，这道翻译工作就是javac，可以理解为将源码编译为字节码，同时做一些词法，语法，语义上的检查，最后生成的.class文件供jvm运行。这一过程就叫编译，更准确的是称为前端编译。.class文件也就是前端编译产生的代码。前端编译：词法分析：词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，将字符序列转换为标记（token）序列的过程。这里的标记是一个字符串，是构成源代码的最小单位。在这个过程中，词法分析器还会对标记进行分类 。词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。语法分析：语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述。将源代码中的字符流构造成抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方法。填充符号表： 符号表是一组符号地址和符号信息构成的表格。注解处理器处理：我们平时使用的Java注解，本质就是用来对语法树做出修改，处理器的任务便是在编译是识别出这些注解同时修改抽象语法树。语义分析与字节码生成：语义分析是编译过程的一个逻辑阶段， 语义分析的任务是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。语义分析的一个重要部分就是类型检查。比如很多语言要求数组下标必须为整数，如果使用浮点数作为下标，编译器就必须报错。再比如，很多语言允许某些类型转换，称为自动类型转换。标注检查：语义分析的第一个步骤，用来检查包括诸如使用的变量是否已经声明、变量与赋值之间的数据类型是否能够匹配。其中有一个重要的步骤就是常量折叠如：int a = 3 + 2， javap查看生成的class字节码，iconst指令向操作数栈中压入的是常量值5，这样在运行时期就不会CPU的运算量重新计算。数据及控制流分析用于检查诸如局部变量在使用前是否已经赋值，方法的每条路径上是否都有返回值，受查异常是否都被正常处理等问题。解语法糖（desugar）Java中我们经常使用的语法糖有泛型、自动装箱/拆箱、遍历循环、条件编译等.. 由于这些语法在运行时无法被识别，因此需要在编译阶段就将他们还原回简单的基础语法结构。泛型泛型的本质是参数化类型的应用，参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。在Java中，泛型只在源码中存在，一旦经常编译，就会替换成原来的原生类型并且在相应的地方加上了强制类型转换代码。这一过程也叫做类型擦除自动装箱/拆箱基本类型自动装箱成包装类型，包装类型拆箱成基本类型，大多数Java程序员都已经了解。只是使用上有些地方需要注意，比方包装类型在使用“==”进行比较时，只有遇到算术运算时才会自动拆箱。遍历循环诸如 for(int i : list) {} 这样的loop循环在编译后都会转换成对数据结构iterator的调用条件编译对于if和常量搭配使用，在编译器发现不会执行到的语句块，将不会出现在编译之后的class文件当中生成字节码class文件在Compiler生成class文件时，不仅仅将前面步骤生成的信息转化成字节码，还会进行少量的代码添加和转换工作，如和就是在该阶段添加进class文件当中，如果Compiler发现代码中没有任何构造器，那么将会添加一个无参数的、访问性与当前类一致的构造器（也即经常所说的默认无参构造器）后端编译在Java中，javac执行的结果就是得到一个字节码，而这个字节码其实就是一种中间代码。然后得到的class文件并不能被机器所识别。这个时候就通过JVM来解释字节码，将其翻译成对应的机器指令，逐条读入，逐条解释执行，这是传统的JVM解释器的功能，为了解决这种效率问题，引入了JIT技术。（即使编译器）深入浅出JIT编译当JVM通过类加载器加载class文件里的字节码后，会通过解释器解释称汇编指令最终再转译成CPU可以识别的机器指令，解释器是软件来实现的，主要是为了实现同一份 Java 字节码可以在不同的硬件平台上运行，而将汇编指令转换成机器指令由硬件直接实现。从软件层面上， class 文件被加载进虚拟机后，类信息会存放在方法区，在实际运行的时候会执行方法区中的代码，在 JVM 中所有的线程共享堆内存和方法区，而每个线程有自己独立的 Java 方法栈，本地方法栈（面向 native 方法），PC寄存器（存放线程执行位置），当调用一个方法的时候， Java 虚拟机会在当前线程对应的方法栈中压入一个栈帧，用来存放 Java 字节码操作数以及局部变量，这个方法执行完会弹出栈帧，一个线程会连续执行多个方法，对应不同的栈帧的压入和弹出，压入栈帧后就是 JVM 解释执行的过程了。JAVA程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。当 JVM 执行代码时，它并不立即开始编译代码。首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。在机器上，执行java -version命令就可以看到自己安装的JDK中JIT是哪种模式:热点检测上面我们说过，要想触发JIT，首先需要识别出热点代码。目前主要的热点代码识别方式是热点探测（Hot Spot Detection），有以下两种：基于采样的方式探测（Sample Based Hot Spot Detection) ：周期性检测各个线程的栈顶，发现某个方法经常出险在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因干扰热点探测。基于计数器的热点探测（Counter Based Hot Spot Detection)。采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。方法计数器。顾名思义，就是记录一个方法被调用次数的计数器。回边计数器。是记录方法中的for或者while的运行次数的计数器。编译优化前面提到过，JIT除了具有缓存的功能外，还会对代码做各种优化。说到这里，不得不佩服HotSpot的开发者，他们在JIT中对于代码优化真的算是面面俱到了。经过前端编译与后端编译，最终我们的java文件被机器所执行。JDK、JRE与JVM：JDKJava Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。最主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了属于自己的JDK。JDK有以下三种版本：J2SE， standard edition，标准版，是我们通常用的一个版本J2EE， enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序J2ME，micro edtion，主要用于移动设备、嵌入式设备上的java应用程序JREJava Runtime Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。JVM我们刚生成的.class文件就是通过jvm来编译执行Java Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的组成包括 JVM 指令集，符号表以及一些补助信息。至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。]]></content>
      <categories>
        <category>JavaSE</category>
        <category>Java入门</category>
      </categories>
      <tags>
        <tag>Java基础入门</tag>
      </tags>
  </entry>
</search>
