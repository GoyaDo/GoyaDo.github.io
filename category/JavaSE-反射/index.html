<!-- build time:Mon Sep 16 2019 13:22:56 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta name="google-site-verification" content="EmMIJLWJtXQxrrJkM-F8VfTiJjK7ASyFu9OBx-ZlSRo"><meta name="baidu-site-verification" content="XVGOi3sgWa"><script></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="baidu-site-verification" content="Kljn7UFZcB"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="java入门,JavaSE反射,反射入门"><link rel="alternate" href="/atom.xml" title="余生梦见皆是缘" type="application/atom+xml"><meta name="description" content="JavaSE反射概述以及使用"><meta name="keywords" content="java入门,JavaSE反射,反射入门"><meta property="og:type" content="article"><meta property="og:title" content="JavaSE-反射"><meta property="og:url" content="https://www.ysmjjsy.com/category/JavaSE-反射/index.html"><meta property="og:site_name" content="余生梦见皆是缘"><meta property="og:description" content="JavaSE反射概述以及使用"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-反射/f1.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-反射/f2.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-反射/f3.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-反射/f4.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-反射/f6.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-反射/f7.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-反射/f8.png"><meta property="og:updated_time" content="2019-09-16T02:13:44.914Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JavaSE-反射"><meta name="twitter:description" content="JavaSE反射概述以及使用"><meta name="twitter:image" content="https://www.ysmjjsy.com/category/JavaSE-反射/f1.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://www.ysmjjsy.com/category/JavaSE-反射/"><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"6e2c9585"}),daovoice("update")</script><title>JavaSE-反射 | 余生梦见皆是缘</title><script>!function(e,t,a,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=t.createElement(a),o=t.getElementsByTagName(a)[0],s.async=1,s.src=n,o.parentNode.insertBefore(s,o)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-145122509-1","auto"),ga("send","pageview")</script><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?45ce68cbde829747ea3eed77723e1cf4";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><a href="https://github.com/GoyaDo" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="https://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">余生梦见皆是缘</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archives"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.ysmjjsy.com/category/JavaSE-反射/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Goya"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="余生梦见皆是缘"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JavaSE-反射</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-03T00:00:00+08:00">2017-09-03 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2019-09-16T10:13:44+08:00">2019-09-16 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE/JavaSE反射/" itemprop="url" rel="index"><span itemprop="name">JavaSE反射</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/category/JavaSE-反射/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/category/JavaSE-反射/" itemprop="commentCount"></span> </a></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">4.4k 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">17 分钟</span></div><div class="post-description">JavaSE反射概述以及使用</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><blockquote><p>Java 反射机制在程序<strong>运行时</strong>，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 <strong>动态的获取信息</strong> 以及 <strong>动态调用对象的方法</strong> 的功能称为 <strong>java 的反射机制</strong>。</p></blockquote><p>反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 <code>.class</code> 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 <code>.class</code> 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。</p><p><strong>要想剖析一个类，必须先要获取到该类的字节码文件对象，而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象</strong></p><p>反射库提供了一个非常丰富且精心设计的工具集，以便编写能够动态操作Java代码的程序.。</p><p>能够分析类能力的程序称为反射，反射机制的功能极其强大，反射机制可以用来:</p><ul><li>在运行中分析类的能力</li><li>在运行中查看对象</li><li>实现通用的数组操作代码</li><li>利用Method对象。</li></ul><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>在程序运行期间，Java运行时系统始终未所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。</p><p>然后，可以通过专门的Java类访问这些信息。保存这些信息的类被称为Class，这个名字很容易让人混淆。<strong>Object类中的getClass()方法将会返回一个Class类型的实例。</strong></p><p>一个Class对象表示一个特定类的属性，<strong>getName()方法返回类的名字</strong>。</p><p>调用forName获得类名对应的Class对象,这个方法在类名保存在字符串中，并可在运行中改变就可以使用，只有在className是类名或接口名时才能够执行。否则将抛出一个checked exception(已检查异常)，所以无论何时使用这个方法，都应该提供一个异常处理器。</p><p>如果T是任意的Java类型，T.class将代表匹配的类对象，一个Class对象实际表示的是一个类型，而这个类型未必一定是一种类。虚拟机为每个类型管理一个Class对象，因此，可以利用==运算符实现两个类对象比较的操作符。newInstance()可以快速地创建一个类的实例。<strong>newInstance方法</strong>调用默认的构造器初始化新创建的对象，如果这个类没有默认的构造器，就会抛出一个异常。将forName与newInstance配合起来使用，可以根据存储在字符串中的类名创建一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = “java.util.Date”;</span><br><span class="line">Object m = Class.forName(s).newInstance();</span><br></pre></td></tr></table></figure><h2 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h2><p><strong>检查类的结构:</strong></p><p>在java.lang.reflect包中有三个类Field、Method和Constructor分别用于描述类的域、方法和构造器。</p><p>这三个类都有一个叫做getName的方法，用来返回项目的名称。</p><p>Field类有一个getType方法，用来返回描述域所属类型的Class对象。Method和Constructor类有能够报告参数类型的方法，</p><p>Method类还有一个可以报告返回类型的方法。</p><p>这三个类还有一个叫做getModifiers的方法，它将返回一个整形数值，用不同的位开关描述public和static这样的修饰符使用状况。</p><p>另外还有java.lang.reflect包中的Modifier类的静态方法分析getModifiers返回的整形数值。</p><p>还可以利用Modifier.toString方法将修饰符打印出来。</p><p>Class类中的getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员。</p><p>Class类的getDeclareFields、getDeclareMethods和getDeclaredConstructors方法将分别返回类中生命的全部域、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员。</p><p><strong>在运行时使用反射分析对象：</strong></p><p>如果f是一个Field类型的对象，obj是某个包含f域的类的对象，f.get(obj)。将返回一个对象，其值为obj域的当前值。</p><p>反射机制的默认行为受限于java的访问控制，然而，如果一个java程序没有收到安全管理器的控制，就可以覆盖访问控制，需要调用Field、Method或Construtor对象的setAsseccible方法</p><h2 id="类的加载和加载时机"><a href="#类的加载和加载时机" class="headerlink" title="类的加载和加载时机"></a>类的加载和加载时机</h2><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><ul><li>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化</li><li>加载<ul><li>就是指将class文件读入内存，并为之创建一个Class对象</li><li>任何类被使用时系统都会建立有个Class对象</li></ul></li><li>连接<ul><li>验证：是否有正确的内部结构，并和其它类协调一致</li><li>准备：负责为类的静态成员分配内存，并设置默认初始化值</li><li>解析：将类的二进制数据中的符号引用替换为直接引用</li></ul></li><li>初始化</li></ul><h3 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h3><ol><li>创建类的实例</li><li>访问类的静态变量，或者为静态变量赋值</li><li>掉用类的静态方法</li><li>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</li><li>初始化某个类的子类</li><li>直接使用java.exe命令来运行某个主类</li></ol><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>负责将.class文件加载到内存中，并为之生成对应的Class对象</p><p><strong>类加载器的组成</strong></p><p><strong>Bootstrap ClassLoader根类加载器</strong></p><ul><li>也被称为引导类加载器，负责Java核心类的加载<ul><li>比如System.String等，在JDK中JRE的lib目录下rt.jar文件中</li></ul></li></ul><p><strong>Extension ClassLoader扩展类加载器</strong></p><ul><li>负责JRE的扩展目录中jar包的加载<ul><li>在JDK中JRE的lib目录下的ext目录</li></ul></li></ul><p><strong>System CLassLoader系统类加载器</strong></p><ul><li>负责在JVM启动时加载来自Java命令的class文件，以及classpath环境变量所指定的jar包和类路径</li></ul><h2 id="反射的基本应用"><a href="#反射的基本应用" class="headerlink" title="反射的基本应用"></a>反射的基本应用</h2><p>反射可以用于判断任意对象所属的类，获得 Class 对象，构造任意一个对象以及调用一个对象。(反射相关的类一般都在 java.lang.relfect 包里)。</p><h3 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h3><ul><li><p>使用Class类的forName静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line"><span class="comment">//比如在 JDBC 开发中常用此方法加载数据库驱动:</span></span><br><span class="line">Class.forName(driver);</span><br></pre></td></tr></table></figure></li><li><p>直接获取某一个对象的class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; klass = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;?&gt; classInt = Integer.TYPE;</span><br></pre></td></tr></table></figure></li><li><p>调用某个对象的getClass()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">Class&lt;?&gt; klass = str.getClass();</span><br></pre></td></tr></table></figure></li></ul><h3 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h3><p>一般地，我们用 <code>instanceof</code> 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的 <code>isInstance()</code> 方法来判断是否为某个类的实例，它是一个 native 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>通过反射来生成对象主要有两种方式。</p><ul><li><p>使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure></li><li><p>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"23333"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取类的构造方法"><a href="#获取类的构造方法" class="headerlink" title="获取类的构造方法"></a>获取类的构造方法</h3><h4 id="获取无参构造"><a href="#获取无参构造" class="headerlink" title="获取无参构造"></a>获取无参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forNmae(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"><span class="comment">//获取构造方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public Constructor[] getConstructors();所有公共构造方法</span></span><br><span class="line"><span class="comment">public Constructor[] getDeclaredConstructors();所有构造方法</span></span><br><span class="line"><span class="comment">Constructor[] cons = c.getDeclaredConstructors();</span></span><br><span class="line"><span class="comment">for(Constructor con : cons)&#123;</span></span><br><span class="line"><span class="comment">	System.out.println(con);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单个构造方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">参数表示的是:你要获取的构造方法的构造参数个数及数据类型的class字节码文件对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Constructor con = c.getConstructor();<span class="comment">//返回的是构造方法对象</span></span><br><span class="line"><span class="comment">//Student s = new Student();</span></span><br><span class="line"><span class="comment">//System.out.println(s);</span></span><br><span class="line"><span class="comment">//public T newInstance(Object... initargs)</span></span><br><span class="line"><span class="comment">//使用此Constructor对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例</span></span><br><span class="line">Object obj = con.newInstance();</span><br><span class="line">System.out.println(obj);</span><br><span class="line"><span class="comment">//Student s = (Student)obj;</span></span><br><span class="line"><span class="comment">//s.show();</span></span><br></pre></td></tr></table></figure><h4 id="获取带参构造"><a href="#获取带参构造" class="headerlink" title="获取带参构造"></a>获取带参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public Student(String name,int age,String address)</span></span><br><span class="line"><span class="comment">Student s = new Student("张三","18","西安");</span></span><br><span class="line"><span class="comment">System.out.println(s);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//获取字节码文件对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"><span class="comment">//获取带参构造方法对象</span></span><br><span class="line"><span class="comment">//public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">Constructor con = c.getConstructor(String.classs,<span class="keyword">int</span>.class,String.class);</span><br><span class="line"><span class="comment">//获取带参构造方法对象创建对象</span></span><br><span class="line"><span class="comment">//public T new Instance(Object... initargs);</span></span><br><span class="line">Objec obj = con.newInstance(<span class="string">"张三"</span>,<span class="string">"18"</span>,<span class="string">"西安"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><h4 id="获取私有构造"><a href="#获取私有构造" class="headerlink" title="获取私有构造"></a>获取私有构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">private Student(String name)&#123;&#125;</span></span><br><span class="line"><span class="comment">Student s = new Student("李四");</span></span><br><span class="line"><span class="comment">System.out.println(s);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//获取字节码文件对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"><span class="comment">//获取私有构造方法对象</span></span><br><span class="line"><span class="comment">//NoSuchMethodException:没有这个方法异常</span></span><br><span class="line"><span class="comment">//原因是一开始我们使用的方法只能获取公共的，下面这种方法就可以</span></span><br><span class="line">Constructor con = c.getDeclaredConstructor(String.class);</span><br><span class="line"><span class="comment">//用该私有构造方法创建对象</span></span><br><span class="line"><span class="comment">//IllegalAcessException:非法访问异常</span></span><br><span class="line"><span class="comment">//暴力访问</span></span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);<span class="comment">//值为true则指示反射的对象在使用时应该取消Java语言访问检查</span></span><br><span class="line">Object obj = con.newInstance(<span class="string">"李四"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><h3 id="获取类的成员变量"><a href="#获取类的成员变量" class="headerlink" title="获取类的成员变量"></a>获取类的成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有成员</span></span><br><span class="line">getFields.getDeclaredFields();</span><br><span class="line"><span class="comment">//获取单个成员</span></span><br><span class="line">getFields.getDeclaredField();</span><br><span class="line"><span class="comment">//修改成员的值</span></span><br><span class="line">set(Object obj,Object value);</span><br><span class="line"><span class="comment">//将指定对象变量上此Field对象表示的字段设置为指定的新值</span></span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取字节码文件对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"><span class="comment">//获取所有成员变量</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Field[] fields = c.getFields();</span></span><br><span class="line"><span class="comment">Field[] fields = c.getDeclaredFiedls();</span></span><br><span class="line"><span class="comment">for(Field field:fields)&#123;</span></span><br><span class="line"><span class="comment">	System.out.println(field);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//Student s = new Student();s.address="上海";</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过无参构造方法创建对象</span></span><br><span class="line">Constructor con = c.getConstructor();</span><br><span class="line">Object obj = con.newInstance();</span><br><span class="line">System.out.println(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单个的成员</span></span><br><span class="line"><span class="comment">//获取address并对其赋值</span></span><br><span class="line">Field addressField = c.getField(<span class="string">"address"</span>);</span><br><span class="line"><span class="comment">//public void set(obj,Object value)</span></span><br><span class="line"><span class="comment">//将指定此对象变量上此Field对象表示的字段设置为指定的新值</span></span><br><span class="line">addressField.set(obj,<span class="string">"上海"</span>);<span class="comment">//给obj对象的addrrssField字段设置值</span></span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><p><strong>对于基本类型的静态常量，JVM 在编译阶段会把引用此常量的代码替换成具体的常量值</strong>。</p><p>这么说来，在实际开发中，如果我们想修改某个类的常量值，恰好那个常量是基本类型的，岂不是无能为力了？反正我个人认为除非修改源码，否则真没办法！</p><p>这里所谓的无能为力是指：<strong>我们在程序运行时刻依然可以使用反射修改常量的值（后面会代码验证），但是 JVM 在编译阶段得到的 .class 文件已经将常量优化为具体的值，在运行阶段就直接使用具体的值了，所以即使修改了常量的值也已经毫无意义了</strong>。</p><h3 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h3><h4 id="获取无参无返回值的成员方法"><a href="#获取无参无返回值的成员方法" class="headerlink" title="获取无参无返回值的成员方法"></a>获取无参无返回值的成员方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取字节码文件对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有的方法</span></span><br><span class="line"><span class="comment">//Method[] methods = c.getMethods();//获取自己的包括父亲的公共方法</span></span><br><span class="line"><span class="comment">//Method[] methods = c.getDeclareMethods();//获取自己的所有的方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(Method method:methods)&#123;</span></span><br><span class="line"><span class="comment">	System.out.println(method);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Constructor con = c.getConstructor();</span><br><span class="line">Object obj = con.newInstance();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Student s = new Student(); s.show();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单个方法并使用</span></span><br><span class="line"><span class="comment">//public void show()</span></span><br><span class="line"><span class="comment">//public Method getMethod(String name,Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">//第一个参数表示的方法名，第二个参数表示的是方法的参数的class类型</span></span><br><span class="line">Methdo m1 = c.getMethod(<span class="string">"show"</span>);</span><br><span class="line"><span class="comment">//public Object invoke(Object obj,Object... args)</span></span><br><span class="line">m1.invole(obj);</span><br></pre></td></tr></table></figure><h4 id="获取带参带返回值成员的方法"><a href="#获取带参带返回值成员的方法" class="headerlink" title="获取带参带返回值成员的方法"></a>获取带参带返回值成员的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public void method(String s)</span></span><br><span class="line">Method m2 = c.getMethod(<span class="string">"method"</span>,String.class);</span><br><span class="line">m2.invoke(obj,<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//public String getString(String s,int i)</span></span><br><span class="line">Method m3 = c.getMethod(<span class="string">"getString"</span>,String.class,<span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//private void function()</span></span><br><span class="line">Method m3 = c.getDeclaredMethod(<span class="string">"function"</span>);</span><br><span class="line">m4.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">m4.invoke(obj);</span><br></pre></td></tr></table></figure><h3 id="通过反射越过泛型检查"><a href="#通过反射越过泛型检查" class="headerlink" title="通过反射越过泛型检查"></a>通过反射越过泛型检查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">Class c = array.getClass();<span class="comment">//集合ArrayList的class对象</span></span><br><span class="line">Method m = c.getMethod(<span class="string">"add"</span>,Object.class);</span><br><span class="line">m.invoke(array,<span class="string">"hello"</span>);<span class="comment">//调用array的add方法，传入的值是hello</span></span><br></pre></td></tr></table></figure><h2 id="反射源码解析"><a href="#反射源码解析" class="headerlink" title="反射源码解析"></a>反射源码解析</h2><p>当我们懂得了如何使用反射后，今天我们就来看看 JDK 源码中是如何实现反射的。或许大家平时没有使用过反射，但是在开发 Web 项目的时候会遇到过下面的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException </span><br><span class="line">...</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</span><br></pre></td></tr></table></figure><p>可以看到异常堆栈指出了异常在 Method 的第 497 的 invoke 方法中，其实这里指的 invoke 方法就是我们反射调用方法中的 invoke。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = clz.getMethod(<span class="string">"setPrice"</span>, <span class="keyword">int</span>.class); </span><br><span class="line">method.invoke(object, <span class="number">4</span>);   <span class="comment">//就是这里的invoke方法</span></span><br></pre></td></tr></table></figure><p>例如我们经常使用的 Spring 配置中，经常会有相关 Bean 的配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.chenshuyi.Apple"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>当我们在 XML 文件中配置了上面这段配置之后，Spring 便会在启动的时候利用反射去加载对应的 Apple 类。而当 Apple 类不存在或发生启发异常时，异常堆栈便会将异常指向调用的 invoke 方法。</p><p>从这里可以看出，我们平常很多框架都使用了反射，而反射中最最终的就是 Method 类的 invoke 方法了。</p><p>下面我们来看看 JDK 的 invoke 方法到底做了些什么。</p><p>进入 Method 的 invoke 方法我们可以看到，一开始是进行了一些权限的检查，最后是调用了 MethodAccessor 类的 invoke 方法进行进一步处理，如下图红色方框所示。</p><p><img src="/category/JavaSE-反射/f1.png" alt="fanshe"></p><p>那么 MethodAccessor 又是什么呢？</p><p>其实 MethodAccessor 是一个接口，定义了方法调用的具体操作，而它有三个具体的实现类：</p><ul><li>sun.reflect.DelegatingMethodAccessorImpl</li><li>sun.reflect.MethodAccessorImpl</li><li>sun.reflect.NativeMethodAccessorImpl</li></ul><p>而要看 ma.invoke() 到底调用的是哪个类的 invoke 方法，则需要看看 MethodAccessor 对象返回的到底是哪个类对象，所以我们需要进入 acquireMethodAccessor() 方法中看看。</p><p><img src="/category/JavaSE-反射/f2.png" alt="fanshe">从 acquireMethodAccessor() 方法我们可以看到，代码先判断是否存在对应的 MethodAccessor 对象，如果存在那么就复用之前的 MethodAccessor 对象，否则调用 ReflectionFactory 对象的 newMethodAccessor 方法生成一个 MethodAccessor 对象。</p><p><img src="/category/JavaSE-反射/f3.png" alt="fanshe">在 ReflectionFactory 类的 newMethodAccessor 方法里，我们可以看到首先是生成了一个 NativeMethodAccessorImpl 对象，再这个对象作为参数调用 DelegatingMethodAccessorImpl 类的构造方法。</p><p>这里的实现是使用了代理模式，将 NativeMethodAccessorImpl 对象交给 DelegatingMethodAccessorImpl 对象代理。我们查看 DelegatingMethodAccessorImpl 类的构造方法可以知道，其实是将 NativeMethodAccessorImpl 对象赋值给 DelegatingMethodAccessorImpl 类的 delegate 属性。</p><p><img src="/category/JavaSE-反射/f4.png" alt="fanshe">所以说ReflectionFactory 类的 newMethodAccessor 方法最终返回 DelegatingMethodAccessorImpl 类对象。所以我们在前面的 ma.invoke() 里，其将会进入 DelegatingMethodAccessorImpl 类的 invoke 方法中。</p><p><img src="/category/JavaSE-反射/f6.png" alt="fanshe">进入 DelegatingMethodAccessorImpl 类的 invoke 方法后，这里调用了 delegate 属性的 invoke 方法，它又有两个实现类，分别是：DelegatingMethodAccessorImpl 和 NativeMethodAccessorImpl。按照我们前面说到的，这里的 delegate 其实是一个 NativeMethodAccessorImpl 对象，所以这里会进入 NativeMethodAccessorImpl 的 invoke 方法。</p><p><img src="/category/JavaSE-反射/f7.png" alt="fanshe">而在 NativeMethodAccessorImpl 的 invoke 方法里，其会判断调用次数是否超过阀值（numInvocations）。如果超过该阀值，那么就会生成另一个MethodAccessor 对象，并将原来 DelegatingMethodAccessorImpl 对象中的 delegate 属性指向最新的 MethodAccessor 对象。</p><p>到这里，其实我们可以知道 MethodAccessor 对象其实就是具体去生成反射类的入口。通过查看源码上的注释，我们可以了解到 MethodAccessor 对象的一些设计信息。</p><blockquote><p>“Inflation” mechanism. Loading bytecodes to implement Method.invoke() and Constructor.newInstance() currently costs 3-4x more than an invocation via native code for the first invocation (though subsequent invocations have been benchmarked to be over 20x faster).Unfortunately this cost increases startup time for certain applications that use reflection intensively (but only once per class) to bootstrap themselves.</p><p>Inflation 机制。初次加载字节码实现反射，使用 Method.invoke() 和 Constructor.newInstance() 加载花费的时间是使用原生代码加载花费时间的 3 - 4 倍。这使得那些频繁使用反射的应用需要花费更长的启动时间。</p><p>To avoid this penalty we reuse the existing JVM entry points for the first few invocations of Methods and Constructors and then switch to the bytecode-based implementations. Package-private to be accessible to NativeMethodAccessorImpl and NativeConstructorAccessorImpl.</p><p>为了避免这种痛苦的加载时间，我们在第一次加载的时候重用了 JVM 的入口，之后切换到字节码实现的实现。</p></blockquote><p>就像注释里说的，实际的 MethodAccessor 实现有两个版本，一个是 Native 版本，一个是 Java 版本。</p><p>Native 版本一开始启动快，但是随着运行时间边长，速度变慢。Java 版本一开始加载慢，但是随着运行时间边长，速度变快。正是因为两种存在这些问题，所以第一次加载的时候我们会发现使用的是 NativeMethodAccessorImpl 的实现，而当反射调用次数超过 15 次之后，则使用 MethodAccessorGenerator 生成的 MethodAccessorImpl 对象去实现反射。</p><p>Method 类的 invoke 方法整个流程可以表示成如下的时序图：</p><p><img src="/category/JavaSE-反射/f8.png" alt="fanshe"> invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能。</p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">----------------本文结束<i class="fa fa-heart"></i>感谢阅读----------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> Goya</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.ysmjjsy.com/category/JavaSE-反射/" title="JavaSE-反射">https://www.ysmjjsy.com/category/JavaSE-反射/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java基础入门/" rel="tag"><i class="fa fa-tag"></i> Java基础入门</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/category/JavaSE-网络编程/" rel="next" title="JavaSE-网络编程"><i class="fa fa-chevron-left"></i> JavaSE-网络编程</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/category/JavaSE-注解/" rel="prev" title="JavaSE-注解">JavaSE-注解 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="addthis_inline_share_toolbox"><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5d44446d8ec752bd" async></script></div></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Goya"><p class="site-author-name" itemprop="name">Goya</p><p class="site-description motion-element" itemprop="description">愿你走出半生，归来仍是少年</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">26</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">2</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/GoyaDo" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/a773949603" target="_blank" title="CSDN"><i class="fa fa-fw fa-copyright"></i>CSDN</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/lemondeah/activities" target="_blank" title="知乎"><i class="fa fa-fw fa-zhihu"></i>知乎</a> </span><span class="links-of-author-item"><a href="https://weibo.com/u/6606679478" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i>微博</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://me.csdn.net/sinyu890807" title="郭霖" target="_blank">郭霖</a></li><li class="links-of-blogroll-item"><a href="https://www.zhihu.com/people/huangsunting/activities" title="bravo1988" target="_blank">bravo1988</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#反射"><span class="nav-number">1.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Class类"><span class="nav-number">1.1.</span> <span class="nav-text">Class类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用反射分析类的能力"><span class="nav-number">1.2.</span> <span class="nav-text">利用反射分析类的能力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的加载和加载时机"><span class="nav-number">1.3.</span> <span class="nav-text">类的加载和加载时机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类的加载"><span class="nav-number">1.3.1.</span> <span class="nav-text">类的加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类初始化时机"><span class="nav-number">1.3.2.</span> <span class="nav-text">类初始化时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载器"><span class="nav-number">1.3.3.</span> <span class="nav-text">类加载器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射的基本应用"><span class="nav-number">1.4.</span> <span class="nav-text">反射的基本应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获得Class对象"><span class="nav-number">1.4.1.</span> <span class="nav-text">获得Class对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断是否为某个类的实例"><span class="nav-number">1.4.2.</span> <span class="nav-text">判断是否为某个类的实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建实例"><span class="nav-number">1.4.3.</span> <span class="nav-text">创建实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取类的构造方法"><span class="nav-number">1.4.4.</span> <span class="nav-text">获取类的构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取无参构造"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">获取无参构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取带参构造"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">获取带参构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取私有构造"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">获取私有构造</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取类的成员变量"><span class="nav-number">1.4.5.</span> <span class="nav-text">获取类的成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取成员方法"><span class="nav-number">1.4.6.</span> <span class="nav-text">获取成员方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取无参无返回值的成员方法"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">获取无参无返回值的成员方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取带参带返回值成员的方法"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">获取带参带返回值成员的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过反射越过泛型检查"><span class="nav-number">1.4.7.</span> <span class="nav-text">通过反射越过泛型检查</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射源码解析"><span class="nav-number">1.5.</span> <span class="nav-text">反射源码解析</span></a></li></ol></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019-09-16</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Goya</span></div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>function createtime(){var n=new Date("07/03/2018 14:13:22");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="网站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}var now=new Date;setInterval("createtime()",250)</script><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> 网站总访客数 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人次 </span><span class="site-pv"><i class="fa fa-eye"></i> 总访问量 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次</span></div></div></footer></div><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="https://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'BuVPeD8Q1vkGqU4nrrrSUa9y-gzGzoHsz',
        appKey: '0SU6m8Ctovo9j6oHFbNVyHPv',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html><script type="text/javascript" src="/js/src/love.js"></script><!-- rebuild by neat -->