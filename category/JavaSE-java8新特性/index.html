<!-- build time:Tue Sep 17 2019 17:17:14 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta name="google-site-verification" content="EmMIJLWJtXQxrrJkM-F8VfTiJjK7ASyFu9OBx-ZlSRo"><meta name="baidu-site-verification" content="XVGOi3sgWa"><script></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="baidu-site-verification" content="Kljn7UFZcB"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="java入门,java8新特性,JUC,NIO"><link rel="alternate" href="/atom.xml" title="余生梦见皆是缘" type="application/atom+xml"><meta name="description" content="JavaSE-java8新特性,JUC,NIO"><meta name="keywords" content="java入门,java8新特性,JUC,NIO"><meta property="og:type" content="article"><meta property="og:title" content="JavaSE-java8新特性"><meta property="og:url" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/index.html"><meta property="og:site_name" content="余生梦见皆是缘"><meta property="og:description" content="JavaSE-java8新特性,JUC,NIO"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/d1.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/1.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/2.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/3.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/4.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/5.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/6.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/7.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/8.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/a1.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/a2.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/b1.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/b2.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/b3.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/c1.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/c2.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/11.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/12.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/21.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/22.png"><meta property="og:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/23.png"><meta property="og:updated_time" content="2019-09-16T10:22:17.697Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JavaSE-java8新特性"><meta name="twitter:description" content="JavaSE-java8新特性,JUC,NIO"><meta name="twitter:image" content="https://www.ysmjjsy.com/category/JavaSE-java8新特性/d1.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://www.ysmjjsy.com/category/JavaSE-java8新特性/"><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"6e2c9585"}),daovoice("update")</script><title>JavaSE-java8新特性 | 余生梦见皆是缘</title><script>!function(e,t,a,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=t.createElement(a),o=t.getElementsByTagName(a)[0],s.async=1,s.src=n,o.parentNode.insertBefore(s,o)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-145122509-1","auto"),ga("send","pageview")</script><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?45ce68cbde829747ea3eed77723e1cf4";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><a href="https://github.com/GoyaDo" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="https://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">余生梦见皆是缘</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archives"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.ysmjjsy.com/category/JavaSE-java8新特性/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Goya"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="余生梦见皆是缘"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JavaSE-java8新特性</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-10T00:00:00+08:00">2017-09-10 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2019-09-16T18:22:17+08:00">2019-09-16 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE/JavaSE-java8新特性/" itemprop="url" rel="index"><span itemprop="name">JavaSE-java8新特性</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/category/JavaSE-java8新特性/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/category/JavaSE-java8新特性/" itemprop="commentCount"></span> </a></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">11.4k 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">43 分钟</span></div><div class="post-description">JavaSE-java8新特性,JUC,NIO</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><p>底层数据结构发生改变，更快<br>底层内存结构发生改变：<br>方法区是堆内存中永久区的一部分，1.8之后去掉方法区的永久区，方法区改为元空间。</p><p><img src="/category/JavaSE-java8新特性/d1.png" alt="i"></p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="为什么使用Lambda表达式"><a href="#为什么使用Lambda表达式" class="headerlink" title="为什么使用Lambda表达式"></a>为什么使用Lambda表达式</h3><blockquote><p>Lambda 是一个匿名函数，我们可以把 Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p></blockquote><h3 id="Lambda表达式-1"><a href="#Lambda表达式-1" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>有一个实现要求:</p><p>SAM（Single AbstractMethod）只有一个抽象方法，除此之外没有其他方法</p><p>@FunctionalInterface 函数式接口</p><p>方法没有参数：（）-&gt;{};</p><p>方法有参数：（参数，参数）-&gt;{};</p><p>如果现在只有一行语句返回:(参数，参数)-&gt;语句</p><h4 id="从匿名类到-Lambda-的转换"><a href="#从匿名类到-Lambda-的转换" class="headerlink" title="从匿名类到 Lambda 的转换"></a>从匿名类到 Lambda 的转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Runnable r1= <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"HelloWorld!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda表达式</span></span><br><span class="line">Runnable r1 = () -&gt; System.out.println(<span class="string">"HelloWorld!"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来使用匿名内部类作为参数传递</span></span><br><span class="line">TreeSet&lt;String&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1,String o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(o1.length().o2.length());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda表达式作为参数传递</span></span><br><span class="line">TreeSet&lt;String&gt; ts2 = <span class="keyword">new</span> TreeSet&lt;&gt;(</span><br><span class="line">	(o1,o2) -&gt; Integer.compare(o1.length(),o2.length())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式语法"><a href="#Lambda表达式语法" class="headerlink" title="Lambda表达式语法"></a>Lambda表达式语法</h3><p>Lambda 表达式在Java 语言中引入了一个新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称<br>为 Lambda 操作符或剪头操作符。</p><p>它将 Lambda 分为两个部分：</p><p>左侧：指定了 Lambda 表达式需要的所有参数</p><p>右侧：指定了 Lambda 体，即 Lambda 表达式要执行的功能。</p><p><strong>语法格式1：</strong></p><p>无参，无返回值，Lambda体只需要一条语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnabe r1 = () -&gt; System.out.println(<span class="string">"HelloWorld!"</span>);</span><br></pre></td></tr></table></figure><p><strong>语法格式2：</strong></p><p>Lambda需要一个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; fun = (args) -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式3：</strong></p><p>Lambda只需要一个参数时，参数的小括号可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; fun = args -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式4：</strong></p><p>Lambda需要两个参数，并且有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo = (x,y) -&gt;&#123;</span><br><span class="line">  System.out.println(<span class="string">"实现函数接口方法"</span>);</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>语法格式5：</strong></p><p>当Lambda体只有一条语句时，return与大括号可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo = (x,y) -&gt; x + y;</span><br></pre></td></tr></table></figure><p><strong>语法格式6：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo = (Long x, Long y) -&gt;&#123;<span class="comment">//数据类型可以省略，因为可由编译器推断得出，称为"类型推断"</span></span><br><span class="line">  System.out.println(<span class="string">"实现函数接口方法"</span>);</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><ul><li>只包含一个抽象方法的接口，称为函数式接口。</li><li>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。</li></ul><ul><li>我们可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</li></ul><h3 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyNumber</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数式接口中使用泛型:</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunc</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作为参数传递Lambda表达式"><a href="#作为参数传递Lambda表达式" class="headerlink" title="作为参数传递Lambda表达式"></a>作为参数传递Lambda表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperString</span><span class="params">(MyFunc&lt;String&gt; mf,String str)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mf.getValue(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为参数传递Lambda表达式:</span></span><br><span class="line"></span><br><span class="line">String newStr = toUpperString(</span><br><span class="line">	(str) -&gt; str.toUpperCase(),<span class="string">"abcdef"</span>);</span><br><span class="line">System.out.println(newStr);</span><br></pre></td></tr></table></figure><p>作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。</p><h3 id="Java内置四大核心函数式接口"><a href="#Java内置四大核心函数式接口" class="headerlink" title="Java内置四大核心函数式接口"></a>Java内置四大核心函数式接口</h3><div class="table-container"><table><thead><tr><th style="text-align:center">函数式接口</th><th style="text-align:center">参数类型</th><th style="text-align:center">返回类型</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center"><code>Consumer&lt;T&gt;</code><br>消费型接口</td><td style="text-align:center">T</td><td style="text-align:center">void</td><td style="text-align:center">对类型为T的对象应用操作，<br>包含方法：<code>void accept(T t);</code></td></tr><tr><td style="text-align:center"><code>Supplier&lt;T&gt;</code><br>供给型接口</td><td style="text-align:center">无</td><td style="text-align:center">T</td><td style="text-align:center">返回类型为T的对象，<br>包含方法：<code>T get();</code></td></tr><tr><td style="text-align:center"><code>Function&lt;T,R&gt;</code></td><td style="text-align:center">T</td><td style="text-align:center">R</td><td style="text-align:center">对类型为T的对象应用操作，并返回结果，结果是R类型的对象，包含方法：<code>R apply(T t);</code></td></tr><tr><td style="text-align:center"><code>Predicate&lt;T&gt;</code></td><td style="text-align:center">T</td><td style="text-align:center">boolean</td><td style="text-align:center">确定类型为T的对象是否满足某约束，并返回boolean值。包含方法：<code>boolean test(T t);</code></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th></tr></thead><tbody><tr><td><code>BiFunction&lt;T,U,R&gt;</code></td><td>T,U</td><td>R</td><td>对类型为T,U参数应用操作，返回R类型的结果，<br>包含方法为<code>R apply(T t,U u);</code></td></tr><tr><td><code>UnaryOperator&lt;T&gt;</code><br>（Function子接口）</td><td>T</td><td>T</td><td>对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为<code>T apply(T t);</code></td></tr><tr><td><code>BinaryOperator&lt;T&gt;</code><br>(BigFunction子接口)</td><td>T，T</td><td>T</td><td>对类型为T的对象进行二元运算，并返回T类型的结果，包含方法为<code>T apply(T t1,T t2);</code></td></tr><tr><td><code>BigConsumer&lt;T,U&gt;</code></td><td>T,U</td><td>void</td><td>对类型为T,U参数应用操作，包含方法为<code>void accept(T t,U u)</code></td></tr><tr><td><code>ToIntFunction&lt;T&gt;</code><br><code>ToLongFunction&lt;T&gt;</code><br><code>ToDoubleFunction</code></td><td>T</td><td>int,long,double</td><td>分别计算int,long,double值的函数</td></tr><tr><td><code>IntFunction&lt;R&gt;</code><br><code>LongFunction&lt;R&gt;</code><br>DoubleFunction<r></r></td><td>int,long,double</td><td>R</td><td>参数分别为int，long，double类型的参数</td></tr></tbody></table></div><h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！<br>（实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致！）<br>方法引用：使用操作符 “::” 将方法名和对象或类的名字分隔开来。<br>如下三种主要使用情况：</p><ul><li>对象::实例方法</li><li>类::静态方法</li><li>类::实例方法</li></ul><p><strong>例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(x) -&gt; System.out.println(x);</span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line">System.out::println;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Double&gt; bo = (x,y) -&gt; Math.pow(x,y);</span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line">BinaryOperator&lt;Double&gt; bo = Math::pow;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compare((x,y) -&gt; x.equals(y),<span class="string">"abcdef"</span>,<span class="string">"abcdef"</span>);</span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line">comare(String::equals,<span class="string">"abc"</span>,<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><p>注意：当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引<br>用方法的第二个参数(或无参数)时：ClassName::methodName</p><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>格式： <code>ClassName::new</code><br>与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，与构造器参数列表要与接口中抽象方法的参数列表一致！</p><p><strong>例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,MyClass&gt; fun = (n) -&gt; <span class="keyword">new</span> MyClass(n);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Function&lt;Integer,MyClass&gt; fun = MyClass::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><p>格式： <code>type[] :: new</code></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,Integer[]&gt; fun = (n) -&gt; <span class="keyword">new</span> Integer[n];</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Function&lt;Integer,Integer[]&gt; fun = Integer[]::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><h2 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h2><blockquote><p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API(java.util.stream.*)。</p><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，</p><p>Stream API 提供了一种高效且易于使用的处理数据的方式。</p></blockquote><p><strong>流(Stream) 到底是什么呢？</strong><br>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br>“集合讲的是数据，流讲的是计算！”</p><p><strong>注意：</strong></p><ol><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol><h3 id="Strean的操作三个步骤"><a href="#Strean的操作三个步骤" class="headerlink" title="Strean的操作三个步骤"></a>Strean的操作三个步骤</h3><ul><li><p><strong>创建Stream</strong></p><p>一个数据源(如：集合、数组),获取一个流</p></li><li><p><strong>中间操作</strong></p><p>一个中间操作链，对数据源的数据进行处理</p></li><li><p><strong>终止操作(终端操作)</strong></p><p>一个终止操作，执行中间操作链，并产生结果</p></li></ul><p><img src="/category/JavaSE-java8新特性/1.png" alt="stream"></p><h4 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h4><p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream <span class="title">stream</span><span class="params">()</span></span>; <span class="comment">//返回一个顺序流</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream <span class="title">parallelStream</span><span class="params">()</span></span>; <span class="comment">//返回一个并行流</span></span><br></pre></td></tr></table></figure><h5 id="由数组创建流"><a href="#由数组创建流" class="headerlink" title="由数组创建流"></a>由数组创建流</h5><p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span>  Stream <span class="title">stream</span><span class="params">(T[] array)</span></span>;<span class="comment">//返回一个流</span></span><br></pre></td></tr></table></figure><p>重载形式，能够处理对应基本类型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">stream</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LongStream <span class="title">stream</span><span class="params">(<span class="keyword">long</span>[] array)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleStream <span class="title">stream</span><span class="params">(<span class="keyword">double</span>[] array)</span></span></span><br></pre></td></tr></table></figure><h5 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h5><p>可以使用静态方法 Stream.of(), 通过显示值创建一个流。它可以接收任意数量的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span></span>; <span class="comment">//返回一个流</span></span><br></pre></td></tr></table></figure><h5 id="由函数创建流：创建无限流"><a href="#由函数创建流：创建无限流" class="headerlink" title="由函数创建流：创建无限流"></a>由函数创建流：创建无限流</h5><p>可以使用静态方法 Stream.iterate() 和Stream.generate(), 创建无限流。</p><p>迭代<br><code>public static Stream iterate(final T seed, finalUnaryOperator f)</code><br>生成<br><code>public static Stream generate(Supplier s）</code></p><h4 id="Stream的中间操作"><a href="#Stream的中间操作" class="headerlink" title="Stream的中间操作"></a>Stream的中间操作</h4><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p><h5 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>filter(Predicate p)</code></td><td>接收Lembda，从流中排除某些元素</td></tr><tr><td><code>distinct()</code></td><td>筛选，通过流所生成元素的hashCode()和equals()去除重复元素</td></tr><tr><td><code>limit(long maxSize)</code></td><td>截断流，使其元素不超过给定数量</td></tr><tr><td><code>skip(long n)</code></td><td>跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，则返回一个空流，与limit(n)互补</td></tr></tbody></table></div><h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>map(Function f)</code></td><td>接收一函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</td></tr><tr><td><code>mapToDouble(ToDoubleFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream</td></tr><tr><td><code>mapToInt(ToIntFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream</td></tr><tr><td><code>mapToLong(ToLongFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream</td></tr><tr><td><code>flatMap(Function f)</code></td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td></tr></tbody></table></div><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sorted()</td><td>产生一个新流，其中按自然顺序排序</td></tr><tr><td>sorted(Comparator comp)</td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table></div><h4 id="Sream的终止操作"><a href="#Sream的终止操作" class="headerlink" title="Sream的终止操作"></a>Sream的终止操作</h4><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</p><h5 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>allMath(Predicate p)</td><td>检查是否匹配所有元素</td></tr><tr><td>antMath(Predicate p)</td><td>检查是否至少匹配一个元素</td></tr><tr><td>noneMath(Predicate p)</td><td>检查是否没有匹配所有元素</td></tr><tr><td>findFirst()</td><td>返回第一个元素</td></tr><tr><td>findAny()</td><td>返回当前流中的任意元素</td></tr><tr><td>count()</td><td>返回流中元素总数</td></tr><tr><td>max(Comparator c)</td><td>返回流中最大值</td></tr><tr><td>min(Coparator c)</td><td>返回流中最小值</td></tr><tr><td>forEach(Consumer c)</td><td>内部迭代(使用Collection接口需要用户去做迭代，称为外部迭代，相反，StreamAPI使用内部迭代—-它帮你把迭代做了)</td></tr></tbody></table></div><h5 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>reduce(T iden,BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回T</td></tr><tr><td>reduce(BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值，返回<code>Optional&lt;T&gt;</code></td></tr></tbody></table></div><h5 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>collect(Collector c)</td><td>将流转换为其他形式，接收一个Collector接口的实现，用于给Steam中元素做汇总工作</td></tr></tbody></table></div><p>Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">toList  List&lt;T&gt;  <span class="comment">//把流中元素收集到List  </span></span><br><span class="line">List&lt;Employee&gt; emps = list.stream().collect(Collectors.tolist());  </span><br><span class="line"></span><br><span class="line">toSet Set&lt;T&gt; <span class="comment">//把流中元素收集到Set</span></span><br><span class="line">Set&lt;Employee emps = list.stream().collect(Collectors.toSet());  </span><br><span class="line"></span><br><span class="line">toCollection Collection&lt;T&gt; <span class="comment">//把流中元素收集到创建的集合</span></span><br><span class="line">Collection&lt;Employee&gt; empls = list.stream().collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">counting Long <span class="comment">//计算流中元素的个数</span></span><br><span class="line"><span class="keyword">long</span> count = list.stream().collect(Collectors.counting());</span><br><span class="line"></span><br><span class="line">summingInt Integer <span class="comment">//对流中元素的整数属性求和</span></span><br><span class="line">inttotal = list.stream().collect(Collectors.summingInt(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">averaginInt Double <span class="comment">// 计算流中元素Integer属性的平均值</span></span><br><span class="line">doubleavg = list.stream().collect(Collectors.averagingInt(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">summarrizingInt IntSummartStatistics <span class="comment">//收集流中Integer属性的统计值，如平均值</span></span><br><span class="line">IntSummaryStatisticsiss = list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">joining String <span class="comment">//连接流中每个字符串</span></span><br><span class="line">String str = list.stream().map(Employee::getName).collect(Collectors.joining());</span><br><span class="line"></span><br><span class="line">maxBy Optional&lt;T&gt; <span class="comment">//根据比较器选择最大值</span></span><br><span class="line">Optional&lt;Emp&gt; max = list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</span><br><span class="line">minBy Optional&lt;T&gt; <span class="comment">//根据比较器选择最小值</span></span><br><span class="line">Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</span><br><span class="line"></span><br><span class="line">reducing 归约产生的类型 <span class="comment">//从一个作为累加器的初始值开始，利用BinaryOperator流中元素逐个结合，从而归约成单个值</span></span><br><span class="line">inttotal=list.stream().collect(Collectors.reducing(<span class="number">0</span>, Employee::getSalar, Integer::sum));</span><br><span class="line"></span><br><span class="line">collectingAndThen 转换函数返回的类型 <span class="comment">//包裹另一个收集器，对其结果转换函数</span></span><br><span class="line">inthow= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</span><br><span class="line"></span><br><span class="line">groupingBy Map&lt;K, List&lt;T&gt;&gt; <span class="comment">//根据某属性值对流分组，属性为K，结果为V</span></span><br><span class="line">Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));</span><br><span class="line"></span><br><span class="line">partitioningBy Map&lt;Boolean, List&lt;T&gt;&gt; <span class="comment">//根据true或false进行分区</span></span><br><span class="line">Map&lt;Boolean,List&lt;Emp&gt;&gt;vd=</span><br><span class="line">list.stream().collect(Collectors.partitioningBy(Employee::getManage));</span><br></pre></td></tr></table></figure><h3 id="并行流与串行流"><a href="#并行流与串行流" class="headerlink" title="并行流与串行流"></a>并行流与串行流</h3><p>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。</p><p>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与sequential() 在并行流与顺序流之间进行切换。</p><h3 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork/Join 框架"></a>Fork/Join 框架</h3><p>Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总.</p><p><img src="/category/JavaSE-java8新特性/2.png" alt="java8"></p><h4 id="Fork-Join-框架与传统线程池的区别"><a href="#Fork-Join-框架与传统线程池的区别" class="headerlink" title="Fork/Join 框架与传统线程池的区别"></a>Fork/Join 框架与传统线程池的区别</h4><blockquote><p>采用 “工作窃取”模式（work-stealing）：</p><p>当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p><p>相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间,提高了性能.</p></blockquote><h2 id="新时间日期API"><a href="#新时间日期API" class="headerlink" title="新时间日期API"></a>新时间日期API</h2><h3 id="使用-LocalDate、LocalTime、LocalDateTime"><a href="#使用-LocalDate、LocalTime、LocalDateTime" class="headerlink" title="使用 LocalDate、LocalTime、LocalDateTime"></a>使用 LocalDate、LocalTime、LocalDateTime</h3><p>LocalDate、LocalTime、LocalDateTime 类的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。</p><p>注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法</p><p><img src="/category/JavaSE-java8新特性/3.png" alt="java8"></p><h3 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant 时间戳"></a>Instant 时间戳</h3><p>用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算</p><h3 id="Duration-和-Period"><a href="#Duration-和-Period" class="headerlink" title="Duration 和 Period"></a>Duration 和 Period</h3><ul><li>Duration:用于计算两个“时间”间隔</li><li>Period:用于计算两个“日期”间隔</li></ul><h3 id="日期的操纵"><a href="#日期的操纵" class="headerlink" title="日期的操纵"></a>日期的操纵</h3><p>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。</p><ul><li>TemporalAdjusters : 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现。</li></ul><p>例如获取下个周日：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate nextSunday = LocalDate.now().with(</span><br><span class="line">	TemporalAdjusters.next(DayOfWeek.SUNDAY)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="解析与格式化"><a href="#解析与格式化" class="headerlink" title="解析与格式化"></a>解析与格式化</h3><p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p><ul><li>预定义的标准格式</li><li>语言环境相关的格式</li><li>自定义的格式</li></ul><h3 id="时区的处理"><a href="#时区的处理" class="headerlink" title="时区的处理"></a>时区的处理</h3><p>Java8 中加入了对时区的支持，带时区的时间为分别为：<br>ZonedDate、ZonedTime、ZonedDateTime<br>其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式<br>例如 ：Asia/Shanghai 等<br>ZoneId：该类中包含了所有的时区信息<br>getAvailableZoneIds() : 可以获取所有时区时区信息<br>of(id) : 用指定的时区信息获取 ZoneId 对象</p><h3 id="与传统日期处理的转换"><a href="#与传统日期处理的转换" class="headerlink" title="与传统日期处理的转换"></a>与传统日期处理的转换</h3><p><img src="/category/JavaSE-java8新特性/4.png" alt="java8"></p><h2 id="接口中的默认方法与静态方法"><a href="#接口中的默认方法与静态方法" class="headerlink" title="接口中的默认方法与静态方法"></a>接口中的默认方法与静态方法</h2><p>Java 8中允许接口中包含具有具体实现的方法，该方法称为“默认方法”，默认方法使用 default 关键字修饰。</p><p><strong>例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunc</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">defalut String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello Java8"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口默认方法的”类优先”原则</strong></p><p>若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时</p><ul><li>选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。</li></ul><ul><li>接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunc</span></span>&#123;</span><br><span class="line">  <span class="function">defalut String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello Java8"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span></span>&#123;</span><br><span class="line">  <span class="function">defalut String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello Java"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyFunc</span>,<span class="title">Named</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Named.<span class="keyword">super</span>,getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口中的静态方法"><a href="#接口中的静态方法" class="headerlink" title="接口中的静态方法"></a>接口中的静态方法</h4><p>Java8 中，接口中允许添加静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">myFun</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello java"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h2><h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><p>Optional 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p><p><strong>常用方法：</strong><br><code>Optional.of(T t)</code> : 创建一个 Optional 实例<br><code>Optional.empty()</code> : 创建一个空的 Optional 实例<br><code>Optional.ofNullable(T t)</code>:若 t 不为 null,创建 Optional 实例,否则创建空实例<br><code>isPresent()</code> : 判断是否包含值<br><code>orElse(T t)</code> : 如果调用对象包含值，返回该值，否则返回t<br><code>orElseGet(Supplier s)</code> :如果调用对象包含值，返回该值，否则返回 s 获取的值<br><code>map(Function f)</code>: 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()<br><code>flatMap(Function mapper)</code>:与 map 类似，要求返回值必须是Optional</p><h3 id="重复注解与类型注解"><a href="#重复注解与类型注解" class="headerlink" title="重复注解与类型注解"></a>重复注解与类型注解</h3><p>Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations&#123;</span><br><span class="line">  MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repetable</span>(MyAnnotations.class)</span><br><span class="line"><span class="meta">@Target</span>(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,ElementType.TYPE_PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetemtionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation</span>(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="meta">@MyANnotation</span>(<span class="string">"World"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(@MyAnnotation(<span class="string">"abc"</span>)</span>String str)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>在 Java 5.0 提供了 java.util.concurrent （简称JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。提供可调的、灵活的线程池。还提供了设计用于多线程上下文中的 Collection 实现等。</p><h3 id="volatile关键字-内存可见性"><a href="#volatile关键字-内存可见性" class="headerlink" title="volatile关键字 内存可见性"></a>volatile关键字 内存可见性</h3><p><strong>内存可见性</strong></p><p>内存可见性（Memory Visibility）是指当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p><ul><li>可见性错误是指当读操作与写操作在不同的线程中执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。</li></ul><ul><li>我们可以通过同步来保证对象被安全地发布。除此之外我们也可以使用一种更加轻量级的 volatile 变量。</li></ul><p><strong>volatile 关键字</strong></p><p>Java 提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。可以将 volatile 看做一个轻量级的锁，但是又与锁有些不同：</p><ul><li>对于多线程，不是一种互斥关系</li><li>不能保证变量状态的“原子性操作”</li></ul><h3 id="原子变量-CAS算法"><a href="#原子变量-CAS算法" class="headerlink" title="原子变量 CAS算法"></a>原子变量 CAS算法</h3><p><strong>CAS算法</strong></p><ul><li>CAS (Compare-And-Swap) 是一种硬件对并发的支持，针对多处理器操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。</li><li>CAS 是一种无锁的非阻塞算法的实现。</li><li>CAS 包含了 3 个操作数：<ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul></li><li>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作。</li></ul><p><strong>原子变量</strong></p><ul><li>类的小工具包，支持在单个变量上解除锁的线程安全编程。事实上，此包中的类可将 volatile 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类。</li><li>类 AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 的实例各自提供对相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。</li><li>AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray 类进一步扩展了原子操作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方面也引人注目，这对于普通数组来说是不受支持的。</li><li><strong>核心方法：boolean compareAndSet(expectedValue, updateValue)</strong></li><li>java.util.concurrent.atomic 包下提供了一些原子操作的常用类:<ul><li>AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference</li><li>AtomicIntegerArray 、AtomicLongArray</li><li>AtomicMarkableReference</li><li>AtomicReferenceArray</li><li>AtomicStampedReference</li></ul></li></ul><h3 id="ConcurrentHashMap-锁分段机制"><a href="#ConcurrentHashMap-锁分段机制" class="headerlink" title="ConcurrentHashMap 锁分段机制"></a>ConcurrentHashMap 锁分段机制</h3><p><strong>ConcurrentHashMap</strong></p><p>Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。</p><ul><li>ConcurrentHashMap 同步容器类是Java 5 增加的一个线程安全的哈希表。对与多线程的操作，介于 HashMap 与 Hashtable 之间。内部采用“锁分段”机制替代 Hashtable 的独占锁。进而提高性能。</li><li>此包还提供了设计用于多线程上下文中的 Collection 实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap，ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。</li></ul><h3 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch 闭锁"></a>CountDownLatch 闭锁</h3><ul><li>Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。</li></ul><ul><li>CountDownLatch 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</li></ul><ul><li>闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行：<ul><li>确保某个计算在其需要的所有资源都被初始化之后才继续执行;</li><li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动;</li><li>等待直到某个操作所有参与者都准备就绪再继续执行。</li></ul></li></ul><h3 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h3><ul><li>Java 5.0 在 java.util.concurrent 提供了一个新的创建执行线程的方式：Callable 接口</li></ul><ul><li>Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常。</li></ul><ul><li>Callable 需要依赖FutureTask ，FutureTask 也可以用作闭锁。</li></ul><h3 id="Lock-同步锁"><a href="#Lock-同步锁" class="headerlink" title="Lock 同步锁"></a>Lock 同步锁</h3><p><strong>显示锁 Lock</strong></p><ul><li>在 Java 5.0 之前，协调共享对象的访问时可以使用的机制只有 synchronized 和 volatile 。Java 5.0 后增加了一些新的机制，但并不是一种替代内置锁的方法，而是当内置锁不适用时，作为一种可选择的高级功能。</li></ul><ul><li>ReentrantLock 实现了 Lock 接口，并提供了与synchronized 相同的互斥性和内存可见性。但相较于synchronized 提供了更高的处理锁的灵活性。</li></ul><h3 id="Condition-控制线程通信"><a href="#Condition-控制线程通信" class="headerlink" title="Condition 控制线程通信"></a>Condition 控制线程通信</h3><p><strong>Condition</strong></p><ul><li>Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。</li></ul><ul><li>在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是await、signal 和 signalAll。</li></ul><ul><li>Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得Condition 实例，请使用其 newCondition() 方法。</li></ul><h3 id="线程按序交替"><a href="#线程按序交替" class="headerlink" title="线程按序交替"></a>线程按序交替</h3><p>编写一个程序，开启 3 个线程，这三个线程的 ID 分别为A、B、C，每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出的结果必须按顺序显示。<br>如：ABCABCABC…… 依次递归</p><h3 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h3><ul><li>ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。。</li></ul><ul><li>ReadWriteLock 读取操作通常不会改变共享资源，但执行写入操作时，必须独占方式来获取锁。对于读取操作占多数的数据结构。 ReadWriteLock 能提供比独占锁更高的并发性。而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作。</li></ul><h3 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h3><ul><li>一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法</li></ul><ul><li>锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</li></ul><ul><li>加个普通方法后发现和同步锁无关</li><li>换成两个对象后，不是同一把锁了，情况立刻变化。</li><li>都换成静态同步方法后，情况又变化</li><li>所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</li></ul><ul><li>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li>第四种获取线程的方法：线程池，一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。</li></ul><ul><li>线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。</li></ul><ul><li>为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 ：</li></ul><ul><li>Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）</li><li>Executors.newFixedThreadPool(int)（固定大小线程池）</li><li>Executors.newSingleThreadExecutor()（单个后台线程）它们均为大多数使用场景预定义了设置。</li></ul><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p><strong>ScheduledExecutorService</strong></p><p>一个 ExecutorService，可安排在给定的延迟后运行或定期执行的命令。</p><h3 id="ForkJoinPool-分支-合并框架-工作窃取"><a href="#ForkJoinPool-分支-合并框架-工作窃取" class="headerlink" title="ForkJoinPool 分支/合并框架 工作窃取"></a>ForkJoinPool 分支/合并框架 工作窃取</h3><p><strong>Fork/Join 框架</strong></p><p>Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总。</p><p><img src="/category/JavaSE-java8新特性/5.png" alt="juc"></p><p><strong>Fork/Join 框架与线程池的区别</strong></p><ul><li>采用 “工作窃取”模式（work-stealing）：当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</li></ul><ul><li>相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间，提高了性能。</li></ul><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</p><p><strong>Java NIO 与 IO 的主要区别</strong></p><p><img src="/category/JavaSE-java8新特性/6.png" alt="nio"></p><h3 id="通道（Channel）与缓冲区（Buffer）"><a href="#通道（Channel）与缓冲区（Buffer）" class="headerlink" title="通道（Channel）与缓冲区（Buffer）"></a>通道（Channel）与缓冲区（Buffer）</h3><p>Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</p><p><strong>简而言之，Channel 负责传输， Buffer 负责存储</strong></p><h4 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h4><ul><li>缓冲区（Buffer）：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。</li></ul><ul><li>Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的。</li></ul><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。都是通过如下方法获取一个 Buffer对象：</p><p><strong>static XxxBuffer allocate(int capacity) : 创建一个容量为 capacity 的 XxxBuffer 对象</strong></p><h5 id="缓冲区的基本属性"><a href="#缓冲区的基本属性" class="headerlink" title="缓冲区的基本属性"></a>缓冲区的基本属性</h5><p>Buffer 中的重要概念：</p><ul><li>容量 (capacity) ：表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。</li></ul><ul><li>限制 (limit)：第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量。</li></ul><ul><li>位置 (position)：下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制</li></ul><ul><li>标记 (mark)与重置 (reset)：标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position.</li></ul><p>标记、位置、限制、容量遵守以下不变式： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p><p><img src="/category/JavaSE-java8新特性/7.png" alt="nio"></p><h5 id="Buffer的常用方法"><a href="#Buffer的常用方法" class="headerlink" title="Buffer的常用方法"></a>Buffer的常用方法</h5><p><img src="/category/JavaSE-java8新特性/8.png" alt="nio"></p><h5 id="缓冲区的数据操作"><a href="#缓冲区的数据操作" class="headerlink" title="缓冲区的数据操作"></a>缓冲区的数据操作</h5><ul><li>Buffer 所有子类提供了两个用于数据操作的方法：get()与 put() 方法<ul><li>获取 Buffer 中的数据<ul><li>get() ：读取单个字节</li><li>get(byte[] dst)：批量读取多个字节到 dst 中</li><li>get(int index)：读取指定索引位置的字节(不会移动 position)</li></ul></li><li>放入数据到 Buffer 中<ul><li>put(byte b)：将给定单个字节写入缓冲区的当前位置</li><li>put(byte[] src)：将 src 中的字节写入缓冲区的当前位置</li><li>put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 position)</li></ul></li></ul></li></ul><h5 id="直接与非直接缓冲区"><a href="#直接与非直接缓冲区" class="headerlink" title="直接与非直接缓冲区"></a>直接与非直接缓冲区</h5><ul><li>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。</li></ul><ul><li>直接字节缓冲区可以通过调用此类的 allocateDirect() 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。</li></ul><ul><li>直接字节缓冲区还可以通过 FileChannel 的 map() 方法 将文件区域直接映射到内存中来创建。该方法返回MappedByteBuffer 。Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。</li></ul><ul><li>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。</li></ul><p><strong>非直接缓冲区</strong></p><p><img src="/category/JavaSE-java8新特性/a1.png" alt="nio"></p><p><strong>直接缓冲区</strong></p><p><img src="/category/JavaSE-java8新特性/a2.png" alt="nio"></p><h4 id="通道（Channel）"><a href="#通道（Channel）" class="headerlink" title="通道（Channel）"></a>通道（Channel）</h4><p>通道（Channel）：由 java.nio.channels 包定义的。Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据，Channel 只能与Buffer 进行交互。</p><p><img src="/category/JavaSE-java8新特性/b1.png" alt="nio"></p><p><img src="/category/JavaSE-java8新特性/b2.png" alt="nio"></p><p><img src="/category/JavaSE-java8新特性/b3.png" alt="nio"></p><p>Java 为 Channel 接口提供的最主要实现类如下：</p><ul><li>FileChannel：用于读取、写入、映射和操作文件的通道。</li><li>DatagramChannel：通过 UDP 读写网络中的数据通道。</li><li>SocketChannel：通过 TCP 读写网络中的数据。</li><li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><h5 id="获取通道"><a href="#获取通道" class="headerlink" title="获取通道"></a>获取通道</h5><p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul><p>获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道。</p><h5 id="通道的数据传输"><a href="#通道的数据传输" class="headerlink" title="通道的数据传输"></a>通道的数据传输</h5><p>将 Buffer 中数据写入 Channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Buffer中数据写入Channel中</span></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure><p>从 Channel 读取数据到 Buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从Channel读取数据到Buffer</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure><h4 id="分散-Scatter-和聚集-Gather"><a href="#分散-Scatter-和聚集-Gather" class="headerlink" title="分散(Scatter)和聚集(Gather)"></a>分散(Scatter)和聚集(Gather)</h4><p><strong>分散读取（Scattering Reads）是指从 Channel 中读取的数据“分散”到多个 Buffer 中。</strong></p><p><img src="/category/JavaSE-java8新特性/c1.png" alt="nio"></p><p>注意：按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满。</p><p><strong>聚集写入（Gathering Writes）是指将多个 Buffer 中的数据“聚集”到 Channel。</strong></p><p><img src="/category/JavaSE-java8新特性/c2.png" alt="nio"></p><p>注意：按照缓冲区的顺序，写入 position 和 limit 之间的数据到 Channel 。</p><h4 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h4><p>将数据从源通道传输到其他 Channel 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/fromFile.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line"><span class="comment">//获取FileChannel</span></span><br><span class="line">FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/toFile.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义传输位置</span></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最多传输的字节数</span></span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据从源通道传输到另一个通道</span></span><br><span class="line">toChannel.transferFrom(fromChannel,count,position);</span><br></pre></td></tr></table></figure><h4 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h4><p>将数据从源通道传输到其他 Channel 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/fromFile.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line"><span class="comment">//获取FileChannel</span></span><br><span class="line">FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/toFile.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义传输位置</span></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最多传输的字节数</span></span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据从源通道传输到另一个通道</span></span><br><span class="line">fromChannel.transferTo(position,count,toChannel);</span><br></pre></td></tr></table></figure><h4 id="FileChannel-的常用方法"><a href="#FileChannel-的常用方法" class="headerlink" title="FileChannel 的常用方法"></a>FileChannel 的常用方法</h4><p><img src="/category/JavaSE-java8新特性/11.png" alt="nio"></p><h3 id="NIO-的非阻塞式网络通信"><a href="#NIO-的非阻塞式网络通信" class="headerlink" title="NIO 的非阻塞式网络通信"></a>NIO 的非阻塞式网络通信</h3><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><ul><li>传统的 IO 流都是阻塞式的。也就是说，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行 IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。</li></ul><ul><li>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO 可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。</li></ul><h4 id="选择器（Selector）"><a href="#选择器（Selector）" class="headerlink" title="选择器（Selector）"></a>选择器（Selector）</h4><ul><li>选择器（Selector） 是 SelectableChannle 对象的多路复用器，Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心。</li></ul><ul><li>SelectableChannle 的结构如下图：</li></ul><p><img src="/category/JavaSE-java8新特性/12.png" alt="nio"></p><h4 id="选择器（Selector）的应用"><a href="#选择器（Selector）的应用" class="headerlink" title="选择器（Selector）的应用"></a>选择器（Selector）的应用</h4><p>创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><p>向选择器注册通道：SelectableChannel.register(Selector sel, int ops)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Socket套接字</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Sokcet(InetAddress.getByName(<span class="string">"127.0.0.1"</span>),<span class="number">9898</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取SocketChannel</span></span><br><span class="line">SocketChannel channel = scoket.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将SocketChannel切换到非阻塞模式</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向Selector注册Channel</span></span><br><span class="line">SelectionKey key = channel.register(selector,SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h4><ul><li>当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器</li></ul><p>对通道的监听事件，需要通过第二个参数 ops 指定。</p><ul><li>可以监听的事件类型（可使用 SelectionKey 的四个常量表示）：<ul><li>读 : SelectionKey.OP_READ （1）</li><li>写 : SelectionKey.OP_WRITE （4）</li><li>连接 : SelectionKey.OP_CONNECT （8）</li><li>接收 : SelectionKey.OP_ACCEPT （16）</li></ul></li></ul><ul><li>若注册时不止监听一个事件，则可以使用“位或”操作符连接。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册"监听事件"</span></span><br><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ|SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><p>SelectionKey：表示 SelectableChannel 和 Selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。</p><p><img src="/category/JavaSE-java8新特性/21.png" alt="nio"></p><h4 id="Selector-的常用方法"><a href="#Selector-的常用方法" class="headerlink" title="Selector 的常用方法"></a>Selector 的常用方法</h4><p><img src="/category/JavaSE-java8新特性/22.png" alt="nio"></p><h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。</p><p>操作步骤：</p><ul><li>打开 SocketChannel</li><li>读写数据</li><li>关闭 SocketChannel</li></ul><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道，就像标准IO中的ServerSocket一样。</p><h4 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h4><p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。<br>操作步骤：</p><ul><li>打开 DatagramChannel</li><li>接收/发送数据</li></ul><h4 id="管道-Pipe"><a href="#管道-Pipe" class="headerlink" title="管道 (Pipe)"></a>管道 (Pipe)</h4><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</p><p><img src="/category/JavaSE-java8新特性/23.png" alt="nio"></p><h5 id="向管道写数据"><a href="#向管道写数据" class="headerlink" title="向管道写数据"></a>向管道写数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">  String str = <span class="string">"测试数据"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建管道</span></span><br><span class="line">  Pipe pipe = Pipe.open();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//向管道写输入</span></span><br><span class="line">  Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//通过SinkChannel的write()方法写数据</span></span><br><span class="line">  ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">  buf.clear();</span><br><span class="line">  buf.put(str.getBytes());</span><br><span class="line">  buf.flip();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">    sinkChannel.write(buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a>从管道读取数据</h5><p>从读取管道的数据，需要访问source通道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从管道读取数据</span></span><br><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br></pre></td></tr></table></figure><p>调用source通道的read()方法来读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用SourceChannel的read()方法读取数据</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">sourceChannel.read(buf);</span><br></pre></td></tr></table></figure><h3 id="NIO-2-–-Path、Paths、Files"><a href="#NIO-2-–-Path、Paths、Files" class="headerlink" title="NIO.2 – Path、Paths、Files"></a>NIO.2 – Path、Paths、Files</h3><h4 id="NIO-2"><a href="#NIO-2" class="headerlink" title="NIO.2"></a>NIO.2</h4><p>随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。</p><h4 id="Path-与-Paths"><a href="#Path-与-Paths" class="headerlink" title="Path 与 Paths"></a>Path 与 Paths</h4><ul><li>java.nio.file.Path 接口代表一个平台无关的平台路径，描述了目录结构中文件的位置。</li><li>Paths 提供的 get() 方法用来获取 Path 对象：<ul><li>Path get(String first, String … more) : 用于将多个字符串串连成路径。</li></ul></li></ul><ul><li>Path 常用方法：<ul><li>boolean endsWith(String path) : 判断是否以 path 路径结束</li><li>boolean startsWith(String path) : 判断是否以 path 路径开始</li><li>boolean isAbsolute() : 判断是否是绝对路径</li><li>Path getFileName() : 返回与调用 Path 对象关联的文件名</li><li>Path getName(int idx) : 返回的指定索引位置 idx 的路径名称</li><li>int getNameCount() : 返回Path 根目录后面元素的数量</li><li>Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</li><li>Path getRoot() ：返回调用 Path 对象的根路径</li><li>Path resolve(Path p) :将相对路径解析为绝对路径</li><li>Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</li><li>String toString() ： 返回调用 Path 对象的字符串表示形式</li></ul></li></ul><h4 id="Files-类"><a href="#Files-类" class="headerlink" title="Files 类"></a>Files 类</h4><ul><li>java.nio.file.Files 用于操作文件或目录的工具类。</li><li>Files常用方法：<ul><li>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</li><li>Path createDirectory(Path path, FileAttribute … attr) : 创建一个目录</li><li>Path createFile(Path path, FileAttribute … arr) : 创建一个文件</li><li>void delete(Path path) : 删除一个文件</li><li>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</li><li>long size(Path path) : 返回 path 指定文件的大小</li></ul></li><li>Files常用方法：用于判断<ul><li>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</li><li>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</li><li>boolean isExecutable(Path path) : 判断是否是可执行文件</li><li>boolean isHidden(Path path) : 判断是否是隐藏文件</li><li>boolean isReadable(Path path) : 判断文件是否可读</li><li>boolean isWritable(Path path) : 判断文件是否可写</li><li>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</li><li><code>public static &lt;A extends BasicFileAttributes&gt; A readAttributes(Path path,Class&lt;A&gt; type,LinkOption...options)</code> : 获取与 path 指定的文件相关联的属性。</li></ul></li></ul><ul><li>Files常用方法：用于操作内容<ul><li>SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式</li><li>DirectoryStream newDirectoryStream(Path path) : 打开 path 指定的目录</li><li>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</li><li>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象]()</li></ul></li></ul><h4 id="自动资源管理"><a href="#自动资源管理" class="headerlink" title="自动资源管理"></a>自动资源管理</h4><p>Java 7 增加了一个新特性，该特性提供了另外一种管理资源的方式，这种方式能自动关闭文件。这个特性有时被称为自动资源管理(Automatic Resource Management, ARM)， 该特性以 try 语句的扩展版为基础。自动资源管理主要用于，当不再需要文件（或其他资源）时，可以防止无意中忘记释放它们。</p><p>自动资源管理基于 try 语句的扩展形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(需要关闭的资源声明)&#123;</span><br><span class="line"><span class="comment">//可能发生异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 变量名)&#123;</span><br><span class="line"><span class="comment">//异常的处理语句</span></span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//一定执行的语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当 try 代码块结束时，自动释放资源。因此不需要显示的调用 close() 方法。该形式也称为“带资源的 try 语句”。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">1. try 语句中声明的资源被隐式声明为 final ，资源的作用局限于带资源的 try 语句</span></span><br><span class="line"><span class="comment">2. 可以在一条 try 语句中管理多个资源，每个资源以“;” 隔开即可。</span></span><br><span class="line"><span class="comment">3. 需要关闭的资源，必须实现了 AutoCloseable 接口或其自接口 Closeable</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">----------------本文结束<i class="fa fa-heart"></i>感谢阅读----------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> Goya</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.ysmjjsy.com/category/JavaSE-java8新特性/" title="JavaSE-java8新特性">https://www.ysmjjsy.com/category/JavaSE-java8新特性/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java基础入门/" rel="tag"><i class="fa fa-tag"></i> Java基础入门</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/category/JavaSE-枚举/" rel="next" title="JavaSE-枚举"><i class="fa fa-chevron-left"></i> JavaSE-枚举</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/category/JavaSE-数组/" rel="prev" title="JavaSE-数组">JavaSE-数组 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="addthis_inline_share_toolbox"><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5d44446d8ec752bd" async></script></div></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Goya"><p class="site-author-name" itemprop="name">Goya</p><p class="site-description motion-element" itemprop="description">愿你走出半生，归来仍是少年</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">30</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">41</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">6</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/GoyaDo" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/a773949603" target="_blank" title="CSDN"><i class="fa fa-fw fa-copyright"></i>CSDN</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/lemondeah/activities" target="_blank" title="知乎"><i class="fa fa-fw fa-zhihu"></i>知乎</a> </span><span class="links-of-author-item"><a href="https://weibo.com/u/6606679478" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i>微博</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://me.csdn.net/sinyu890807" title="郭霖" target="_blank">郭霖</a></li><li class="links-of-blogroll-item"><a href="https://www.zhihu.com/people/huangsunting/activities" title="bravo1988" target="_blank">bravo1988</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java8新特性"><span class="nav-number">1.</span> <span class="nav-text">Java8新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda表达式"><span class="nav-number">1.1.</span> <span class="nav-text">Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么使用Lambda表达式"><span class="nav-number">1.1.1.</span> <span class="nav-text">为什么使用Lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda表达式-1"><span class="nav-number">1.1.2.</span> <span class="nav-text">Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从匿名类到-Lambda-的转换"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">从匿名类到 Lambda 的转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda表达式语法"><span class="nav-number">1.1.3.</span> <span class="nav-text">Lambda表达式语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类型推断"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">类型推断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式接口"><span class="nav-number">1.2.</span> <span class="nav-text">函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义函数式接口"><span class="nav-number">1.2.1.</span> <span class="nav-text">自定义函数式接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作为参数传递Lambda表达式"><span class="nav-number">1.2.2.</span> <span class="nav-text">作为参数传递Lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java内置四大核心函数式接口"><span class="nav-number">1.2.3.</span> <span class="nav-text">Java内置四大核心函数式接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法引用与构造器引用"><span class="nav-number">1.3.</span> <span class="nav-text">方法引用与构造器引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法引用"><span class="nav-number">1.3.1.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器引用"><span class="nav-number">1.3.2.</span> <span class="nav-text">构造器引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组引用"><span class="nav-number">1.3.3.</span> <span class="nav-text">数组引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StreamAPI"><span class="nav-number">1.4.</span> <span class="nav-text">StreamAPI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Strean的操作三个步骤"><span class="nav-number">1.4.1.</span> <span class="nav-text">Strean的操作三个步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建Stream"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">创建Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#由数组创建流"><span class="nav-number">1.4.1.1.1.</span> <span class="nav-text">由数组创建流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#由值创建流"><span class="nav-number">1.4.1.1.2.</span> <span class="nav-text">由值创建流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#由函数创建流：创建无限流"><span class="nav-number">1.4.1.1.3.</span> <span class="nav-text">由函数创建流：创建无限流</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream的中间操作"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">Stream的中间操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#筛选与切片"><span class="nav-number">1.4.1.2.1.</span> <span class="nav-text">筛选与切片</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#映射"><span class="nav-number">1.4.1.2.2.</span> <span class="nav-text">映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#排序"><span class="nav-number">1.4.1.2.3.</span> <span class="nav-text">排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sream的终止操作"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">Sream的终止操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#查找与匹配"><span class="nav-number">1.4.1.3.1.</span> <span class="nav-text">查找与匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#归约"><span class="nav-number">1.4.1.3.2.</span> <span class="nav-text">归约</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#收集"><span class="nav-number">1.4.1.3.3.</span> <span class="nav-text">收集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并行流与串行流"><span class="nav-number">1.4.2.</span> <span class="nav-text">并行流与串行流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork-Join-框架"><span class="nav-number">1.4.3.</span> <span class="nav-text">Fork/Join 框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Fork-Join-框架与传统线程池的区别"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">Fork/Join 框架与传统线程池的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#新时间日期API"><span class="nav-number">1.5.</span> <span class="nav-text">新时间日期API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-LocalDate、LocalTime、LocalDateTime"><span class="nav-number">1.5.1.</span> <span class="nav-text">使用 LocalDate、LocalTime、LocalDateTime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Instant-时间戳"><span class="nav-number">1.5.2.</span> <span class="nav-text">Instant 时间戳</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Duration-和-Period"><span class="nav-number">1.5.3.</span> <span class="nav-text">Duration 和 Period</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期的操纵"><span class="nav-number">1.5.4.</span> <span class="nav-text">日期的操纵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析与格式化"><span class="nav-number">1.5.5.</span> <span class="nav-text">解析与格式化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时区的处理"><span class="nav-number">1.5.6.</span> <span class="nav-text">时区的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与传统日期处理的转换"><span class="nav-number">1.5.7.</span> <span class="nav-text">与传统日期处理的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口中的默认方法与静态方法"><span class="nav-number">1.6.</span> <span class="nav-text">接口中的默认方法与静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口中的静态方法"><span class="nav-number">1.6.0.1.</span> <span class="nav-text">接口中的静态方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他特性"><span class="nav-number">1.7.</span> <span class="nav-text">其他特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Optional类"><span class="nav-number">1.7.1.</span> <span class="nav-text">Optional类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重复注解与类型注解"><span class="nav-number">1.7.2.</span> <span class="nav-text">重复注解与类型注解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC"><span class="nav-number">1.8.</span> <span class="nav-text">JUC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile关键字-内存可见性"><span class="nav-number">1.8.1.</span> <span class="nav-text">volatile关键字 内存可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子变量-CAS算法"><span class="nav-number">1.8.2.</span> <span class="nav-text">原子变量 CAS算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap-锁分段机制"><span class="nav-number">1.8.3.</span> <span class="nav-text">ConcurrentHashMap 锁分段机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch-闭锁"><span class="nav-number">1.8.4.</span> <span class="nav-text">CountDownLatch 闭锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-Callable-接口"><span class="nav-number">1.8.5.</span> <span class="nav-text">实现 Callable 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock-同步锁"><span class="nav-number">1.8.6.</span> <span class="nav-text">Lock 同步锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition-控制线程通信"><span class="nav-number">1.8.7.</span> <span class="nav-text">Condition 控制线程通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程按序交替"><span class="nav-number">1.8.8.</span> <span class="nav-text">线程按序交替</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadWriteLock-读写锁"><span class="nav-number">1.8.9.</span> <span class="nav-text">ReadWriteLock 读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程八锁"><span class="nav-number">1.8.10.</span> <span class="nav-text">线程八锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">1.8.11.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程调度"><span class="nav-number">1.8.12.</span> <span class="nav-text">线程调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoinPool-分支-合并框架-工作窃取"><span class="nav-number">1.8.13.</span> <span class="nav-text">ForkJoinPool 分支/合并框架 工作窃取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO"><span class="nav-number">1.9.</span> <span class="nav-text">NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通道（Channel）与缓冲区（Buffer）"><span class="nav-number">1.9.1.</span> <span class="nav-text">通道（Channel）与缓冲区（Buffer）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲区（Buffer）"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">缓冲区（Buffer）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#缓冲区的基本属性"><span class="nav-number">1.9.1.1.1.</span> <span class="nav-text">缓冲区的基本属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Buffer的常用方法"><span class="nav-number">1.9.1.1.2.</span> <span class="nav-text">Buffer的常用方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缓冲区的数据操作"><span class="nav-number">1.9.1.1.3.</span> <span class="nav-text">缓冲区的数据操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#直接与非直接缓冲区"><span class="nav-number">1.9.1.1.4.</span> <span class="nav-text">直接与非直接缓冲区</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通道（Channel）"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">通道（Channel）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#获取通道"><span class="nav-number">1.9.1.2.1.</span> <span class="nav-text">获取通道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通道的数据传输"><span class="nav-number">1.9.1.2.2.</span> <span class="nav-text">通道的数据传输</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分散-Scatter-和聚集-Gather"><span class="nav-number">1.9.1.3.</span> <span class="nav-text">分散(Scatter)和聚集(Gather)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#transferFrom"><span class="nav-number">1.9.1.4.</span> <span class="nav-text">transferFrom()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#transferTo"><span class="nav-number">1.9.1.5.</span> <span class="nav-text">transferTo()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FileChannel-的常用方法"><span class="nav-number">1.9.1.6.</span> <span class="nav-text">FileChannel 的常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO-的非阻塞式网络通信"><span class="nav-number">1.9.2.</span> <span class="nav-text">NIO 的非阻塞式网络通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞与非阻塞"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">阻塞与非阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择器（Selector）"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">选择器（Selector）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择器（Selector）的应用"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">选择器（Selector）的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SelectionKey"><span class="nav-number">1.9.2.4.</span> <span class="nav-text">SelectionKey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Selector-的常用方法"><span class="nav-number">1.9.2.5.</span> <span class="nav-text">Selector 的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SocketChannel"><span class="nav-number">1.9.2.6.</span> <span class="nav-text">SocketChannel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DatagramChannel"><span class="nav-number">1.9.2.7.</span> <span class="nav-text">DatagramChannel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管道-Pipe"><span class="nav-number">1.9.2.8.</span> <span class="nav-text">管道 (Pipe)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#向管道写数据"><span class="nav-number">1.9.2.8.1.</span> <span class="nav-text">向管道写数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从管道读取数据"><span class="nav-number">1.9.2.8.2.</span> <span class="nav-text">从管道读取数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO-2-–-Path、Paths、Files"><span class="nav-number">1.9.3.</span> <span class="nav-text">NIO.2 – Path、Paths、Files</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NIO-2"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">NIO.2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Path-与-Paths"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">Path 与 Paths</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Files-类"><span class="nav-number">1.9.3.3.</span> <span class="nav-text">Files 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动资源管理"><span class="nav-number">1.9.3.4.</span> <span class="nav-text">自动资源管理</span></a></li></ol></li></ol></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019-09-17</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Goya</span></div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>function createtime(){var n=new Date("07/03/2018 14:13:22");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="网站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}var now=new Date;setInterval("createtime()",250)</script><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> 网站总访客数 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人次 </span><span class="site-pv"><i class="fa fa-eye"></i> 总访问量 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次</span></div></div></footer></div><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="https://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'BuVPeD8Q1vkGqU4nrrrSUa9y-gzGzoHsz',
        appKey: '0SU6m8Ctovo9j6oHFbNVyHPv',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html><script type="text/javascript" src="/js/src/love.js"></script><!-- rebuild by neat -->