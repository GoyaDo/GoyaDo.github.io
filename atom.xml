<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余生梦见皆是缘</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ysmjjsy.com/"/>
  <updated>2019-09-18T09:24:42.242Z</updated>
  <id>https://www.ysmjjsy.com/</id>
  
  <author>
    <name>Goya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SSH框架-Hibernate</title>
    <link href="https://www.ysmjjsy.com/category/Hibernate/"/>
    <id>https://www.ysmjjsy.com/category/Hibernate/</id>
    <published>2018-09-26T16:00:00.000Z</published>
    <updated>2019-09-18T09:24:42.242Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 18 2019 17:27:47 GMT+0800 (GMT+08:00) --><h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><p>JavaEE三层结构：<br>web层：struts2框架<br>service层：spring框架<br>dao层：hibernate框架<br>MVC思想：<br>m：模型<br>v：视图<br>c：控制器</p><p><img src="/category/Hibernate/1.png" alt="Hibernate"></p><p>Hibernate概述：<br>hibernate框架应用在javaee三层结果中的dao层框架<br>在dao层里面做对数据库crud操作，使用hibernate实现crud操作，hibernate底层代码就是jdbc，hibernate对jdbc进行封装，使用hibernate好处，不需要写复杂的jdbc代码了，不需要写sql语句实现<br>hibernate开源的轻量级框架<br>hibernate版本：<br>Hibernate3.x<br>Hibernate4.x<br>Hibernate5.x（学习）</p><p><img src="/category/Hibernate/2.png" alt="Hibernate"></p><p>lib：hibernate相关jar包</p><p>Hibernate核心内容是ORM（关系对象模型）。可以将对象自动的生成数据库中的信息，使得开发更加的面向对象。这样作为程序员就可以使用面向对象的思想来操作数据库，而不用关心繁琐的JDBC。所以，Hibernate处于三层架构中的D层（持久层）。</p><p><strong>使用Hibernate的优点</strong></p><ol><li>Hibernate可以使用在java的任何项目中，不一定非要使用在java web项目中。因为Hibernate不需要类似于tomact这些容器的支持，可以直接通过一个main方法进行测试。</li><li>通过下面的实例，可以发现使用Hibernate可以大大减少代码量。</li><li>由于使用了Hibernate，代码中不涉及具体的JDBC语句，所以就方便了代码的可移植性。</li></ol><p><strong>缺点</strong></p><p>首先，hibernate把数据库和你隔离了，你不需要关注数据库是mysql还是oracle，hibernate来帮你生成查询的sql。但问题也来了，如果你就要用某种数据库特有的功能，或者你就要让查询的sql完全符合你的心意，这就难了。如果使用hibernate，虽然它也能对生成的查询进行一定程度的定制，但就有点隔靴搔痒了，而且你开发起来付出的代价可能更大。至于hibernate对native sql的支持，其实也还是完善的，有兴趣的朋友可以看看。而且这种native sql还能返回non-managed entity，不走hibernate的cache，优化是能搞了，但如果你整个项目都这么搞，那还是ibatis对sql管理的好些。</p><p>第二，很多web服务，对cache的依赖是非常大的，hibernate自带的cache按理说也是很强大的，但是还是不能满足很多需求。</p><p>第三，hibernate的确是在你项目开始的时候给你节约了很多时间。但是它让你的业务逻辑模型和数据库模型互相依赖的程度太高了。这短期没有问题，但随着项目的变迁，这些都会改变，在维持这种紧紧耦合的关系的时候，你会发现你的代码特别脆弱，随便改一处数据库的schema，整个java项目可能要改几十处。而且现在mybatis的自动mapping做的也不差，开发起来也没多花多少时间。等项目进入中后期，你需要大量定制和优化查询的时候，mybatis的开发效率就胜出了。</p><p>强烈建议不用hibernate，尤其是需要处理大量数据或者大并发情况的网站服务</p><p>当一个 历经多年，无数个程序员迭代出来的 一千多张表 的大型系统 然后 hibernate 到底有多噩梦了, 后期 干脆 直接JDBC了 因为hibernate 在这种 表结构 完全乱套的</p><h2 id="ORM思想"><a href="#ORM思想" class="headerlink" title="ORM思想"></a>ORM思想</h2><p>hibernate使用orm思想对数据库进行crud操作<br>在web阶段学习javabean，更正确的叫法，实体类<br><strong>orm：object relational mapping：对象关系映射</strong><br>让实体类和数据库进行一一对应<br>让实体类首先和数据库表对应<br>让实体类属性和表里面字段对应<br>不需要直接操作数据库表，而操作表对应实体类对象</p><p><img src="/category/Hibernate/3.png" alt="Hibernate"></p><h2 id="Hibernate入门"><a href="#Hibernate入门" class="headerlink" title="Hibernate入门"></a>Hibernate入门</h2><p><strong>搭建hibernate环境：</strong></p><ul><li><p>第一步：导入hibernate的jar包</p><p><img src="/category/Hibernate/4.png" alt="Hibernate"></p><p>hibernate本身没有日志信息输出，需要导入日志信息输出的jar包：</p><p>还有mysql驱动的jar包：</p><p><img src="/category/Hibernate/5.png" alt="Hibernate"></p></li><li><p>第二步：创建实体类：</p><p><img src="/category/Hibernate/6.png" alt="Hibernate"></p><p>使用hibernate，不需要自己手动创建表，hibernate帮把表创建出来</p></li><li><p>第三步：配置实体类和数据库表一一对应关系（映射关系）</p><p>使用配置文件实现映射关系<br>创建xml格式的配置文件。实体类名字.hbm.xml<br>映射配置文件没有固定要求，建议，在实体类所在包里面创建。<br>配置是xml格式，在配置文件中首先引入xml约束<br>学过dtd、schema，在hibernate里面引入dtd约束</p><p><img src="/category/Hibernate/7.png" alt="Hibernate"></p><p>配置映射关系</p><p><img src="/category/Hibernate/8.png" alt="Hibernate"></p><p><img src="/category/Hibernate/9.png" alt="Hibernate"></p></li><li><p>第四步：创建hibernatede的核心配置文件</p><p>核心配置文件格式xml，但是核心配置文件名称和位置是固定的<br>位置必须在src下面，名称：必须hibernate.cfg.xml</p><p>引入dtd约束：</p><p><img src="/category/Hibernate/10.png" alt="Hibernate"></p><p>hibernate操作过程中，只会加载核心配置文件，其他配置文件不会加载</p><ul><li><p>第一部分：配置数据库信息</p><p><img src="/category/Hibernate/11.png" alt="Hibernate"></p></li><li><p>第二部分：配置hibernate信息</p><p><img src="/category/Hibernate/12.png" alt="Hibernate"></p></li><li><p>第三部分：把映射文件放到核心配置文件中</p><p><img src="/category/Hibernate/13.png" alt="Hibernate"></p></li></ul></li></ul><h3 id="实现添加操作"><a href="#实现添加操作" class="headerlink" title="实现添加操作"></a>实现添加操作</h3><ul><li>第一步：加载hibernate核心配置文件</li><li>第二步：创建SessionFactory对象</li><li>第三步：使用SessionFactory创建session对象</li><li>第四步：开启事务</li><li>第五步：写具体逻辑crud操作</li><li>第六步：提交事务</li><li>第七步：关闭资源</li></ul><p><img src="/category/Hibernate/a1.png" alt="Hibernate"></p><p><img src="/category/Hibernate/a2.png" alt="Hibernate"></p><p>建表，插入记录</p><h3 id="Hibernate配置文件详解"><a href="#Hibernate配置文件详解" class="headerlink" title="Hibernate配置文件详解"></a>Hibernate配置文件详解</h3><h4 id="Hibernate映射配置文件"><a href="#Hibernate映射配置文件" class="headerlink" title="Hibernate映射配置文件"></a>Hibernate映射配置文件</h4><p>映射配置文件位置名称和位置没有固定要求<br>映射配置文件中，标签name属性值写实体类相关内容<br>class标签name属性值实体类全路径<br>id标签和property标签name属性值，实体类属性内容<br>id标签和property标签，column属性可以省略，不写默认和name属性值一样<br>property标签里面还有type属性：设置生成表字段的类型，自动对应类型</p><h4 id="Hibernate核心配置文件"><a href="#Hibernate核心配置文件" class="headerlink" title="Hibernate核心配置文件"></a>Hibernate核心配置文件</h4><p>配置写位置要求：</p><p><img src="/category/Hibernate/a3.png" alt="Hibernate"></p><p>配置三部分要求：<br>数据库部分必须的<br>hibernate部分可选的<br>映射文件必须的<br>核心配置文件和名称位置固定的：<br>位置：src下面<br>名称：hibernate.cfg.xml</p><h3 id="Hibernate核心api"><a href="#Hibernate核心api" class="headerlink" title="Hibernate核心api"></a>Hibernate核心api</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><p><img src="/category/Hibernate/a4.png" alt="Hibernate"></p><p>到src下面找到名称hibernate.cfg.xml配置文件，创建对象，把配置文件放到对象里面（加载核心配置文件）</p><h4 id="SessionFactory"><a href="#SessionFactory" class="headerlink" title="SessionFactory"></a>SessionFactory</h4><p>使用Configuration对象创建sessionFactory对象<br>创建sessionfactory过程中做事情：<br>根据核心配置文件中，有数据库配置，有映射文件部分，到数据库立案根据映射关系吧表创建</p><p><img src="/category/Hibernate/a5.png" alt="Hibernate"></p><p>创建sessionFactory过程中，这个过程特别耗资源：<br>在hibernate操作中，建议一个项目一般创建一个sessionFactory对象<br>具体实现：<br>写工具类：写静态代码块实现<br>静态代码块在类加载时候执行，执行一次</p><p><img src="/category/Hibernate/a6.png" alt="Hibernate"></p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>session类似于jdbc中connection<br>调用session里面不同的方法实现crud操作<br>添加：save方法<br>修改：update方法<br>删除：delete方法<br>根据id查询fget方法<br>session对象-单线程对象：<br>session对象不能共用，只能自己使用</p><h4 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h4><p>事务对象</p><p><img src="/category/Hibernate/a7.png" alt="Hibernate"></p><p>事务提交和回滚方法</p><p><img src="/category/Hibernate/a8.png" alt="Hibernate"></p><p>事务概念<br>事务四个特性<br>原子性、一致性、隔离性、持久性</p><h3 id="解决配置文件没有提示问题"><a href="#解决配置文件没有提示问题" class="headerlink" title="解决配置文件没有提示问题"></a>解决配置文件没有提示问题</h3><p>把约束文件引入到eclipse中<br>window—&gt;Perferences—&gt;xm c(XML Catalog)—&gt;<br>在配置文件复制网址<br>add<br>url-key-网址<br>location：本地文件路径</p><h3 id="实体类编写规则"><a href="#实体类编写规则" class="headerlink" title="实体类编写规则"></a>实体类编写规则</h3><p>实体类里的属性要是私有的<br>私有属性使用公开的get、set方法操作<br>要求实体类有属性作为唯一的值（一般使用ID值）<br>实体类属性建议不使用基本数据类型，建议使用基本数据类型对应的包装类<br>八个基本类型对应的包装类：<br>int-Integer<br>char-Character<br>byte-Byte<br>short-Short<br>long-Long<br>float-Float<br>double-Double<br>boolean-Boolean</p><h3 id="Hibernate主键生成策略"><a href="#Hibernate主键生成策略" class="headerlink" title="Hibernate主键生成策略"></a>Hibernate主键生成策略</h3><p>hibernate要求实体类里面有一个属性作为唯一值，对应表主键，主键可以不同生成策略<br>hibernate主键生成策略有很多值：</p><p><img src="/category/Hibernate/b1.png" alt="Hibernate"></p><p>在class属性里面有很多的值：</p><p><img src="/category/Hibernate/b2.png" alt="Hibernate"></p><p>native：根据使用的数据库帮选择那个值<br>uuid：hibernaete自动生成uuid的值：<br>使用uuid生成策略，实体类里的id属性类型必须字符串类型</p><p><img src="/category/Hibernate/b3.png" alt="Hibernate"></p><p>配置部分写出uuid值</p><p><img src="/category/Hibernate/b4.png" alt="Hibernate"></p><h3 id="实体类操作"><a href="#实体类操作" class="headerlink" title="实体类操作"></a>实体类操作</h3><p>save会保存，如果update没查就该，只会该指定值，其他为null<br>调用session里的save方法实现</p><p><img src="/category/Hibernate/b5.png" alt="Hibernate"></p><p>根据id查询：<br>调用session里面的get方法</p><p><img src="/category/Hibernate/b6.png" alt="Hibernate"></p><p><strong>修改操作：</strong></p><p><img src="/category/Hibernate/b7.png" alt="Hibernate"></p><p><strong>删除操作：</strong></p><p><img src="/category/Hibernate/b8.png" alt="Hibernate"></p><p><strong>实体类对象状态（概念）：</strong></p><ul><li><p><strong>瞬时态：对象里面没有id值，对象与session没有关联</strong></p><p><img src="/category/Hibernate/b9.png" alt="Hibernate"></p></li><li><p><strong>持久态：对象里面有id值，对象与session关联</strong></p><p><img src="/category/Hibernate/b10.png" alt="Hibernate"></p></li><li><p><strong>托管态：对象里面有id值，对象与session没有关联</strong></p><p><img src="/category/Hibernate/b11.png" alt="Hibernate"></p></li></ul><p>演示实体类对象的方法：</p><p>saveOrUpdate：实现添加、修改</p><p><img src="/category/Hibernate/b12.png" alt="Hibernate"></p><p><img src="/category/Hibernate/b13.png" alt="Hibernate"></p><p><img src="/category/Hibernate/b14.png" alt="Hibernate"></p><h3 id="Hibernate一级缓存"><a href="#Hibernate一级缓存" class="headerlink" title="Hibernate一级缓存"></a>Hibernate一级缓存</h3><p>什么是缓存<br>数据存到数据库里面，数据库本身是文件系统，使用流方式操作文件，效率不是很高：<br>把数据存到内存里面，不需要使用流方式，可以读取内存中数据<br>把数据放到内存中，提供读取效率</p><h4 id="Hibernate缓存"><a href="#Hibernate缓存" class="headerlink" title="Hibernate缓存"></a>Hibernate缓存</h4><p>hibernate框架中提供很多优化方式，hibernate的缓存就是一个优化方式<br>hibernate缓存特点：</p><ul><li><strong>第一类：hibernate的一级缓存</strong><ul><li>hibernate的一级缓存默认打开的</li><li>hibernate的一级缓存使用范围，是session范围，从session创建到session关闭范围</li><li>hibernate的一级缓存中，存储数据必须持久态数据</li></ul></li></ul><ul><li><strong>第二类：hibernate的二级缓存</strong><ul><li>目前已经不适用了，替代技术：redis</li><li>二级缓存默认不是打开的，需要配置及</li><li>二级缓存适用范围是sessionFactory</li></ul></li></ul><h4 id="验证一级缓存存在"><a href="#验证一级缓存存在" class="headerlink" title="验证一级缓存存在"></a>验证一级缓存存在</h4><p>验证方式：<br>首先根据uid=1查询，返回对象<br>其次再根据uid=1查询，返回对象</p><p><img src="/category/Hibernate/c1.png" alt="Hibernate"></p><p><img src="/category/Hibernate/c2.png" alt="Hibernate"></p><p>第一步执行get方法之后，发送sql语句查询数据库<br>第二步执行get方法之后，没有发送sql语句，查询一级缓存内容</p><h4 id="Hibernate一级缓存执行过程"><a href="#Hibernate一级缓存执行过程" class="headerlink" title="Hibernate一级缓存执行过程"></a>Hibernate一级缓存执行过程</h4><p><img src="/category/Hibernate/c3.png" alt="Hibernate"></p><h4 id="Hibernate一级缓存特性"><a href="#Hibernate一级缓存特性" class="headerlink" title="Hibernate一级缓存特性"></a>Hibernate一级缓存特性</h4><p>持久态自动更新数据库</p><p><img src="/category/Hibernate/c4.png" alt="Hibernate"></p><p>执行过程</p><p><img src="/category/Hibernate/c5.png" alt="Hibernate"></p><h3 id="Hibernate事务操作"><a href="#Hibernate事务操作" class="headerlink" title="Hibernate事务操作"></a>Hibernate事务操作</h3><p>什么是事务：<br>是操作中基本单元，一组操作，要么都成功，要么都失败<br>事务特性：<br>原子性，一致性，持久性，隔离性<br>不考虑隔离性产生问题：<br>脏读，不可重复读，虚度<br>设置事务隔离级别：<br>mysql默认隔离级别：repeatable read</p><p><img src="/category/Hibernate/c6.png" alt="Hibernate"></p><h4 id="Hibernate事务代码规范写法"><a href="#Hibernate事务代码规范写法" class="headerlink" title="Hibernate事务代码规范写法"></a>Hibernate事务代码规范写法</h4><p>代码结构：</p><p><img src="/category/Hibernate/c7.png" alt="Hibernate"></p><p><img src="/category/Hibernate/c8.png" alt="Hibernate"></p><h3 id="Hibernate绑定session"><a href="#Hibernate绑定session" class="headerlink" title="Hibernate绑定session"></a>Hibernate绑定session</h3><p>session类似于jdbc的connection，之前web阶段学过ThreadLocal<br>Hibernate帮实现与本地线程绑定session<br>获取与本地线程session：<br>在hibernate核心配置文件中配置</p><p><img src="/category/Hibernate/c9.png" alt="Hibernate"></p><p>调用sessionFactory里面的方法得到</p><p><img src="/category/Hibernate/c0.png" alt="Hibernate"></p><p>获取与本地线程绑定session时候，关闭session报错，不需要手动关闭</p><p><img src="/category/Hibernate/cc.png" alt="Hibernate"></p><h3 id="Hibernate的api使用"><a href="#Hibernate的api使用" class="headerlink" title="Hibernate的api使用"></a>Hibernate的api使用</h3><h4 id="Query对象"><a href="#Query对象" class="headerlink" title="Query对象"></a>Query对象</h4><p>使用Query对象，不需要写sql语句，但是写hql语句<br>hql：hibernate query language，hibernate提供的查询语言，这个hql语句和普通sql很相似<br>hql和sql区别：<br>使用sql操作表和表字段<br>使用hql操作实体类和属性<br>查询所有hql语句：<br>from 实体类名称<br>Query对象的使用：<br>创建Query对象<br>调用Query对象里的方法</p><p><img src="/category/Hibernate/d1.png" alt="Hibernate"></p><h4 id="Criteria对象"><a href="#Criteria对象" class="headerlink" title="Criteria对象"></a>Criteria对象</h4><p>使用这个对象查询操作，但是使用这个对象的时候，不需要写语句，直接调用实现</p><p><img src="/category/Hibernate/d2.png" alt="Hibernate"></p><h4 id="SQlQuery对象"><a href="#SQlQuery对象" class="headerlink" title="SQlQuery对象"></a>SQlQuery对象</h4><p>使用hibernate时候，调用底层sql实现</p><p><img src="/category/Hibernate/d3.png" alt="Hibernate"></p><p>返回的是一个数组形式list集合每部分是个数组</p><p><img src="/category/Hibernate/d4.png" alt="Hibernate"></p><p>返回的是一个对象数组</p><p><img src="/category/Hibernate/d5.png" alt="Hibernate"></p><p><strong>web开发中sessionFactory不要关闭</strong></p><h3 id="表与表之间的关系"><a href="#表与表之间的关系" class="headerlink" title="表与表之间的关系"></a>表与表之间的关系</h3><p>一对多：一个分类里有多个商品，一个商品只能属于一个分类<br>一对多建表：通过外键建立关系</p><p><img src="/category/Hibernate/d6.png" alt="Hibernate"></p><p>多对多：一个订单里面有多个商品，一个商品属于多个订单</p><p><img src="/category/Hibernate/d7.png" alt="Hibernate"></p><p>一对一：一个男人只能有一个妻子，一个女人只能有一个丈夫</p><h3 id="一对多操作"><a href="#一对多操作" class="headerlink" title="一对多操作"></a>一对多操作</h3><h4 id="一对多映射配置"><a href="#一对多映射配置" class="headerlink" title="一对多映射配置"></a>一对多映射配置</h4><p>以客户（Customer）联系人（LinkMan）为例<br>第一步：创建两个实体类，客户和联系人<br>第二步：让两个实体类之间互相表示：<br>在客户实体类里面表示多个联系人：一个客户里面有多个联系人</p><p>hibernate要求使用集合表示多的数据，使用set集合</p><p><img src="/category/Hibernate/e1.png" alt="Hibernate"></p><p>在联系人实体类里面表示所属客户：一个联系人只能属于一个客户</p><p><img src="/category/Hibernate/e2.png" alt="Hibernate"></p><p>配置映射文件：<br>实体类名称.hbm.xml：hibernate-mapping里面配置<br>一般一个实体类对应一个映射文件<br>把映射最基本配置完成</p><p><img src="/category/Hibernate/e3.png" alt="Hibernate"></p><p>在映射文件中，配置一对多关系：<br>在客户映射文件中，表示所有联系人<br>class里面配置：</p><p><img src="/category/Hibernate/e4.png" alt="Hibernate"></p><p>在联系人映射文件中，表示所属客户<br>class里面配置：</p><p><img src="/category/Hibernate/e5.png" alt="Hibernate"></p><p>创建核心配置文件，把映射文件引入核心配置文件中</p><p><img src="/category/Hibernate/e6.png" alt="Hibernate"></p><h4 id="一对多级联操作"><a href="#一对多级联操作" class="headerlink" title="一对多级联操作"></a>一对多级联操作</h4><p>级联操作：<br>级联保存：添加了一个客户，为这个客户添加多个联系人<br>添加客户，为这个客户添加一个联系人<br>方式一：</p><p><img src="/category/Hibernate/f1.png" alt="Hibernate"></p><p>方式二：<br>一般都是根据客户添加联系人<br>第一步：在客户映射文件中进行配置<br>在客户映射文件里面，set标签进行配置</p><p><img src="/category/Hibernate/f2.png" alt="Hibernate"></p><p>第二步：创建客户和联系人对象，只需要把联系人放到客户里面就可以了，最终只需要保存客户就行了</p><p><img src="/category/Hibernate/f3.png" alt="Hibernate"></p><p>级联删除：删除某一个客户，这个客户的所有联系人都删除<br>删除某个客户，把客户里面联系人也删除<br>具体实现：<br>第一步：在客户映射文件中，进行配置<br>set标签属性cascade属性值delete</p><p><img src="/category/Hibernate/f4.png" alt="Hibernate"></p><p>第二步：在代码中直接删除客户：<br>先根据id查询对象，调用session里面delete方法删除</p><p><img src="/category/Hibernate/f5.png" alt="Hibernate"></p><p>执行过程：<br>根据id查询客户<br>根据外键id查联系人<br>把联系人外键设置为null<br>删除联系人</p><h4 id="一对多修改操作"><a href="#一对多修改操作" class="headerlink" title="一对多修改操作"></a>一对多修改操作</h4><p><img src="/category/Hibernate/f6.png" alt="Hibernate"></p><p><strong><em>inverse属性</em></strong><br>因为hibernate是双向维护外键，在客户和联系人里面都需要维护外键，修改客户时候修改一次外键，修改联系人时候也修改一次外键，造成效率问题<br>解决方式：让其中一方不维护外键<br>一对多里面，让其中为一的那一方方放弃外键维护<br>具体实现：在放弃关系维护映射文件中，进行配置，在set标签上使用inverse属性<br>inverse属性默认值：false，不放弃关系维护。true，表示放弃关系维护</p><p><img src="/category/Hibernate/f7.png" alt="Hibernate"></p><h3 id="多对多操作"><a href="#多对多操作" class="headerlink" title="多对多操作"></a>多对多操作</h3><h4 id="多对多映射配置"><a href="#多对多映射配置" class="headerlink" title="多对多映射配置"></a>多对多映射配置</h4><p>以用户和角色为例：<br>第一步：创建实体类，用户和角色<br>第二步：让两个实体类之间互相表示<br>用户里面表示所有角色，使用set集合</p><p><img src="/category/Hibernate/g1.png" alt="Hibernate"></p><p>一个角色多个用户，使用set集合</p><p><img src="/category/Hibernate/g2.png" alt="Hibernate"></p><p>第三步：配置映射关系：<br>基本配置：Role.hbm.xml：</p><p><img src="/category/Hibernate/g3.png" alt="Hibernate"></p><p>User.hbm.xml：</p><p><img src="/category/Hibernate/g4.png" alt="Hibernate"></p><p>配置多对多关系<br>在用户里面表示所有角色，使用set标签<br>Role.hbm.xml：</p><p><img src="/category/Hibernate/g5.png" alt="Hibernate"></p><p>User.hbm.xml：</p><p><img src="/category/Hibernate/g6.png" alt="Hibernate"></p><p>在角色里面表示所用用户，使用set标签<br>第四步：在核心配置文件中引入映射文件</p><p><img src="/category/Hibernate/g7.png" alt="Hibernate"></p><h4 id="多对多级联保存"><a href="#多对多级联保存" class="headerlink" title="多对多级联保存"></a>多对多级联保存</h4><p>根据用户保存角色<br>第一步：在用户配置文件中set标签进行配置，cascade值save-update</p><p><img src="/category/Hibernate/g8.png" alt="Hibernate"></p><p>第二步：写代码实现：<br>创建用户和角色对象，把角色放到用户里面，最终保存用户就可以了</p><p><img src="/category/Hibernate/g9.png" alt="Hibernate"></p><h4 id="多对多级联删除"><a href="#多对多级联删除" class="headerlink" title="多对多级联删除"></a>多对多级联删除</h4><p>第一步：在set标签进行配置，cascade值delete</p><p><img src="/category/Hibernate/g10.png" alt="Hibernate"></p><p>第二步：删除用户</p><p><img src="/category/Hibernate/g11.png" alt="Hibernate"></p><h4 id="维护第三张表关系"><a href="#维护第三张表关系" class="headerlink" title="维护第三张表关系"></a>维护第三张表关系</h4><p>用户和角色是多对多关系，维护关系通过第三张表维护<br>让某个用户有某个角色：<br>第一步：通过id查询用户和角色<br>第二步：把角色放到用户界面：<br>把角色对象放到用户set集合</p><p><img src="/category/Hibernate/g12.png" alt="Hibernate"></p><p>让某个用户没有某个角色：<br>第一步：通过id查询用户和角色<br>第二步：从用户里面把角色去掉：<br>从set集合里面把角色移出</p><p><img src="/category/Hibernate/g13.png" alt="Hibernate"></p><h3 id="Hibernate查询方式"><a href="#Hibernate查询方式" class="headerlink" title="Hibernate查询方式"></a>Hibernate查询方式</h3><h4 id="对象导航查询"><a href="#对象导航查询" class="headerlink" title="对象导航查询"></a>对象导航查询</h4><p>根据id查询某个客户，再查询客户里面所有联系人<br><img src="/category/Hibernate/q1.png" alt="Hibernate"></p><h4 id="OID查询"><a href="#OID查询" class="headerlink" title="OID查询"></a>OID查询</h4><p>根据id查询某一条记录，返回对象<br>调用session里面的get方法实现</p><p><img src="/category/Hibernate/q2.png" alt="Hibernate"></p><h4 id="hql查询"><a href="#hql查询" class="headerlink" title="hql查询"></a>hql查询</h4><p>Query对象，写hq语句实现查询<br>普通sql操作数据库表和字段，hql操作实体类和属性<br>常用的hql语句：<br>查询所有：from 实体类名称<br>条件查询：<br>from 实体类名称 where 实体类属性名称=? and 实体类属性名称=?<br>from 实体类名称 where 实体类属性名称 like ?<br>排序查询：from 实体类名称 order by 实体类属性名称 asc/desc<br>使用hql查询操作时候，使用Query对象：<br>创建Query对象，写hql语句<br>调用query对象里面的方法得到结果</p><h5 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h5><p><img src="/category/Hibernate/q3.png" alt="Hibernate"></p><h5 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h5><p>hql条件查询语句写法：<br>from 实体类名称 where 实体类属性名称=? and 实体类属性名称=?</p><p><img src="/category/Hibernate/q4.png" alt="Hibernate"></p><p>from 实体类名称 where 实体类属性名称 like ?</p><p><img src="/category/Hibernate/q5.png" alt="Hibernate"></p><h5 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h5><p>from 实体类名称 order by 实体类属性名称 asc/desc</p><p><img src="/category/Hibernate/q6.png" alt="Hibernate"></p><h5 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h5><p>使用关键字limit实现</p><p><img src="/category/Hibernate/q7.png" alt="Hibernate"></p><p>在hql中实现分页：<br>在hql操作中，在语句里面不能写limit，hibernate的Query对象封装了两个方法实现分页操作</p><p><img src="/category/Hibernate/q8.png" alt="Hibernate"></p><h5 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h5><p>查询的不是所有字段的值，而是部分字段的值<br>投影查询的hql语句：<br>select 实体类属性名称1，实体类属性名称2 from 实体类属性名称<br>select后面不能写* ，不支持</p><p><img src="/category/Hibernate/q9.png" alt="Hibernate"></p><h5 id="聚合函数的使用"><a href="#聚合函数的使用" class="headerlink" title="聚合函数的使用"></a>聚合函数的使用</h5><p>常用聚集函数：count、sum、avg、max、min<br>hql聚集函数写法：<br>查询表记录数：<br>select count(* ) from 实体类名称</p><p><img src="/category/Hibernate/q10.png" alt="Hibernate"></p><p><img src="/category/Hibernate/q11.png" alt="Hibernate"></p><h4 id="QBC查询"><a href="#QBC查询" class="headerlink" title="QBC查询"></a>QBC查询</h4><p>Criteria对象<br>使用hql查询需要写hql语句实现，使用qbc时候，不需要写语句，使用方法实现<br>使用qbc时候，操作实体类和属性<br>使用qbc，使用Criteria对象实现</p><h5 id="查询所有-1"><a href="#查询所有-1" class="headerlink" title="查询所有"></a>查询所有</h5><p>创建Criteria对象<br>调用方法得到结果</p><p><img src="/category/Hibernate/w1.png" alt="Hibernate"></p><h5 id="条件查询-1"><a href="#条件查询-1" class="headerlink" title="条件查询"></a>条件查询</h5><p>没有语句，使用封装的方法</p><p><img src="/category/Hibernate/w2.png" alt="Hibernate"></p><p><img src="/category/Hibernate/w3.png" alt="Hibernate"></p><h5 id="排序查询-1"><a href="#排序查询-1" class="headerlink" title="排序查询"></a>排序查询</h5><p><img src="/category/Hibernate/w4.png" alt="Hibernate"></p><h5 id="分页查询-1"><a href="#分页查询-1" class="headerlink" title="分页查询"></a>分页查询</h5><p><img src="/category/Hibernate/w5.png" alt="Hibernate"></p><p>开始位置计算公式：（当前页-1）* 每页记录数</p><h5 id="统计查询"><a href="#统计查询" class="headerlink" title="统计查询"></a>统计查询</h5><p><img src="/category/Hibernate/w6.png" alt="Hibernate"></p><h5 id="离线查询"><a href="#离线查询" class="headerlink" title="离线查询"></a>离线查询</h5><p>不用session也能创建Criteria对象</p><p><img src="/category/Hibernate/w7.png" alt="Hibernate"></p><p>servlet调用service，service调用dao<br>dao里面对数据库crud操作<br>在dao里面使用hibernate框架，使用hibernate框架的时候，调用session里面的方法实现功能</p><h4 id="HQL多表查询"><a href="#HQL多表查询" class="headerlink" title="HQL多表查询"></a>HQL多表查询</h4><p>Mysql里面多表查询：<br>内连接：</p><p><img src="/category/Hibernate/e1 [2].png" alt="Hibernate"></p><p>左外连接：</p><p><img src="/category/Hibernate/e2 [2].png" alt="Hibernate"></p><p>右外连接：</p><p><img src="/category/Hibernate/e3 [2].png" alt="Hibernate"></p><p>HQL多表查询：<br>内连接：<br>内连接查询hql语句写法：客户联系人为例<br>from Customer c inner join c.setLinkMan</p><p><img src="/category/Hibernate/e4 [2].png" alt="Hibernate"></p><p><img src="/category/Hibernate/e5 [2].png" alt="Hibernate"></p><p>左外连接：<br>返回list中每部分是数组<br>hql语句：from Customer c left outer join c.setLinkMan<br>右外连接：<br>迫切内连接：和内连接底层实现一样的<br>区别：使用内连接返回list中每部分是数组，迫切内连接返回list每部分是对象<br>hql语句写法：from Customer c inner join fetch c.setLinkMan<br>迫切左外连接：from Customer c left outer join fetch c.setLinkMan<br>返回list每部分是对象</p><h4 id="本地sql查询"><a href="#本地sql查询" class="headerlink" title="本地sql查询"></a>本地sql查询</h4><p>SQLQuery对象，使用普通sql实现查询</p><h3 id="Hibernate检索策略概念"><a href="#Hibernate检索策略概念" class="headerlink" title="Hibernate检索策略概念"></a>Hibernate检索策略概念</h3><p>hibernate检索策略分为两类：<br>立即查询：根据id查询，调用get方法，一调用get方法马上发送语句查询数据库</p><p><img src="/category/Hibernate/r1.png" alt="Hibernate"></p><p>延迟查询：根据id查询，还有load方法，调用load方法不会马上发送语句查询数据，只有得到对象里面的值时候才会发送语句查询数据库</p><p><img src="/category/Hibernate/r2.png" alt="Hibernate"></p><p>延迟查询：<br>类级别延迟：根据id查询返回实体类对象，调用load方法不会马上发送语句<br>关联级别延迟：查询某个客户，再查询这个客户的所有联系人，查询客户的所有联系人的过程是否需要延迟，这个过程称为关联级别延迟</p><p><img src="/category/Hibernate/r3.png" alt="Hibernate"></p><p>关联级别延迟操作：<br>在映射文件中进行配置实现：<br>根据客户得到所有的联系人，在客户映射文件中配置</p><p><img src="/category/Hibernate/r4.png" alt="Hibernate"></p><p>在set标签傻瓜使用属性<br>fetch：值：select（默认）<br>lazy：值：<br>true：延迟（默认）<br>false：不延迟，调用get后，发送两条sql语句<br>extra：极其延迟，极其懒惰，要什么值给什么值</p><h3 id="Hibernate批量抓取"><a href="#Hibernate批量抓取" class="headerlink" title="Hibernate批量抓取"></a>Hibernate批量抓取</h3><p>查询所有客户，返回list集合，遍历list集合，得到每个客户，得到每个客户的所有联系人<br>效率低：会发送很多sql语句<br><img src="/category/Hibernate/r5.png" alt="Hibernate"><br>在客户的映射文件中，set标签配置<br><img src="/category/Hibernate/r6.png" alt="Hibernate"><br>batch-size值：值越大，发送语句越少</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      SSH框架-Hibernate
    
    </summary>
    
      <category term="SSH框架" scheme="https://www.ysmjjsy.com/categories/SSH%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Hibernate" scheme="https://www.ysmjjsy.com/categories/SSH%E6%A1%86%E6%9E%B6/Hibernate/"/>
    
    
      <category term="SSH框架" scheme="https://www.ysmjjsy.com/tags/SSH%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>SSH框架-Spring</title>
    <link href="https://www.ysmjjsy.com/category/Spring/"/>
    <id>https://www.ysmjjsy.com/category/Spring/</id>
    <published>2018-09-19T16:00:00.000Z</published>
    <updated>2019-09-18T07:55:33.764Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 18 2019 16:03:08 GMT+0800 (GMT+08:00) --><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>spring是开源的轻量级框架</p><p>spring是一站式框架：<br>spring在javaee三层结构中，每一层都提供不同的解决技术<br>web层：springMVC<br>service层：spring的ioc<br>dao层：spring的jdbcTemplate</p><p>EJB：重量级框架（相比spring比EJB依赖资源少，销毁的资源少）</p><p><strong>spring核心主要两部分：</strong></p><ul><li><strong>AOP：</strong> 面向切面编程，扩展功能不是修改源代码实现</li><li><strong>IOC：</strong> 控制反转，比如有一个类，在类里有方法（不是静态方法），调用类里面的方法，创建类的对象，使用对象调用方法，创建类对象的过程，需要new出来对象，把对象的创建不是通过new方式实现，而是交给spring配置创建类对象（反射）</li></ul><p>spring版本：4.x</p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>把对象的创建交给spring进行管理<br>ioc操作两部分：<br>ioc的配置文件方式<br>ioc的注解方式</p><h3 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h3><p><strong>IOC底层原理实用技术</strong><br>xml配置文件<br>dom4j解决xml<br>工厂设计模式<br>反射</p><p><img src="/category/Spring/1.png" alt="Sring"></p><p><img src="/category/Spring/2.png" alt="Sring"></p><h3 id="IOC入门案例"><a href="#IOC入门案例" class="headerlink" title="IOC入门案例"></a>IOC入门案例</h3><p>第一步：导入jar包：<br>核心四个基本功能jar包</p><p><img src="/category/Spring/3.png" alt="Sring"></p><p>导入支持日志输出的jar包<br>第二步：创建类，在类里面创建方法<br>第三步：创建spring配置文件，配置创建类：<br>spring核心配置文件名称和位置不是固定的：<br>建议放在src下面，官方建议：applicationContext.xml<br>引入schema约束：</p><p><img src="/category/Spring/4.png" alt="Sring"></p><p>配置：</p><p><img src="/category/Spring/5.png" alt="Sring"></p><p><img src="/category/Spring/6.png" alt="Sring"></p><h2 id="Spring的bean管理（xml方式）"><a href="#Spring的bean管理（xml方式）" class="headerlink" title="Spring的bean管理（xml方式）"></a>Spring的bean管理（xml方式）</h2><p>Bean实例化的方式<br>在spring里面通过配置文件创建对象<br>bean实例化三种方式实现：</p><ul><li><p><strong>第一种：使用类的无参数构造创建：</strong></p><p>当类里面没有无参数的构造，出现异常</p><p><img src="/category/Spring/7.png" alt="Sring"></p></li></ul><ul><li><p>第二种：使用静态工厂创建：</p><p>创建静态的方法，返回类的对象</p><p><img src="/category/Spring/8.png" alt="Sring"></p><p><img src="/category/Spring/9.png" alt="Sring"></p></li><li><p>第三种：使用实例工厂创建：</p><p>创建不是静态的方法，返回类的对象</p><p><img src="/category/Spring/10.png" alt="Sring"></p><p><img src="/category/Spring/11.png" alt="Sring"></p></li></ul><h2 id="Bean标签的常用属性"><a href="#Bean标签的常用属性" class="headerlink" title="Bean标签的常用属性"></a>Bean标签的常用属性</h2><p>id属性：起的名称，id属性属性值名称任意命名，不能包含特殊符号，根据id值得到配置对象<br>class属性：创建对象所在类的全路径<br>name属性：功能和id属性一样的，name属性可以包含特殊符号（遗留的struts1）<br>scope属性：</p><p><img src="/category/Spring/a1.png" alt="Sring"></p><h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><p>创建对象时候，向类里面属性里面设置值<br>属性注入方式介绍（三种方式）：</p><p><img src="/category/Spring/a2.png" alt="Sring"></p><p><strong>在spring框架里面，支持前两种方式：</strong></p><ul><li><strong>set方法注入</strong></li></ul><p><img src="/category/Spring/a3.png" alt="Sring"></p><p><img src="/category/Spring/a4.png" alt="Sring"></p><ul><li>有参数构造注入</li></ul><p><img src="/category/Spring/a5.png" alt="Sring"></p><p><img src="/category/Spring/a6.png" alt="Sring"></p><p>测试：</p><p><img src="/category/Spring/a7.png" alt="Sring"></p><p><strong>注入对象类型属性</strong><br>创建service类和dao类：<br>在service得到dao对象<br>具体实现：<br>在service里面把dao作为类型属性<br>生成dao类型属性的set方法</p><p><img src="/category/Spring/a8.png" alt="Sring"></p><p>在配置文件中完成注入关系</p><p><img src="/category/Spring/a9.png" alt="Sring"></p><p><strong>P名称空间注入</strong></p><p><img src="/category/Spring/b1.png" alt="Sring"></p><p><img src="/category/Spring/b2.png" alt="Sring"></p><p><img src="/category/Spring/b3.png" alt="Sring"></p><p><strong>复杂类型属性注入</strong></p><p>数组<br>list集合<br>map集合<br>properties类型</p><p><img src="/category/Spring/b4.png" alt="Sring"></p><p><img src="/category/Spring/b5.png" alt="Sring"></p><p><img src="/category/Spring/b6.png" alt="Sring"></p><h2 id="IOC和DI区别"><a href="#IOC和DI区别" class="headerlink" title="IOC和DI区别"></a>IOC和DI区别</h2><p>IOC：控制反转，把对象创建交给spring进行配置<br>DI：依赖注入，向类里面的属性中设置值</p><p>关系：依赖注入不能单独存在，需要在ioc基础之上完成操作</p><h2 id="Spring的bean管理（注解）"><a href="#Spring的bean管理（注解）" class="headerlink" title="Spring的bean管理（注解）"></a>Spring的bean管理（注解）</h2><p>代码里面特殊的标记，使用注解可以完成功能<br>注解写法：@注解名称(属性名称=属性值)<br>注解使用在类上面，方法上面和属性上面</p><h3 id="Spring注解开发准备"><a href="#Spring注解开发准备" class="headerlink" title="Spring注解开发准备"></a>Spring注解开发准备</h3><p>导入jar包：导入基本jar包，导入aop的jar包<br>创建类，创建方法<br>创建spring配置文件，引入约束：<br>做spring的ioc注解开发，引入新约束</p><p><img src="/category/Spring/b8.png" alt="Sring"></p><p><img src="/category/Spring/b9.png" alt="Sring"></p><p><img src="/category/Spring/b10.png" alt="Sring"></p><h3 id="注解创建对象"><a href="#注解创建对象" class="headerlink" title="注解创建对象"></a>注解创建对象</h3><p><img src="/category/Spring/c1.png" alt="Sring"></p><p><img src="/category/Spring/c2.png" alt="Sring"></p><p>创建对象有四个注解：这四个注解功能是一样的，都创建对象</p><p><img src="/category/Spring/c3.png" alt="Sring"></p><p>创建对象单实例、多实例：</p><p><img src="/category/Spring/c4.png" alt="Sring"></p><h3 id="注解注入属性"><a href="#注解注入属性" class="headerlink" title="注解注入属性"></a>注解注入属性</h3><p>创建service，创建dao，在service里得到dao对象<br>注入属性第一个注解：@Autowired，根据类名找属性<br>name属性值写注解创建dao对象value值</p><p>@Resource(name=”userDao”)</p><p><img src="/category/Spring/c5.png" alt="Sring"></p><p><img src="/category/Spring/c6.png" alt="Sring"></p><h3 id="配置文件和注解混合使用"><a href="#配置文件和注解混合使用" class="headerlink" title="配置文件和注解混合使用"></a>配置文件和注解混合使用</h3><p>创建对象操作使用配置文件方式实现</p><p><img src="/category/Spring/c7.png" alt="Sring"></p><p>注入属性的操作使用注解方式实现</p><p><img src="/category/Spring/c8.png" alt="Sring"></p><h2 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h2><p>AOP：面向切面（方面）编程，扩展功能不修改源代码实现<br>AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码</p><p><img src="/category/Spring/c9.png" alt="Sring"></p><p><img src="/category/Spring/c0.png" alt="Sring"></p><h3 id="AOP操作术语"><a href="#AOP操作术语" class="headerlink" title="AOP操作术语"></a>AOP操作术语</h3><p><img src="/category/Spring/d1.png" alt="Sring"></p><p><img src="/category/Spring/d2.png" alt="Sring"></p><h3 id="Spring的AspectJ简介"><a href="#Spring的AspectJ简介" class="headerlink" title="Spring的AspectJ简介"></a>Spring的AspectJ简介</h3><p><img src="/category/Spring/d3.png" alt="Sring"></p><p>aspectJ不是spring一部分，而是和spring一起使用进行aop操作<br>spring2.0以后新增了对AspectJ支持<br>使用aspectJ实现aop有两种方式：<br>基于aspectj的xml配置<br>基于aspectj的注解方式</p><p><strong>AOP准备工作：</strong><br>除了导入基本的jar包之外，还需要导入aop相关的jar包<br>创建sprig核心配置文件，导入aop约束</p><p><img src="/category/Spring/d4.png" alt="Sring"></p><p><strong>使用表达式配置切入点：</strong></p><p><img src="/category/Spring/d5.png" alt="Sring"></p><p>切入点：实际增强的方法<br>常用表达式：</p><p><img src="/category/Spring/d6.png" alt="Sring"></p><p><img src="/category/Spring/d7.png" alt="Sring"></p><p>execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)<br>execution(* 增强方法的全路径)：</p><p><strong>aspectj的AOP操作：</strong></p><p><img src="/category/Spring/d8.png" alt="Sring"></p><p><strong>aspectk的aop其他操作：</strong></p><p><img src="/category/Spring/d9.png" alt="Sring"></p><p><img src="/category/Spring/d0.png" alt="Sring"></p><h2 id="log4j"><a href="#log4j" class="headerlink" title="log4j"></a>log4j</h2><p>通过log4j可以看到程序运行过程中更详细的信息<br>经常使用log4j查看日志<br>使用：<br>导入log4j的jar包<br>复制log4j的配置文件，复制到src下面</p><p><img src="/category/Spring/e1.png" alt="Sring"></p><p>日志级别：info（基本信息）、debug（更详细信息）</p><h2 id="基于aspectj的注解aop"><a href="#基于aspectj的注解aop" class="headerlink" title="基于aspectj的注解aop"></a>基于aspectj的注解aop</h2><p><strong>使用注解实现aop操作</strong></p><ol><li>第一步：创建对象：</li></ol><p><img src="/category/Spring/f1.png" alt="Sring"></p><ol><li>第二步：在spring核心配置文件中，开启aop操作</li></ol><p><img src="/category/Spring/f2.png" alt="Sring"></p><ol><li>第三步：在增强类上面使用注解完成aop操作</li></ol><p><img src="/category/Spring/f3.png" alt="Sring"></p><p><img src="/category/Spring/f4.png" alt="Sring"></p><h2 id="Spring的jdbcTemplate操作"><a href="#Spring的jdbcTemplate操作" class="headerlink" title="Spring的jdbcTemplate操作"></a>Spring的jdbcTemplate操作</h2><p>spring框架一站式框架<br>针对javaee三层，每一层都有解决技术<br>针对dao层，使用jdbcTemplate<br>spring对不同的持久化层技术都进行封装</p><p><img src="/category/Spring/f5.png" alt="Sring"></p><p>jdbcTemplate对jdbc进行了封装<br>jdbcTemplate使用和dbutils使用很相似，都对数据库进行crud操作</p><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>导入jdbcTemplate的jar包和数据库驱动jar包</p><p><img src="/category/Spring/f6.png" alt="Sring"></p><p>创建对象，设置数据库信息<br>创建jdbcTemplate对象，设置数据源<br>调用jdbcTemplate对象里面的方法实现操作</p><p><img src="/category/Spring/f7.png" alt="Sring"></p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p><img src="/category/Spring/f8.png" alt="Sring"></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><img src="/category/Spring/f9.png" alt="Sring"></p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>使用jdbcTemplate实现查询操作<br>dbutils：</p><p><img src="/category/Spring/f0.png" alt="Sring"></p><h4 id="查询具体实现："><a href="#查询具体实现：" class="headerlink" title="查询具体实现："></a>查询具体实现：</h4><h5 id="第一个：查询返回某一个值"><a href="#第一个：查询返回某一个值" class="headerlink" title="第一个：查询返回某一个值"></a>第一个：查询返回某一个值</h5><p><img src="/category/Spring/f11.png" alt="Sring"></p><p>第一个参数是sql语句<br>第二个参数，返回类型的class</p><p><img src="/category/Spring/f22.png" alt="Sring"></p><h5 id="第二个：查询返回对象"><a href="#第二个：查询返回对象" class="headerlink" title="第二个：查询返回对象"></a>第二个：查询返回对象</h5><p><strong>JDBC实现：</strong></p><p><img src="/category/Spring/f33.png" alt="Sring"></p><p><strong>jdbcTemplate实现：</strong></p><p><img src="/category/Spring/f44.png" alt="Sring"></p><p>第一个参数是sql语句<br>第二个参数是RowMapper，是接口，类似于dbutils里面接口<br>第三个参数是可变参数</p><p><img src="/category/Spring/f55.png" alt="Sring"></p><p><img src="/category/Spring/f66.png" alt="Sring"></p><h5 id="第三个：查询返回list集合"><a href="#第三个：查询返回list集合" class="headerlink" title="第三个：查询返回list集合"></a>第三个：查询返回list集合</h5><p><img src="/category/Spring/f77.png" alt="Sring"></p><p><img src="/category/Spring/f88.png" alt="Sring"></p><p><img src="/category/Spring/f99.png" alt="Sring"></p><h2 id="Spring配置c3p0连接池"><a href="#Spring配置c3p0连接池" class="headerlink" title="Spring配置c3p0连接池"></a>Spring配置c3p0连接池</h2><p>第一步：导入jar包</p><p><img src="/category/Spring/q1.png" alt="Sring"></p><p>第二步：创建spring配置文件，配置连接池</p><p><img src="/category/Spring/q2.png" alt="Sring"></p><p>把代码在配置文件进行配置：</p><p><img src="/category/Spring/q3.png" alt="Sring"></p><p>dao使用jdbcTemplate：<br>创建service和dao，配置service和dao对象，在service注入dao对象</p><p><img src="/category/Spring/q4.png" alt="Sring"></p><p>创建jdbcTemplate对象，把模板对象注入到dao里面</p><p><img src="/category/Spring/q5.png" alt="Sring"></p><p><img src="/category/Spring/q6.png" alt="Sring"></p><p>在jdbcTemplate对象里面注入dataSource</p><p><img src="/category/Spring/q7.png" alt="Sring"></p><p><img src="/category/Spring/q8.png" alt="Sring"></p><h2 id="Spring的事务管理"><a href="#Spring的事务管理" class="headerlink" title="Spring的事务管理"></a>Spring的事务管理</h2><p>spring事务管理两种方式：<br>第一种：编程式事务管理（不用）<br>第二种：声明式事务管理：<br>基于xml配置文件实现<br>基于注解实现</p><h3 id="spring事务管理的api介绍"><a href="#spring事务管理的api介绍" class="headerlink" title="spring事务管理的api介绍"></a>spring事务管理的api介绍</h3><p><img src="/category/Spring/w1.png" alt="Sring"></p><p>spring针对不同的dao层框架，提供接口不同的实现类</p><p><img src="/category/Spring/w2.png" alt="Sring"></p><p>配置事务管理器</p><h3 id="搭建转账环境"><a href="#搭建转账环境" class="headerlink" title="搭建转账环境"></a>搭建转账环境</h3><p>创建数据库表，添加数据</p><p><img src="/category/Spring/w3.png" alt="Sring"></p><p>创建service和dao类，完成注入关系：</p><p><img src="/category/Spring/w4.png" alt="Sring"></p><p>service层又叫业务逻辑层</p><p><img src="/category/Spring/w5.png" alt="Sring"></p><p>dao层，单独对数据库操作层，在dao层不添加业务</p><p><img src="/category/Spring/w6.png" alt="Sring"></p><p>产生问题：如果小王少1000，出现异常，小马不会多1000，钱丢了<br>解决：添加事务解决，出现异常进行回滚操作</p><p><strong>声明式事务管理（xml配置）：</strong><br>配置文件方式使用aop思想配置</p><ol><li><p>第一步：配置事务管理器：</p><p><img src="/category/Spring/w7.png" alt="Sring"></p></li></ol><ol><li><p>第二步：配置事务增强：</p><p><img src="/category/Spring/w8.png" alt="Sring"></p></li><li><p>第三步：配置切面：</p><p><img src="/category/Spring/w9.png" alt="Sring"></p></li></ol><p><strong>声明式事务管理（注解）：</strong></p><ol><li><p>第一步：配置事务管理器</p><p><img src="/category/Spring/w0.png" alt="Sring"></p></li><li><p>第二步：配置事务注解</p><p><img src="/category/Spring/w01.png" alt="Sring"></p></li><li><p>第三步：在要使用事务的方法所在类上面添加注解</p><p><img src="/category/Spring/w02.png" alt="Sring"></p></li></ol><h2 id="Spring整合web项目原理"><a href="#Spring整合web项目原理" class="headerlink" title="Spring整合web项目原理"></a>Spring整合web项目原理</h2><blockquote><p>1、加载spring核心配置文件：<br><img src="/category/Spring/b7.png" alt="Sring"><br>new对象，功能可以实现，效率很低<br>2、实现思想：把加载配置文件和创建对象过程，在服务器启动时候完成<br>3、实现原理：<br>ServletContext对象<br>监听器</p><p>具体使用：<br>在服务器启动时候，为每个项目创建一个ServletContext对象<br>在ServletContext对象创建时候，使用监听器可以具体到ServletContext对象在什么时候创建<br>使用监听器监听到ServletContext对象创建时候<br>加载spring配置文件，把配置文件配置对象创建<br>把创建出来的对象放到ServletContext域对象里面（setAttribute方法）<br>获取对象时候，到ServletContext域得到getAttribute方法）</p></blockquote><h2 id="Spring整合web项目"><a href="#Spring整合web项目" class="headerlink" title="Spring整合web项目"></a>Spring整合web项目</h2><p>演示问题：<br>action调用service，service调用dao</p><p><img src="/category/Spring/e2.png" alt="Sring"></p><p>每次访问action时候，都会加载spring配置文件<br>解决方案：<br>在服务器启动时候，创建对象加载配置文件<br>底层使用监听器、ServletContext对象<br>在spring里面不需要自己写代码实现，帮封装：<br>封装了一个监听器，只需要配置监听器就可以了<br>配置监听器之前，导入spring整合web项目jar包</p><p><img src="/category/Spring/e3.png" alt="Sring"></p><p><img src="/category/Spring/e4.png" alt="Sring"></p><p>指定加载spring配置文件位置</p><p><img src="/category/Spring/e5.png" alt="Sring"></p><p><img src="/category/Spring/e6.png" alt="Sring"></p><p><img src="/category/Spring/e7.png" alt="Sring"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      SSH框架-Sring
    
    </summary>
    
      <category term="SSH框架" scheme="https://www.ysmjjsy.com/categories/SSH%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://www.ysmjjsy.com/categories/SSH%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="SSH框架" scheme="https://www.ysmjjsy.com/tags/SSH%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>SSH框架-Struts2</title>
    <link href="https://www.ysmjjsy.com/category/Struts2/"/>
    <id>https://www.ysmjjsy.com/category/Struts2/</id>
    <published>2018-09-12T16:00:00.000Z</published>
    <updated>2019-09-18T08:00:10.214Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 18 2019 16:03:08 GMT+0800 (GMT+08:00) --><h1 id="Struts2"><a href="#Struts2" class="headerlink" title="Struts2"></a>Struts2</h1><blockquote><p>软件=应用组件+业务组件<br>应用组件可以写成框架，框架开发方便很多，是半成品的软件。<br>框架的性能问题：低</p></blockquote><p>Struts2框架：Struts2=WebWork+Struts名字+杂七杂八<br>MVC框架：(jsp+servlet)+service+dao<br>Struts1和Struts2没关系<br>WebWork内核是XWork<br><strong>Struts2版本：2.3.24 </strong>Web层常见框架：** struts2、springMVC</p><h2 id="Struts简单模型"><a href="#Struts简单模型" class="headerlink" title="Struts简单模型"></a>Struts简单模型</h2><p><img src="/category/Struts2/1.png" alt="Struts2"></p><p><img src="/category/Struts2/2.png" alt="Struts2"></p><p><img src="/category/Struts2/3.png" alt="Struts2"></p><p><strong>工作流程：</strong><br>（1）客户端浏览器发送HTTP请求到Web应用<br>（2）Web容器将请求传递到标准ActionContextCleanUp过滤器以消除属性，而不让后续过滤器清楚，以延长Action中属性（包括自定义属性）的生命周期。<br>（3）再经过如stimesh等其他过滤器后，请求传递给StrutsPrepareAndExecuteFilter核心控制器<br>（4）StrutsPrepareAndExecuteFilter调用ActionMapper（Action映射器）确定调用哪个Action，再将控制权转移给ActionProxy代理<br>（5）ActionProxy代理调用配置管理器ConfigurationManager从配置文件struts.xml中读取配置信息，然后创建ActionInvocation对象<br>（6）ActionInvocation在调用拦截器链中的拦截器后再调用Action，根据Action返回的结果字符串查找对应的Result<br>（7）Result调用视图模板，再以相反的顺序执行拦截器链，返回HTTP响应<br>（8）HTTP响应以相反的顺序返回给核心控制器StrutsPrepareAndExecuteFilter以及其他web.xml中定义的过滤器，最终返回给客户端。</p><h2 id="Struts2搭建"><a href="#Struts2搭建" class="headerlink" title="Struts2搭建"></a>Struts2搭建</h2><p><strong>Struts2搭建流程</strong></p><ol><li><p>下载Struts2jar包</p></li><li><p>创建空项目</p></li><li><p>导包：lib中有jar包，不是都用的上；在apps目录里面，找到示例程序，从示例程序复制jar包：blank.war</p></li><li><p>配置核心控制器</p><p><img src="/category/Struts2/4.png" alt="Struts2"></p></li><li><p>添加struts配置文件：在src目录下创建struts.xml</p><p><img src="/category/Struts2/5.png" alt="Struts2"></p></li><li><p>创建start.jsp</p><p><img src="/category/Struts2/6.png" alt="Struts2"></p></li><li><p>写一个Action类：每次访问action，默认执行名称execute方法</p><p><img src="/category/Struts2/7.png" alt="Struts2"></p></li><li><p>配置文件src下面：struts.xml：</p><p><img src="/category/Struts2/8.png" alt="Struts2"></p><p>​</p></li><li><p>补充：添加结果的配置</p><p><img src="/category/Struts2/9.png" alt="Struts2"></p></li><li><p>引入dtd约束</p></li><li><p>在Action中添加返回值</p><p><img src="/category/Struts2/10.png" alt="Struts2"></p></li><li><p><a href="http://localhost:8080/项目名/xxx.action" target="_blank" rel="noopener">http://localhost:8080/项目名/xxx.action</a></p></li></ol><h2 id="Struts2基本执行过程"><a href="#Struts2基本执行过程" class="headerlink" title="Struts2基本执行过程"></a>Struts2基本执行过程</h2><p><img src="/category/Struts2/a1.png" alt="Struts2"></p><p>过滤器在服务器创建时候创建，创建过滤器时候执行init方法</p><p>在init方法中加载配置文件</p><p>包含自己创建的配置文件和struts2自带配置文件：struts.xml、web.xml</p><h2 id="Struts2配置"><a href="#Struts2配置" class="headerlink" title="Struts2配置"></a>Struts2配置</h2><p>struts2位置与名称是固定的</p><p>根标签：struts</p><h3 id="在配置文件中主要三个标签"><a href="#在配置文件中主要三个标签" class="headerlink" title="在配置文件中主要三个标签"></a>在配置文件中主要三个标签</h3><h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><p><strong>类似于代码包，区分不同的action，要配置action，必须先写package，再写action</strong></p><p>package标签属性：</p><ul><li>name属性：<ul><li>name属性属性值跟功能本身没有关系</li><li>在一个配置文件可以写多个package标签，name属性值不能相同</li></ul></li><li>extends属性：<ul><li>属性值是固定的：extends=”struts-default”</li><li>写了这个属性之后，在package里面配置的类具有action功能</li></ul></li><li>namespace属性：<ul><li>namespace属性值和action标签里的name属性值构成访问路径，可以不写，默认是”/“</li></ul></li></ul><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p><strong>action标签配置action访问路径</strong></p><p>action标签属性：</p><ul><li>name属性：<ul><li>namespace属性值和action标签里的name属性值构成访问路径</li><li>在package标签里写多个action标签，但action的name属性值不能相同的</li></ul></li><li>class属性：<ul><li>action的全路径</li></ul></li><li>method：<ul><li>比如在action里面默认执行execute方法，但是在action里面写其他的方法</li><li>让action里面多个方法执行，使用method进行配置</li></ul></li></ul><h4 id="result"><a href="#result" class="headerlink" title="result"></a>result</h4><p><strong>根本action的方法返回值，配置到不同的路径里面</strong></p><ul><li>name属性：<ul><li>和方法返回值一样</li></ul></li><li>type属性：<ul><li>配置如何到路径中（转发或重定向）</li><li>默认做的转发操作</li></ul></li></ul><h3 id="修改struts2默认常量值"><a href="#修改struts2默认常量值" class="headerlink" title="修改struts2默认常量值"></a>修改struts2默认常量值</h3><p><strong>常用方式：</strong></p><p>在struts.xml中进行配置：</p><p><img src="/category/Struts2/a2.png" alt="Struts2"></p><p>struts.properties进行修改<br>web.xml进行配置<br><strong>最常用常量：</strong></p><p><img src="/category/Struts2/a3.png" alt="Struts2"></p><p>表单提交数据到action里面，在action可以获取表单提交数据</p><p><strong>表单提交数据有中文，乱码问题：</strong></p><ul><li>POST提交直接设置编码</li><li>GET提交做编码转换</li></ul><p>如果在action获取表单通过post方式提交中文，中文乱码问题帮解决了，不需要自己处理问题</p><h2 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h2><p>单独写配置文件，把配置文件引入到核心配置为文件中</p><p><img src="/category/Struts2/a4.png" alt="Struts2"></p><h2 id="Action的编写方式"><a href="#Action的编写方式" class="headerlink" title="Action的编写方式"></a>Action的编写方式</h2><p><strong>action编写有三种方法：</strong></p><ul><li>第一种：创建普通类，这个不继承任何类，不实现任何接口</li><li>第二种：创建类，实现接口Action</li><li><strong>第三种：创建类，继承类ActionSupport</strong></li></ul><h2 id="Action方法访问介绍"><a href="#Action方法访问介绍" class="headerlink" title="Action方法访问介绍"></a>Action方法访问介绍</h2><p>三种方式实现</p><ul><li><strong>第一种：使用action标签的method属性，在这个属性里面写执行的action方法</strong></li><li><strong>第二种：使用通配符方式实现</strong></li><li>第三种：动态访问实现（不用）</li></ul><p>如果action方法有返回值，在配置文件中没有配置，出现错误：404<br>action里面的方法有返回值，如果有返回值时候类型必须是String<br>action里面的方法可以没有返回值， 没有返回值的时候，在result标签不需要配置：<br>把方法写出void<br>让返回值，返回”none”</p><h3 id="使用method属性"><a href="#使用method属性" class="headerlink" title="使用method属性"></a>使用method属性</h3><p><img src="/category/Struts2/a5.png" alt="Struts2"></p><p><img src="/category/Struts2/a6.png" alt="Struts2"></p><p>缺陷：action每个方法都需要配置，如果action里面有多个方法，配置很多的action</p><h3 id="使用通配符实现"><a href="#使用通配符实现" class="headerlink" title="使用通配符实现"></a>使用通配符实现</h3><p>在action标签里面name属性，name属性里面写上* 号：理解：可以匹配任意内容</p><p><img src="/category/Struts2/a7.png" alt="Struts2"></p><p><img src="/category/Struts2/a8.png" alt="Struts2"></p><h3 id="全局结果页面"><a href="#全局结果页面" class="headerlink" title="全局结果页面"></a>全局结果页面</h3><p>result标签配置action方法的返回值到不同的页面<br>如果多个action，方法里面返回值相同的，到页面也是相同的，这个时候可以使用全局页面配置<br>在package标签里面进行配置：只生效于当前package</p><p><img src="/category/Struts2/b1.png" alt="Struts2"></p><h3 id="局部结果页面"><a href="#局部结果页面" class="headerlink" title="局部结果页面"></a>局部结果页面</h3><p>配置了全局，也配置了局部，最终以局部为准</p><p><strong>Result标签的type属性：</strong><br>result标签里面除了name属性之外，还有一个属性type属性<br>type属性：如何到路径里面（转发还是重定向）<br>type属性值：<br>默认值：做转发操作，值是dispatcher</p><p><img src="/category/Struts2/b2.png" alt="Struts2"></p><p>做重定向操作，值是redirect</p><p><img src="/category/Struts2/b3.png" alt="Struts2"></p><p><img src="/category/Struts2/b4.png" alt="Struts2"></p><p>dispatcher、redirect这两个值一般针对到页面中配置，配置到其他的action里面：<br>chain：转发到action，一般不用，缓存问题<br>redirectAction：重定向到action（写action访问名称）</p><p><img src="/category/Struts2/b5.png" alt="Struts2"></p><h2 id="使用ActionContext获取表单数据"><a href="#使用ActionContext获取表单数据" class="headerlink" title="使用ActionContext获取表单数据"></a>使用ActionContext获取表单数据</h2><p>之前web阶段，提交表单到servlet里面，在servlet里面使用request对象里面的方法获取，getParameter，getParameterMap方法。<br>提交表单到action，但是action没有request对象，不能直接使用request对象<br>action获取表单提交数据主要三种方式</p><ol><li><p><strong>使用ActionContext类、</strong></p><p><strong>方法：</strong></p><p><img src="/category/Struts2/c1.png" alt="Struts2"></p><p>因为方法不是静态方法，需要创建ActionContext类的对象</p><p>这个ActionContext类对象不是new出来的</p><p><img src="/category/Struts2/c2.png" alt="Struts2"></p><p><strong>演示：</strong></p><p>创建表单，提交表单到action里面</p><p>在action使用ActionContext获取数据</p><p><img src="/category/Struts2/c3.png" alt="Struts2"></p></li><li><p><strong>使用ServletActionContext类</strong></p><p><img src="/category/Struts2/c4.png" alt="Struts2"></p><p>调用类里的静态方法，得到request对象</p><p><img src="/category/Struts2/c5.png" alt="Struts2"></p></li><li><p>使用接口注入方式（一般不用）</p><p>让action实现接口，得到request对象</p><p><img src="/category/Struts2/c6.png" alt="Struts2"></p><p><img src="/category/Struts2/c7.png" alt="Struts2"></p></li></ol><h2 id="在Action操作域对象"><a href="#在Action操作域对象" class="headerlink" title="在Action操作域对象"></a>在Action操作域对象</h2><p>request、session、servletContext对象</p><p><img src="/category/Struts2/c8.png" alt="Struts2"></p><h3 id="Struts2封装获取表单数据方式"><a href="#Struts2封装获取表单数据方式" class="headerlink" title="Struts2封装获取表单数据方式"></a>Struts2封装获取表单数据方式</h3><p><strong>原始方式获取表单封装到实体对象：</strong><br>使用ServletActionContext获取表单数据封装到实体类对象里面</p><p><img src="/category/Struts2/d1.png" alt="Struts2"></p><p><strong>Struts2提供的封装方式：</strong></p><h4 id="属性封装："><a href="#属性封装：" class="headerlink" title="属性封装："></a><strong>属性封装：</strong></h4><p>直接把表单提交属性封装到action的属性里面<br><strong>实现步骤：</strong></p><ol><li>在action成员变量位置定义变量</li><li>变量名称和表单输入项的name属性值一样</li><li>生成变量的set方法（set和get方法都写出来）</li></ol><p>使用属性封装获取表单数据到属性里面，不能把数据直接封装到实体类对象里面</p><h4 id="模型驱动封装："><a href="#模型驱动封装：" class="headerlink" title="模型驱动封装："></a><strong>模型驱动封装：</strong></h4><p>使用模型驱动方式，可以直接把表单数据封装到实体类对象里面<br>前提要求：表单输入项name属性值和实体类属性名称一样<br><strong>实现步骤：</strong></p><ol><li><p>action实现接口ModelDriven</p><p><img src="/category/Struts2/d2.png" alt="Struts2"></p></li><li><p>实现接口里面的方法，getModel方法。把创建对象返回</p></li><li><p>在action里面创建实体类对象</p><p><img src="/category/Struts2/d3.png" alt="Struts2"></p></li></ol><p>使用模型驱动和属性封装注意问题：</p><p>在一个action中，获取表单数据可以属性封装，使用模型驱动封装，不能同时使用属性封装和模型驱动封装获取同一表单数据，如果同时使用，只执行模型驱动</p><h4 id="表达式封装：（会用）"><a href="#表达式封装：（会用）" class="headerlink" title="表达式封装：（会用）"></a>表达式封装：（会用）</h4><p>实现过程：</p><p>使用表达式封装可以把表单数据封装到实体类对象里面</p><ol><li>第一步：在action里面声明实体类</li><li>第二步：生成实体类变量的set和get方法</li></ol><p><img src="/category/Struts2/d4.png" alt="Struts2"></p><ol><li><p>第三步：在表单输入项的name属性值里面写表达式形式</p><p><img src="/category/Struts2/d5.png" alt="Struts2"></p></li></ol><h4 id="比较表达式封装和模型驱动封装"><a href="#比较表达式封装和模型驱动封装" class="headerlink" title="比较表达式封装和模型驱动封装"></a>比较表达式封装和模型驱动封装</h4><p>使用表达式封装和模型驱动封装都可以把数据封装到实体类对象里面<br>不同点：</p><ul><li>使用模型驱动只能把数据封装到一个实体类里面</li><li>在一个action里面不能使用模型驱动把数据封装到不同的实体类对象里面</li><li>使用表达式封装可以把数据封装到不同的实体类里面</li></ul><h3 id="封装数据到集合"><a href="#封装数据到集合" class="headerlink" title="封装数据到集合"></a>封装数据到集合</h3><h4 id="封装数据到list集合："><a href="#封装数据到list集合：" class="headerlink" title="封装数据到list集合："></a><strong>封装数据到list集合：</strong></h4><ol><li><p>第一步：在action声明List</p></li><li><p>第二步：生成list变量的set和get方法</p><p><img src="/category/Struts2/d6.png" alt="Struts2"></p></li><li><p>第三步：在表单输入项里面写表达式</p><p><img src="/category/Struts2/d7.png" alt="Struts2"></p></li></ol><h4 id="封装到Map集合："><a href="#封装到Map集合：" class="headerlink" title="封装到Map集合："></a><strong>封装到Map集合：</strong></h4><ol><li><p>第一步：声明map集合</p></li><li><p>第二步：生成get和set方法</p><p><img src="/category/Struts2/d8.png" alt="Struts2"></p></li><li><p>第三步：在表单输入项的name属性值里面写表达式</p><p><img src="/category/Struts2/d9.png" alt="Struts2"></p></li></ol><h2 id="OGNL表达式"><a href="#OGNL表达式" class="headerlink" title="OGNL表达式"></a>OGNL表达式</h2><p>EL表达式在jsp中获取域对象里面的值<br>OGNL表达式：在struts2里面操作值栈数据，一般把ognl在struts2操作：和struts2标签一起使用操作值栈</p><p><img src="/category/Struts2/e1.png" alt="Struts2"></p><p>使用OGNL时候先导入jar包，struts2有jar包</p><p>导入标签库：</p><p><img src="/category/Struts2/e2.png" alt="Struts2"></p><p><img src="/category/Struts2/e3.png" alt="Struts2"></p><h2 id="值栈"><a href="#值栈" class="headerlink" title="值栈"></a>值栈</h2><p>web阶段，在servlet里面进行操作，把数据放到域对象里面，在页面中使用el表达式获取到，域对象在一定范围内，存值和取值<br>struts2里面提供本身一种存储机制，类似于域对象，是值栈，可以存值和取值<br>在action里面把数据放到值栈里面，在页面中获取到值栈数据<br><strong>servlet和action区别：</strong></p><ul><li>servlet：默认在第一次访问时候创建，创建一次</li><li>action：访问时候创建，每次访问action时候，都会创建action对象，创建多次，多实例对象</li></ul><p><strong>值栈存储位置：</strong></p><ul><li>每次访问action时候，都会创建action对象</li><li>在每个action对象里面只会有一个值栈对象</li></ul><p><img src="/category/Struts2/e4.png" alt="Struts2"></p><h3 id="获取值栈对象"><a href="#获取值栈对象" class="headerlink" title="获取值栈对象"></a>获取值栈对象</h3><p>获取值栈对象有多种方式:<br><strong>（常用方法）使用ActionContext类里面的方法得到值栈对象</strong></p><p><img src="/category/Struts2/e5.png" alt="Struts2"></p><h3 id="值栈的内部结构"><a href="#值栈的内部结构" class="headerlink" title="值栈的内部结构"></a>值栈的内部结构</h3><p>值栈分为两部分：</p><p><img src="/category/Struts2/e6.png" alt="Struts2"></p><ul><li><p>第一部分：root，结构是list集合</p><ul><li>一般操作都是root里面数据</li></ul></li><li><p>第二部分：context，结构是map集合</p><p><img src="/category/Struts2/e7.png" alt="Struts2"></p></li></ul><p>struts2里面的标签：s:debug，使用这个标签可以查看值栈结构和存储值<br>访问action，执行action的方法有返回值，配置返回值到jsp页面中，在jsp页面中使用debug这个标签</p><p>在action没有任何操作，栈顶元素是</p><p><img src="/category/Struts2/e8.png" alt="Struts2"></p><p>action对象里面有值栈对象<br>值栈对象里面有action引用</p><h3 id="向值栈中放数据"><a href="#向值栈中放数据" class="headerlink" title="向值栈中放数据"></a>向值栈中放数据</h3><p>向值栈放数据多种方式：</p><ul><li><p>第一种：获取值栈对象，调用值栈对象里面的set方法</p><p><img src="/category/Struts2/e9.png" alt="Struts2"></p><p><img src="/category/Struts2/e10.png" alt="Struts2"></p></li><li><p>第二种：获取值栈对象，调用值栈对象里面的push方法</p><p><img src="/category/Struts2/e11.png" alt="Struts2"></p><p><img src="/category/Struts2/e12.png" alt="Struts2"></p></li><li><p><strong>第三种：在action定义变量，生成变量的get方法</strong></p><p><img src="/category/Struts2/e13.png" alt="Struts2"></p><p><img src="/category/Struts2/e14.png" alt="Struts2"></p><p><img src="/category/Struts2/e15.png" alt="Struts2"></p></li></ul><h3 id="向值栈放对象"><a href="#向值栈放对象" class="headerlink" title="向值栈放对象"></a>向值栈放对象</h3><p>实现步骤：</p><ol><li>第一步：定义对象变量</li><li>第二步：生成变量的get方法</li><li>第三步：在执行的方法里面向对象中设置值</li></ol><p><img src="/category/Struts2/f1.png" alt="Struts2"></p><p><img src="/category/Struts2/f2.png" alt="Struts2"></p><h3 id="向值栈放list集合"><a href="#向值栈放list集合" class="headerlink" title="向值栈放list集合"></a>向值栈放list集合</h3><ol><li>第一步：定义list集合变量</li><li>第二步：生成变量的get方法</li><li>第三步：在执行的方法里面向list集合设置值</li></ol><p><img src="/category/Struts2/f3.png" alt="Struts2"></p><p><img src="/category/Struts2/f4.png" alt="Struts2"></p><h3 id="从值栈获取数据"><a href="#从值栈获取数据" class="headerlink" title="从值栈获取数据"></a>从值栈获取数据</h3><p>使用struts2的标签+ognl表达式获取值栈数据</p><p><code>&lt;s:property value=&quot;ognl表达式&quot;/&gt;</code></p><p><strong>获取字符串：</strong></p><ol><li><p>第一步：向值栈中放入数据</p><p><img src="/category/Struts2/f5.png" alt="Struts2"></p></li><li><p>第二步：在jsp使用struts2标签+ognl表达式获取</p><p><img src="/category/Struts2/f6.png" alt="Struts2"></p><p><strong>获取list集合：</strong></p></li></ol><ul><li><p>第一种方式：</p><p><img src="/category/Struts2/f7.png" alt="Struts2"></p></li><li><p>第二种方式：</p><p><img src="/category/Struts2/f8.png" alt="Struts2"></p></li><li><p>第三种方式：</p><p><img src="/category/Struts2/f9.png" alt="Struts2"></p></li></ul><h3 id="获取set和push方法设置值"><a href="#获取set和push方法设置值" class="headerlink" title="获取set和push方法设置值"></a>获取set和push方法设置值</h3><p><strong>使用set方法向值栈放数据，获取</strong></p><p><img src="/category/Struts2/g1.png" alt="Struts2"></p><p><img src="/category/Struts2/g2.png" alt="Struts2"></p><p><strong>使用push方法向值栈放数据，获取</strong></p><p><img src="/category/Struts2/g3.png" alt="Struts2"></p><p>使用push方法设置值，没有名称，只有设置的值<br>向值栈放数据，把向值栈放数据存到数组里面，数组名称top，根据数组获取值</p><p><img src="/category/Struts2/g4.png" alt="Struts2"></p><h3 id="el表达式为什么获取值栈数据"><a href="#el表达式为什么获取值栈数据" class="headerlink" title="el表达式为什么获取值栈数据"></a>el表达式为什么获取值栈数据</h3><p><img src="/category/Struts2/g5.png" alt="Struts2"></p><p><img src="/category/Struts2/g6.png" alt="Struts2"></p><p>EL表达式可以获取值栈数据（为什么）：性能不好<br>EL表达式获取域对象值<br>向域对象里面放值使用setAttribute方法，获取值使用getAttribute方法<br>底层增强request对象里面的方法getAttribute方法：<br>首先从request域获取值，如果获取到，直接返回<br>如果从request域获取不到值，到值栈中把值获取出来，把值放到域对象里面<br>查看源代码：</p><p><img src="/category/Struts2/g7.png" alt="Struts2"></p><p><img src="/category/Struts2/g8.png" alt="Struts2"></p><h3 id="OGNL的-、-使用"><a href="#OGNL的-、-使用" class="headerlink" title="OGNL的#、%使用"></a>OGNL的#、%使用</h3><p>使用#获取context里面数据<br>向request域放值</p><p><img src="/category/Struts2/q1.png" alt="Struts2"></p><p>在页面中使用ognl获取</p><p><img src="/category/Struts2/q2.png" alt="Struts2"></p><p><img src="/category/Struts2/q3.png" alt="Struts2"></p><p><strong>%使用：</strong></p><p>在struts2标签中表单标签</p><p>在struts2标签里面使用ognl表达式，如果直接在struts2表单标签里面使用ognl表达式不识别，只有%之后才会识别</p><p><img src="/category/Struts2/q4.png" alt="Struts2"></p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>struts2是框架，封装了很多功能。struts2里面封装的功能都是在拦截器里面<br>struts2里面封装了很多功能，有很多拦截器，不是每次这些拦截器都执行，每次执行默认的拦截器<br>struts2默认拦截器</p><p><img src="/category/Struts2/q5.png" alt="Struts2"></p><p><img src="/category/Struts2/q6.png" alt="Struts2"></p><p><img src="/category/Struts2/q7.png" alt="Struts2"></p><p><strong>拦截器在什么时候执行？</strong><br>在action对象创建之后，action的方法执行之前</p><h3 id="拦截器底层原理"><a href="#拦截器底层原理" class="headerlink" title="拦截器底层原理"></a>拦截器底层原理</h3><p>拦截器底层使用两个原理<br><strong>aop思想</strong><br>文字描述：</p><blockquote><p>AOP是面向切面（方面）编程，有基本功能，扩展功能，不通过修改源代码方式扩展功能 （底层：动态代理）</p></blockquote><p>画图分析：</p><p><img src="/category/Struts2/q8.png" alt="Struts2"></p><p><strong>责任链模式</strong><br>在java中有很多设计模式，责任链模式是其中的一种<br>责任链模式和过滤链很相似<br>责任链模式：</p><blockquote><p>要执行多个操作，有添加、修改、删除三个操作</p><p>首先执行添加操作，添加操作执行之后做类似于放行操作，执行修改操作，修改操作执行之后做类似于放行操作，执行删除操作</p></blockquote><p>过滤链：一个请求可以有多个过滤器进行过滤，每个过滤器只有做放行才能到下一个过滤器</p><p><img src="/category/Struts2/q9.png" alt="Struts2"></p><p><strong>aop思想和责任链模式如何应用到拦截器里面？</strong><br>文字描述：</p><blockquote><p>拦截器在action对象创建之后，action方法执行之前执行</p><p>在action方法执行之前执行默认拦截器，执行过程使用aop思想，在action并没有直接调用拦截器方法，而是使用配置文件方式进行操作</p><p>执行拦截器时候，执行很多的拦截器，这个过程使用责任链模式</p><p>假如执行三个拦截器，执行拦截器1，执行拦截器1之后做放行操作，执行拦截器2，执行拦截器2之后做放行，执行拦截器3，执行拦截器3之后放行，执行action方法</p></blockquote><p>画图分析</p><p><img src="/category/Struts2/w1.png" alt="Struts2"></p><p>查看源代码：<br>执行action</p><p><img src="/category/Struts2/w2.png" alt="Struts2"></p><p>创建action对象，使用后动态代理方式</p><p><img src="/category/Struts2/w3.png" alt="Struts2"></p><p>执行action的方法</p><p><img src="/category/Struts2/w4.png" alt="Struts2"></p><p>执行很多的拦截器，遍历执行</p><p><img src="/category/Struts2/w5.png" alt="Struts2"></p><p>类似于放行的操作方法</p><p><img src="/category/Struts2/w6.png" alt="Struts2"></p><h3 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h3><p>过滤器：过滤器理论上可以过滤任意内容，比如html、jsp、servlet、图片路径<br>拦截器：拦截器只可以拦截action</p><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><p>在struts2里面有很多的拦截器，这些拦截器是struts2封装的功能，但是在实际开发中，struts2里面的拦截器中可以没有要使用的功能，这个时候需要自己写拦截器实现功能</p><p><strong>拦截器结构：</strong><br>查看源代码看拦截器结构：</p><p>继承类:</p><p><img src="/category/Struts2/e1 [2].png" alt="Struts2"></p><p><img src="/category/Struts2/e2 [2].png" alt="Struts2"></p><p>在接口里面有三个方法：</p><p>初始化方法:</p><p><img src="/category/Struts2/e3 [2].png" alt="Struts2"></p><p>销毁：</p><p><img src="/category/Struts2/e4 [2].png" alt="Struts2"></p><p>拦截逻辑的操作：</p><p><img src="/category/Struts2/e5 [2].png" alt="Struts2"></p><p>开发中建议：<br>写类，继承MethodFilterInterceptor实现<br>让action里面的某个方法不进行拦截<br>让拦截器和action有关系<br>不是在action调用拦截器的方法，而是用过配置文件方式让建立关系</p><h3 id="自定义登录拦截器"><a href="#自定义登录拦截器" class="headerlink" title="自定义登录拦截器"></a>自定义登录拦截器</h3><p><img src="/category/Struts2/e6 [2].png" alt="Struts2"></p><p><img src="/category/Struts2/e7 [2].png" alt="Struts2"></p><p><img src="/category/Struts2/e8 [2].png" alt="Struts2"></p><p><img src="/category/Struts2/e9 [2].png" alt="Struts2"></p><p><img src="/category/Struts2/e10 [2].png" alt="Struts2"></p><p><img src="/category/Struts2/e11 [2].png" alt="Struts2"></p><p><img src="/category/Struts2/e12 [2].png" alt="Struts2"></p><h3 id="struts2标签"><a href="#struts2标签" class="headerlink" title="struts2标签"></a>struts2标签</h3><p><img src="/category/Struts2/r1.png" alt="Struts2"></p><p><img src="/category/Struts2/r2.png" alt="Struts2"></p><p><strong>表单标签：</strong></p><p><img src="/category/Struts2/r4.png" alt="Struts2"></p><p><img src="/category/Struts2/r5.png" alt="Struts2"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      SSH框架-Struts2入门
    
    </summary>
    
      <category term="SSH框架" scheme="https://www.ysmjjsy.com/categories/SSH%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Struts2" scheme="https://www.ysmjjsy.com/categories/SSH%E6%A1%86%E6%9E%B6/Struts2/"/>
    
    
      <category term="SSH框架" scheme="https://www.ysmjjsy.com/tags/SSH%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-java8新特性</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-java8新特性/</id>
    <published>2018-09-09T16:00:00.000Z</published>
    <updated>2019-09-17T09:28:50.452Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:29:31 GMT+0800 (GMT+08:00) --><h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><p>底层数据结构发生改变，更快<br>底层内存结构发生改变：<br>方法区是堆内存中永久区的一部分，1.8之后去掉方法区的永久区，方法区改为元空间。</p><p><img src="/category/JavaSE-java8新特性/d1.png" alt="i"></p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="为什么使用Lambda表达式"><a href="#为什么使用Lambda表达式" class="headerlink" title="为什么使用Lambda表达式"></a>为什么使用Lambda表达式</h3><blockquote><p>Lambda 是一个匿名函数，我们可以把 Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p></blockquote><h3 id="Lambda表达式-1"><a href="#Lambda表达式-1" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>有一个实现要求:</p><p>SAM（Single AbstractMethod）只有一个抽象方法，除此之外没有其他方法</p><p>@FunctionalInterface 函数式接口</p><p>方法没有参数：（）-&gt;{};</p><p>方法有参数：（参数，参数）-&gt;{};</p><p>如果现在只有一行语句返回:(参数，参数)-&gt;语句</p><h4 id="从匿名类到-Lambda-的转换"><a href="#从匿名类到-Lambda-的转换" class="headerlink" title="从匿名类到 Lambda 的转换"></a>从匿名类到 Lambda 的转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Runnable r1= <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"HelloWorld!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda表达式</span></span><br><span class="line">Runnable r1 = () -&gt; System.out.println(<span class="string">"HelloWorld!"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来使用匿名内部类作为参数传递</span></span><br><span class="line">TreeSet&lt;String&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1,String o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(o1.length().o2.length());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda表达式作为参数传递</span></span><br><span class="line">TreeSet&lt;String&gt; ts2 = <span class="keyword">new</span> TreeSet&lt;&gt;(</span><br><span class="line">(o1,o2) -&gt; Integer.compare(o1.length(),o2.length())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式语法"><a href="#Lambda表达式语法" class="headerlink" title="Lambda表达式语法"></a>Lambda表达式语法</h3><p>Lambda 表达式在Java 语言中引入了一个新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称<br>为 Lambda 操作符或剪头操作符。</p><p>它将 Lambda 分为两个部分：</p><p>左侧：指定了 Lambda 表达式需要的所有参数</p><p>右侧：指定了 Lambda 体，即 Lambda 表达式要执行的功能。</p><p><strong>语法格式1：</strong></p><p>无参，无返回值，Lambda体只需要一条语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnabe r1 = () -&gt; System.out.println(<span class="string">"HelloWorld!"</span>);</span><br></pre></td></tr></table></figure><p><strong>语法格式2：</strong></p><p>Lambda需要一个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; fun = (args) -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式3：</strong></p><p>Lambda只需要一个参数时，参数的小括号可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; fun = args -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式4：</strong></p><p>Lambda需要两个参数，并且有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo = (x,y) -&gt;&#123;</span><br><span class="line">  System.out.println(<span class="string">"实现函数接口方法"</span>);</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>语法格式5：</strong></p><p>当Lambda体只有一条语句时，return与大括号可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo = (x,y) -&gt; x + y;</span><br></pre></td></tr></table></figure><p><strong>语法格式6：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo = (Long x, Long y) -&gt;&#123;<span class="comment">//数据类型可以省略，因为可由编译器推断得出，称为"类型推断"</span></span><br><span class="line">  System.out.println(<span class="string">"实现函数接口方法"</span>);</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><ul><li>只包含一个抽象方法的接口，称为函数式接口。</li><li>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。</li></ul><ul><li>我们可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</li></ul><h3 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyNumber</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数式接口中使用泛型:</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunc</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作为参数传递Lambda表达式"><a href="#作为参数传递Lambda表达式" class="headerlink" title="作为参数传递Lambda表达式"></a>作为参数传递Lambda表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperString</span><span class="params">(MyFunc&lt;String&gt; mf,String str)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mf.getValue(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为参数传递Lambda表达式:</span></span><br><span class="line"></span><br><span class="line">String newStr = toUpperString(</span><br><span class="line">(str) -&gt; str.toUpperCase(),<span class="string">"abcdef"</span>);</span><br><span class="line">System.out.println(newStr);</span><br></pre></td></tr></table></figure><p>作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。</p><h3 id="Java内置四大核心函数式接口"><a href="#Java内置四大核心函数式接口" class="headerlink" title="Java内置四大核心函数式接口"></a>Java内置四大核心函数式接口</h3><div class="table-container"><table><thead><tr><th style="text-align:center">函数式接口</th><th style="text-align:center">参数类型</th><th style="text-align:center">返回类型</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center"><code>Consumer&lt;T&gt;</code><br>消费型接口</td><td style="text-align:center">T</td><td style="text-align:center">void</td><td style="text-align:center">对类型为T的对象应用操作，<br>包含方法：<code>void accept(T t);</code></td></tr><tr><td style="text-align:center"><code>Supplier&lt;T&gt;</code><br>供给型接口</td><td style="text-align:center">无</td><td style="text-align:center">T</td><td style="text-align:center">返回类型为T的对象，<br>包含方法：<code>T get();</code></td></tr><tr><td style="text-align:center"><code>Function&lt;T,R&gt;</code></td><td style="text-align:center">T</td><td style="text-align:center">R</td><td style="text-align:center">对类型为T的对象应用操作，并返回结果，结果是R类型的对象，包含方法：<code>R apply(T t);</code></td></tr><tr><td style="text-align:center"><code>Predicate&lt;T&gt;</code></td><td style="text-align:center">T</td><td style="text-align:center">boolean</td><td style="text-align:center">确定类型为T的对象是否满足某约束，并返回boolean值。包含方法：<code>boolean test(T t);</code></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th></tr></thead><tbody><tr><td><code>BiFunction&lt;T,U,R&gt;</code></td><td>T,U</td><td>R</td><td>对类型为T,U参数应用操作，返回R类型的结果，<br>包含方法为<code>R apply(T t,U u);</code></td></tr><tr><td><code>UnaryOperator&lt;T&gt;</code><br>（Function子接口）</td><td>T</td><td>T</td><td>对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为<code>T apply(T t);</code></td></tr><tr><td><code>BinaryOperator&lt;T&gt;</code><br>(BigFunction子接口)</td><td>T，T</td><td>T</td><td>对类型为T的对象进行二元运算，并返回T类型的结果，包含方法为<code>T apply(T t1,T t2);</code></td></tr><tr><td><code>BigConsumer&lt;T,U&gt;</code></td><td>T,U</td><td>void</td><td>对类型为T,U参数应用操作，包含方法为<code>void accept(T t,U u)</code></td></tr><tr><td><code>ToIntFunction&lt;T&gt;</code><br><code>ToLongFunction&lt;T&gt;</code><br><code>ToDoubleFunction</code></td><td>T</td><td>int,long,double</td><td>分别计算int,long,double值的函数</td></tr><tr><td><code>IntFunction&lt;R&gt;</code><br><code>LongFunction&lt;R&gt;</code><br>DoubleFunction<r></r></td><td>int,long,double</td><td>R</td><td>参数分别为int，long，double类型的参数</td></tr></tbody></table></div><h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！<br>（实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致！）<br>方法引用：使用操作符 “::” 将方法名和对象或类的名字分隔开来。<br>如下三种主要使用情况：</p><ul><li>对象::实例方法</li><li>类::静态方法</li><li>类::实例方法</li></ul><p><strong>例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(x) -&gt; System.out.println(x);</span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line">System.out::println;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Double&gt; bo = (x,y) -&gt; Math.pow(x,y);</span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line">BinaryOperator&lt;Double&gt; bo = Math::pow;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compare((x,y) -&gt; x.equals(y),<span class="string">"abcdef"</span>,<span class="string">"abcdef"</span>);</span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line">comare(String::equals,<span class="string">"abc"</span>,<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><p>注意：当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引<br>用方法的第二个参数(或无参数)时：ClassName::methodName</p><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>格式： <code>ClassName::new</code><br>与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，与构造器参数列表要与接口中抽象方法的参数列表一致！</p><p><strong>例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,MyClass&gt; fun = (n) -&gt; <span class="keyword">new</span> MyClass(n);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Function&lt;Integer,MyClass&gt; fun = MyClass::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><p>格式： <code>type[] :: new</code></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,Integer[]&gt; fun = (n) -&gt; <span class="keyword">new</span> Integer[n];</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Function&lt;Integer,Integer[]&gt; fun = Integer[]::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><h2 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h2><blockquote><p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API(java.util.stream.*)。</p><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，</p><p>Stream API 提供了一种高效且易于使用的处理数据的方式。</p></blockquote><p><strong>流(Stream) 到底是什么呢？</strong><br>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br>“集合讲的是数据，流讲的是计算！”</p><p><strong>注意：</strong></p><ol><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol><h3 id="Strean的操作三个步骤"><a href="#Strean的操作三个步骤" class="headerlink" title="Strean的操作三个步骤"></a>Strean的操作三个步骤</h3><ul><li><p><strong>创建Stream</strong></p><p>一个数据源(如：集合、数组),获取一个流</p></li><li><p><strong>中间操作</strong></p><p>一个中间操作链，对数据源的数据进行处理</p></li><li><p><strong>终止操作(终端操作)</strong></p><p>一个终止操作，执行中间操作链，并产生结果</p></li></ul><p><img src="/category/JavaSE-java8新特性/1.png" alt="stream"></p><h4 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h4><p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream <span class="title">stream</span><span class="params">()</span></span>; <span class="comment">//返回一个顺序流</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream <span class="title">parallelStream</span><span class="params">()</span></span>; <span class="comment">//返回一个并行流</span></span><br></pre></td></tr></table></figure><h5 id="由数组创建流"><a href="#由数组创建流" class="headerlink" title="由数组创建流"></a>由数组创建流</h5><p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span>  Stream <span class="title">stream</span><span class="params">(T[] array)</span></span>;<span class="comment">//返回一个流</span></span><br></pre></td></tr></table></figure><p>重载形式，能够处理对应基本类型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">stream</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LongStream <span class="title">stream</span><span class="params">(<span class="keyword">long</span>[] array)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleStream <span class="title">stream</span><span class="params">(<span class="keyword">double</span>[] array)</span></span></span><br></pre></td></tr></table></figure><h5 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h5><p>可以使用静态方法 Stream.of(), 通过显示值创建一个流。它可以接收任意数量的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span></span>; <span class="comment">//返回一个流</span></span><br></pre></td></tr></table></figure><h5 id="由函数创建流：创建无限流"><a href="#由函数创建流：创建无限流" class="headerlink" title="由函数创建流：创建无限流"></a>由函数创建流：创建无限流</h5><p>可以使用静态方法 Stream.iterate() 和Stream.generate(), 创建无限流。</p><p>迭代<br><code>public static Stream iterate(final T seed, finalUnaryOperator f)</code><br>生成<br><code>public static Stream generate(Supplier s）</code></p><h4 id="Stream的中间操作"><a href="#Stream的中间操作" class="headerlink" title="Stream的中间操作"></a>Stream的中间操作</h4><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p><h5 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>filter(Predicate p)</code></td><td>接收Lembda，从流中排除某些元素</td></tr><tr><td><code>distinct()</code></td><td>筛选，通过流所生成元素的hashCode()和equals()去除重复元素</td></tr><tr><td><code>limit(long maxSize)</code></td><td>截断流，使其元素不超过给定数量</td></tr><tr><td><code>skip(long n)</code></td><td>跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，则返回一个空流，与limit(n)互补</td></tr></tbody></table></div><h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>map(Function f)</code></td><td>接收一函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</td></tr><tr><td><code>mapToDouble(ToDoubleFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream</td></tr><tr><td><code>mapToInt(ToIntFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream</td></tr><tr><td><code>mapToLong(ToLongFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream</td></tr><tr><td><code>flatMap(Function f)</code></td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td></tr></tbody></table></div><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sorted()</td><td>产生一个新流，其中按自然顺序排序</td></tr><tr><td>sorted(Comparator comp)</td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table></div><h4 id="Sream的终止操作"><a href="#Sream的终止操作" class="headerlink" title="Sream的终止操作"></a>Sream的终止操作</h4><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</p><h5 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>allMath(Predicate p)</td><td>检查是否匹配所有元素</td></tr><tr><td>antMath(Predicate p)</td><td>检查是否至少匹配一个元素</td></tr><tr><td>noneMath(Predicate p)</td><td>检查是否没有匹配所有元素</td></tr><tr><td>findFirst()</td><td>返回第一个元素</td></tr><tr><td>findAny()</td><td>返回当前流中的任意元素</td></tr><tr><td>count()</td><td>返回流中元素总数</td></tr><tr><td>max(Comparator c)</td><td>返回流中最大值</td></tr><tr><td>min(Coparator c)</td><td>返回流中最小值</td></tr><tr><td>forEach(Consumer c)</td><td>内部迭代(使用Collection接口需要用户去做迭代，称为外部迭代，相反，StreamAPI使用内部迭代—-它帮你把迭代做了)</td></tr></tbody></table></div><h5 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>reduce(T iden,BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回T</td></tr><tr><td>reduce(BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值，返回<code>Optional&lt;T&gt;</code></td></tr></tbody></table></div><h5 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>collect(Collector c)</td><td>将流转换为其他形式，接收一个Collector接口的实现，用于给Steam中元素做汇总工作</td></tr></tbody></table></div><p>Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">toList  List&lt;T&gt;  <span class="comment">//把流中元素收集到List  </span></span><br><span class="line">List&lt;Employee&gt; emps = list.stream().collect(Collectors.tolist());  </span><br><span class="line"></span><br><span class="line">toSet Set&lt;T&gt; <span class="comment">//把流中元素收集到Set</span></span><br><span class="line">Set&lt;Employee emps = list.stream().collect(Collectors.toSet());  </span><br><span class="line"></span><br><span class="line">toCollection Collection&lt;T&gt; <span class="comment">//把流中元素收集到创建的集合</span></span><br><span class="line">Collection&lt;Employee&gt; empls = list.stream().collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">counting Long <span class="comment">//计算流中元素的个数</span></span><br><span class="line"><span class="keyword">long</span> count = list.stream().collect(Collectors.counting());</span><br><span class="line"></span><br><span class="line">summingInt Integer <span class="comment">//对流中元素的整数属性求和</span></span><br><span class="line">inttotal = list.stream().collect(Collectors.summingInt(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">averaginInt Double <span class="comment">// 计算流中元素Integer属性的平均值</span></span><br><span class="line">doubleavg = list.stream().collect(Collectors.averagingInt(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">summarrizingInt IntSummartStatistics <span class="comment">//收集流中Integer属性的统计值，如平均值</span></span><br><span class="line">IntSummaryStatisticsiss = list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">joining String <span class="comment">//连接流中每个字符串</span></span><br><span class="line">String str = list.stream().map(Employee::getName).collect(Collectors.joining());</span><br><span class="line"></span><br><span class="line">maxBy Optional&lt;T&gt; <span class="comment">//根据比较器选择最大值</span></span><br><span class="line">Optional&lt;Emp&gt; max = list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</span><br><span class="line">minBy Optional&lt;T&gt; <span class="comment">//根据比较器选择最小值</span></span><br><span class="line">Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</span><br><span class="line"></span><br><span class="line">reducing 归约产生的类型 <span class="comment">//从一个作为累加器的初始值开始，利用BinaryOperator流中元素逐个结合，从而归约成单个值</span></span><br><span class="line">inttotal=list.stream().collect(Collectors.reducing(<span class="number">0</span>, Employee::getSalar, Integer::sum));</span><br><span class="line"></span><br><span class="line">collectingAndThen 转换函数返回的类型 <span class="comment">//包裹另一个收集器，对其结果转换函数</span></span><br><span class="line">inthow= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</span><br><span class="line"></span><br><span class="line">groupingBy Map&lt;K, List&lt;T&gt;&gt; <span class="comment">//根据某属性值对流分组，属性为K，结果为V</span></span><br><span class="line">Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));</span><br><span class="line"></span><br><span class="line">partitioningBy Map&lt;Boolean, List&lt;T&gt;&gt; <span class="comment">//根据true或false进行分区</span></span><br><span class="line">Map&lt;Boolean,List&lt;Emp&gt;&gt;vd=</span><br><span class="line">list.stream().collect(Collectors.partitioningBy(Employee::getManage));</span><br></pre></td></tr></table></figure><h3 id="并行流与串行流"><a href="#并行流与串行流" class="headerlink" title="并行流与串行流"></a>并行流与串行流</h3><p>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。</p><p>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与sequential() 在并行流与顺序流之间进行切换。</p><h3 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork/Join 框架"></a>Fork/Join 框架</h3><p>Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总.</p><p><img src="/category/JavaSE-java8新特性/2.png" alt="java8"></p><h4 id="Fork-Join-框架与传统线程池的区别"><a href="#Fork-Join-框架与传统线程池的区别" class="headerlink" title="Fork/Join 框架与传统线程池的区别"></a>Fork/Join 框架与传统线程池的区别</h4><blockquote><p>采用 “工作窃取”模式（work-stealing）：</p><p>当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p><p>相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间,提高了性能.</p></blockquote><h2 id="新时间日期API"><a href="#新时间日期API" class="headerlink" title="新时间日期API"></a>新时间日期API</h2><h3 id="使用-LocalDate、LocalTime、LocalDateTime"><a href="#使用-LocalDate、LocalTime、LocalDateTime" class="headerlink" title="使用 LocalDate、LocalTime、LocalDateTime"></a>使用 LocalDate、LocalTime、LocalDateTime</h3><p>LocalDate、LocalTime、LocalDateTime 类的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。</p><p>注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法</p><p><img src="/category/JavaSE-java8新特性/3.png" alt="java8"></p><h3 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant 时间戳"></a>Instant 时间戳</h3><p>用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算</p><h3 id="Duration-和-Period"><a href="#Duration-和-Period" class="headerlink" title="Duration 和 Period"></a>Duration 和 Period</h3><ul><li>Duration:用于计算两个“时间”间隔</li><li>Period:用于计算两个“日期”间隔</li></ul><h3 id="日期的操纵"><a href="#日期的操纵" class="headerlink" title="日期的操纵"></a>日期的操纵</h3><p>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。</p><ul><li>TemporalAdjusters : 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现。</li></ul><p>例如获取下个周日：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate nextSunday = LocalDate.now().with(</span><br><span class="line">TemporalAdjusters.next(DayOfWeek.SUNDAY)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="解析与格式化"><a href="#解析与格式化" class="headerlink" title="解析与格式化"></a>解析与格式化</h3><p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p><ul><li>预定义的标准格式</li><li>语言环境相关的格式</li><li>自定义的格式</li></ul><h3 id="时区的处理"><a href="#时区的处理" class="headerlink" title="时区的处理"></a>时区的处理</h3><p>Java8 中加入了对时区的支持，带时区的时间为分别为：<br>ZonedDate、ZonedTime、ZonedDateTime<br>其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式<br>例如 ：Asia/Shanghai 等<br>ZoneId：该类中包含了所有的时区信息<br>getAvailableZoneIds() : 可以获取所有时区时区信息<br>of(id) : 用指定的时区信息获取 ZoneId 对象</p><h3 id="与传统日期处理的转换"><a href="#与传统日期处理的转换" class="headerlink" title="与传统日期处理的转换"></a>与传统日期处理的转换</h3><p><img src="/category/JavaSE-java8新特性/4.png" alt="java8"></p><h2 id="接口中的默认方法与静态方法"><a href="#接口中的默认方法与静态方法" class="headerlink" title="接口中的默认方法与静态方法"></a>接口中的默认方法与静态方法</h2><p>Java 8中允许接口中包含具有具体实现的方法，该方法称为“默认方法”，默认方法使用 default 关键字修饰。</p><p><strong>例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunc</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">defalut String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello Java8"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口默认方法的”类优先”原则</strong></p><p>若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时</p><ul><li>选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。</li></ul><ul><li>接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunc</span></span>&#123;</span><br><span class="line">  <span class="function">defalut String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello Java8"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span></span>&#123;</span><br><span class="line">  <span class="function">defalut String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello Java"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyFunc</span>,<span class="title">Named</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Named.<span class="keyword">super</span>,getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口中的静态方法"><a href="#接口中的静态方法" class="headerlink" title="接口中的静态方法"></a>接口中的静态方法</h4><p>Java8 中，接口中允许添加静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">myFun</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello java"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h2><h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><p>Optional 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p><p><strong>常用方法：</strong><br><code>Optional.of(T t)</code> : 创建一个 Optional 实例<br><code>Optional.empty()</code> : 创建一个空的 Optional 实例<br><code>Optional.ofNullable(T t)</code>:若 t 不为 null,创建 Optional 实例,否则创建空实例<br><code>isPresent()</code> : 判断是否包含值<br><code>orElse(T t)</code> : 如果调用对象包含值，返回该值，否则返回t<br><code>orElseGet(Supplier s)</code> :如果调用对象包含值，返回该值，否则返回 s 获取的值<br><code>map(Function f)</code>: 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()<br><code>flatMap(Function mapper)</code>:与 map 类似，要求返回值必须是Optional</p><h3 id="重复注解与类型注解"><a href="#重复注解与类型注解" class="headerlink" title="重复注解与类型注解"></a>重复注解与类型注解</h3><p>Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations&#123;</span><br><span class="line">  MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repetable</span>(MyAnnotations.class)</span><br><span class="line"><span class="meta">@Target</span>(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,ElementType.TYPE_PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetemtionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation</span>(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="meta">@MyANnotation</span>(<span class="string">"World"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(@MyAnnotation(<span class="string">"abc"</span>)</span>String str)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>在 Java 5.0 提供了 java.util.concurrent （简称JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。提供可调的、灵活的线程池。还提供了设计用于多线程上下文中的 Collection 实现等。</p><h3 id="volatile关键字-内存可见性"><a href="#volatile关键字-内存可见性" class="headerlink" title="volatile关键字 内存可见性"></a>volatile关键字 内存可见性</h3><p><strong>内存可见性</strong></p><p>内存可见性（Memory Visibility）是指当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p><ul><li>可见性错误是指当读操作与写操作在不同的线程中执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。</li></ul><ul><li>我们可以通过同步来保证对象被安全地发布。除此之外我们也可以使用一种更加轻量级的 volatile 变量。</li></ul><p><strong>volatile 关键字</strong></p><p>Java 提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。可以将 volatile 看做一个轻量级的锁，但是又与锁有些不同：</p><ul><li>对于多线程，不是一种互斥关系</li><li>不能保证变量状态的“原子性操作”</li></ul><h3 id="原子变量-CAS算法"><a href="#原子变量-CAS算法" class="headerlink" title="原子变量 CAS算法"></a>原子变量 CAS算法</h3><p><strong>CAS算法</strong></p><ul><li>CAS (Compare-And-Swap) 是一种硬件对并发的支持，针对多处理器操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。</li><li>CAS 是一种无锁的非阻塞算法的实现。</li><li>CAS 包含了 3 个操作数：<ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul></li><li>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作。</li></ul><p><strong>原子变量</strong></p><ul><li>类的小工具包，支持在单个变量上解除锁的线程安全编程。事实上，此包中的类可将 volatile 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类。</li><li>类 AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 的实例各自提供对相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。</li><li>AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray 类进一步扩展了原子操作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方面也引人注目，这对于普通数组来说是不受支持的。</li><li><strong>核心方法：boolean compareAndSet(expectedValue, updateValue)</strong></li><li>java.util.concurrent.atomic 包下提供了一些原子操作的常用类:<ul><li>AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference</li><li>AtomicIntegerArray 、AtomicLongArray</li><li>AtomicMarkableReference</li><li>AtomicReferenceArray</li><li>AtomicStampedReference</li></ul></li></ul><h3 id="ConcurrentHashMap-锁分段机制"><a href="#ConcurrentHashMap-锁分段机制" class="headerlink" title="ConcurrentHashMap 锁分段机制"></a>ConcurrentHashMap 锁分段机制</h3><p><strong>ConcurrentHashMap</strong></p><p>Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。</p><ul><li>ConcurrentHashMap 同步容器类是Java 5 增加的一个线程安全的哈希表。对与多线程的操作，介于 HashMap 与 Hashtable 之间。内部采用“锁分段”机制替代 Hashtable 的独占锁。进而提高性能。</li><li>此包还提供了设计用于多线程上下文中的 Collection 实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap，ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。</li></ul><h3 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch 闭锁"></a>CountDownLatch 闭锁</h3><ul><li>Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。</li></ul><ul><li>CountDownLatch 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</li></ul><ul><li>闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行：<ul><li>确保某个计算在其需要的所有资源都被初始化之后才继续执行;</li><li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动;</li><li>等待直到某个操作所有参与者都准备就绪再继续执行。</li></ul></li></ul><h3 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h3><ul><li>Java 5.0 在 java.util.concurrent 提供了一个新的创建执行线程的方式：Callable 接口</li></ul><ul><li>Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常。</li></ul><ul><li>Callable 需要依赖FutureTask ，FutureTask 也可以用作闭锁。</li></ul><h3 id="Lock-同步锁"><a href="#Lock-同步锁" class="headerlink" title="Lock 同步锁"></a>Lock 同步锁</h3><p><strong>显示锁 Lock</strong></p><ul><li>在 Java 5.0 之前，协调共享对象的访问时可以使用的机制只有 synchronized 和 volatile 。Java 5.0 后增加了一些新的机制，但并不是一种替代内置锁的方法，而是当内置锁不适用时，作为一种可选择的高级功能。</li></ul><ul><li>ReentrantLock 实现了 Lock 接口，并提供了与synchronized 相同的互斥性和内存可见性。但相较于synchronized 提供了更高的处理锁的灵活性。</li></ul><h3 id="Condition-控制线程通信"><a href="#Condition-控制线程通信" class="headerlink" title="Condition 控制线程通信"></a>Condition 控制线程通信</h3><p><strong>Condition</strong></p><ul><li>Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。</li></ul><ul><li>在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是await、signal 和 signalAll。</li></ul><ul><li>Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得Condition 实例，请使用其 newCondition() 方法。</li></ul><h3 id="线程按序交替"><a href="#线程按序交替" class="headerlink" title="线程按序交替"></a>线程按序交替</h3><p>编写一个程序，开启 3 个线程，这三个线程的 ID 分别为A、B、C，每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出的结果必须按顺序显示。<br>如：ABCABCABC…… 依次递归</p><h3 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h3><ul><li>ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。。</li></ul><ul><li>ReadWriteLock 读取操作通常不会改变共享资源，但执行写入操作时，必须独占方式来获取锁。对于读取操作占多数的数据结构。 ReadWriteLock 能提供比独占锁更高的并发性。而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作。</li></ul><h3 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h3><ul><li>一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法</li></ul><ul><li>锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</li></ul><ul><li>加个普通方法后发现和同步锁无关</li><li>换成两个对象后，不是同一把锁了，情况立刻变化。</li><li>都换成静态同步方法后，情况又变化</li><li>所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</li></ul><ul><li>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li>第四种获取线程的方法：线程池，一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。</li></ul><ul><li>线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。</li></ul><ul><li>为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 ：</li></ul><ul><li>Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）</li><li>Executors.newFixedThreadPool(int)（固定大小线程池）</li><li>Executors.newSingleThreadExecutor()（单个后台线程）它们均为大多数使用场景预定义了设置。</li></ul><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p><strong>ScheduledExecutorService</strong></p><p>一个 ExecutorService，可安排在给定的延迟后运行或定期执行的命令。</p><h3 id="ForkJoinPool-分支-合并框架-工作窃取"><a href="#ForkJoinPool-分支-合并框架-工作窃取" class="headerlink" title="ForkJoinPool 分支/合并框架 工作窃取"></a>ForkJoinPool 分支/合并框架 工作窃取</h3><p><strong>Fork/Join 框架</strong></p><p>Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总。</p><p><img src="/category/JavaSE-java8新特性/5.png" alt="juc"></p><p><strong>Fork/Join 框架与线程池的区别</strong></p><ul><li>采用 “工作窃取”模式（work-stealing）：当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</li></ul><ul><li>相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间，提高了性能。</li></ul><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</p><p><strong>Java NIO 与 IO 的主要区别</strong></p><p><img src="/category/JavaSE-java8新特性/6.png" alt="nio"></p><h3 id="通道（Channel）与缓冲区（Buffer）"><a href="#通道（Channel）与缓冲区（Buffer）" class="headerlink" title="通道（Channel）与缓冲区（Buffer）"></a>通道（Channel）与缓冲区（Buffer）</h3><p>Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</p><p><strong>简而言之，Channel 负责传输， Buffer 负责存储</strong></p><h4 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h4><ul><li>缓冲区（Buffer）：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。</li></ul><ul><li>Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的。</li></ul><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。都是通过如下方法获取一个 Buffer对象：</p><p><strong>static XxxBuffer allocate(int capacity) : 创建一个容量为 capacity 的 XxxBuffer 对象</strong></p><h5 id="缓冲区的基本属性"><a href="#缓冲区的基本属性" class="headerlink" title="缓冲区的基本属性"></a>缓冲区的基本属性</h5><p>Buffer 中的重要概念：</p><ul><li>容量 (capacity) ：表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。</li></ul><ul><li>限制 (limit)：第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量。</li></ul><ul><li>位置 (position)：下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制</li></ul><ul><li>标记 (mark)与重置 (reset)：标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position.</li></ul><p>标记、位置、限制、容量遵守以下不变式： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p><p><img src="/category/JavaSE-java8新特性/7.png" alt="nio"></p><h5 id="Buffer的常用方法"><a href="#Buffer的常用方法" class="headerlink" title="Buffer的常用方法"></a>Buffer的常用方法</h5><p><img src="/category/JavaSE-java8新特性/8.png" alt="nio"></p><h5 id="缓冲区的数据操作"><a href="#缓冲区的数据操作" class="headerlink" title="缓冲区的数据操作"></a>缓冲区的数据操作</h5><ul><li>Buffer 所有子类提供了两个用于数据操作的方法：get()与 put() 方法<ul><li>获取 Buffer 中的数据<ul><li>get() ：读取单个字节</li><li>get(byte[] dst)：批量读取多个字节到 dst 中</li><li>get(int index)：读取指定索引位置的字节(不会移动 position)</li></ul></li><li>放入数据到 Buffer 中<ul><li>put(byte b)：将给定单个字节写入缓冲区的当前位置</li><li>put(byte[] src)：将 src 中的字节写入缓冲区的当前位置</li><li>put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 position)</li></ul></li></ul></li></ul><h5 id="直接与非直接缓冲区"><a href="#直接与非直接缓冲区" class="headerlink" title="直接与非直接缓冲区"></a>直接与非直接缓冲区</h5><ul><li>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。</li></ul><ul><li>直接字节缓冲区可以通过调用此类的 allocateDirect() 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。</li></ul><ul><li>直接字节缓冲区还可以通过 FileChannel 的 map() 方法 将文件区域直接映射到内存中来创建。该方法返回MappedByteBuffer 。Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。</li></ul><ul><li>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。</li></ul><p><strong>非直接缓冲区</strong></p><p><img src="/category/JavaSE-java8新特性/a1.png" alt="nio"></p><p><strong>直接缓冲区</strong></p><p><img src="/category/JavaSE-java8新特性/a2.png" alt="nio"></p><h4 id="通道（Channel）"><a href="#通道（Channel）" class="headerlink" title="通道（Channel）"></a>通道（Channel）</h4><p>通道（Channel）：由 java.nio.channels 包定义的。Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据，Channel 只能与Buffer 进行交互。</p><p><img src="/category/JavaSE-java8新特性/b1.png" alt="nio"></p><p><img src="/category/JavaSE-java8新特性/b2.png" alt="nio"></p><p><img src="/category/JavaSE-java8新特性/b3.png" alt="nio"></p><p>Java 为 Channel 接口提供的最主要实现类如下：</p><ul><li>FileChannel：用于读取、写入、映射和操作文件的通道。</li><li>DatagramChannel：通过 UDP 读写网络中的数据通道。</li><li>SocketChannel：通过 TCP 读写网络中的数据。</li><li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><h5 id="获取通道"><a href="#获取通道" class="headerlink" title="获取通道"></a>获取通道</h5><p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul><p>获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道。</p><h5 id="通道的数据传输"><a href="#通道的数据传输" class="headerlink" title="通道的数据传输"></a>通道的数据传输</h5><p>将 Buffer 中数据写入 Channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Buffer中数据写入Channel中</span></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure><p>从 Channel 读取数据到 Buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从Channel读取数据到Buffer</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure><h4 id="分散-Scatter-和聚集-Gather"><a href="#分散-Scatter-和聚集-Gather" class="headerlink" title="分散(Scatter)和聚集(Gather)"></a>分散(Scatter)和聚集(Gather)</h4><p><strong>分散读取（Scattering Reads）是指从 Channel 中读取的数据“分散”到多个 Buffer 中。</strong></p><p><img src="/category/JavaSE-java8新特性/c1.png" alt="nio"></p><p>注意：按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满。</p><p><strong>聚集写入（Gathering Writes）是指将多个 Buffer 中的数据“聚集”到 Channel。</strong></p><p><img src="/category/JavaSE-java8新特性/c2.png" alt="nio"></p><p>注意：按照缓冲区的顺序，写入 position 和 limit 之间的数据到 Channel 。</p><h4 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h4><p>将数据从源通道传输到其他 Channel 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/fromFile.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line"><span class="comment">//获取FileChannel</span></span><br><span class="line">FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/toFile.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义传输位置</span></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最多传输的字节数</span></span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据从源通道传输到另一个通道</span></span><br><span class="line">toChannel.transferFrom(fromChannel,count,position);</span><br></pre></td></tr></table></figure><h4 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h4><p>将数据从源通道传输到其他 Channel 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/fromFile.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line"><span class="comment">//获取FileChannel</span></span><br><span class="line">FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/toFile.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义传输位置</span></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最多传输的字节数</span></span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据从源通道传输到另一个通道</span></span><br><span class="line">fromChannel.transferTo(position,count,toChannel);</span><br></pre></td></tr></table></figure><h4 id="FileChannel-的常用方法"><a href="#FileChannel-的常用方法" class="headerlink" title="FileChannel 的常用方法"></a>FileChannel 的常用方法</h4><p><img src="/category/JavaSE-java8新特性/11.png" alt="nio"></p><h3 id="NIO-的非阻塞式网络通信"><a href="#NIO-的非阻塞式网络通信" class="headerlink" title="NIO 的非阻塞式网络通信"></a>NIO 的非阻塞式网络通信</h3><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><ul><li>传统的 IO 流都是阻塞式的。也就是说，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行 IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。</li></ul><ul><li>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO 可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。</li></ul><h4 id="选择器（Selector）"><a href="#选择器（Selector）" class="headerlink" title="选择器（Selector）"></a>选择器（Selector）</h4><ul><li>选择器（Selector） 是 SelectableChannle 对象的多路复用器，Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心。</li></ul><ul><li>SelectableChannle 的结构如下图：</li></ul><p><img src="/category/JavaSE-java8新特性/12.png" alt="nio"></p><h4 id="选择器（Selector）的应用"><a href="#选择器（Selector）的应用" class="headerlink" title="选择器（Selector）的应用"></a>选择器（Selector）的应用</h4><p>创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><p>向选择器注册通道：SelectableChannel.register(Selector sel, int ops)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Socket套接字</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Sokcet(InetAddress.getByName(<span class="string">"127.0.0.1"</span>),<span class="number">9898</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取SocketChannel</span></span><br><span class="line">SocketChannel channel = scoket.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将SocketChannel切换到非阻塞模式</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向Selector注册Channel</span></span><br><span class="line">SelectionKey key = channel.register(selector,SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h4><ul><li>当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器</li></ul><p>对通道的监听事件，需要通过第二个参数 ops 指定。</p><ul><li>可以监听的事件类型（可使用 SelectionKey 的四个常量表示）：<ul><li>读 : SelectionKey.OP_READ （1）</li><li>写 : SelectionKey.OP_WRITE （4）</li><li>连接 : SelectionKey.OP_CONNECT （8）</li><li>接收 : SelectionKey.OP_ACCEPT （16）</li></ul></li></ul><ul><li>若注册时不止监听一个事件，则可以使用“位或”操作符连接。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册"监听事件"</span></span><br><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ|SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><p>SelectionKey：表示 SelectableChannel 和 Selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。</p><p><img src="/category/JavaSE-java8新特性/21.png" alt="nio"></p><h4 id="Selector-的常用方法"><a href="#Selector-的常用方法" class="headerlink" title="Selector 的常用方法"></a>Selector 的常用方法</h4><p><img src="/category/JavaSE-java8新特性/22.png" alt="nio"></p><h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。</p><p>操作步骤：</p><ul><li>打开 SocketChannel</li><li>读写数据</li><li>关闭 SocketChannel</li></ul><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道，就像标准IO中的ServerSocket一样。</p><h4 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h4><p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。<br>操作步骤：</p><ul><li>打开 DatagramChannel</li><li>接收/发送数据</li></ul><h4 id="管道-Pipe"><a href="#管道-Pipe" class="headerlink" title="管道 (Pipe)"></a>管道 (Pipe)</h4><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</p><p><img src="/category/JavaSE-java8新特性/23.png" alt="nio"></p><h5 id="向管道写数据"><a href="#向管道写数据" class="headerlink" title="向管道写数据"></a>向管道写数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">  String str = <span class="string">"测试数据"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建管道</span></span><br><span class="line">  Pipe pipe = Pipe.open();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//向管道写输入</span></span><br><span class="line">  Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//通过SinkChannel的write()方法写数据</span></span><br><span class="line">  ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">  buf.clear();</span><br><span class="line">  buf.put(str.getBytes());</span><br><span class="line">  buf.flip();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">    sinkChannel.write(buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a>从管道读取数据</h5><p>从读取管道的数据，需要访问source通道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从管道读取数据</span></span><br><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br></pre></td></tr></table></figure><p>调用source通道的read()方法来读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用SourceChannel的read()方法读取数据</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">sourceChannel.read(buf);</span><br></pre></td></tr></table></figure><h3 id="NIO-2-–-Path、Paths、Files"><a href="#NIO-2-–-Path、Paths、Files" class="headerlink" title="NIO.2 – Path、Paths、Files"></a>NIO.2 – Path、Paths、Files</h3><h4 id="NIO-2"><a href="#NIO-2" class="headerlink" title="NIO.2"></a>NIO.2</h4><p>随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。</p><h4 id="Path-与-Paths"><a href="#Path-与-Paths" class="headerlink" title="Path 与 Paths"></a>Path 与 Paths</h4><ul><li>java.nio.file.Path 接口代表一个平台无关的平台路径，描述了目录结构中文件的位置。</li><li>Paths 提供的 get() 方法用来获取 Path 对象：<ul><li>Path get(String first, String … more) : 用于将多个字符串串连成路径。</li></ul></li></ul><ul><li>Path 常用方法：<ul><li>boolean endsWith(String path) : 判断是否以 path 路径结束</li><li>boolean startsWith(String path) : 判断是否以 path 路径开始</li><li>boolean isAbsolute() : 判断是否是绝对路径</li><li>Path getFileName() : 返回与调用 Path 对象关联的文件名</li><li>Path getName(int idx) : 返回的指定索引位置 idx 的路径名称</li><li>int getNameCount() : 返回Path 根目录后面元素的数量</li><li>Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</li><li>Path getRoot() ：返回调用 Path 对象的根路径</li><li>Path resolve(Path p) :将相对路径解析为绝对路径</li><li>Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</li><li>String toString() ： 返回调用 Path 对象的字符串表示形式</li></ul></li></ul><h4 id="Files-类"><a href="#Files-类" class="headerlink" title="Files 类"></a>Files 类</h4><ul><li>java.nio.file.Files 用于操作文件或目录的工具类。</li><li>Files常用方法：<ul><li>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</li><li>Path createDirectory(Path path, FileAttribute … attr) : 创建一个目录</li><li>Path createFile(Path path, FileAttribute … arr) : 创建一个文件</li><li>void delete(Path path) : 删除一个文件</li><li>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</li><li>long size(Path path) : 返回 path 指定文件的大小</li></ul></li><li>Files常用方法：用于判断<ul><li>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</li><li>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</li><li>boolean isExecutable(Path path) : 判断是否是可执行文件</li><li>boolean isHidden(Path path) : 判断是否是隐藏文件</li><li>boolean isReadable(Path path) : 判断文件是否可读</li><li>boolean isWritable(Path path) : 判断文件是否可写</li><li>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</li><li><code>public static &lt;A extends BasicFileAttributes&gt; A readAttributes(Path path,Class&lt;A&gt; type,LinkOption...options)</code> : 获取与 path 指定的文件相关联的属性。</li></ul></li></ul><ul><li>Files常用方法：用于操作内容<ul><li>SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式</li><li>DirectoryStream newDirectoryStream(Path path) : 打开 path 指定的目录</li><li>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</li><li>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象]()</li></ul></li></ul><h4 id="自动资源管理"><a href="#自动资源管理" class="headerlink" title="自动资源管理"></a>自动资源管理</h4><p>Java 7 增加了一个新特性，该特性提供了另外一种管理资源的方式，这种方式能自动关闭文件。这个特性有时被称为自动资源管理(Automatic Resource Management, ARM)， 该特性以 try 语句的扩展版为基础。自动资源管理主要用于，当不再需要文件（或其他资源）时，可以防止无意中忘记释放它们。</p><p>自动资源管理基于 try 语句的扩展形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(需要关闭的资源声明)&#123;</span><br><span class="line"><span class="comment">//可能发生异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 变量名)&#123;</span><br><span class="line"><span class="comment">//异常的处理语句</span></span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//一定执行的语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当 try 代码块结束时，自动释放资源。因此不需要显示的调用 close() 方法。该形式也称为“带资源的 try 语句”。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">1. try 语句中声明的资源被隐式声明为 final ，资源的作用局限于带资源的 try 语句</span></span><br><span class="line"><span class="comment">2. 可以在一条 try 语句中管理多个资源，每个资源以“;” 隔开即可。</span></span><br><span class="line"><span class="comment">3. 需要关闭的资源，必须实现了 AutoCloseable 接口或其自接口 Closeable</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE-java8新特性,JUC,NIO
    
    </summary>
    
      <category term="JavaSE" scheme="https://www.ysmjjsy.com/categories/JavaSE/"/>
    
      <category term="JavaSE-java8新特性" scheme="https://www.ysmjjsy.com/categories/JavaSE/JavaSE-java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>路径问题</title>
    <link href="https://www.ysmjjsy.com/category/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.ysmjjsy.com/category/路径问题/</id>
    <published>2018-08-28T16:00:00.000Z</published>
    <updated>2019-09-17T09:16:19.183Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:16:56 GMT+0800 (GMT+08:00) --><h1 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h1><p>绝对路径：不可改变的路径<br>本地绝对路径：增加盘符的路径（e:/test/test.html）<br>网络绝对路径：增加协议，IP地址，端口号的路径（<a href="http://localhost:8080/test/test.html）" target="_blank" rel="noopener">http://localhost:8080/test/test.html）</a><br>相对路径：可以改变的路径，但是以基准路径为参考，查找其他路径<br>默认情况下，相对路径的基准路径是以当前资源的访问路径为基准<br>路径以斜杠开头，表示的特殊的相对路径，在不同的场景中，相对的位置会发生变化。<br>url : <a href="http://localhost:8080/atcrowdfunding-web/test/test.html" target="_blank" rel="noopener">http://localhost:8080/atcrowdfunding-web/test/test.html</a><br>前台路径：&lt;a href=rdquo;/sssssrdquo;&gt;&lt;img src=rdquo;rdquo;&gt;<br>相对服务器的根 ： <a href="http://localhost:8080/sssss" target="_blank" rel="noopener">http://localhost:8080/sssss</a><br>后台路径：forward（rdquo;/user.jsprdquo;）, xml<br>相对web应用的根：<a href="http://localhost:8080/atcrowdfunding-web/user.jsp" target="_blank" rel="noopener">http://localhost:8080/atcrowdfunding-web/user.jsp</a><br>监听器解决路径问题：</p><p><img src="/category/路径问题/1.png" alt="路径"></p><p><img src="/category/路径问题/2.png" alt="路径"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      绝对路径与相对路径
    
    </summary>
    
      <category term="Java相关" scheme="https://www.ysmjjsy.com/categories/Java%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Java相关" scheme="https://www.ysmjjsy.com/tags/Java%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>从零开始Intellij的使用</title>
    <link href="https://www.ysmjjsy.com/category/Intelij/"/>
    <id>https://www.ysmjjsy.com/category/Intelij/</id>
    <published>2018-08-28T16:00:00.000Z</published>
    <updated>2019-09-18T01:45:30.266Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 18 2019 09:46:37 GMT+0800 (GMT+08:00) --><h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><h2 id="IDEA的主要优势-相较于Eclipse而言"><a href="#IDEA的主要优势-相较于Eclipse而言" class="headerlink" title="IDEA的主要优势(相较于Eclipse而言)"></a>IDEA的主要优势(相较于Eclipse而言)</h2><ol><li>强大的整合能力，比如Git、Maven、Spring等</li><li>提示功能的快速、便捷</li><li>提示功能的范围广</li><li>好用的快捷键和代码模板</li><li>精准搜索</li><li>…</li></ol><h2 id="IDEA的目录结构"><a href="#IDEA的目录结构" class="headerlink" title="IDEA的目录结构"></a>IDEA的目录结构</h2><ul><li>bin：容器，执行文件和启动参数</li><li>help：快捷键文档和其他帮助文档</li><li>jre64：64位java运行环境</li><li>lib：idea依赖的类库</li><li>license：各个插件许可</li><li>plugin：插件</li></ul><p><strong>设置目录结构：</strong></p><p><img src="/category/Intelij/1.png" alt="idea"></p><ul><li>config目录是Intellij个性化设置目录</li><li>system目录是Intellij系统文件目录</li></ul><h2 id="IDEA的使用"><a href="#IDEA的使用" class="headerlink" title="IDEA的使用"></a>IDEA的使用</h2><h3 id="如何调整VM配置文件"><a href="#如何调整VM配置文件" class="headerlink" title="如何调整VM配置文件"></a>如何调整VM配置文件</h3><p><img src="/category/Intelij/2.png" alt="idea"></p><h3 id="创建Java工程"><a href="#创建Java工程" class="headerlink" title="创建Java工程"></a>创建Java工程</h3><p><img src="/category/Intelij/3.png" alt="idea"></p><ul><li>Create New Project：创建一个新的工程</li><li>Import Project：导入一个现有工程</li><li>Open：打开一个已有工程</li><li>Check out form Version Control： 可以通过服务器上的项目地址 check out Github 上面项目或其他 Git 托管服务器上的项目</li></ul><h3 id="设置显示常见的视图"><a href="#设置显示常见的视图" class="headerlink" title="设置显示常见的视图"></a>设置显示常见的视图</h3><p><img src="/category/Intelij/4.png" alt="idea"></p><h3 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module:模块"></a>Module:模块</h3><p>在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module。一个 Project IntelliJ IDEA 的安装、配置与使用 可以有多个 Module。目前主流的大型项目都是分布式部署的，结构都是类似这 种多 Module 结构。</p><p><img src="/category/Intelij/5.png" alt="idea"></p><p>这类项目一般是这样划分的，比如：core Module、web Module、plugin Module、 solr Module 等等，模块之间彼此可以相互依赖。通过这些 Module 的命名也可 以看出，他们之间都是处于同一个项目业务下的模块，彼此之间是有不可分割的 业务关系的。</p><p>相比较于多 Module 项目，小项目就无需搞得这么复杂。只有一个 Module 的 结构 IntelliJ IDEA 也是支持的，并且 IntelliJ IDEA 创建项目的时候，默认就是单 IntelliJ IDEA 的安装、配置与使用 Module 的结构的。</p><h4 id="如何删除模块"><a href="#如何删除模块" class="headerlink" title="如何删除模块"></a>如何删除模块</h4><p><img src="/category/Intelij/6.png" alt="idea"></p><p><img src="/category/Intelij/61.png" alt="idea"></p><p><img src="/category/Intelij/62.png" alt="idea"></p><p><img src="/category/Intelij/63.png" alt="idea"></p><h3 id="查看项目配置："><a href="#查看项目配置：" class="headerlink" title="查看项目配置："></a>查看项目配置：</h3><p><img src="/category/Intelij/7.png" alt="idea"></p><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p><img src="/category/Intelij/8.png" alt="idea"></p><h4 id="Appearance-amp-Behavior"><a href="#Appearance-amp-Behavior" class="headerlink" title="Appearance &amp; Behavior"></a>Appearance &amp; Behavior</h4><h5 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h5><p><img src="/category/Intelij/a1.png" alt="idea"></p><h5 id="设置窗体及菜单的字体及字体大小-可忽略"><a href="#设置窗体及菜单的字体及字体大小-可忽略" class="headerlink" title="设置窗体及菜单的字体及字体大小(可忽略)"></a>设置窗体及菜单的字体及字体大小(可忽略)</h5><p><img src="/category/Intelij/a2.png" alt="idea"></p><h5 id="设置编辑区主题-可忽略"><a href="#设置编辑区主题-可忽略" class="headerlink" title="设置编辑区主题(可忽略)"></a>设置编辑区主题(可忽略)</h5><p>Idea默认提供了两个编辑区主题，可以通过如下的方式进行选择</p><p><img src="/category/Intelij/a3.png" alt="idea"></p><ul><li><p>如果想要更多的主题效果，可以到如下网站下载：</p><p><a href="http://www.riaway.com" target="_blank" rel="noopener">主题</a></p></li><li><p>下载以后，导入主题</p><p>file - &gt; import settings - &gt; 选中下载的主题jar文件 -&gt; 一路确认 - &gt; 重启</p></li></ul><h4 id="Editor-General"><a href="#Editor-General" class="headerlink" title="Editor - General"></a>Editor - General</h4><h5 id="设置鼠标滚轮修改字体大小-可忽略"><a href="#设置鼠标滚轮修改字体大小-可忽略" class="headerlink" title="设置鼠标滚轮修改字体大小(可忽略)"></a>设置鼠标滚轮修改字体大小(可忽略)</h5><p><img src="/category/Intelij/b1.png" alt="idea"></p><p>可以增加 <strong>Ctrl + 鼠标滚轮</strong> 快捷键来控制代码字体大小写显示</p><h5 id="设置鼠标悬浮提示"><a href="#设置鼠标悬浮提示" class="headerlink" title="设置鼠标悬浮提示"></a>设置鼠标悬浮提示</h5><p><img src="/category/Intelij/b2.png" alt="idea"></p><h5 id="设置自动导包功能"><a href="#设置自动导包功能" class="headerlink" title="设置自动导包功能"></a>设置自动导包功能</h5><p><img src="/category/Intelij/b3.png" alt="idea"></p><ul><li>Add unambiguous imports on the fly：自动导入不明确的结构</li><li>Optimize imports on the fly：自动帮我们优化导入的包</li></ul><h5 id="设置显示行号和方法间的分隔符"><a href="#设置显示行号和方法间的分隔符" class="headerlink" title="设置显示行号和方法间的分隔符"></a>设置显示行号和方法间的分隔符</h5><p><img src="/category/Intelij/b.png" alt="idea"></p><p>如上图红圈所示，可以勾选Show line numers：显示行数，建议一般勾选上</p><p>Show method separators：显示方法分隔线，有助于区分开方法，建议勾选</p><h5 id="忽略大小写提示"><a href="#忽略大小写提示" class="headerlink" title="忽略大小写提示"></a>忽略大小写提示</h5><p><img src="/category/Intelij/b4.png" alt="idea"></p><p>IDEA的代码提示和补充功能有一个特性，区分大小写，如上图标注所示，默认就是First letter区分大小写的。</p><p><strong>新版：2019-1-3这样修改</strong></p><p><img src="/category/Intelij/b5.png" alt="idea"></p><h5 id="设置取消单行显示tabs的操作"><a href="#设置取消单行显示tabs的操作" class="headerlink" title="设置取消单行显示tabs的操作"></a>设置取消单行显示tabs的操作</h5><p><img src="/category/Intelij/b6.png" alt="idea"></p><h4 id="Editor-Font"><a href="#Editor-Font" class="headerlink" title="Editor - Font"></a>Editor - Font</h4><h5 id="设置默认的字体、字体大小、字体行间距"><a href="#设置默认的字体、字体大小、字体行间距" class="headerlink" title="设置默认的字体、字体大小、字体行间距"></a>设置默认的字体、字体大小、字体行间距</h5><p><img src="/category/Intelij/b7.png" alt="idea"></p><h4 id="Editor-Color-Scheme"><a href="#Editor-Color-Scheme" class="headerlink" title="Editor - Color Scheme"></a>Editor - Color Scheme</h4><h5 id="修改当前字体、字体大小、字体行间距-可忽略"><a href="#修改当前字体、字体大小、字体行间距-可忽略" class="headerlink" title="修改当前字体、字体大小、字体行间距(可忽略)"></a>修改当前字体、字体大小、字体行间距(可忽略)</h5><p>如果当前主题不希望使用默认字体、字体大小、字体行间距、还可以单独设置</p><p><img src="/category/Intelij/b8.png" alt="idea"></p><h5 id="修改当前主题的控制台输出的字体及字体大小-可忽略"><a href="#修改当前主题的控制台输出的字体及字体大小-可忽略" class="headerlink" title="修改当前主题的控制台输出的字体及字体大小(可忽略)"></a>修改当前主题的控制台输出的字体及字体大小(可忽略)</h5><p><img src="/category/Intelij/b9.png" alt="idea"></p><h5 id="修改代码中注释的字体颜色"><a href="#修改代码中注释的字体颜色" class="headerlink" title="修改代码中注释的字体颜色"></a>修改代码中注释的字体颜色</h5><p><img src="/category/Intelij/b11.png" alt="idea"></p><p>Doc Comment-Text：修改文档注释的字体颜色</p><p>Block Comment：修改多行注释的字体颜色</p><p>Line Comment：修改单行注释的字体颜色</p><h4 id="Editor-Code-Style"><a href="#Editor-Code-Style" class="headerlink" title="Editor - Code Style"></a>Editor - Code Style</h4><h5 id="设置超过指定import个数，改为-，-可忽略"><a href="#设置超过指定import个数，改为-，-可忽略" class="headerlink" title="设置超过指定import个数，改为*，(可忽略)"></a>设置超过指定import个数，改为*，(可忽略)</h5><p><img src="/category/Intelij/b12.png" alt="idea"></p><h4 id="Editor-File-and-Code-Templates"><a href="#Editor-File-and-Code-Templates" class="headerlink" title="Editor - File and Code Templates"></a>Editor - File and Code Templates</h4><h5 id="修改类头的文档注释信息"><a href="#修改类头的文档注释信息" class="headerlink" title="修改类头的文档注释信息"></a>修改类头的文档注释信息</h5><p><img src="/category/Intelij/b13.png" alt="idea"></p><p><code>/** @author shkstart @create ${YEAR}-${MONTH}-${DAY} ${TIME} *///</code></p><p><strong>常用的预设的变量，这里直接贴出官网给的：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$&#123;PACKAGE_NAME&#125; - the name of the target <span class="keyword">package</span> where the <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="title">or</span> <span class="title">interface</span> <span class="title">will</span> <span class="title">be</span> <span class="title">created</span>. </span></span><br><span class="line"><span class="class">$</span>&#123;PROJECT_NAME&#125; - the name of the current project. </span><br><span class="line">$&#123;FILE_NAME&#125; - the name of the PHP file that will be created.</span><br><span class="line">$&#123;NAME&#125; - the name of the <span class="keyword">new</span> file which you specify in the New File dialog box during the file creation. </span><br><span class="line">$&#123;USER&#125; - the login name of the current user. </span><br><span class="line">$&#123;DATE&#125; - the current system date. </span><br><span class="line">$&#123;TIME&#125; - the current system time. </span><br><span class="line">$&#123;YEAR&#125; - the current year. </span><br><span class="line">$&#123;MONTH&#125; - the current month. </span><br><span class="line">$&#123;DAY&#125; - the current day of the month. </span><br><span class="line">$&#123;HOUR&#125; - the current hour. </span><br><span class="line">$&#123;MINUTE&#125; - the current minute. </span><br><span class="line">$&#123;PRODUCT_NAME&#125; - the name of the IDE in which the file will be created. </span><br><span class="line">$&#123;MONTH_NAME_SHORT&#125; - the first <span class="number">3</span> letters of the month name. Example: Jan, Feb, etc. </span><br><span class="line">$&#123;MONTH_NAME_FULL&#125; - full name of a month. Example: January, February, etc</span><br></pre></td></tr></table></figure><h4 id="Editor-File-Encodings"><a href="#Editor-File-Encodings" class="headerlink" title="Editor - File Encodings"></a>Editor - File Encodings</h4><h5 id="设置项目文件编码"><a href="#设置项目文件编码" class="headerlink" title="设置项目文件编码"></a>设置项目文件编码</h5><p><img src="/category/Intelij/c1.png" alt="idea"></p><p>说明：Transparent native-to-ascii conversion主要用于转换ascii，一般都要勾选，不然Properties文件中的注释信息显示的都不是中文</p><h4 id="Build-Execution-Deployment"><a href="#Build-Execution-Deployment" class="headerlink" title="Build,Execution,Deployment"></a>Build,Execution,Deployment</h4><h5 id="设置自动编译"><a href="#设置自动编译" class="headerlink" title="设置自动编译"></a>设置自动编译</h5><p><img src="/category/Intelij/c2.png" alt="idea"></p><h5 id="设置省电模式-可忽略"><a href="#设置省电模式-可忽略" class="headerlink" title="设置省电模式(可忽略)"></a>设置省电模式(可忽略)</h5><p><img src="/category/Intelij/c3.png" alt="idea"></p><h5 id="设置代码水平或垂直显示"><a href="#设置代码水平或垂直显示" class="headerlink" title="设置代码水平或垂直显示"></a>设置代码水平或垂直显示</h5><p><img src="/category/Intelij/c4.png" alt="idea"></p><h4 id="设置快捷键-Keymap"><a href="#设置快捷键-Keymap" class="headerlink" title="设置快捷键(Keymap)"></a>设置快捷键(Keymap)</h4><h5 id="设置快捷键为Eclipse快捷键"><a href="#设置快捷键为Eclipse快捷键" class="headerlink" title="设置快捷键为Eclipse快捷键"></a>设置快捷键为Eclipse快捷键</h5><p><img src="/category/Intelij/c5.png" alt="idea"></p><h5 id="通过快捷键功能修改快捷键设置"><a href="#通过快捷键功能修改快捷键设置" class="headerlink" title="通过快捷键功能修改快捷键设置"></a>通过快捷键功能修改快捷键设置</h5><p><img src="/category/Intelij/c6.png" alt="idea"></p><h5 id="通过指定快捷键，查找或修改其他功能"><a href="#通过指定快捷键，查找或修改其他功能" class="headerlink" title="通过指定快捷键，查找或修改其他功能"></a>通过指定快捷键，查找或修改其他功能</h5><p><img src="/category/Intelij/c7.png" alt="idea"></p><h5 id="导入已有的设置"><a href="#导入已有的设置" class="headerlink" title="导入已有的设置"></a>导入已有的设置</h5><p><img src="/category/Intelij/c8.png" alt="idea"></p><h3 id="关于模板-Templates"><a href="#关于模板-Templates" class="headerlink" title="关于模板(Templates)"></a>关于模板(Templates)</h3><p>(Editor - Live Templates 和 Editor - General - Postfix Completion)</p><h4 id="Live-Templates-实时代码模板-功能介绍"><a href="#Live-Templates-实时代码模板-功能介绍" class="headerlink" title="Live Templates(实时代码模板)功能介绍"></a>Live Templates(实时代码模板)功能介绍</h4><p>它的原理就是配置一些常用代码字母缩写，在输入简写时可以出现你预定义的固定模式的代码，使得开发效率大大提高，同时也可以增加个性化。最简单的例子 就是在 Java 中输入 sout 会出现 System.out.println();</p><h4 id="已有的常用模板"><a href="#已有的常用模板" class="headerlink" title="已有的常用模板"></a>已有的常用模板</h4><h5 id="Postfix-Completion默认如下"><a href="#Postfix-Completion默认如下" class="headerlink" title="Postfix Completion默认如下"></a>Postfix Completion默认如下</h5><p><img src="/category/Intelij/d1.png" alt="idea"></p><h5 id="Live-Templates默认如下"><a href="#Live-Templates默认如下" class="headerlink" title="Live Templates默认如下"></a>Live Templates默认如下</h5><p><img src="/category/Intelij/d2.png" alt="idea"></p><p>二者的区别：Live Templates可以自定义，而Postfix Completion不可以，同时，有些操作二者都提供了模板，Postfix Templates较Live Templates能快0.01s</p><p><strong>举例：</strong></p><p><strong>psvm：可生成main方法</strong></p><p><strong>sout：System.out.println()快捷输出</strong></p><p>类似的：</p><p>soutp = System.out.println(“方法形参名 = “ + 形参名);</p><p>soutv = System.out.println(“变量名 = “ + 变量);</p><p>soutm = System.out.println(“当前类名.当前方法”);</p><p>“abc”.sout =&gt; System.out.println(“abc”);</p><p><strong>fori：可生成for循环</strong></p><p>iter：可成增强for循环</p><p>itar：可生成普通for循环</p><p><strong>list.for：可生成集合list的for循环</strong></p><p><strong>ifn：可生成if(xxx = null)<em>**</em></strong></p><p><strong>prsf：可生成private static final</strong></p><p>类似的：</p><p>psf：可生成 public static final</p><p>psfi：可生成 pubic static final int</p><p>psfs：可生成 public static final String</p><h4 id="修改现有模板：Live-Templates"><a href="#修改现有模板：Live-Templates" class="headerlink" title="修改现有模板：Live Templates"></a>修改现有模板：Live Templates</h4><p>通过调用psvm调用不习惯，可以修改</p><h4 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h4><p><img src="/category/Intelij/d3.png" alt="idea"></p><p>先定义一个模板组：</p><p><img src="/category/Intelij/d4.png" alt="idea"></p><p><img src="/category/Intelij/d5.png" alt="idea"></p><p>选中自定义的模板组，点击”+”来定义模板</p><p><img src="/category/Intelij/d6.png" alt="idea"></p><ol><li>Abbreviation：模板的缩略名称</li><li>Description：模板的描述</li><li>Template text：模板的代码片段</li><li>应用范围，比如点击Define,选择如下</li></ol><p><img src="/category/Intelij/d7.png" alt="idea"></p><h3 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h3><p>在IDEA中配置Tomcat之前，需要保证已经安装并配置了Tomcat的环境变量</p><p><img src="/category/Intelij/d8.png" alt="idea"></p><p><img src="/category/Intelij/d9.png" alt="idea"></p><p><img src="/category/Intelij/e1.png" alt="idea"></p><p><img src="/category/Intelij/e2.png" alt="idea"></p><p><img src="/category/Intelij/e3.png" alt="idea"></p><p><img src="/category/Intelij/e4.png" alt="idea"></p><h3 id="关联数据库"><a href="#关联数据库" class="headerlink" title="关联数据库"></a>关联数据库</h3><h4 id="关联方式"><a href="#关联方式" class="headerlink" title="关联方式"></a>关联方式</h4><p><img src="/category/Intelij/e5.png" alt="idea"></p><p><img src="/category/Intelij/e6.png" alt="idea"></p><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><p><img src="/category/Intelij/e7.png" alt="idea"></p><h3 id="版本控制-Version-Control"><a href="#版本控制-Version-Control" class="headerlink" title="版本控制(Version Control)"></a>版本控制(Version Control)</h3><p>不管是个人开发还是团队开发，版本控制都会被使用，而IDEA也很好的集成了版本控制相关结果</p><p><img src="/category/Intelij/e8.png" alt="idea"></p><p>很多人认为Intellij自带了SVN或是Git等版本控制工具，认为只要安装了IntellijIDEa就可以完全使用版本控制应有的功能，这是一种完全错误的解读，Intellij IDEA是自带对这些版本控制工具的插件支持，但是该装什么版本控制客户端还是要照样装的</p><p><img src="/category/Intelij/f1.png" alt="idea"></p><p>Intellij IDEA对版本控制的支持是以插件化的方式来实现的，旗舰版默认支持目前主流的版本控制软件，CVS、Subversion(SVN)、Git、Mercurial、Perforce、TFS。又因为目前太多人使用Github进行协同或是项目版本管理，所以Intellij IDEA同时自带了Github插件，方便Checkout和管理你的Github项目</p><p>在实际开发中，发现IDEA中使用SVN经历不算愉快，经常会遇到很多问题，比如紧急下IDEA无法更新、提交等</p><h4 id="提前安装好Git客户端"><a href="#提前安装好Git客户端" class="headerlink" title="提前安装好Git客户端"></a>提前安装好Git客户端</h4><p><a href="https://git-scm.com/" target="_blank" rel="noopener">Git的msysGit官网下载</a></p><p><a href="http://download.tortoisegit.org/tgit/" target="_blank" rel="noopener">Git客户端TortoiseGit官网下载</a></p><h4 id="关联git-exe"><a href="#关联git-exe" class="headerlink" title="关联git.exe"></a>关联git.exe</h4><p><img src="/category/Intelij/f2.png" alt="idea"></p><h4 id="关联GitHub上的账户，并测试连接"><a href="#关联GitHub上的账户，并测试连接" class="headerlink" title="关联GitHub上的账户，并测试连接"></a>关联GitHub上的账户，并测试连接</h4><p><img src="/category/Intelij/f3.png" alt="idea"></p><h4 id="在Github上创建账户下的一个新的仓库作为测试"><a href="#在Github上创建账户下的一个新的仓库作为测试" class="headerlink" title="在Github上创建账户下的一个新的仓库作为测试"></a>在Github上创建账户下的一个新的仓库作为测试</h4><p><img src="/category/Intelij/f4.png" alt="idea"></p><h4 id="支持从当前登录的github账号上直接Checkout项目"><a href="#支持从当前登录的github账号上直接Checkout项目" class="headerlink" title="支持从当前登录的github账号上直接Checkout项目"></a>支持从当前登录的github账号上直接Checkout项目</h4><p><img src="/category/Intelij/f5.png" alt="idea"></p><h4 id="在IDEA中clone-Github上的仓库"><a href="#在IDEA中clone-Github上的仓库" class="headerlink" title="在IDEA中clone Github上的仓库"></a>在IDEA中clone Github上的仓库</h4><p><img src="/category/Intelij/f6.png" alt="idea"></p><p>这里需要在Github的自己账户下，复制项目仓库路径，填写上图git repository URL中</p><p><img src="/category/Intelij/f7.png" alt="idea"></p><h4 id="连接成功会下载github上的项目"><a href="#连接成功会下载github上的项目" class="headerlink" title="连接成功会下载github上的项目"></a>连接成功会下载github上的项目</h4><p><img src="/category/Intelij/f8.png" alt="idea"></p><p><img src="/category/Intelij/f9.png" alt="idea"></p><p>根据自己需要，选择本窗口还是开启一个新窗口</p><h4 id="除此之外，还可以通过如下方式连接GitHub"><a href="#除此之外，还可以通过如下方式连接GitHub" class="headerlink" title="除此之外，还可以通过如下方式连接GitHub"></a>除此之外，还可以通过如下方式连接GitHub</h4><p><img src="/category/Intelij/g1.png" alt="idea"></p><h4 id="本地代码分享到GitHub"><a href="#本地代码分享到GitHub" class="headerlink" title="本地代码分享到GitHub"></a>本地代码分享到GitHub</h4><p><img src="/category/Intelij/g2.png" alt="idea"></p><p><img src="/category/Intelij/g3.png" alt="idea"></p><p>此时会在github上创建一个新的仓库，而非更新已经存在的仓库</p><h4 id="Git的常用操作"><a href="#Git的常用操作" class="headerlink" title="Git的常用操作"></a>Git的常用操作</h4><p><img src="/category/Intelij/g4.png" alt="idea"></p><p>clone：拷贝远程仓库</p><p>commit：本地提交</p><p>push：远程提交</p><p>pull：更新到本地</p><h4 id="没有使用Git时本地历史记录的查看"><a href="#没有使用Git时本地历史记录的查看" class="headerlink" title="没有使用Git时本地历史记录的查看"></a>没有使用Git时本地历史记录的查看</h4><p><img src="/category/Intelij/g5.png" alt="idea"></p><p>即使我们项目没有使用版本控制功能，Intellij IDEA也给我们提供了本地文件历史记录</p><h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><h4 id="Debug的设置"><a href="#Debug的设置" class="headerlink" title="Debug的设置"></a>Debug的设置</h4><p><img src="/category/Intelij/g6.png" alt="idea"></p><p>设置Debug连接方式，默认时Socket，Shared memory是Windows特有的一个属性，一般在Windows系统下建议使用此设置，内存占用相对较少</p><h4 id="常用断点调试快捷键"><a href="#常用断点调试快捷键" class="headerlink" title="常用断点调试快捷键"></a>常用断点调试快捷键</h4><p><img src="/category/Intelij/g7.png" alt="idea"></p><h4 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h4><p><strong>说明：</strong></p><p>调试的时候，在循环里增加条件判断，可以极大的提高效率，心情也能愉悦</p><p><strong>具体操作：</strong></p><p>在断点处点击调出条件断点，可以在满足某个条件下，实施断点</p><p><strong>查看表达式的值(Ctrl+u)</strong></p><p>选择行 ctrl+u 还可以查看框中输入编写代码时的其他方法</p><p><img src="/category/Intelij/g8.png" alt="idea"></p><h3 id="配置Maven"><a href="#配置Maven" class="headerlink" title="配置Maven"></a>配置Maven</h3><h4 id="Mavan介绍"><a href="#Mavan介绍" class="headerlink" title="Mavan介绍"></a>Mavan介绍</h4><p>Maven -&gt; Ant -&gt; Maven -&gt; Gradle</p><p>Mave是Apache提供的一款自动化构建工具，用于自动化构建和依赖管理，开发团队基本不用花多少时间就能自动完成工程的基础构建配置，因为Maven使用了一个标准的目录结构和一个默认的构建生命周期。</p><p><strong>构建环节：</strong></p><p><img src="/category/Intelij/q1.png" alt="idea"></p><h4 id="Maven的配置"><a href="#Maven的配置" class="headerlink" title="Maven的配置"></a>Maven的配置</h4><p>maven下载-解压-配置(settings配置仓库reposiroty)</p><p><img src="/category/Intelij/q2.png" alt="idea"></p><ul><li>Maven home directory：可以指定本地Maven的安装目录所在，因为已经配置了M2_HOME系统参数，所以直接这样配置Intellij IDEA是可以找到的，但是加入没有配置，这里选择Maven安装目录，此外不建议使用IDEA默认的</li><li>User settings file/Local repository：我们还可以指定Maven的settings.xml位置和本地仓库位置</li></ul><p><img src="/category/Intelij/q3.png" alt="idea"></p><ul><li>Import Maven projects atuomaticallu：表示Intellij IDEA会实时监控项目的pom.xml文件，进行项目变动设置</li><li>Automatically download：在Maven导入依赖包时候，是否自动下载源码和文档，不建议勾选，因为会加快项目从外网导入依赖包的速度。Intellij支持直接从公网下载源码和文档，如果需要我们可以针对某个依赖包进行联网下载</li><li>VM options for importer：可以设置导入的VM参数，一般不需要主动该，除非项目真的导入太慢了我们再增大此参数</li></ul><h4 id="创建对应的Module"><a href="#创建对应的Module" class="headerlink" title="创建对应的Module"></a>创建对应的Module</h4><p><img src="/category/Intelij/q4.png" alt="idea"></p><p>Group：组织或公司域名，倒叙</p><p>Artiface：项目模块名称</p><p>Version：默认maven生成版本</p><p>其中常用的是clean、compile、package、install。</p><p>如果其他项目需要将这里的模块作为依赖使用，那就可以install安装到本地仓库的位置</p><p>maven下创建的web工程目录会和eclipse不一样，需要手动创建resource、java、test文件</p><h3 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h3><h4 id="生成javadoc"><a href="#生成javadoc" class="headerlink" title="生成javadoc"></a>生成javadoc</h4><p><img src="/category/Intelij/q5.png" alt="idea"></p><p>输入：</p><p>Locale：输入语言类型：zh_CN</p><p>Other command line arguments：-encoding UTF-8 -charset UTF-8</p><h4 id="缓存和索引的清理"><a href="#缓存和索引的清理" class="headerlink" title="缓存和索引的清理"></a>缓存和索引的清理</h4><p><img src="/category/Intelij/q6.png" alt="idea"></p><h4 id="取消更新"><a href="#取消更新" class="headerlink" title="取消更新"></a>取消更新</h4><p><img src="/category/Intelij/q7.png" alt="idea"></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><img src="/category/Intelij/w1.png" alt="idea"></p><p><img src="/category/Intelij/w2.png" alt="idea"></p><p><img src="/category/Intelij/w3.png" alt="idea"></p><p><img src="/category/Intelij/w4.png" alt="idea"></p><p><img src="/category/Intelij/w5.png" alt="idea"></p><p><img src="/category/Intelij/w6.png" alt="idea"></p><p><img src="/category/Intelij/w7.png" alt="idea"></p><p><img src="/category/Intelij/w8.png" alt="idea"></p><p><img src="/category/Intelij/w9.png" alt="idea"></p><p><img src="/category/Intelij/w11.png" alt="idea"></p><p><img src="/category/Intelij/w12.png" alt="idea"></p><p><a href="https://blog.csdn.net/qq_42914528/article/details/89710864" target="_blank" rel="noopener">IDEA</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Intellij入门,环境配置,tomcat、mysql配置
    
    </summary>
    
      <category term="工具使用" scheme="https://www.ysmjjsy.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
      <category term="Intellij" scheme="https://www.ysmjjsy.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Intellij/"/>
    
    
      <category term="Intellij" scheme="https://www.ysmjjsy.com/tags/Intellij/"/>
    
  </entry>
  
  <entry>
    <title>Maven的使用</title>
    <link href="https://www.ysmjjsy.com/category/maven/"/>
    <id>https://www.ysmjjsy.com/category/maven/</id>
    <published>2018-07-19T16:00:00.000Z</published>
    <updated>2019-09-17T06:19:47.697Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 14:20:56 GMT+0800 (GMT+08:00) --><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p><img src="/category/maven/1.png" alt="maven"></p><h2 id="目前的技术在开发中存在的问题"><a href="#目前的技术在开发中存在的问题" class="headerlink" title="目前的技术在开发中存在的问题"></a>目前的技术在开发中存在的问题</h2><ul><li><strong>一个项目就是一个工程</strong><ul><li>一个项目如果非常庞大，就不适合用package来划分模块，最好是每一个模块对应一个工程</li><li>借助于Maven就可以将一个项目拆分成多个工程</li></ul></li><li><strong>项目中需要的jar包必须手动”复制”、”粘贴”到WEB-INF/lib目录下</strong><ul><li>带来的问题：同样的jar包文件重复出现在不同的项目工程中，一方面浪费存储空间，另外让工程比较臃肿</li><li>借助Maven，可以将jar包仅仅保存在”仓库中”，有需要使用的工程”引用”这个文件接口，并不需要真的把jar包复制过来</li></ul></li><li><strong>jar包需要别人替我们准备好，或者到官网下载</strong><ul><li>不同技术的官网提供jar包下载的形式是五花八门的</li><li>有些技术的官网就是通过Maven或SVN等专门的工具来提供下载的</li><li>如果以不规范的方式下载的jar包，那么卡中的内容很可能也是不规范的</li><li>借助于Maven可以以一种规范的方式下载jar包，因为所有知名框架或第三方工具的jar包以及按照统一的规范放在了Maven的中央仓库的，以规范的方式下载的jar包，内容也是可靠的</li><li>“统一的规范”不仅是对IT开发领域非常重要，对于整个人类社会都是非常重要的</li></ul></li><li><strong>一个jar包依赖的其他jar包需要自己手动加入到项目中</strong><ul><li>FileUpload组件 -&gt; IO组件。commons-fileupload-1.3.jar依赖于commons-io-2.0.1.jar</li><li>如果所有的jar包之间的依赖关系都需要程序员自己非常清楚了解，那么就会增大学习成本</li><li>Maven会自动将依赖的jar包导入出来</li></ul></li></ul><h2 id="Maven是什么？"><a href="#Maven是什么？" class="headerlink" title="Maven是什么？"></a>Maven是什么？</h2><ul><li><strong>Maven是一款服务于java平台的自动化构建工具</strong><ul><li>Make-&gt;Ant-Maven-&gt;Gradle</li></ul></li><li><p><strong>构建</strong></p><ul><li><p>概念：以java源文件、框架配置文件、JSP、HTML、图片等资源为原材料去生产一个可以运行的项目的过程</p><ul><li>编译</li><li>部署</li><li>构建</li></ul></li><li><p>编译：java源文件-&gt;编译-&gt;Class字节码文件-&gt;交给JVM去执行</p></li><li><p>部署：一个BS项目最终运行的并不是动态Web工程本身，而是这个动态Web工程编译得结果</p><ul><li>动态Web工程—&gt;编译、部署—&gt;编译结果</li></ul></li><li><p>运行时环境</p><p><img src="/category/maven/2.png" alt="maven"></p></li><li><p>其实是一组jar包的引用，并没有把jar包本身复制到工程中，所以并不是目录</p><p><img src="/category/maven/3.png" alt="maven"></p></li><li><p>开发过程中，所有的路径或配置文件中的配置的类路径等都是以编译结果的目录结构为标准的</p></li></ul></li></ul><ul><li><strong>构建过程中的各个环节</strong><ul><li>清理：将以前编译得到的旧的class字节码文件删除，为下一次编译做准备</li><li>编译：将Java源程序编译成class字节码文件</li><li>测试：自动测试，自动调用junit程序</li><li>报告：测试程序执行的结果</li><li>打包：动态Web工程打war包，Java工程打jar包</li><li>安装：Maven特定的概念—将打包得到的文件复制到”仓库”中的指定位置</li><li>部署：将动态Web工程生成的war包复制到Servlet容器的指定目录下，使其可以运行</li></ul></li><li><strong>自动化构建</strong></li></ul><h2 id="安装Maven的核心程序"><a href="#安装Maven的核心程序" class="headerlink" title="安装Maven的核心程序"></a>安装Maven的核心程序</h2><ul><li>检查Java_Home环境变量</li><li>解压Maven核心程序的压缩包，放在一个非中文无空格路径下</li><li>配置Maven相关的环境变量<ul><li>MAVEN_HOME或M2_HOME</li><li>path:maven的bin目录</li></ul></li></ul><h2 id="Maven的核心概念"><a href="#Maven的核心概念" class="headerlink" title="Maven的核心概念"></a>Maven的核心概念</h2><ul><li><strong>约定的目录结构</strong></li><li><strong>POM</strong><ul><li>含义：Project Object Model项目对象模型</li><li>pom.xml对于Maven工程是核心配置文件，与构建过程相关的一切设置都在这个文件中进行配置</li></ul></li><li><p><strong>坐标</strong></p><ul><li><p>Maven中的坐标</p><ul><li><p>使用下面三个向量在仓库中定位一个Maven工程（gav）</p><ul><li>groupid：公司或组织域名倒叙+项目名</li><li>artifactid：模块名</li><li>version：版本</li></ul></li><li><p>Maven工程的坐标与仓库中路径的对应关系</p><p><img src="/category/maven/4.png" alt="maven"></p></li></ul></li></ul></li></ul><ul><li><strong>依赖</strong></li><li><p>仓库</p><ul><li><p>仓库的分类</p><ul><li>本地仓库：当前电脑上部署的仓库目录，为当前电脑上所有Maven工程服务</li><li><p>远程仓库：</p><ul><li><p>私服：架设在当前局域网环境下，为当前局域网范围内的所有Maven工程服务</p><p><img src="/category/maven/5.png" alt="maven"></p></li><li><p>中央仓库：架设在Internate上，为全世界所有Maven工程服务</p></li><li><p>中央仓库的镜像：架设在各大洲，为中央仓库分担流量，减轻中央仓库的压力，同时更快的响应用户请求</p></li></ul></li></ul></li></ul></li></ul><ul><li>生命周期/插件/目标</li><li>继承</li><li>聚合</li></ul><h2 id="第一个Maven工程"><a href="#第一个Maven工程" class="headerlink" title="第一个Maven工程"></a>第一个Maven工程</h2><ul><li><strong>创建约定的目录结构</strong><ul><li>根目录：工程名</li><li>src目录：源码</li><li>pom.xml文件：Maven工程的核心配置文件</li><li>main目录：存放主程序</li><li>test目录：存放测试程序</li><li>java目录：存放java源文件</li><li>resource目录：存放框架或其他工具的配置文件</li></ul></li><li><strong>为什么要遵守约定的目录结构？</strong><ul><li>Maven要负责我们这个项目的自动化构建，以编译为例，Maven要想自动进行编译，那么它必须知道java源文件保存在哪里</li><li>如果我们自定义的东西想要框架或工具知道，有两种办法：<ul><li>以配置的方式明确告诉框架</li><li>遵守框架已经存在的约定</li></ul></li><li>约定&gt;配置&gt;编码</li></ul></li><li><strong>常用Maven命令</strong><ul><li>注意：执行与构建过程相关的Maven命令，必须进入pom.xml所在目录<ul><li>与构建过程相关：编译、测试、打包、…</li></ul></li><li>常用命令：<ul><li>mvn clean：清理</li><li>mvn compile：编译主程序</li><li>mvn test-compile：编译测试程序</li><li>mvn test：执行测试</li><li>mvn package：打包</li><li>mvn install：安装</li><li>mvn site：生成站点</li></ul></li></ul></li><li>关于联网问题<ul><li>Maven的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须由特定的插件来完成。而插件本身并不包含在Maven的核心程序中</li><li>当我们执行的Maven命令需要用到某些插件式，Maven核心程序会首先到本地仓库中查找</li><li>本地仓库的默认位置：[系统中当前用户的家目录].m2\repository</li><li>Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网，到中央仓库下载</li><li>如果此时无法连接外网，则构建失败</li><li>修改默认本地仓库的位置，可以让Maven核心程序到我们事先准备好的目录下查找插件<ul><li>找到Maven解压目录\conf\settings.xml</li><li>在settings.xml文件中找到localRepository标签</li><li>将<localrepository>/path/to/local/repo</localrepository>从注释中取出</li><li>将标签体内容内容修改为已经准备好的Maven仓库目录</li></ul></li></ul></li></ul><ul><li><p>依赖</p><ul><li><p>Maven解析依赖信息时会到本地仓库中查找被依赖的 jar包</p><ul><li>对于我们自己开发的Maven工程。使用install命令安装后就可以进入仓库</li></ul></li><li><p>依赖的范围</p><p><img src="/category/maven/6.png" alt="maven"></p></li><li><p>compile范围依赖</p><p><img src="/category/maven/7.png" alt="maven"></p></li><li><p>对主程序是否有效：有效</p></li><li><p>对测试程序是否有效：有效</p></li><li><p>是否参与打包：参与</p></li><li><p>是否参与部署：参与</p></li></ul></li><li><p>test范围依赖</p><ul><li>对主程序是否有效：无效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：不参与</li><li>是否参与部署：不参与</li></ul></li><li><p>provided范围依赖</p><p><img src="/category/maven/8.png" alt="maven"></p><ul><li>对主程序是否有效：有效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：不参与</li><li>是否参与部署：不参与</li></ul></li></ul><ul><li>生命周期<ul><li>各个构建环节的执行顺序：不能打乱顺序，必须按照 既定的正确顺序来执行</li><li>Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的</li><li>Maven核心程序为了更好的实现自动化构建，按照这一特点执行生命周期中的各个阶段：不论现在要执行生命周期中的哪一个阶段，都是从这个生命周期最初的位置开始执行</li><li>插件和目标<ul><li>生命周期的各个阶段仅仅定义了要执行的任务是什么</li><li>各个阶段和插件的目标是对应的</li><li>相似的目标由特定的插件来完成的</li><li>可以将目标看作：调用插件功能的命令</li></ul></li></ul></li></ul><div class="table-container"><table><thead><tr><th>生命周期阶段</th><th>插件目标</th><th>插件</th></tr></thead><tbody><tr><td>compile</td><td>compile</td><td>maven-compiler-plugin</td></tr><tr><td>test-compile</td><td>testCompile</td><td>maven-compiler-plugin</td></tr></tbody></table></div><h2 id="Maven插件的使用"><a href="#Maven插件的使用" class="headerlink" title="Maven插件的使用"></a>Maven插件的使用</h2><ul><li><p>Eclipse中Maven插件的设置</p><ul><li>Maven插件：Eclipse内置<ul><li>installations：指定Maven核心程序的设置，不建议使用内置的</li><li>user settings：指定conf/settings.xml的位置，进而获取本地仓库的位置</li></ul></li><li>基本操作<ul><li>创建Maven版的Java工程</li><li>创建Maven版的Web工程</li><li>执行Maven命令</li></ul></li></ul></li><li><p>依赖</p><ul><li><p>依赖的传递性</p><p><img src="/category/maven/9.png" alt="maven"></p></li><li><p>好处：可以传递的依赖不必在每个模块中都重复声明，在”最下面”的工程中依赖一次即可</p></li><li><p>注意：非compile范围的依赖不能传递，所以在各个工程模块中如果需要就得重复声明依赖</p></li></ul></li><li><p>依赖的排除</p><ul><li><p>需要设置依赖排除的场合</p><p><img src="/category/maven/a1.png" alt="maven"></p></li><li><p>依赖排除的设置方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>依赖的原则</p><ul><li><p>作用：解决模块工程之间的jar包冲突问题</p></li><li><p>验证路径最短者原则</p><p><img src="/category/maven/a2.png" alt="maven"></p></li><li><p>路径相同时，先声明者优先（先声明指的是dependency标签的声明顺序）</p><p><img src="/category/maven/a3.png" alt="maven"></p></li></ul></li><li><p>统一管理依赖版本</p><ul><li><p>建议配置方式</p><ul><li><p>使用properties标签统一声明版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>                           <span class="tag">&lt;<span class="name">cj.spring.version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">cj.spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在需要统一版本的位置，使用${自定义标签名}引用声明的版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;cj.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>其实properties标签配合自定义标签声明数据的配置并不是只能用于声明依赖的版本号，凡是需要统一声明后再引用的场合都可以使用</p></li></ul></li></ul></li></ul></li><li><p>继承</p><p><img src="/category/maven/a4.png" alt="maven"></p><p><img src="/category/maven/a5.png" alt="maven"></p></li><li><p>聚合</p><p><img src="/category/maven/a6.png" alt="maven"></p></li></ul><p>推荐博文：</p><p><a href="https://www.cnblogs.com/best/p/9676515.html#_lab2_1_2" target="_blank" rel="noopener">一个小时学会Maven</a></p><p><a href="https://blog.csdn.net/qq_37859539/article/details/80182729" target="_blank" rel="noopener">Maven默认骨架</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      maven入门,详解
    
    </summary>
    
      <category term="Maven" scheme="https://www.ysmjjsy.com/categories/Maven/"/>
    
    
      <category term="Maven" scheme="https://www.ysmjjsy.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>国际化实现原理</title>
    <link href="https://www.ysmjjsy.com/category/%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://www.ysmjjsy.com/category/国际化实现原理/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2019-09-16T10:26:09.126Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 16 2019 18:26:38 GMT+0800 (GMT+08:00) --><h1 id="国际化程序实现原理"><a href="#国际化程序实现原理" class="headerlink" title="国际化程序实现原理"></a>国际化程序实现原理</h1><p>定义保存文字的文件信息<br>根据不同的区域语言的编码读取指定的资源信息</p><p>把与语言相关的所有字符串都写成变量<br>写两个配置文件，一个文件中存放中文信息、另一个存放英文信息</p><p><img src="/category/国际化实现原理/1.png" alt="guojihua"></p><h2 id="Locale类"><a href="#Locale类" class="headerlink" title="Locale类"></a>Locale类</h2><p>描述区域和语言编码的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Locale</span><span class="params">(String language)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Locale</span><span class="params">(String language,String country)</span></span>;</span><br><span class="line"></span><br><span class="line">Locale loc = <span class="keyword">new</span> Locale(<span class="string">"zh"</span>,<span class="string">"CN"</span>);  <span class="comment">//中文环境</span></span><br><span class="line"></span><br><span class="line">Locale.getDefault(): <span class="comment">//默认环境</span></span><br></pre></td></tr></table></figure><h2 id="读取资源文件：ResourceBundle"><a href="#读取资源文件：ResourceBundle" class="headerlink" title="读取资源文件：ResourceBundle"></a>读取资源文件：ResourceBundle</h2><p>获取ResourceBundle类对象的方法:</p><p><code>public static final ResourceBundle getBundle(String baseName);</code><br>baseName -&gt; 描述资源文件的名称，但是没有后缀<br><code>String getString()</code>:获取资源信息</p><blockquote><p>使用一个类，来通过语言环境，最终识别加载哪一个文件的信息：ResourceBundle</p><p>语言环境：Locale</p><p>new Locale(“zh”,”CN”);</p><p>Locale.getDefault();</p><p>Locale.CHINA</p></blockquote><h2 id="消息格式化"><a href="#消息格式化" class="headerlink" title="消息格式化"></a>消息格式化</h2><p><strong>MessageFormat类</strong></p><p>占位符 {0},<br><code>format()</code>:处理占位符信息</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取Locale，这是由客户端的浏览器提供的Locale</span><br><span class="line">创建ResourceBundle</span><br><span class="line">把所有语言信息使用rb.getString(<span class="string">"xxx"</span>)来替换</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      关于国际化实现原理
    
    </summary>
    
      <category term="Java相关" scheme="https://www.ysmjjsy.com/categories/Java%E7%9B%B8%E5%85%B3/"/>
    
      <category term="国际化实现原理" scheme="https://www.ysmjjsy.com/categories/Java%E7%9B%B8%E5%85%B3/%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Java相关" scheme="https://www.ysmjjsy.com/tags/Java%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-分享</title>
    <link href="https://www.ysmjjsy.com/category/JavaWeb%E5%AD%A6%E4%B9%A0%E5%88%86%E4%BA%AB/"/>
    <id>https://www.ysmjjsy.com/category/JavaWeb学习分享/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2019-09-17T09:06:46.089Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:12:06 GMT+0800 (GMT+08:00) --><h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://www.cnblogs.com/xdp-gacl/tag/JavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">JavaWeb学习总结</a></p><h2 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h2><p>崔希凡JavaWeb</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      推荐一些学习资料
    
    </summary>
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/categories/JavaWeb/"/>
    
      <category term="分享" scheme="https://www.ysmjjsy.com/categories/JavaWeb/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-注解</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E6%B3%A8%E8%A7%A3/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-注解/</id>
    <published>2018-03-21T16:00:00.000Z</published>
    <updated>2019-09-16T09:11:47.034Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 16 2019 17:55:59 GMT+0800 (GMT+08:00) --><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>语法：@注解名称<br>注解的作用：替代xml配置文件<br>servlet3.0就可以不使用web.xml,而是所有配置都使用注解<br>注解是由框架来读取使用的</p><blockquote><p>以前，『XML』是各大框架的青睐者，它以松耦合的方式完成了框架中几乎所有的配置，但是随着项目越来越庞大，『XML』的内容也越来越复杂，维护成本变高。</p><p>于是就有人提出来一种标记式高耦合的配置方式，『注解』。方法上可以进行注解，类上也可以注解，字段属性上也可以注解，反正几乎需要配置的地方都可以进行注解。</p><p>关于『注解』和『XML』两种不同的配置模式，争论了好多年了，各有各的优劣，注解可以提供更大的便捷性，易于维护修改，但耦合度高，而 XML 相对于注解则是相反的。</p><p>追求低耦合就要抛弃高效率，追求效率必然会遇到耦合。</p></blockquote><p>实际上Java注解与普通修饰符(public、static、void等)的使用方式并没有多大区别，下面的例子是常见的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//@Test注解修饰方法A</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个方法上可以拥有多个不同的注解</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"uncheck"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在方法上使用@Test注解后，在运行该方法时，测试框架会自动识别该方法并单独调用，@Test实际上是一种标记注解，起标记作用，运行时告诉测试框架该方法为测试方法。而对于@Deprecated和@SuppressWarnings(“uncheck”)，则是Java本身内置的注解，在代码中，可以经常看见它们，但这并不是一件好事，毕竟当方法或是类上面有@Deprecated注解时，说明该方法或是类都已经过期不建议再用，@SuppressWarnings 则表示忽略指定警告，比如@SuppressWarnings(“uncheck”)，这就是注解的最简单的使用方式</p><h2 id="注解的本质"><a href="#注解的本质" class="headerlink" title="注解的本质"></a>注解的本质</h2><p>「java.lang.annotation.Annotation」接口中有这么一句话，用来描述『注解』。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The common <span class="class"><span class="keyword">interface</span> <span class="title">extended</span> <span class="title">by</span> <span class="title">all</span> <span class="title">annotation</span> <span class="title">types</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//所有的注解类型都继承自这个普通的接口（<span class="title">Annotation</span>）</span></span><br></pre></td></tr></table></figure><p>这句话有点抽象，但却说出了注解的本质。我们看一个 JDK 内置注解的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是注解 @Override 的定义，其实它本质上就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Override</span> <span class="keyword">extends</span> <span class="title">Annotation</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，注解的本质就是一个继承了 Annotation 接口的接口。有关这一点，你可以去反编译任意一个注解类，你会得到结果的。</p><p><strong>一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有解析它的代码，它可能连注释都不如。</strong></p><p>而解析一个类或者方法的注解往往有两种形式，一种是编译期直接的扫描，一种是运行期反射。反射的事情我们待会说，而编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。</p><p>典型的就是注解 @Override，一旦编译器检测到某个方法被修饰了 @Override 注解，编译器就会检查当前方法的方法签名是否真正重写了父类的某个方法，也就是比较父类中是否具有一个同样的方法签名。</p><p>这一种情况只适用于那些编译器已经熟知的注解类，比如 JDK 内置的几个注解，而你自定义的注解，编译器是不知道你这个注解的作用的，当然也不知道该如何处理，往往只是会根据该注解的作用范围来选择是否编译进字节码文件，仅此而已。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>『元注解』是用于修饰注解的注解，通常用在注解的定义上，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们 @Override 注解的定义，你可以看到其中的 @Target，@Retention 两个注解就是我们所谓的『元注解』，『元注解』一般用于指定某个注解生命周期以及作用目标等信息。</p><p>JAVA 中有以下几个『元注解』：</p><ul><li>@Target：注解的作用目标</li><li>@Retention：注解的生命周期</li><li>@Documented：注解是否应当被包含在 JavaDoc 文档中</li><li>@Inherited：是否允许子类继承该注解</li></ul><p>其中，@Target 用于指明被修饰的注解最终可以作用的目标是谁，也就是指明，你的注解到底是用来修饰方法的？修饰类的？还是用来修饰字段属性的。</p><p>@Target 的定义如下：</p><p><img src="/category/JavaSE-注解/1.png" alt="注解"></p><p>我们可以通过以下的方式来为这个 value 传值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.FIELD&#125;)</span><br></pre></td></tr></table></figure><p>被这个 @Target 注解修饰的注解将只能作用在成员字段上，不能用于修饰方法或者类。其中，ElementType 是一个枚举类型，有以下一些值：</p><ul><li>ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上</li><li>ElementType.FIELD：允许作用在属性字段上</li><li>ElementType.METHOD：允许作用在方法上</li><li>ElementType.PARAMETER：允许作用在方法参数上</li><li>ElementType.CONSTRUCTOR：允许作用在构造器上</li><li>ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上</li><li>ElementType.ANNOTATION_TYPE：允许作用在注解上</li><li>ElementType.PACKAGE：允许作用在包上</li></ul><p>@Retention 用于指明当前注解的生命周期，它的基本定义如下：</p><p><img src="/category/JavaSE-注解/2.png" alt="注解"></p><p>同样的，它也有一个 value 属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME</span><br></pre></td></tr></table></figure><p>这里的 RetentionPolicy 依然是一个枚举类型，它有以下几个枚举值可取：</p><ul><li>RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件</li><li>RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件</li><li>RetentionPolicy.RUNTIME：永久保存，可以反射获取</li></ul><p>@Retention 注解指定了被修饰的注解的生命周期，一种是只能在编译期可见，编译后会被丢弃，一种会被编译器编译进 class 文件中，无论是类或是方法，乃至字段，他们都是有属性表的，而 JAVA 虚拟机也定义了几种注解属性表用于存储注解信息，但是这种可见性不能带到方法区，类加载时会予以丢弃，最后一种则是永久存在的可见性。</p><p>剩下两种类型的注解我们日常用的不多，也比较简单，这里不再详细的进行介绍了，你只需要知道他们各自的作用即可。@Documented 注解修饰的注解，当我们执行 JavaDoc 文档打包时会被保存进 doc 文档，反之将在打包时丢弃。@Inherited 注解修饰的注解是具有可继承性的，也就说我们的注解修饰了一个类，而该类的子类将自动继承父类的该注解。</p><h3 id="Java的内置三大注解"><a href="#Java的内置三大注解" class="headerlink" title="Java的内置三大注解"></a>Java的内置三大注解</h3><p>除了上述四种元注解外，JDK 还为我们预定义了另外三种注解，它们是：</p><ul><li>@Override</li><li>@Deprecated</li><li>@SuppressWarnings</li></ul><p>@Override 注解想必是大家很熟悉的了，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它没有任何的属性，所以并不能存储任何其他信息。它只能作用于方法之上，编译结束后将被丢弃。</p><p>所以你看，它就是一种典型的『标记式注解』，仅被编译器可知，编译器在对 java 文件进行编译成字节码的过程中，一旦检测到某个方法上被修饰了该注解，就会去匹对父类中是否具有一个同样方法签名的函数，如果不是，自然不能通过编译。</p><p>@Deprecated 的基本定义如下：</p><p><img src="/category/JavaSE-注解/3.png" alt="注解"></p><p>依然是一种『标记式注解』，永久存在，可以修饰所有的类型，作用是，标记当前的类或者方法或者字段等已经不再被推荐使用了，可能下一次的 JDK 版本就会删除。</p><p>当然，编译器并不会强制要求你做什么，只是告诉你 JDK 已经不再推荐使用当前的方法或者类了，建议你使用某个替代者。</p><p>@SuppressWarnings 主要用来压制 java 的警告，它的基本定义如下：</p><p><img src="/category/JavaSE-注解/4.png" alt="注解"></p><p>它有一个 value 属性需要你主动的传值，这个 value 代表一个什么意思呢，这个 value 代表的就是需要被压制的警告类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一段代码，程序启动时编译器会报一个警告。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning:(<span class="number">8</span>, <span class="number">21</span>) java: java.util.Date 中的 Date(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>) <span class="comment">//已过时</span></span><br></pre></td></tr></table></figure><p>而如果我们不希望程序启动时，编译器检查代码中过时的方法，就可以使用 @SuppressWarnings 注解并给它的 value 属性传入一个参数值来压制编译器的检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarning</span>(value = <span class="string">"deprecated"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样你就会发现，编译器不再检查 main 方法下是否有过时的方法调用，也就压制了编译器对于这种警告的检查。</p><p>当然，JAVA 中还有很多的警告类型，他们都会对应一个字符串，通过设置 value 属性的值即可压制对于这一类警告类型的检查。</p><p>自定义注解的相关内容就不再赘述了，比较简单，通过类似以下的语法即可自定义一个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InnotationName&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，自定义注解的时候也可以选择性的使用元注解进行修饰，这样你可以更加具体的指定你的注解的生命周期、作用范围等信息。</p><h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><h4 id="定义注解类"><a href="#定义注解类" class="headerlink" title="定义注解类"></a>定义注解类</h4><p>@Overrid：作用在方法上的注解，当方法不是重写父类的方法时会报错<br>@Deprecated：作用在方法伤害，标记该方法为作废方法（已过时）<br>@SuppressWarnings：作用在方法上，压制警告</p><p>定义注解使用@interface<br>public @interface MyAnn{}<br>所有的注解都是Annotation的子类</p><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><ul><li>注解的作用目标：<ul><li>类（接口、枚举）</li><li>属性</li><li>方法</li><li>构造器</li><li>参数</li><li>局部变量</li><li>包</li></ul></li></ul><h4 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h4><ul><li><p>定义属性</p><ul><li>格式：类型 属性名()</li></ul></li><li><p>使用注解时给属性赋值</p><ul><li>@MyAnno1(age=100,name=”zhangSan”)</li></ul></li><li><p>注解属性的默认值：在定义注解时，可以给注解指定默认值</p><ul><li>int age() default 100;</li><li>在使用注解时，可以不给带有默认值的属性赋值</li></ul></li><li><p>名为value的属性的特权</p><ul><li>当使用注解时，如果只给名为value的属性赋值时，可以省略”value=”<ul><li>例如：@MyAnno1(value=”hello”),可以书写成 @MyAnno1(“hello”)</li></ul></li></ul></li><li><p>注解属性的类型</p><ul><li>8种基本类型</li><li>String</li><li>Enum</li><li>Class</li><li>注解类型</li><li>以上类型的一维数组类型</li><li><p>当给数组类型的属性赋值时，若数组元素的个数为1时，可以省略大括号</p><p><img src="/category/JavaSE-注解/5.png" alt="注解"></p><p><img src="/category/JavaSE-注解/6.png" alt="注解"></p><h4 id="注解的作用目标限定以及保存策略限定"><a href="#注解的作用目标限定以及保存策略限定" class="headerlink" title="注解的作用目标限定以及保存策略限定"></a>注解的作用目标限定以及保存策略限定</h4></li></ul></li><li>让一个注解，它的作用目标只能在类上，不能再方法上，这就叫作用目标的限定<ul><li>再定义注解时，给注解添加注解，这个注解是@Target<br><img src="/category/JavaSE-注解/7.png" alt="注解"></li></ul></li><li>保留策略<ul><li>源代码文件(SOURCE)：只在源代码种存在，当编译时就被忽略了</li><li>字节码文件(CLASS)：注解在源代码中存在，然后编译时会把注解信息放到class文件，但jvm在加载类时，会忽略注解</li><li>JVM中(RUNTIME)：注解在源代码、字节码文件中存在，并且在JVM加载类时，会把注解加载到JVM内存中（它是唯一可反射注解)<br>限定注解的保留策略：使用Retention<br><img src="/category/JavaSE-注解/8.png" alt="注解"></li></ul></li></ul><h2 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h2><p>「注解的本质就是一个继承了 Annotation 接口的接口」，现在我们就来从虚拟机的层面看看，注解的本质到底是什么。</p><p>首先，我们自定义一个注解类型：</p><p><img src="/category/JavaSE-注解/9.png" alt="注解"></p><p>这里我们指定了 Hello 这个注解只能修饰字段和方法，并且该注解永久存活，以便我们反射获取。</p><p>之前我们说过，虚拟机规范定义了一系列和注解相关的属性表，也就是说，无论是字段、方法或是类本身，如果被注解修饰了，就可以被写进字节码文件。属性表有以下几种：</p><ul><li>RuntimeVisibleAnnotations：运行时可见的注解</li><li>RuntimeInVisibleAnnotations：运行时不可见的注解</li><li>RuntimeVisibleParameterAnnotations：运行时可见的方法参数注解</li><li>RuntimeInVisibleParameterAnnotations：运行时不可见的方法参数注解</li><li>AnnotationDefault：注解类元素的默认值</li></ul><p>给大家看虚拟机的这几个注解相关的属性表的目的在于，让大家从整体上构建一个基本的印象，注解在字节码文件中是如何存储的。</p><p>所以，对于一个类或者接口来说，Class 类中提供了以下一些方法用于反射注解。</p><ul><li>getAnnotation：返回指定的注解</li><li>isAnnotationPresent：判定当前元素是否被指定注解修饰</li><li>getAnnotations：返回所有的注解</li><li>getDeclaredAnnotation：返回本元素的指定注解</li><li>getDeclaredAnnotations：返回本元素的所有注解，不包含父类继承而来的</li></ul><p>方法、字段中相关反射注解的方法基本是类似的，这里不再赘述，我们下面看一个完整的例子。</p><p>首先，设置一个虚拟机启动参数，用于捕获 JDK 动态代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dsun.misc.ProxyGenerator.saveGeneratedFiles=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>然后 main 函数。</p><p><img src="/category/JavaSE-注解/10.png" alt="注解"></p><p>我们说过，注解本质上是继承了 Annotation 接口的接口，而当你通过反射，也就是我们这里的 getAnnotation 方法去获取一个注解类实例的时候，其实 JDK 是通过动态代理机制生成一个实现我们注解（接口）的代理类。</p><p>我们运行程序后，会看到输出目录里有这么一个代理类，反编译之后是这样的：</p><p><img src="/category/JavaSE-注解/11.png" alt="注解"></p><p><img src="/category/JavaSE-注解/12.png" alt="注解"></p><p>代理类实现接口 Hello 并重写其所有方法，包括 value 方法以及接口 Hello 从 Annotation 接口继承而来的方法。</p><p>而这个关键的 InvocationHandler 实例是谁？</p><p>AnnotationInvocationHandler 是 JAVA 中专门用于处理注解的 Handler， 这个类的设计也非常有意思。</p><p><img src="/category/JavaSE-注解/a1.png" alt="注解"></p><p>这里有一个 memberValues，它是一个 Map 键值对，键是我们注解属性名称，值就是该属性当初被赋上的值。</p><p><img src="/category/JavaSE-注解/a2.png" alt="注解"></p><p><img src="/category/JavaSE-注解/a3.png" alt="注解"></p><p>而这个 invoke 方法就很有意思了，大家注意看，我们的代理类代理了 Hello 接口中所有的方法，所以对于代理类中任何方法的调用都会被转到这里来。</p><p>var2 指向被调用的方法实例，而这里首先用变量 var4 获取该方法的简明名称，接着 switch 结构判断当前的调用方法是谁，如果是 Annotation 中的四大方法，将 var7 赋上特定的值。</p><p>如果当前调用的方法是 toString，equals，hashCode，annotationType 的话，AnnotationInvocationHandler 实例中已经预定义好了这些方法的实现，直接调用即可。</p><p>那么假如 var7 没有匹配上这四种方法，说明当前的方法调用的是自定义注解字节声明的方法，例如我们 Hello 注解的 value 方法。<strong>这种情况下，将从我们的注解 map 中获取这个注解属性对应的值。</strong></p><p>其实，JAVA 中的注解设计个人觉得有点反人类，明明是属性的操作，非要用方法来实现。当然，如果你有不同的见解，欢迎留言探讨。</p><p>最后我们再总结一下整个反射注解的工作原理：</p><p>首先，我们通过键值对的形式可以为注解属性赋值，像这样：@Hello（value = “hello”）。</p><p>接着，你用注解修饰某个元素，编译器将在编译期扫描每个类或者方法上的注解，会做一个基本的检查，你的这个注解是否允许作用在当前位置，最后会将注解信息写入元素的属性表。</p><p>然后，当你进行反射的时候，虚拟机将所有生命周期在 RUNTIME 的注解取出来放到一个 map 中，并创建一个 AnnotationInvocationHandler 实例，把这个 map 传递给它。</p><p>最后，虚拟机将采用 JDK 动态代理机制生成一个目标注解的代理类，并初始化好处理器。</p><p>那么这样，一个注解的实例就创建出来了，它本质上就是一个代理类，你应当去理解好 AnnotationInvocationHandler 中 invoke 方法的实现逻辑，这是核心。一句话概括就是，<strong>通过方法名返回注解属性值</strong>。</p><h2 id="Java8中注解增强"><a href="#Java8中注解增强" class="headerlink" title="Java8中注解增强"></a>Java8中注解增强</h2><h3 id="元注解-Repeatable"><a href="#元注解-Repeatable" class="headerlink" title="元注解@Repeatable"></a>元注解@Repeatable</h3><p>元注解@Repeatable是JDK1.8新加入的，它表示在同一个位置重复相同的注解。在没有该注解前，一般是无法在同一个类型上使用相同的注解的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java8前无法这样使用</span></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/update"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/add"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>Java8前如果是想实现类似的功能，我们需要在定义@FilterPath注解时定义一个数组元素接收多个值如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FilterPath &#123;</span><br><span class="line">    String [] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="meta">@FilterPath</span>(&#123;<span class="string">"/update"</span>,<span class="string">"/add"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>但在Java8新增了@Repeatable注解后就可以采用如下的方式定义并使用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.annotationdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Java8新增@Repeatable原注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Repeatable</span>(FilterPaths.class)<span class="comment">//参数指明接收的注解class</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FilterPath &#123;</span><br><span class="line">    <span class="function">String  <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> FilterPaths &#123;</span><br><span class="line">    FilterPath[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用案例</span></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/update"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/add"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/delete"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>我们可以简单理解为通过使用@Repeatable后，将使用@FilterPaths注解作为接收同一个类型上重复注解的容器，而每个@FilterPath则负责保存指定的路径串。为了处理上述的新增注解，Java8还在AnnotatedElement接口新增了getDeclaredAnnotationsByType() 和 getAnnotationsByType()两个方法并在接口给出了默认实现，在指定@Repeatable的注解时，可以通过这两个方法获取到注解相关信息。但请注意，旧版API中的getDeclaredAnnotation()和 getAnnotation()是不对@Repeatable注解的处理的(除非该注解没有在同一个声明上重复出现)。注意getDeclaredAnnotationsByType方法获取到的注解不包括父类，其实当 getAnnotationsByType()方法调用时，其内部先执行了getDeclaredAnnotationsByType方法，只有当前类不存在指定注解时，getAnnotationsByType()才会继续从其父类寻找，但请注意如果@FilterPath和@FilterPaths没有使用了@Inherited的话，仍然无法获取。下面通过代码来演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Java8新增@Repeatable原注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Repeatable</span>(FilterPaths.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FilterPath &#123;</span><br><span class="line">    <span class="function">String  <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> FilterPaths &#123;</span><br><span class="line">    FilterPath[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/list"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用案例</span></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/update"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/add"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/delete"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> <span class="keyword">extends</span> <span class="title">CC</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = AA.class;</span><br><span class="line">        <span class="comment">//通过getAnnotationsByType方法获取所有重复注解</span></span><br><span class="line">        FilterPath[] annotationsByType = clazz.getAnnotationsByType(FilterPath.class);</span><br><span class="line">        FilterPath[] annotationsByType2 = clazz.getDeclaredAnnotationsByType(FilterPath.class);</span><br><span class="line">        <span class="keyword">if</span> (annotationsByType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FilterPath filter : annotationsByType) &#123;</span><br><span class="line">                System.out.println(<span class="string">"1:"</span>+filter.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (annotationsByType2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FilterPath filter : annotationsByType2) &#123;</span><br><span class="line">                System.out.println(<span class="string">"2:"</span>+filter.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"使用getAnnotation的结果:"</span>+clazz.getAnnotation(FilterPath.class));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行结果(当前类拥有该注解FilterPath,则不会从CC父类寻找)</span></span><br><span class="line"><span class="comment">         1:/web/update</span></span><br><span class="line"><span class="comment">         1:/web/add</span></span><br><span class="line"><span class="comment">         1:/web/delete</span></span><br><span class="line"><span class="comment">         -----------------</span></span><br><span class="line"><span class="comment">         2:/web/update</span></span><br><span class="line"><span class="comment">         2:/web/add</span></span><br><span class="line"><span class="comment">         2:/web/delete</span></span><br><span class="line"><span class="comment">         使用getAnnotation的结果:null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从执行结果来看如果当前类拥有该注解@FilterPath,则getAnnotationsByType方法不会从CC父类寻找，下面看看另外一种情况，即AA类上没有@FilterPath注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Java8新增@Repeatable原注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">//添加可继承元注解</span></span><br><span class="line"><span class="meta">@Repeatable</span>(FilterPaths.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FilterPath &#123;</span><br><span class="line">    <span class="function">String  <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">//添加可继承元注解</span></span><br><span class="line"><span class="meta">@interface</span> FilterPaths &#123;</span><br><span class="line">    FilterPath[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/list"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/getList"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AA上不使用@FilterPath注解,getAnnotationsByType将会从父类查询</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> <span class="keyword">extends</span> <span class="title">CC</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = AA.class;</span><br><span class="line">        <span class="comment">//通过getAnnotationsByType方法获取所有重复注解</span></span><br><span class="line">        FilterPath[] annotationsByType = clazz.getAnnotationsByType(FilterPath.class);</span><br><span class="line">        FilterPath[] annotationsByType2 = clazz.getDeclaredAnnotationsByType(FilterPath.class);</span><br><span class="line">        <span class="keyword">if</span> (annotationsByType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FilterPath filter : annotationsByType) &#123;</span><br><span class="line">                System.out.println(<span class="string">"1:"</span>+filter.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (annotationsByType2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FilterPath filter : annotationsByType2) &#123;</span><br><span class="line">                System.out.println(<span class="string">"2:"</span>+filter.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"使用getAnnotation的结果:"</span>+clazz.getAnnotation(FilterPath.class));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行结果(当前类没有<span class="doctag">@FilterPath</span>,getAnnotationsByType方法从CC父类寻找)</span></span><br><span class="line"><span class="comment">         1:/web/list</span></span><br><span class="line"><span class="comment">         1:/web/getList</span></span><br><span class="line"><span class="comment">         -----------------</span></span><br><span class="line"><span class="comment">         使用getAnnotation的结果:null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意定义@FilterPath和@FilterPath时必须指明@Inherited，getAnnotationsByType方法否则依旧无法从父类获取@FilterPath注解，这是为什么呢，不妨看看getAnnotationsByType方法的实现源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口默认实现方法</span></span><br><span class="line"><span class="keyword">default</span> &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) &#123;</span><br><span class="line"><span class="comment">//先调用getDeclaredAnnotationsByType方法</span></span><br><span class="line">T[] result = getDeclaredAnnotationsByType(annotationClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前类获取到的注解数组是否为0</span></span><br><span class="line"><span class="keyword">if</span> (result.length == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span> <span class="keyword">instanceof</span> Class &amp;&amp; </span><br><span class="line"><span class="comment">//判断定义注解上是否使用了@Inherited元注解 </span></span><br><span class="line"> AnnotationType.getInstance(annotationClass).isInherited()) &#123; <span class="comment">// Inheritable</span></span><br><span class="line">        <span class="comment">//从父类获取</span></span><br><span class="line">       Class&lt;?&gt; superClass = ((Class&lt;?&gt;) <span class="keyword">this</span>).getSuperclass();</span><br><span class="line">   <span class="keyword">if</span> (superClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = superClass.getAnnotationsByType(annotationClass);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增的两种ElementType"><a href="#新增的两种ElementType" class="headerlink" title="新增的两种ElementType"></a>新增的两种ElementType</h3><p>在Java8中 ElementType 新增两个枚举成员，TYPE_PARAMETER 和 TYPE_USE ，在Java8前注解只能标注在一个声明(如字段、类、方法)上，Java8后，新增的TYPE_PARAMETER可以用于标注类型参数，而TYPE_USE则可以用于标注任意类型(不包括class)。如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TYPE_PARAMETER 标注在类型参数上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&lt;@<span class="title">Parameter</span> <span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TYPE_USE则可以用于标注任意类型(不包括class)</span></span><br><span class="line"><span class="comment">//用于父类或者接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> <span class="keyword">implements</span> @<span class="title">Rectangular</span> <span class="title">Shape</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于构造函数</span></span><br><span class="line"><span class="keyword">new</span> <span class="meta">@Path</span> String(<span class="string">"/usr/bin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于强制转换和instanceof检查,注意这些注解中用于外部工具，它们不会对类型转换或者instanceof的检查行为带来任何影响。</span></span><br><span class="line">String path=(<span class="meta">@Path</span> String)input;</span><br><span class="line"><span class="keyword">if</span>(input <span class="keyword">instanceof</span> <span class="meta">@Path</span> String)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于指定异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> @Localized IOException.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//用于通配符绑定</span></span></span><br><span class="line"><span class="function">List&lt;@ReadOnly ? extends Person&gt;</span></span><br><span class="line"><span class="function">List&lt;? extends @ReadOnly Person&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">@NotNull String.class <span class="comment">//非法，不能标注class</span></span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.lang.@NotNull String <span class="comment">//非法，不能标注import</span></span></span><br></pre></td></tr></table></figure><p>这里主要说明一下TYPE_USE，类型注解用来支持在Java的程序中做强类型检查，配合第三方插件工具（如Checker Framework），可以在编译期检测出runtime error（如UnsupportedOperationException、NullPointerException异常），避免异常延续到运行期才发现，从而提高代码质量，这就是类型注解的主要作用。总之Java 8 新增加了两个注解的元素类型ElementType.TYPE_USE 和ElementType.TYPE_PARAMETER ，通过它们，我们可以把注解应用到各种新场合中。</p><p>参考博文：</p><p><a href="https://blog.csdn.net/javazejian/article/details/71860633" target="_blank" rel="noopener">深入理解Java注解类型(@Annotation)</a>（Java8中注解增强）</p><p><a href="https://juejin.im/post/5b45bd715188251b3a1db54f" target="_blank" rel="noopener">JAVA 注解的基本原理</a></p><p>推荐博文：</p><p><a href="https://www.jianshu.com/p/5cac4cb9be54" target="_blank" rel="noopener">深入浅出Java注解</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE注解入门
    
    </summary>
    
      <category term="JavaSE" scheme="https://www.ysmjjsy.com/categories/JavaSE/"/>
    
      <category term="JavaSE注解" scheme="https://www.ysmjjsy.com/categories/JavaSE/JavaSE%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-JavaBean</title>
    <link href="https://www.ysmjjsy.com/category/JavaBean/"/>
    <id>https://www.ysmjjsy.com/category/JavaBean/</id>
    <published>2018-03-16T16:00:00.000Z</published>
    <updated>2019-09-17T09:04:48.315Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:12:06 GMT+0800 (GMT+08:00) --><h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><p>必须要为成员提供get/set方法（提供一个也可以）如果只有get方法，那么这个属性是只读属性必须要有默认构造器（没参）一般对于具有get/set方法的成员变量称之为属性其实就算一个属性没有对应的成员变量，只有get/set方法也是可以的属性的名称就是get/set方法去除get/set后，再把首字母小写</p><p>get/set决定属性名称</p><p>方法名称满足一定的规范，那么他就是属性</p><p>boolean类型的属性，他的读方法可以是is开头或是get开头</p><p><strong>JavaBean内省</strong><br>内省类 —&gt;Bean信息 —&gt;属性描述符 —&gt;属性的get/set对应的Method! —&gt;反射</p><p>commons-beanutils 依赖内省完成的<br>导包：<br>commons-beanutils.jar<br>commons-logging.jar<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="string">"cn.cj.domain.Person"</span>;</span><br><span class="line">Class clazz = Class.forName(className);</span><br><span class="line">Object bean = clazz.newInstance();</span><br><span class="line">BeanUtils.setProperty(bean,<span class="string">"name"</span>,<span class="string">"张三"</span>);</span><br><span class="line"></span><br><span class="line">String age = BeanUtils.getProperty(bean,<span class="string">"age"</span>);</span><br></pre></td></tr></table></figure><p></p><p>把map中的属性直接封装到一个bean中要求map的key与bean的属性名相同<br>BeanUtils.populate(user,map);</p><p>map转换成指定类型的javaBean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">toBean</span><span class="params">(Map map, Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    T bean = clazz.clazz.newInstance();</span><br><span class="line">    BeanUtils.populate(bean,map);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/category/JavaBean/1.png" alt="JavaBean"></p><p><strong>jsp中的javabean相关标签</strong></p><p><code>&lt;jsp:useBean&gt;</code> 创建或查询bean<br>在域中查找名为user1的bean，如果不存在，创建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id = <span class="string">"user1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.cj.domain.User"</span> scope=<span class="string">"page"</span>/&gt;创建保存</span><br><span class="line">&lt;jsp:useBean id = <span class="string">"user1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.cj.domain.User"</span> scope=<span class="string">"page"</span>/&gt;查找</span><br></pre></td></tr></table></figure><p><code>&lt;jsp:setProperty&gt;</code><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:setProperty property=<span class="string">"username"</span> name=<span class="string">"user1"</span> value=<span class="string">"admin"</span>/&gt;设置名为user1的javabean的username属性值为admin</span><br></pre></td></tr></table></figure><p></p><p><code>&lt;jsp:getProperty&gt;</code><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:getProperty property=<span class="string">"username"</span> name=<span class="string">"user1"</span>/&gt;获取名为user1的javabean的名为username属性值</span><br></pre></td></tr></table></figure><p></p><h2 id="JDBC分页-监听器"><a href="#JDBC分页-监听器" class="headerlink" title="JDBC分页-监听器"></a>JDBC分页-监听器</h2><p><strong>分页</strong></p><p>分页的优点：只查询一页，不查询所有页<br>分页数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数据都是从Servlet传递来的</span><br><span class="line">Servlet：</span><br><span class="line">    当前页：pageCode，pc</span><br><span class="line">        pc：如果页面没有传递当前页码，那么Servlet默认是第一页，或者按页面传递为准</span><br><span class="line">    总页数：totallPages。tp</span><br><span class="line">        tp：总记录数/每页记录数</span><br><span class="line">    总记录数：totallRecored，tr</span><br><span class="line">        tr：dao来获取，<span class="function">select <span class="title">count</span><span class="params">(*)</span> from t_customer</span>;</span><br><span class="line">    每页记录数：业务数据或叫系统数据</span><br><span class="line">    当前页数据：beanList</span><br><span class="line">    url</span><br></pre></td></tr></table></figure><p>数据的传递：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这些分页数据总要在各层之间来回传递</span><br><span class="line">把这些分页数据封装到一个javaBean中，就叫分页Bean，例如PageBean</span><br></pre></td></tr></table></figure><p></p><p>分页在各层中处理：</p><p>页面：给出分页相关的链接们</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    页面需要给Servlet传递当前页码pc</span><br><span class="line">Servlet：创建PageBean对象，给PageBean所有属性赋值，然后传递给页面</span><br><span class="line">    Servlet需要给Dao传递pc、ps</span><br><span class="line">Service：</span><br><span class="line">Dao：</span><br><span class="line">    tr：<span class="function">select <span class="title">count</span><span class="params">(*)</span> t_customer</span></span><br><span class="line"><span class="function">    beanList：select * from t_customer LIMIT x,y</span></span><br></pre></td></tr></table></figure><p><img src="/category/JavaBean/2.png" alt="JavaBean"></p><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>JavaWeb监听器：Listener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">监听器是一个接口，内容我们来实现</span><br><span class="line">监听器需要注册</span><br><span class="line">监听器的方法，会在特定事件发生时被调用</span><br></pre></td></tr></table></figure><p>观察者：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">事件源</span><br><span class="line">事件</span><br><span class="line">监听器</span><br></pre></td></tr></table></figure><p></p><p>事件源：三大域<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ServletContext：</span><br><span class="line">    生命周期监听：ServletContextListener：两个方法，一个出生时调用，一个死亡时调用</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span>：创建SErvletcontext时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span>：销毁SErvletcontext时</span></span><br><span class="line"><span class="function">    属性监听：ServletCcontextAttributeListener：三个方法，一个在添加属性时调用，一个在替换属性时调用，最后一个在移出属性时调用</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextEvent event)</span>：添加属性时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletContextEvent event)</span>：替换属性时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextEvent event)</span>：移除属性时</span></span><br><span class="line"><span class="function">    可以存放一些在tomcat启动时就要完成的代码</span></span><br><span class="line"><span class="function">HttpSesion：</span></span><br><span class="line"><span class="function">    生命周期监听：HttpSesionListener：两个方法，一个出生时调用，一个死亡时调用</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent se)</span>：创建session时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span>：销毁session时</span></span><br><span class="line"><span class="function">    属性监听：HttpSesionAttributeListener：三个方法，一个在添加属性时调用，一个在替换属性时调用，最后一个在移出属性时调用</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(HttpSessionBindingEvent event)</span>：添加属性时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(HttpSessionBindingEvent event)</span>：替换属性时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(HttpSessionBindingEvent event)</span>：移除属性时</span></span><br><span class="line"><span class="function">ServletRequest：</span></span><br><span class="line"><span class="function">    生命周期监听：ServletRequestListener：两个方法，一个出生时调用，一个死亡时调用</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span>：创建request时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span>：销毁request时</span></span><br><span class="line"><span class="function">    属性监听：ServletRequestAttributeListener：三个方法，一个在添加属性时调用，一个在替换属性时调用，最后一个在移出属性时调用</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletRequestEvent event)</span>：添加属性时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletRequestEvent event)</span>：替换属性时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletRequestEventevent)</span>：移除属性时</span></span><br></pre></td></tr></table></figure><p></p><p>写一个监听器类：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">要求必须实现某个监听器接口</span><br><span class="line">注册，是在web.xml中配置来完成注册</span><br></pre></td></tr></table></figure><p></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>cn.cj.web.listener.AListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事件对象：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ServletContextEvent：<span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">HttpServletEvent：HttpSession <span class="title">getSession</span><span class="params">()</span></span></span><br><span class="line"><span class="function">ServletRequest：</span></span><br><span class="line"><span class="function">    ServletContext <span class="title">getServletContext</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">    ServletRequest <span class="title">getServletRequest</span><span class="params">()</span></span>;</span><br><span class="line">ServletContextAttributeEvent:</span><br><span class="line">    <span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span>：获取属性名</span></span><br><span class="line"><span class="function">    Object <span class="title">getValue</span><span class="params">()</span>：获取属性值</span></span><br><span class="line"><span class="function">HttpSessionBindingEvent</span></span><br><span class="line"><span class="function">    String <span class="title">getName</span><span class="params">()</span>：获取属性名</span></span><br><span class="line"><span class="function">    Object <span class="title">getValue</span><span class="params">()</span>：获取属性值</span></span><br><span class="line"><span class="function">ServletRequestEvent</span></span><br><span class="line"><span class="function">    String <span class="title">getName</span><span class="params">()</span>：获取属性名</span></span><br><span class="line"><span class="function">    Object <span class="title">getValue</span><span class="params">()</span>：获取属性值</span></span><br><span class="line"><span class="function">感知监听器（都与HttpSession相关）</span></span><br><span class="line"><span class="function">    用来添加到JavaBena上，而不是添加到三大域上</span></span><br><span class="line"><span class="function">    这两个监听器都不需要在web.xml中注册</span></span><br></pre></td></tr></table></figure><p></p><p>HttpSessionBindingListener：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">添加到javaBean上，javaBean就知道自己是否添加到Session中</span><br></pre></td></tr></table></figure><p></p><p>HttpSessionActivationListener：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tomcat会在session从时间不被使用时钝化session对象，所谓钝化session，就是把session通过序列化的方式保存到硬盘文件中。当用户再使用session时，Tomcat还会把钝化的对象再活化session，所谓活化就是把硬盘文件中的session在反序列化回内存。当session被Tomcat钝化时，session中存储的对象也被纯化，当session被活化时，也会把session中存储的对象活化。如果某个类实现了HttpSessionActiveationListener接口后，当对象随着session被钝化和活化时，下面两个方法就会被调用：</span><br></pre></td></tr></table></figure><p></p><p>public void sessionWillPassivate(HttpSessionEvent se)：当对象感知被活化时调用本方法；<br>public void sessionDidActivate(HttpSessionEvent se)：当对象感知被钝化时调用本方法；<br>HttpSessionActivationListener监听器与HttpSessionBindingListener监听器相似，都是感知型的监听器，例如让Person类实现了HttpSessionActivationListener监听器接口，并把Person对象添加到了session中后，当Tomcat钝化session时，同时也会钝化session中的Person对象，这时Person对象就会感知到自己被钝化了，其实就是调用Person对象的sessionWillPassivate()方法。当用户再次使用session时，Tomcat会活化session，这时Person会感知到自己被活化，其实就是调用Person对象的sessionDidActivate()方法。<br>注意，因为钝化和活化session，其实就是使用序列化和反序列化技术把session从内存保存到硬盘，和把session从硬盘加载到内存。这说明如果Person类没有实现Serializable接口，那么当session钝化时就不会钝化Person，而是把Person从session中移除再钝化！这也说明session活化后，session中就不在有Person对象了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaBean
    
    </summary>
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/categories/JavaWeb/"/>
    
      <category term="JavaBean" scheme="https://www.ysmjjsy.com/categories/JavaWeb/JavaBean/"/>
    
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-JSP</title>
    <link href="https://www.ysmjjsy.com/category/JSP/"/>
    <id>https://www.ysmjjsy.com/category/JSP/</id>
    <published>2018-03-14T16:00:00.000Z</published>
    <updated>2019-09-17T08:57:50.475Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:12:06 GMT+0800 (GMT+08:00) --><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><p>JSP就是一种包装的Servlet</p><h2 id="JSP和Servlet的分工"><a href="#JSP和Servlet的分工" class="headerlink" title="JSP和Servlet的分工"></a><strong>JSP和Servlet的分工</strong></h2><p><strong>JSP:</strong></p><ul><li>作为请求发起页面，例如显示表单、超链接</li><li>作为请求结束页面，例如显示数据</li></ul><p><strong>Servlet:</strong></p><ul><li>作为请求中处理数据的环节</li><li>获取JSP发送过来的请求参数</li><li>处理请求，得到处理后的数据</li><li>把结果保存到request域中</li><li>转发到显示结果的JSP</li></ul><h2 id="JSP的组成"><a href="#JSP的组成" class="headerlink" title="JSP的组成"></a><strong>JSP的组成</strong></h2><p>JSP=html+java脚本+jsp标签(指令)</p><h2 id="JSP九大内置对象"><a href="#JSP九大内置对象" class="headerlink" title="JSP九大内置对象"></a><strong>JSP九大内置对象</strong></h2><p>request—&gt;HttpServletRequest<br>response—&gt;HttpServletResponse<br>sessio—&gt;HttpSession<br>applicatio—&gt;servletContext类的对象<br>pageContext—&gt;页面上下文对象<br>config—&gt;ServletConfig<br>out—&gt;输出流，用来向客户端响应<br>page—&gt;当前jsp的”this”，真身Object<br>exception—&gt;Throwable</p><p><strong>pageContext</strong></p><p>Servlet中有三大域：request、response、application<br>Jsp中有四大域:request、response、application、pageContext<br>servletCotext:整个应用程序<br>session:整个会话（一个会话中只有一个用户）<br>request：一个请求链<br>pageContext：一个jsp页面！这个域是在当前jsp页面和当前jsp页面中使用的标签之间共享数据<br>域对象<br>代理其他域：pageContext.setAttribute(“xxx”,”xxx”,PageContext.SESSION.SCOPE);<br>全域查找：pageContext.findAttribute(“xxx”);从小到大，依赖查找<br>获取其他8个内置对象</p><h2 id="3种Java脚本"><a href="#3种Java脚本" class="headerlink" title="3种Java脚本"></a><strong>3种Java脚本</strong></h2><p>&lt;%…%&gt;java代码片段，用于定义0~N条Java语句。方法内写什么，它写什么<br>&lt;%= …%&gt;java表达式，用于输出，输出一条表达式的结果。response.getWrite().print(…)这里能放什么，它就能放什么<br>&lt;%!…%&gt;声明，用来创建类的成员和变量方法，class MyClass{}（类体）这里能放什么它放什么<br>JSP输出<br>&lt;%— … —%&gt;当服务器把JSP编译成java文件时已经忽略了注释部分</p><p>&lt;%@ …%&gt; jsp指令，也是一种特殊的标签</p><h2 id="JSP原理"><a href="#JSP原理" class="headerlink" title="JSP原理"></a><strong>JSP原理</strong></h2><p>JSP其实就是一种特殊的Servlet<br>当jsp页面第一次被访问时，服务器会把jsp编译成java文件（这个java其实是一个servlet)类<br>然后再把java编译成.class<br>然后创建该类对象<br>最后调用它的service()方法<br>第二次请求同一jsp时，直接调用service()方法</p><p>tomcat的work目录下可以找到jsp对应的.java源代码</p><h2 id="JSP标签"><a href="#JSP标签" class="headerlink" title="JSP标签"></a>JSP标签</h2><p><strong>JSP三大指令：</strong><br>指令格式:&lt;%@ … %&gt;</p><p><strong>page:最复杂</strong></p><ul><li>pageEncoding和ContentType：<ul><li>pageEncoding:指定当前jsp页面的编码，只要不说谎就不会乱码,在服务器要把jsp编译成.java需要使用pageEncoding</li><li>ContentType：添加一个响应头，等同于response.setContentType(“text/html;charset=utf-8”):</li></ul></li></ul><p>如果两个属性只提供一个，那么另一个的默认值为设置那一个。<br>如果两个都没设置，默认时iso</p><ul><li>import:导包</li><li><p>errorPage和isErrorPage：</p><ul><li>errorPage：当前页面抛出异常，那么要转发到哪一个页面，由errorPage来指定（请求转发）</li><li>isErrorPage：当前页面是否为处理错误的页面，当该属性为true时，这个页面会设置状态码为500，而且这个页面可以使用9大内置对象中的exception。</li></ul><p><strong>web.xml中配置错误页面</strong></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/error404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/error500.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.RuntimeException<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>autoFlush和buffer</strong></p><ul><li>autoFlush:指定jsp输出缓冲区满时，是否自动刷新，默认时true，如果为false，那么在缓冲区满时抛出异常</li><li>buffer:指定缓冲区大小，默认为8kb，通常不需要修改</li><li>isELIgnored:是否忽略el表达式，默认值为false，不忽略，支持</li><li>language:指定当前jsp编译后的语言类型，默认值为java</li><li>info：信息</li><li>isThreadSafe：默认为false，是否支持并发访问</li><li>session:当前页面是否支持session，如果false，则当前页面没有session内置对象</li><li>extends:让jsp生成的servlet去继承该属性指定的类</li></ul><p><strong>include:静态包含</strong><br>与RequestDispatcher的include()方法的功能相似<br><a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x25;&#64;&#105;&#x6e;&#99;&#108;&#117;&#x64;&#x65;&#x25;">&#x25;&#64;&#105;&#x6e;&#99;&#108;&#117;&#x64;&#x65;&#x25;</a>：它是在jsp编译成java文件时完成的，共同生成一个java文件（一个Servlet），再生成一个class<br>RequestDispatcher的include()方法：包含和被包含的是两个servlet，即两个.class它们只是把响应的内容在运行时合并了<br>作用：把不变的和变得分开</p><p><strong>taglib:导入标签库</strong><br>prefix:指定标签库在本页中的前缀，由我们自己来起名字<br>uri：指定标签库的位置</p><p><strong>JSP动作标签</strong><br>是由服务器来解释执行<br>html提供的标签由浏览器来执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward&gt;:与RequestDispatcher的forward方法是一样的，一个在Servlet中使用，一个在JSP中使用</span><br><span class="line">&lt;jsp:include&gt;:与RequestDispatcher的include方法是一样的，一个在Servlet中使用，一个在JSP中使用</span><br><span class="line">&lt;%<span class="meta">@include</span>%&gt;和&lt;jsp:include&gt;的不同，前者是两者包含在一起，后者是仅仅把输出结果合并</span><br><span class="line">&lt;jsp:param&gt;:作为forward和include的子标签，用来给转发或包含的页面传递参数</span><br></pre></td></tr></table></figure><p>tomcat cof目录下 context.xml<br><code>&lt;Context reloadable=&quot;true&quot;&gt;</code>:不用重启tomcat</p><p>JSP其实是一个servlet，在conf下的web.xml里看到有个JspServlet，调用jsp页面则是调用这个JspServlet，把jsp文件读取变成.java,然后编译成.class，然后创建其对象，调用其service方法</p><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>EL是JSP内置的表达式语言，可以全域查找${xxx}<br>如果查找不到，输出空字符串，不是null<br>（pageContext—&gt;request—&gt;session—&gt;application）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageContextScope.xxx&#125;</span><br><span class="line"></span><br><span class="line">$&#123;requestScope.xxx&#125;</span><br><span class="line"></span><br><span class="line">$&#123;session.xxx&#125;</span><br><span class="line"></span><br><span class="line">$&#123;application.xxx&#125;</span><br></pre></td></tr></table></figure><p>jsp2.0开始不让使用java脚本，而是使用el表达式和动态标签来替代java脚本<br>EL替代的是&lt;%=…%&gt;,也就是说EL只能做输出</p><p><strong>JavaBean导航：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;requestScope.emp.address.street&#125;得到这个bean里的街道</span><br><span class="line"></span><br><span class="line">&lt;!--request.getAttribute(<span class="string">"emp"</span>).getAddress().getStreet() --&gt;</span><br></pre></td></tr></table></figure><p>EL可以输出的东西都在11个内置对象中！11个内置对象，其中10个是Map，pageContext不是map，它就是PageContext类型</p><p>EL可以输出的东西都在11个内置对象中！11个内置对象，其中10个是Map，pageContext不是map，它就是PageContext类型</p><p>param和paramValues这两个内置对象是用来获取请求参数的<br><strong>param：</strong> <code>Map&lt;String,String&gt;</code>类型，param对象可以用来获取参数，与request.getParameter()方法相同 ，key时参数名，value是参数值，适用于单值的参数<br>map.key是el的语法<br>map[‘key’]也可以操作map<br><strong>paramValues：</strong> paramValues是<code>Map&lt;String,String[]&gt;</code>类型，当一个参数名，对应多个参数值时可以使用它</p><p><strong>header：</strong> 对应请求头，是一个Map，其中key表示头名称，value是个单个头值，适用于单值请求头<br>${header[‘User-Agent’]}<br><strong>headerValues：</strong> 对应请求头，是一个Map，其中key表示头名称，value是多个头值，适用于多值请求头</p><p><strong>initParam：</strong> 获取<code>&lt;context-param&gt;</code>内的参数</p><p><strong>Cookie：</strong> <code>Map&lt;String,Cookie&gt;</code>类型，key是Cooke的name，value是cookie对象<br>${cookie.username.value}获取值</p><p><strong>pageContext：</strong> 它是pageContext类型${pageContext.request.contextPath}</p><p><strong><em>EL函数库</em></strong><br>EL函数库是由第三方对EL的扩展，由JSTL提供<br>EL函数库就是定义一些有返回值的静态方法<br>因为是第三方，所以需要导入，导入需要talib指令<br>导入标签库<code>&lt;%@ taglib prefix=&quot;fu&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot;%&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">(String input)</span></span>;<span class="comment">//参数转大写</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">(Stirng input)</span></span>;<span class="comment">//参数转小写</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String input,String substring)</span></span>;<span class="comment">//大串输出小串位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String input,String substring)</span></span>;<span class="comment">//大串是否包含小串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsIgnoreCase</span><span class="params">(String input,String substring)</span></span>;<span class="comment">//忽略大小写，是否包含</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String input,String substring)</span></span>;<span class="comment">//是否以小串为前缀</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWIth</span><span class="params">(String input,String subString)</span></span>;<span class="comment">//是否以小串为后缀</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">subString</span><span class="params">(String input,<span class="keyword">int</span> beginIndex,<span class="keyword">int</span> endIndex)</span></span>;<span class="comment">//截取字串</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">subStringAfter</span><span class="params">(String input,String substring)</span></span>;<span class="comment">//获取大串中，小串在位置后面的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">subStringBefore</span><span class="params">(String input,String substring)</span></span>;<span class="comment">//获取大串中，小串所在位置前面的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">escapeXml</span><span class="params">(String input)</span>:把input中字符串的"&gt;""&lt;"<span class="comment">//转义</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">(String input)</span></span>;<span class="comment">//去除前后空格</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(String input,String substringBefore,String substringAfter)</span></span>;<span class="comment">//替换</span></span><br><span class="line"></span><br><span class="line">String[] split(String input,String delimiters);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(Object obj)</span></span>;<span class="comment">//可以获取字符串、数组、各种集合的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">join</span><span class="params">(String array[],String separator)</span></span>;<span class="comment">//联合字符串数组</span></span><br></pre></td></tr></table></figure><p><strong>自定义EL函数库</strong><br>写一个类，写一个有返回值的静态方法<br>编写<em>*</em>.tld文件，可以参数fn.tld文件来写，把xxx.tld文件放到/WEB-INF目录下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">function-class</span>&gt;</span>cn.cj.fn.MyFunction<span class="tag">&lt;/<span class="name">function-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">function-signature</span>&gt;</span>java.lang.String fun()<span class="tag">&lt;/<span class="name">function-signature</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在页面中添加taglib指令，导入自定义标签库<br>${cj: fun()};</p><h2 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h2><ol><li><p>jstl的概述</p><ul><li>apache的东西，依赖EL</li><li>使用jstl需要导入jstl1.2.jar</li><li>四大库：<blockquote><p>core：核心库，重点<br>fmt：格式化：日期、数字<br>sql：过时<br>xml：过时</p></blockquote></li></ul></li><li><p>导入标签库</p><ul><li>jar包</li><li>在jsp页面中：&lt;%@taglib prefix=”前缀” uri=”路径”%&gt;</li></ul></li></ol><p>core —&gt; c标签！</p><ol><li><p>out和set</p><ul><li><c:out>：输出<blockquote><p>value：可以是字符串常量，也可以是EL表达式<br>default：当要输出的内容为null时，会输出default指定的值<br>escapeXml：默认值为true，表示转义！</p></blockquote></c:out></li><li><c:set>：设置(创建域的属性)<blockquote><p>var：变量名<br>value：变量值，可以是EL表达式<br>scope：域，默认为page，可选值：page、request、session、application</p></blockquote></c:set></li></ul></li><li><p>remove</p><ul><li><remove>：删除域变量<blockquote><p>var：变量名<br>scope：如果不给出scope，表示删除所有域中的该名称的变量；如果指定了域，那么只删除该域的变量。</p></blockquote></remove></li></ul></li><li><p>url</p><ul><li><p>value：指定一个路径！它会在路径前面自动添加项目名。<br>&lt;&gt; <code>&lt;c:url value=&quot;/index.jsp&quot;/&gt;</code>，它会输出/day13_1/index.jsp</p></li><li><p>子标签：<code>&lt;c:param&gt;</code>，用来给url后面添加参数，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:url value=<span class="string">"/index.jsp"</span>&gt;</span><br><span class="line">  &lt;c:param name=<span class="string">"username"</span> value=<span class="string">"张三"</span>/&gt;  <span class="xml"><span class="comment">&lt;!--可以对参数进行url编码！！--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">c:url</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>结果为：/day13_1/index.jsp?username=%ED%2C%3F%ED%2C%3F</p></li><li><p>var：指定变量名，一旦添加了这个属性，那么url标签就不会再输出到页面，而是把生成url保存到域中。</p></li><li><p>scope：它与var一起使用，用来保存url。</p></li></ul></li><li><p>if：对应java中的if语句</p><ul><li><code>&lt;c:if test=&quot;布尔类型&quot;&gt;...&lt;/c:if&gt;</code>，当test为值时，执行标签体内容！</li></ul></li><li><p>choose：它对应java中的if/else if/ … /else</p><ul><li><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c:choose</span><br><span class="line">  &lt;c:when test=<span class="string">""</span>&gt;.../c:when</span><br><span class="line">  &lt;c:when test=<span class="string">""</span>&gt;.../c:when</span><br><span class="line">  &lt;c:when test=<span class="string">""</span>&gt;.../c:when</span><br><span class="line">   ... </span><br><span class="line">  c:otherwise .../c:otherwise</span><br><span class="line">/c:choose</span><br></pre></td></tr></table></figure><p>等同与<br>if(…) {<br>} else if( ….) {<br>} else if( ….) {<br>} else if( ….) {<br>} …<br>else { …}</p></li></ul></li><li><p>forEach<br>它用来循环遍历数组、集合！<br>它还可以用来计数方式来循环！</p><p>计数方式：</p><p>for(int i = 1; i &lt;= 10; i++) {<br>…<br>}</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"i"</span> begin=<span class="string">"1"</span> end=<span class="string">"10"</span>&gt;</span><br><span class="line">  $&#123;i&#125;</span><br><span class="line">&lt;<span class="regexp">/c:forEach&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>var：循环变量</li><li>begin：设置循环变量从几开始。</li><li>end：设置循环变量到几结束。</li><li>step：设置步长！等同与java中的i++，或i+=2。step默认为1</li></ul></li></ol><p>用来输出数组、集合！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">"$&#123;strs &#125;"</span> <span class="keyword">var</span>=<span class="string">"str"</span>&gt;</span><br><span class="line"> $&#123;str &#125;&lt;br/&gt;</span><br><span class="line">&lt;<span class="regexp">/c:forEach&gt;</span></span><br></pre></td></tr></table></figure><p>等同于</p><p>for(String str : strs) {<br>…<br>}</p><p>属性：</p><ul><li>items：指定要循环谁，它可以是一个数组或一个集合</li><li>var：把数组或集合中的每个元素赋值给var指定的变量。</li></ul><p>循环状态</p><p>可以使用varStatus来创建循环状态变量！</p><p>循环状态变量有如下属性：</p><ul><li>count：循环元素的个数</li><li>index：循环元素的下标</li><li>first：是否为第一个元素</li><li>last：是否为最后一个元素</li><li>current：当前元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">"$&#123;list &#125;"</span> <span class="keyword">var</span>=<span class="string">"ele"</span> varStatus=<span class="string">"vs"</span>&gt;</span><br><span class="line">    $&#123;vs.index&#125; $&#123;vs.count &#125; $&#123;vs.first &#125; $&#123;vs.last &#125; $&#123;vs.current &#125;&lt;br/&gt;</span><br><span class="line">&lt;<span class="regexp">/c:forEach&gt;</span></span><br></pre></td></tr></table></figure><p>fmt库<br>它是格式化库</p><p><code>&lt;fmt:formatDate value=&quot;&quot; pattern=&quot;&quot;&gt;</code></p><p>value：指定一个Date类型的变量<br>pattern：用来指定输出的模板！例如：yyyy-MM-dd HH:mm:ss</p><p><code>&lt;fmt:formatNumber value=&quot;${num1}&quot; pattern=&quot;0.00&quot;&gt;</code><br>保留小数点后2位，它会四舍五入！如果不足2位，以0补位！</p><p><code>&lt;fmt:formatNumber value=&quot;${num1}&quot; pattern=&quot;#.##&quot;&gt;</code><br>保留小数点后2位，它会四舍五入！如果不足2位，不补位！</p><p><strong>自定义标签</strong></p><ol><li><p>步骤</p><ul><li>标签处理类（标签也是一个对象，那么就需要先有类！）</li><li>tld文件，它是一个xml</li><li>页面中使用<code>&lt;%@taglib%&gt;</code>来指定tld文件的位置</li></ul></li><li><p>标签处理类<br>SimpleTag接口：</p><ul><li>void doTag()：每次执行标签时都会调用这个方法；</li><li>JspTag getParent()：返回父标签（非生命周期方法）</li><li>void setParent(JspTag)：设置父标签</li><li>void setJspBody(JspFragment)：设置标签体</li><li>void seetJspContext(JspContext)：设置jsp上下文对象，它儿子是PageContext</li></ul></li></ol><p>其中doTag()会在其他三个方法之后被tomcat调用。</p><ol><li>配置tld文件</li></ol><p>tld文件一般都放到WEB-INF之下，这样保证客户端访问不到！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>myTag1<span class="tag">&lt;/<span class="name">name</span>&gt;</span> 指定当前标签的名称</span><br><span class="line"><span class="tag">&lt;<span class="name">tag-class</span>&gt;</span>cn.itcast.tag.MyTag1<span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span> 指定当前标签的标签处理类！</span><br><span class="line"><span class="tag">&lt;<span class="name">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span> 指定标签体的类型，我们这里使用的是空标签！</span><br><span class="line"><span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>页面中指定tld文件位置</li></ol><p>&lt;%@ taglib prefix=”it” uri=”/WEB-INF/tlds/itcast-tag.tld” %&gt;<br>导标签库，就是为页面指定tld文件的位置！</p><p>进阶</p><p>标签体内容</p><ul><li>empty：无标签体！</li><li>JSP：jsp2.0已经不在支持这个类型了！表示标签体内容可以是：java脚本，可以是标签，可以是el表达式</li><li>scriptless：只能是EL表达式，也可以是其他的标签！</li><li>tagdependent：标签体内容不会被执行，而是直接赋值标签处理类！</li></ul><p>不在执行标签下面内容的标签！</p><p>在标签处理类中的doTag()中使用SkipPageException来结束！<br>Tomcat会调用标签处理类的doTag()方法，然后Tomcat会得到SkipPageException，它会跳过本页面其他内容！</p><p>标签属性</p><p>步骤：</p><ol><li><p>给你的标签处理类添加属性！<br>为标签处理类添加属性，属性至少要且一个set方法！这个set方法会在doTag()方法之前被tomcat执行！所在doTag()中就可以使用属性了。</p></li><li><p>在tld文件中对属性进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">attribute</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!--指定属性名--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">required</span>&gt;</span>true<span class="tag">&lt;/<span class="name">required</span>&gt;</span> <span class="comment">&lt;!--指定属性是否为必需的--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">rtexprvalue</span>&gt;</span>true<span class="tag">&lt;/<span class="name">rtexprvalue</span>&gt;</span> <span class="comment">&lt;!--指定属性是否可以使用EL--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">attribute</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>推荐博文：</p><p><a href="https://www.cnblogs.com/xdp-gacl/tag/JavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">JavaWeb</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JSP
    
    </summary>
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/categories/JavaWeb/"/>
    
      <category term="JSP" scheme="https://www.ysmjjsy.com/categories/JavaWeb/JSP/"/>
    
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-MVC</title>
    <link href="https://www.ysmjjsy.com/category/MVC/"/>
    <id>https://www.ysmjjsy.com/category/MVC/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2019-09-17T08:38:04.543Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:12:06 GMT+0800 (GMT+08:00) --><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p><img src="/category/MVC/1.png" alt="MVC"></p><p>不是java独有，所有的B/S结构都使用的它<br>M—Model模型<br>V—View视图（jsp）<br>C—Cotroller控制器（Servlet）<br>JSP Model1</p><p><img src="/category/MVC/2.png" alt="MVC"></p><p>JSP Model1</p><p><img src="/category/MVC/3.png" alt="MVC"></p><p>JSP Model2</p><p><img src="/category/MVC/4.png" alt="MVC"></p><p><strong><em>JavaWeb三层框架</em></strong><br>Web层 —&gt;与web相关的内容（Servlet，JSP，Servlet相关API:request,response,session,ServletContext）<br>业务层 —&gt;业务对象(service)<br>数据层 —&gt;操作数据库（DAO Data Access Object)(所有对数据库的操作不能跳出到DAO之外)<br><img src="/category/MVC/5.png" alt="MVC"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      MVC
    
    </summary>
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/categories/JavaWeb/"/>
    
      <category term="MVC" scheme="https://www.ysmjjsy.com/categories/JavaWeb/MVC/"/>
    
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-Servlet</title>
    <link href="https://www.ysmjjsy.com/category/Servlet/"/>
    <id>https://www.ysmjjsy.com/category/Servlet/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2019-09-17T09:10:26.352Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:12:06 GMT+0800 (GMT+08:00) --><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>每个Servlet都是唯一的，它们处理的请求都是不同的<br>浏览器把请求发送给不同的Servlet。Servlet是异步的线程不安全的。<br>单例，一个类只有一个对象</p><h2 id="Servlet调用过程？"><a href="#Servlet调用过程？" class="headerlink" title="Servlet调用过程？"></a><strong>Servlet调用过程？</strong></h2><ol><li>在浏览器输入地址，浏览器先去查找hosts文件，将主机名翻译为ip地址，如果找不到就再去查询dns服务器将主机名翻译成ip地址。</li><li>浏览器根据ip地址和端口号访问服务器，组织http请求信息发送给服务器。</li><li>服务器收到请求后首先根据Host请求头判断当前访问的是哪台虚拟主机。</li><li>服务器根据http请求头中的请求URI判断当前访问的是哪个web应用。</li><li>服务器根据http请求头中的请求URI判断当前访问的是web应用中的哪个web资源。</li><li>检查web应用的web.xml文件，如果根据路径找到具体的servlet处理类的全路径名交给该servlet处理,如果找不到就交给缺省servlet处理。</li><li>这个过程中浏览器只知道自己发出来http请求，不久就收到了http响应，浏览器不知道也不关心服务器内部是如何处理的。浏览器和服务器之间的关系是非常单纯的，只有HTTP协议。</li><li>解析请求、封装RequestResponse对象、创建Servlet、调用Service方法都是服务器自动进行的，开发人员只需要写好Servlet配置进容器中即可，无需操心具体的底层实现。</li></ol><h2 id="实现Servlet的方式："><a href="#实现Servlet的方式：" class="headerlink" title="实现Servlet的方式："></a><strong>实现Servlet的方式：</strong></h2><p>实现javax.servlet.Servlet接口</p><h2 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a><strong>生命周期方法</strong></h2><p>init(); 会在Servlet对象创建之后马上执行，并且执行一次<br>service()； 会被调用多次，每次处理请求都是在调用这个方法<br>destroy()；会在Servlet被销毁之前调用，并且只会被调用一次<br>ServletConfig()；获取Servlet配置信息<br>getServletInfo()；获取Servlet的信息<br>继承javax.servlet.GenericServlet类<br>继承javax.servlet.http.HttpServlet类<br>Servlet中的方法大多数不由我们来调用，而是由Tomcat来调用，并且Servlet的对象也由Tomcat来创建</p><h2 id="如何让浏览器访问Servlet"><a href="#如何让浏览器访问Servlet" class="headerlink" title="如何让浏览器访问Servlet"></a><strong>如何让浏览器访问Servlet</strong></h2><p>给Servlet指定一个Servlet路径（让Servlet与一个路径绑定在一起）<br>需要在web.xml中队Servlet进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>AServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>java.test.web.AServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>v1<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>AServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/AServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器访问Servlet路径</p><h2 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a><strong>ServletConfig</strong></h2><p>1个ServletConfig对象，对应一段web.xml中Servlet的配置信息<br>String getServletName():获取 <code>&lt;servlet-name&gt;&lt;/servlet-name&gt;</code><br>ServletContext getServletContext():获取Servlet上下文对象<br>String getInitParameter(String name):通过名称获取指定初始化参数的值<br>Enumeration getInitParameterNames()：获取所有初始化参数的名称</p><h2 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a><strong>GenericServlet</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServletConfig config;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest arg0, ServletResponse arg1)</span> throwsServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.config.getInitParameter(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">super</span>.getInitParameterNames();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.config;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.config.getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">super</span>.getServletInfo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.config.getServletName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.config=config;</span><br><span class="line">         init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CServlet</span> <span class="keyword">extends</span> <span class="title">BServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest arg0, ServletResponse arg1)</span> throwsServletException, IOException </span>&#123;</span><br><span class="line">         String value = <span class="keyword">super</span>.getInitParameter(<span class="string">"p1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a><strong>HttpServlet</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HttpServlet extends GenderServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest,ServletResponse)</span>--&gt;生命周期方法</span></span><br><span class="line"><span class="function">    <span class="comment">//强转两个参数为http协议相关的类型</span></span></span><br><span class="line"><span class="function">    <span class="comment">//调用本类的</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest,HttpServletResponse)</span>--&gt;参数已经是Http协议相关的，使用起来更加方便</span></span><br><span class="line"><span class="function">    <span class="comment">//它会通过request得到当前请求方式，例如：GET或POST</span></span></span><br><span class="line"><span class="function">    <span class="comment">//根据请求方式再调用doGet()或doPost()方法</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">doGet</span><span class="params">()</span></span>&#123;...&#125;重写</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doPost</span><span class="params">()</span></span>&#123;...&#125;重写</span><br><span class="line">    <span class="comment">//doGet和doPost由自己覆盖，如果没有覆盖，并且它们被调用了，那么会出现405</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Servlet细节"><a href="#Servlet细节" class="headerlink" title="Servlet细节"></a><strong>Servlet细节</strong></h2><p>Servlet只有一个实例对象，那么就有可能出现一个Servlet同时处理多个请求，那么Servlet就不是线程安全的，这说明Servlet的工作效率很高，但也存在线程安全问题<br>所以我们不应该Servlet中创建成员变量，因为可能会存在一个线程对这个成员进行写操作，另外一个线程对这个成员进行读操作<br>可以创建局部变量<br>可以创建无状态成员<br>可以创建有状态成员，但成员是可读的（去掉set方法）</p><p>让服务器在启动时就创建Servlet<br>默认情况下，服务器会在某个Servlet第一次请求时创建它，也可以在web.xml中对Servlet进行配置，使服务器启动时就创建Servlet<br>在<code>&lt;servlet&gt;</code>中配置<code>&lt;load-on-startup&gt;</code>(一个非负整数)<code>&lt;/load-on-startup&gt;</code></p><p><code>&lt;url-pattern&gt;&lt;/url-pattern&gt;</code><br>早期达到过滤功能给出多个url-pattern<br>通配符：路径匹配 ：/serlvet/<em> ，可以匹配任何前缀后缀<br>扩展名匹配 </em>.do<br>/<em> ：都匹配<br>“</em> “ 只能在两端不能在中间</p><h2 id="conf下的web-xml"><a href="#conf下的web-xml" class="headerlink" title="conf下的web.xml"></a><strong>conf下的web.xml</strong></h2><p>default:优先级最低，如果一个请求没人处理，它处理—&gt;404<br>jsp是jspServlet处理的<br>session的过期时间是30min</p><h2 id="Servlet与反射"><a href="#Servlet与反射" class="headerlink" title="Servlet与反射"></a><strong>Servlet与反射</strong></h2><p>访问Servlet，通过url-pattern找到，然后name匹配找到地址，反射拿到class</p><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a><strong>ServletContext</strong></h2><p>一个项目只有一个ServletContext对象<br>我们可以在多个Servlet中来获取这个唯一的对象，使用它可以给多个Servlet传递数据<br>在tomcat启动时创建，在tomcat关闭死去<br>服务器为每个应用创建一个ServletContext对象：</p><p>ServletContext对象的创建是在服务器启动时完成的<br>ServletContext对象的销毁是在服务器关闭时完成的<br>在整个web应用的动态资源之间共享数据<br>获取ServletContext对象</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getServletConfig.getServletContext();</span><br><span class="line"><span class="keyword">this</span>.getServletContext();</span><br><span class="line">       </span><br><span class="line">ServletConfig#getServletContext();</span><br><span class="line">GenericServletContext()#getServletContext();</span><br><span class="line">HttpSession#getServletContext();</span><br><span class="line">ServletContextEvent#getServletContext();</span><br></pre></td></tr></table></figure><h2 id="域对象的功能"><a href="#域对象的功能" class="headerlink" title="域对象的功能"></a><strong>域对象的功能</strong></h2><p>ServletContext是JavaWeb四大域对象之一，域对象就是用来在多个Servlet中传递数据，域对象必须有要存储数据的功能，有取数据的功能<br>四大域对象：PageContext,ServletRequest,HttpSession,ServletContext<br>域对象内部有一个Map，用来存储数据<br>ServletContext操作数据的方法：<br>void setAttribute(String name Object value):用来存储一个对象，也可以称之为存储一个域属性，如果多次调用该方法，并且使用相同的name，那么会覆盖上一次的值，这一特性与Map相同<br>Object getAttribute(String name):用来获取ServletContext中的数据<br>void removeAttribute(String name):用来移出ServletContext中的域属性，如果不存在，则什么都不做<br>Enumeration getAttributeNames():获取所有域属性的名称</p><h2 id="获取应用初始化参数"><a href="#获取应用初始化参数" class="headerlink" title="获取应用初始化参数"></a><strong>获取应用初始化参数</strong></h2><p>Servlet也可以获取初始化参数，但是它是局部参数，也就是说，一个Servlet只能获取自己的初始化参数，不能获取别人的，即初始化参数只为一个Servlet准备<br>可以配置公共的初始化参数，为所有的Servlet而用，使用ServletContext使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parm-name</span>&gt;</span><span class="tag">&lt;/<span class="name">parm-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parm-value</span>&gt;</span><span class="tag">&lt;/<span class="name">parm-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>得到ServletContext<br>调用getInitParameter(String)得到初始化参数</p><h2 id="获取资源路径"><a href="#获取资源路径" class="headerlink" title="获取资源路径"></a><strong>获取资源路径</strong></h2><p>获取真实路径<br>String path = this.getServletContext().getRealPath(“”);<br>得到的是有盘符的路径F:/xxx/xxx/xx<br>获取资源的路径后，创建流对象<br>this.getServletContext().getResourceAsStream(“/index.jsp”);<br>获取当前路径下所有资源的路径<br>this.getServletContext().getResourcePaths(“/WEB-INF”)</p><h2 id="获取类路径下的资源"><a href="#获取类路径下的资源" class="headerlink" title="获取类路径下的资源"></a><strong>获取类路径下的资源</strong></h2><p>获取类路径资源，对javaweb项目而言，就是/WEB-INF/classes和/WEB-INF/lib/每个jar包<br>得到ClassLoader</p><p>先得到CLass，再得到ClassLoader<br>调用其getResourceAsStream();得到一个InputStream<br>相对当前.class文件所在目录<br>加/相对于classes下</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p><strong>在web.xml中<code>&lt;url-pattren&gt;</code>路径</strong></p><p>Servlet路径<br>要么以”* “开头，要么以”/“开头</p><p><strong>转发和包含路径</strong><br>以”/“开头，相对当前项目路径</p><p><strong>重定向路径(客户端路径)</strong><br>以”/“开头，相对当前主机</p><p><strong>页面中超链接和表单路径</strong><br>与重定向相同，都是客户端路径，需要添加项目名</p><p><strong>ServletContext获取资源路径</strong><br>相对当前项目目录，即当前index.jsp所在目录</p><p><strong>ClassLoader获取资源路径</strong><br>相对classes目录</p><p><strong>Class获取资源路径</strong><br>以”/“开头相对classes目录<br>不以”/“开头，相对当前.class文件所在目录</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>常见的字符编码：iso-8859-1（不支持中文）<br>gbk（系统默认编码，中国的国际码）<br>utf-8（万国码，支持全世界的编码）</p><p><strong><em>响应编码</em></strong></p><ul><li>当使用respnse.getWrite()向客户端发送字符数据时，如果在之前没有设置编码，那么默认使用iso，因为iso不支持中文，一定乱码</li><li>在使用response.getWrite()之前使用response.setCharacterEncoding()来设置字符流的编码为gbk或utf-8，通常选择utf-8</li><li>在使用response.getWrite()之前使用response.setHeader(“Content-type”,”text/html;charset=utf-8”)来设置响应头，通知浏览器服务器这边使用的编码格式，并设置字符流编码</li><li>在getWrite()之前使用：<ul><li>setHeader(“Content-type”,”text/html;charset=utf-8”)的快捷方法是：setContentType(“text/html;charset=utf-8”)</li></ul></li></ul><p>就不会乱码</p><p><strong><em>请求编码</em></strong><br>客户端发送给服务器的请求参数，在请求这个页面时，服务器响应的编码是什么，那么客户端发送请求时的编码就是什么<br>服务器端默认使用ISO-8859-1来解码<br>请求编码处理分为两种：</p><p>GET和POST：GET请求参数不在请求体中，而POST请求参数在请求体中，所以它们的处理方式是不同的</p><p><strong>GET请求编码处理：</strong></p><blockquote><p>String username = new String(request.getParameter(“iso-8859-1”),”utf-8”);</p><p>在/cof/servler.xml中&lt;Connector port中，URIEncoding=:UTF-8”/&gt;配置URIEncoding=utf-8(不让用）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">反编回来</span><br><span class="line"><span class="keyword">byte</span>[] bytes[] = name.getBytes(<span class="string">"ISO-8859-1"</span>);</span><br><span class="line">name = <span class="keyword">new</span> String(bytes,<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure><p><u>URL最大长度2048，发送数据是URL一 部分，安全性较差</u></p><p><strong>POST请求编码处理：</strong><br>String username = new String(request.getParameter(“iso-8859-1”),”utf-8”);<br>在获取参数之前调用request.setCharacterEncoding(“utf-8”);</p><p><strong>URL编码</strong></p><p>表单的类型：Content-Type:application/x-www-form-urlencoded，就是把中文转换成%后面跟随两位的16进制<br>在客户端和服务器之间传递中文时需要把它转换成网络适合的方式<br>它不是字符编码<br>它是用来在客户端与服务器之间传递参数用的一种方式<br>URL编码需要先指定一个字符编码，把字符串解码后，得到byte[]，然后把小于0的字节+256，再转换成16进制，前面再添加%<br>POST请求默认使用URL编码，tomcat会自动使用URL解码<br>URL编码：String username = URLEncoder.encode(username,”utf-8”);<br>URL解码：String username = URLDecoder.decode(username,”utf-9”);</p><h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><ol><li>get请求用来从服务器上获得资源，而post是用来向服务器提交数据；</li><li>get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；</li><li>get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据， POST数据是没有限制的，上传文件通常要使用post方式；</li><li>使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</li><li>get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。</li><li>Jsp页面中的FORM标签里的method属性为get时调用doGet()，为post时调用doPost()。</li></ol><h2 id="在JS中-和-的区别？"><a href="#在JS中-和-的区别？" class="headerlink" title="在JS中==和===的区别？"></a>在JS中==和===的区别？</h2><hr><p>简单来说： == 代表相同， ===代表严格相同,为啥这么说呢，</p><p>这么理解： 当进行双等号比较时候：先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较，而===比较时， 如果类型不同，直接就是false.</p><h2 id="自动刷新-定时刷新"><a href="#自动刷新-定时刷新" class="headerlink" title="自动刷新,定时刷新"></a>自动刷新,定时刷新</h2><p>自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如：</p><p>Response.setHeader(“Refresh”,”1000;URL=<a href="http://localhost:8080/servlet/example.htm" target="_blank" rel="noopener">http://localhost:8080/servlet/example.htm</a>“);</p><p>其中1000为时间，单位为毫秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现没过一秒自动刷新本页面一次）</p><p>推荐博文：</p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3760336.html" target="_blank" rel="noopener">Servlet(一)</a></p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3763559.html" target="_blank" rel="noopener">Servlet(二)</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Servlet
    
    </summary>
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/categories/JavaWeb/"/>
    
      <category term="Servlet" scheme="https://www.ysmjjsy.com/categories/JavaWeb/Servlet/"/>
    
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-Tomcat</title>
    <link href="https://www.ysmjjsy.com/category/tomcat/"/>
    <id>https://www.ysmjjsy.com/category/tomcat/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2019-09-17T08:15:26.140Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:12:06 GMT+0800 (GMT+08:00) --><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p><a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br><strong><em>Tomcat目录</em></strong><br>bin：包含一些jar，bat文件<br>conf：tomcat的配置、server.xml、web.xml<br>lib：tomcat运行所需要的jar文件<br>logs：运行的日志文件<br>temp：临时文件<br>webapps：发布在tomcat服务器上的项目，就存放在这个目录<br>把这下面的每一个文件夹当成一个项目<br>在浏览器里访问资源，需要把资源放到webapps文件夹下。<br>work：jsp翻译成java文件存放地<br><strong>配置虚拟路径发布资源到服务器</strong><br>在con/server.xml找到host元素节点<br>加入:<br>&lt;Context docBase=”E:*<strong> path=”/a”&gt;<context><br>docBase：项目的路径地址<br>path：对应的访问方式：<a href="http://localhost:8080/a/???" target="_blank" rel="noopener">http://localhost:8080/a/???</a>;</context></strong>配置虚拟路径2**<br>在apache-tomcat-7.0.92\conf\Catalina\localhost/文件夹下新建一个xml文件，名字可以自己定义 ??.xml</p><p>在这个文件里面写入:<br>&lt;?xml version=’1,0’ encoding=’UTF-8’?&gt;<br><context dobase="??:\???"></context></p><h2 id="Tomcat顶层架构"><a href="#Tomcat顶层架构" class="headerlink" title="Tomcat顶层架构"></a>Tomcat顶层架构</h2><p><img src="/category/tomcat/1.png" alt="tomcat"></p><p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，用于具体提供服务。</p><p>Service主要包含两个部分：Connector和Container。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下：</p><ol><li><strong>Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化;</strong></li><li><strong>Container用于封装和管理Servlet，以及具体处理Request请求；</strong></li></ol><p>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接,示意图如下（Engine、Host、Context下边会说到）：<img src="/category/tomcat/2.png" alt="tomcat"></p><p>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由 Server 控制。</p><p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的server.xml配置文件中看出，下图是删除了注释内容之后的一个完整的server.xml配置文件（Tomcat版本为8.5）</p><p><img src="/category/tomcat/3.png" alt="tomcat"></p><p>详细的配置文件文件内容可以到<a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html" target="_blank" rel="noopener">Tomcat官网</a>查看</p><p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p><p><img src="/category/tomcat/4.png" alt="tomcat"></p><p>Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置，一个Service有多个，Service左边的内容都属于Container的，Service下边是Connector。</p><h3 id="Tomcat顶层架构小结："><a href="#Tomcat顶层架构小结：" class="headerlink" title="Tomcat顶层架构小结："></a>Tomcat顶层架构小结：</h3><ol><li>Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；</li><li>Server掌管着整个Tomcat的生死大权；</li><li>Service 是对外提供服务的；</li><li>Connector用于接受请求并将请求封装成Request和Response来具体处理；</li><li>Container用于封装和管理Servlet，以及具体处理request请求；</li></ol><p>知道了整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下Connector和Container。</p><h3 id="Connector和Container的微妙关系"><a href="#Connector和Container的微妙关系" class="headerlink" title="Connector和Container的微妙关系"></a>Connector和Container的微妙关系</h3><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！</p><p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！</p><p>Tomcat既然处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！</p><h3 id="Connector架构分析"><a href="#Connector架构分析" class="headerlink" title="Connector架构分析"></a>Connector架构分析</h3><p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。</p><p>因此，我们可以把Connector分为四个方面进行理解：</p><ol><li>Connector如何接受请求的？</li><li>如何将请求封装成Request和Response的？</li><li>封装完之后的Request和Response如何交给Container进行处理的？</li><li>Container处理完之后如何交给Connector并返回给客户端的？</li></ol><p>首先看一下Connector的结构图，如下所示：</p><p><img src="/category/tomcat/5.png" alt="tomcat"></p><p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。</p><p>其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。</p><ol><li>Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。</li><li>Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。</li><li>Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。</li></ol><p>至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？</p><h3 id="Container架构分析"><a href="#Container架构分析" class="headerlink" title="Container架构分析"></a>Container架构分析</h3><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器，结构图如下：</p><p><img src="/category/tomcat/6.png" alt="tomcat"></p><p>4个子容器的作用分别是：</p><ol><li>Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；</li><li>Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；</li><li>Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；</li><li>Wrapper：每一Wrapper封装着一个Servlet；</li></ol><p>下面找一个Tomcat的文件目录对照一下，如下图所示：</p><p><img src="/category/tomcat/7.png" alt="tomcat"></p><p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。</p><p>我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：www.goya.com,如果是Host（webapps）下的其他应用，则可以使用www.goya.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。</p><p>看到这里我们知道Container是什么，但是还是不知道Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！</p><h3 id="Container如何处理请求的"><a href="#Container如何处理请求的" class="headerlink" title="Container如何处理请求的"></a>Container如何处理请求的</h3><p>Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意）</p><p>Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。<br><img src="/category/tomcat/8.png" alt="tomcat"></p><p>但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p><ol><li>每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做BaseValve，BaseValve是不可删除的；</li></ol><ol><li>在上层容器的管道的BaseValve中会调用下层容器的管道。</li></ol><p>我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve。Pipeline的处理流程图如下</p><p><img src="/category/tomcat/9.png" alt="tomcat"></p><ol><li>Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）；</li><li>在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。</li><li>当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！</li><li>当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</li></ol><p>推荐博文：</p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3734395.html" target="_blank" rel="noopener">Tomcat(一)</a></p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3744053.html" target="_blank" rel="noopener">Tomcat(二)</a></p><p><a href="https://blog.csdn.net/yangwenxue_admin/article/details/72845360" target="_blank" rel="noopener">Tomcat集群</a></p><p><a href="https://blog.csdn.net/Ediwal/article/details/47779971" target="_blank" rel="noopener">Nginx+Tomcat集群搭建</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      tomcat
    
    </summary>
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/categories/JavaWeb/"/>
    
      <category term="Tomcat" scheme="https://www.ysmjjsy.com/categories/JavaWeb/Tomcat/"/>
    
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-Http协议</title>
    <link href="https://www.ysmjjsy.com/category/Http/"/>
    <id>https://www.ysmjjsy.com/category/Http/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2019-09-17T08:15:36.710Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:12:06 GMT+0800 (GMT+08:00) --><p><strong>请求头</strong></p><p>请求行<br>多个请求头信息:头名称:头值<br>空行<br>请求体</p><p><strong>响应头</strong></p><p>响应行(协议/版本 状态码 状态码的解析)<br>响应头(key/value格式)<br>空行<br>响应正文</p><p><strong>正文</strong></p><p>表单是一大堆内容，而发送给服务器的只有一行字符串</p><p>POST请求可以有体，GET请求不能有请求体</p><p>Referer: 请求来自哪个页面</p><p>Content-Type:application/x-www-form-urlencoded</p><p>表单数据类型，说明会使用url格式编码数据；url编码的数据都是以%为前缀，后面跟随两位的16进制</p><p>Content-Length:13:</p><p>请求体的长度</p><p>keyword = hello;</p><p>请求体内容</p><p>200：请求成功<br>404：请求的资源没有找到，说明客户端错误的请求了不存在的资源<br>500：请求资源找到了，但是服务器内部出现了错误<br>302：重定向，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应体Location，它指定了新请求的URL地址</p><p><strong>什么是http协议：</strong></p><p>HTTP协议就是一套基于tcp/ip协议的应用层协议<br>。简单来说，就是一个基于应用层的通信规范，双方要进行通信，大家都要遵守一个规范，这个规范就是HTTP协议。它规定了客户端（通常是浏览器）和服务器之间的通信方式。</p><p><strong>HTTP协议工作原理？</strong></p><p>HTTP协议基于请求响应模型。</p><p>一次请求对应一次响应。</p><p>首先客户端发送一个请求(request)给服务器，服务器在接收到这个请求后将生成一个响应(response)返回给客户端。</p><p><strong>HTTP协议的特点是什么 ?</strong></p><ol><li>它是一个无状态的协议，服务器端在处理相应请求后不会保留任何客户端的信息，每次请求都是独立的</li><li>客户端与服务器端的每一次数据交互，都要经过一次请求/响应的过程。</li><li>服务器端无法识别能够出发客户端请求的方法。</li><li>一个典型的HTTP请求分为 一个请求行 若干请求头 一个空行 实体内容。</li></ol><p><strong>get和post请求的区别？</strong></p><ol><li>get请求用来从服务器上获得资源，而post是用来向服务器提交数据；</li><li>get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；</li><li>get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据， POST数据是没有限制的，上传文件通常要使用post方式；</li><li>使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</li><li>get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。</li><li>Jsp页面中的FORM标签里的method属性为get时调用doGet()，为post时调用doPost()</li></ol><p><strong>Http和Https的区别？</strong></p><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>推荐博文：</p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3729033.html" target="_blank" rel="noopener">WEB开发入门</a></p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3751277.html" target="_blank" rel="noopener">Http协议</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Http协议
    
    </summary>
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/categories/JavaWeb/"/>
    
      <category term="Http协议" scheme="https://www.ysmjjsy.com/categories/JavaWeb/Http%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-代理</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E4%BB%A3%E7%90%86/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-代理/</id>
    <published>2018-03-02T16:00:00.000Z</published>
    <updated>2019-09-16T09:12:18.807Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 16 2019 17:55:59 GMT+0800 (GMT+08:00) --><h1 id="Java三种代理"><a href="#Java三种代理" class="headerlink" title="Java三种代理"></a>Java三种代理</h1><h2 id="代理模式介绍"><a href="#代理模式介绍" class="headerlink" title="代理模式介绍"></a>代理模式介绍</h2><p>代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p><p>通过使用代理，通常有两个优点，并且能够分别与我们提到的微商代理的两个特点对应起来：</p><p>优点一：可以隐藏委托类的实现;</p><p>优点二：可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。</p><p><strong>代理模式</strong>：给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。</p><p>代理模式角色分为 3 种：</p><p><strong>Subject（抽象主题角色）</strong>：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</p><p><strong>RealSubject（真实主题角色</strong>）：真正实现业务逻辑的类；</p><p><strong>Proxy（代理主题角色）</strong>：用来代理和封装真实主题；</p><p>代理模式的结构比较简单，其核心是代理类，为了让客户端能够<strong>一致性地对待</strong>真实对象和代理对象，在代理模式中引入了抽象层</p><p><strong>代理模式UML类图</strong></p><p><img src="/category/JavaSE-代理/1.png" alt="代理"></p><p>代理模式<strong>按照职责</strong>（使用场景）来分类，至少可以分为以下几类：1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理等等。</p><p>如果<strong>根据字节码的创建时机</strong>来分类，可以分为静态代理和动态代理：</p><ul><li>所谓<strong>静态</strong>也就是在<strong>程序运行前</strong>就已经存在代理类的<strong>字节码文件</strong>，代理类和真实主题角色的关系在运行前就确定了。</li><li>而动态代理的源码是在程序运行期间由<strong>JVM</strong>根据反射等机制<strong>动态的生成</strong>，所以在运行前并不存在代理类的字节码文件</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p><ol><li>当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</li></ol><ul><li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong></li><li>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong></li></ul><ol><li>当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护</strong>。</li></ol><p>编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"查询 selectById"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新 update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将通过静态代理对 UserServiceImpl 进行功能增强，在调用 <code>select</code> 和 <code>update</code> 之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserService proxy = <span class="keyword">new</span> UserServiceProxy(userServiceImpl);</span><br><span class="line"></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>]</span><br></pre></td></tr></table></figure><p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><strong>为什么类可以动态的生成？</strong></p><p>这就涉及到Java虚拟机的<strong>类加载机制</strong>了，推荐翻看《深入理解Java虚拟机》7.3节 类加载的过程。</p><p>Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下3件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据访问入口</li></ol><p>由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，<strong>获取类的二进制字节流</strong>（class字节码）就有很多途径：</p><ul><li>从ZIP包获取，这是JAR、EAR、WAR等格式的基础</li><li>从网络中获取，典型的应用是 Applet</li><li><strong>运行时计算生成</strong>，这种场景使用最多的是动态代理技术，在 java.lang.reflect.Proxy 类中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流</li><li>由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类</li><li>从数据库中获取等等</li></ul><p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。</p><h4 id="常见的字节码操作类库"><a href="#常见的字节码操作类库" class="headerlink" title="常见的字节码操作类库"></a>常见的字节码操作类库</h4><blockquote><p>这里有一些介绍：<a href="https://link.juejin.im?target=https%3A%2F%2Fjava-source.net%2Fopen-source%2Fbytecode-libraries" target="_blank" rel="noopener">java-source.net/open-source…</a></p><p>Apache BCEL (Byte Code Engineering Library)：是Java classworking广泛使用的一种框架，它可以深入到JVM汇编语言进行类操作的细节。</p><p>ObjectWeb ASM：是一个Java字节码操作框架。它可以用于直接以二进制形式动态生成stub根类或其他代理类，或者在加载时动态修改类。</p><p>CGLIB(Code Generation Library)：是一个功能强大，高性能和高质量的代码生成库，用于扩展JAVA类并在运行时实现接口。</p><p>Javassist：是Java的加载时反射系统，它是一个用于在Java中编辑字节码的类库; 它使Java程序能够在运行时定义新类，并在JVM加载之前修改类文件。</p><p>…</p></blockquote><h4 id="实现动态代理的思考方向"><a href="#实现动态代理的思考方向" class="headerlink" title="实现动态代理的思考方向"></a>实现动态代理的思考方向</h4><p>为了让生成的代理类与目标对象（真实主题角色）保持一致性，从现在开始将介绍以下两种最常见的方式：</p><ol><li>通过实现接口的方式 -&gt; JDK动态代理</li><li>通过继承类的方式 -&gt; CGLIB动态代理</li></ol><p>注：使用ASM对使用者要求比较高，使用Javassist会比较麻烦</p><h4 id="newProxyInstance"><a href="#newProxyInstance" class="headerlink" title="newProxyInstance"></a>newProxyInstance</h4><p><img src="/category/JavaSE-代理/2.png" alt="daili"><br>在运行时，动态实现一组指定的接口的实现类对象（在运行时，创建实现了指定的一组接口的对象）</p><p><code>Object proxyObject = Poxy.newProxyInstance(ClassLoader classLoader,Class[] interfaces,InvocationHandler h)</code><br>ClassLoader：类加载器<br>用来加载类的，把.class文件加载到内存，形成Class对象<br>Class[] interfaces：指定要实现的接口们<br>InvocationHandler：代理对象的所有方法（个别不执行，getClass()）都会调用InvocationHandler的invoke()方法</p><h4 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h4><p><code>public Object invoke(Object proxy,Method method,Object[] args);</code><br>这个invoke方法在什么时候被调用！<br>在调用代理对象所实现接口中的方法时调用<br>Object proxy：当前对象，在调用谁的方法<br>Method method：当前被调用的方法（目标方法）<br>Object[] args：实参！</p><p><img src="/category/JavaSE-代理/3.png" alt="daili"></p><p><img src="/category/JavaSE-代理/4.png" alt="daili"></p><p><img src="/category/JavaSE-代理/5.png" alt="daili"></p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code>，我们仍然通过案例来学习</p><p>编写一个调用逻辑处理器 LogHandler 类，提供日志增强功能，并实现 InvocationHandler 接口；在 LogHandler 中维护一个目标对象，这个对象是被代理的对象（真实主题角色）；在 <code>invoke</code> 方法中编写方法调用的逻辑处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Object target;  <span class="comment">// 被代理的对象，实际的方法执行者</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = method.invoke(target, args);  <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之前执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之后执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写客户端，获取动态生成的代理类的对象须借助 Proxy 类的 newProxyInstance 方法，具体步骤可见代码和注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"><span class="keyword">import</span> proxy.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span></span><br><span class="line">        <span class="comment">// System.getProperties().setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");</span></span><br><span class="line">        <span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class="line">        UserServiceImpl userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        <span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class="line">        Class[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class="line">        <span class="comment">//     这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span></span><br><span class="line">        InvocationHandler logHandler = <span class="keyword">new</span> LogHandler(userServiceImpl);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">   5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class="line"><span class="comment">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class="line"><span class="comment">               b.然后根据相应的字节码转换成对应的class，</span></span><br><span class="line"><span class="comment">               c.然后调用newInstance()创建代理实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line">        <span class="comment">// 调用代理的方法</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">        <span class="comment">// ProxyUtils.generateClassFile(userServiceImpl.getClass(), "UserServiceProxy");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>] </span><br><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>]</span><br></pre></td></tr></table></figure><p>InvocationHandler 和 Proxy 的主要方法介绍如下：</p><p><strong>java.lang.reflect.InvocationHandler</strong></p><p><code>Object invoke(Object proxy, Method method, Object[] args)</code> 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</p><p><strong>java.lang.reflect.Proxy</strong></p><p><code>static InvocationHandler getInvocationHandler(Object proxy)</code> 用于获取指定代理对象所关联的调用处理器</p><p><code>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</code> 返回指定接口的代理类</p><p><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code> 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</p><p><code>static boolean isProxyClass(Class&lt;?&gt; cl)</code> 返回 cl 是否为一个代理类</p><h4 id="代理类的调用过程"><a href="#代理类的调用过程" class="headerlink" title="代理类的调用过程"></a>代理类的调用过程</h4><p>生成的代理类到底长什么样子呢？借助下面的工具类，把代理类保存下来再探个究竟<br>（通过设置环境变量sun.misc.ProxyGenerator.saveGeneratedFiles=true也可以保存代理类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.ProxyGenerator;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将根据类信息动态生成的二进制字节码保存到硬盘中，默认的是clazz目录下</span></span><br><span class="line"><span class="comment">     * params: clazz 需要生成动态代理类的类</span></span><br><span class="line"><span class="comment">     * proxyName: 为动态生成的代理类的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateClassFile</span><span class="params">(Class clazz, String proxyName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据类信息和提供的代理类名称，生成字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces());</span><br><span class="line">        String paths = clazz.getResource(<span class="string">"."</span>).getPath();</span><br><span class="line">        System.out.println(paths);</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//保留到硬盘中</span></span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(paths + proxyName + <span class="string">".class"</span>);</span><br><span class="line">            out.write(classFile);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Client2 测试类的main的最后面加入一行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">ProxyUtils.generateClassFile(userServiceImpl.getClass(), <span class="string">"UserServiceProxy"</span>);</span><br></pre></td></tr></table></figure><p>IDEA 再次运行之后就可以在 target 的类路径下找到 UserServiceProxy.class，双击后IDEA的反编译插件会将该二进制class文件</p><p><img src="/category/JavaSE-代理/6.png" alt="daili"></p><p>UserServiceProxy 的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">"proxy.UserService"</span>).getMethod(<span class="string">"select"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"proxy.UserService"</span>).getMethod(<span class="string">"update"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 UserServiceProxy 的代码中我们可以发现：</p><ul><li>UserServiceProxy 继承了 Proxy 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法</li><li>由于 UserServiceProxy 继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器</li><li>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</li><li>每个方法都有一个 Method 对象来描述，Method 对象在static静态代码块中创建，以 <code>m + 数字</code> 的格式命名</li><li>调用方法的时候通过 <code>super.h.invoke(this, m1, (Object[])null);</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 LogHandler 对象，它继承 InvocationHandler 类，负责实际的调用处理逻辑</li></ul><p>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    before();</span><br><span class="line">    Object result = method.invoke(target, args);       <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">    after();</span><br><span class="line">    <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK动态代理执行方法调用的过程简图如下：</p><p><img src="/category/JavaSE-代理/7.png" alt="daili"></p><h4 id="动态代理的秘密"><a href="#动态代理的秘密" class="headerlink" title="动态代理的秘密"></a>动态代理的秘密</h4><p>一定有同学对于为什么 Proxy 能够动态产生不同接口类型的代理感兴趣，我的猜测是肯定通过传入进去的接口然后通过反射动态生成了一个接口实例。<br>比如 SellWine 是一个接口，那么 Proxy.newProxyInstance() 内部肯定会有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SellWine();</span><br></pre></td></tr></table></figure><p>这样相同作用的代码，不过它是通过反射机制创建的。那么事实是不是这样子呢？直接查看它们的源码好了。需要说明的是，我当前查看的源码是 1.8 版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>newProxyInstance 的确创建了一个实例，它是通过 cl 这个 Class 文件的构造方法反射生成。cl 由 getProxyClass0() 方法获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接通过缓存获取，如果获取不到，注释说会通过 ProxyClassFactory 生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A factory function that generates, defines and returns the proxy class given</span></span><br><span class="line"><span class="comment">     * the ClassLoader and array of interfaces.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Proxy class 的前缀是 “$Proxy”，</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next number to use for generation of unique proxy class names</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Verify that the class loader resolves the name of this</span></span><br><span class="line"><span class="comment">                 * interface to the same Class object.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Verify that the Class object actually represents an</span></span><br><span class="line"><span class="comment">                 * interface.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Verify that this interface is not a duplicate.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">            <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Record the package of a non-public proxy interface so that the</span></span><br><span class="line"><span class="comment">             * proxy class will be defined in the same package.  Verify that</span></span><br><span class="line"><span class="comment">             * all non-public proxy interfaces are in the same package.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">                <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">                <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                    accessFlags = Modifier.FINAL;</span><br><span class="line">                    String name = intf.getName();</span><br><span class="line">                    <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                    String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        proxyPkg = pkg;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">                proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">            String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces, accessFlags);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                    proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">                 * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">                 * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">                 * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">                 * exceeded).</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个类的注释说，通过指定的 ClassLoader 和 接口数组 用工厂方法生成 proxy class。 然后这个 proxy class 的名字是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Proxy class 的前缀是 “$Proxy”，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line"></span><br><span class="line">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br></pre></td></tr></table></figure><p>所以，动态生成的代理类名称是<strong>包名+$Proxy+id序号</strong>。</p><p>生成的过程，核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces, accessFlags);</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line"><span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                    proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br></pre></td></tr></table></figure><p>这两个方法，我没有继续追踪下去，defineClass0() 甚至是一个 native 方法。我们只要知道，动态创建代理这回事就好了。</p><p>现在我们还需要做一些验证，我要检测一下动态生成的代理类的名字是不是<strong>包名+$Proxy+id序号</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">MaotaiJiu maotaijiu = <span class="keyword">new</span> MaotaiJiu();</span><br><span class="line"></span><br><span class="line">Wuliangye wu = <span class="keyword">new</span> Wuliangye();</span><br><span class="line"></span><br><span class="line">Furongwang fu = <span class="keyword">new</span> Furongwang();</span><br><span class="line"></span><br><span class="line">InvocationHandler jingxiao1 = <span class="keyword">new</span> GuitaiA(maotaijiu);</span><br><span class="line">InvocationHandler jingxiao2 = <span class="keyword">new</span> GuitaiA(wu);</span><br><span class="line"></span><br><span class="line">InvocationHandler jingxiao3 = <span class="keyword">new</span> GuitaiA(fu);</span><br><span class="line"></span><br><span class="line">SellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),</span><br><span class="line">MaotaiJiu.class.getInterfaces(), jingxiao1);</span><br><span class="line">SellWine dynamicProxy1 = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),</span><br><span class="line">MaotaiJiu.class.getInterfaces(), jingxiao2);</span><br><span class="line"></span><br><span class="line">dynamicProxy.mainJiu();</span><br><span class="line"></span><br><span class="line">dynamicProxy1.mainJiu();</span><br><span class="line"></span><br><span class="line">SellCigarette dynamicProxy3 = (SellCigarette) Proxy.newProxyInstance(Furongwang.class.getClassLoader(),</span><br><span class="line">Furongwang.class.getInterfaces(), jingxiao3);</span><br><span class="line"></span><br><span class="line">dynamicProxy3.sell();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"dynamicProxy class name:"</span>+dynamicProxy.getClass().getName());</span><br><span class="line">System.out.println(<span class="string">"dynamicProxy1 class name:"</span>+dynamicProxy1.getClass().getName());</span><br><span class="line">System.out.println(<span class="string">"dynamicProxy3 class name:"</span>+dynamicProxy3.getClass().getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">销售开始  柜台是： GuitaiA</span><br><span class="line">我卖得是茅台酒。</span><br><span class="line">销售结束</span><br><span class="line">销售开始  柜台是： GuitaiA</span><br><span class="line">我卖得是五粮液。</span><br><span class="line">销售结束</span><br><span class="line">销售开始  柜台是： GuitaiA</span><br><span class="line">售卖的是正宗的芙蓉王，可以扫描条形码查证。</span><br><span class="line">销售结束</span><br><span class="line"></span><br><span class="line">dynamicProxy class name:com.sun.proxy.$Proxy0</span><br><span class="line">dynamicProxy1 class name:com.sun.proxy.$Proxy0</span><br><span class="line">dynamicProxy3 class name:com.sun.proxy.$Proxy1</span><br></pre></td></tr></table></figure><p>SellWine 接口的代理类名是：com.sun.proxy.$Proxy0<br>SellCigarette 接口的代理类名是：com.sun.proxy.$Proxy1</p><p>这说明动态生成的 proxy class 与 Proxy 这个类同一个包。</p><p>下面用一张图让大家记住动态代理涉及到的角色。<br><img src="/category/JavaSE-代理/10.png" alt="daili"></p><p>红框中 <code>$Proxy0</code>就是通过 Proxy 动态生成的。<br><code>$Proxy0</code>实现了要代理的接口。<br><code>$Proxy0</code>通过调用 <code>InvocationHandler</code>来执行任务。</p><h2 id="cglib代理"><a href="#cglib代理" class="headerlink" title="cglib代理"></a>cglib代理</h2><p><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">cglib</a> (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。</p><p><strong>cglib特点</strong></p><ul><li>JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。<br>如果想代理没有实现接口的类，就可以使用CGLIB实现。</li><li>CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。<br>它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。</li><li>CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。<br>不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉。</li></ul><p>cglib与动态代理最大的<strong>区别</strong>就是</p><ul><li>使用动态代理的对象必须实现一个或多个接口</li><li>使用cglib代理的对象则无需实现接口，达到代理类无侵入。</li></ul><p>使用cglib需要引入<a href="https://repo1.maven.org/maven2/cglib/cglib/3.2.5/cglib-3.2.5.jar" target="_blank" rel="noopener">cglib的jar包</a>，如果你已经有spring-core的jar包，则无需引入，因为spring中包含了cglib。</p><ul><li>cglib的Maven坐标</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>maven引入CGLIB包，然后编写一个UserDao类，它没有接口，只有两个方法，select() 和 update()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDao 查询 selectById"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDao 更新 update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个 LogInterceptor ，继承了 MethodInterceptor，用于方法的拦截回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 表示要进行增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 表示拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);   <span class="comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DaoProxy daoProxy = <span class="keyword">new</span> DaoProxy(); </span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Dao.class);  <span class="comment">// 设置超类，cglib是通过继承来实现的</span></span><br><span class="line">        enhancer.setCallback(daoProxy);</span><br><span class="line"></span><br><span class="line">        Dao dao = (Dao)enhancer.create();   <span class="comment">// 创建代理类</span></span><br><span class="line">        dao.update();</span><br><span class="line">        dao.select();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>] </span><br><span class="line">log start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>]</span><br></pre></td></tr></table></figure><p>还可以进一步多个 MethodInterceptor 进行过滤筛选</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor2</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log2 start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log2 end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调过滤器: 在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFilter</span> <span class="keyword">implements</span> <span class="title">CallbackFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"select"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// Callback 列表第1个拦截器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// Callback 列表第2个拦截器，return 2 则为第3个，以此类推</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LogInterceptor logInterceptor = <span class="keyword">new</span> LogInterceptor();</span><br><span class="line">        LogInterceptor2 logInterceptor2 = <span class="keyword">new</span> LogInterceptor2();</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserDao.class);   <span class="comment">// 设置超类，cglib是通过继承来实现的</span></span><br><span class="line">        enhancer.setCallbacks(<span class="keyword">new</span> Callback[]&#123;logInterceptor, logInterceptor2, NoOp.INSTANCE&#125;);   <span class="comment">// 设置多个拦截器，NoOp.INSTANCE是一个空拦截器，不做任何处理</span></span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> DaoFilter());</span><br><span class="line"></span><br><span class="line">        UserDao proxy = (UserDao) enhancer.create();   <span class="comment">// 创建代理类</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>] </span><br><span class="line">log2 start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log2 end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>]</span><br></pre></td></tr></table></figure><p>CGLIB 创建动态代理类的模式是：</p><ol><li>查找目标类上的所有非final 的public类型的方法定义；</li><li>将这些方法的定义转换成字节码；</li><li>将组成的字节码转换成相应的代理的class对象；</li><li>实现 MethodInterceptor接口，用来处理对代理类上所有方法的请求</li></ol><h2 id="JDK动态代理与CGLIB动态代理对比"><a href="#JDK动态代理与CGLIB动态代理对比" class="headerlink" title="JDK动态代理与CGLIB动态代理对比"></a>JDK动态代理与CGLIB动态代理对比</h2><p>JDK动态代理：基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。</p><p>cglib动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。</p><p>JDK Proxy 的优势：</p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</li><li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li><li>代码实现简单。</li></ul><p>基于类似 cglib 框架的优势：</p><ul><li>无需实现接口，达到代理类无侵入</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li><li>高性能</li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p><strong>描述动态代理的几种实现方式？分别说出相应的优缺点</strong></p><p>代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK动态代理” 和 “CGLIB动态代理” 实现。</p><p><strong>静态代理</strong>：代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object</p><ul><li><strong>优点</strong>：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。</li><li><strong>缺点</strong>：不同的接口要有不同的代理类实现，会很冗余</li></ul><p><strong>JDK 动态代理</strong>：</p><ul><li>为了解决静态代理中，生成大量的代理类造成的冗余；</li><li>JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，</li><li>jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象</li><li>jdk动态代理之所以<strong>只能代理接口</strong>是因为<strong>代理类本身已经extends了Proxy，而java是不允许多重继承的</strong>，但是允许实现多个接口</li><li><strong>优点</strong>：解决了静态代理中冗余的代理实现类问题。</li><li><strong>缺点</strong>：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</li></ul><p><strong>CGLIB 代理</strong>：</p><ul><li>由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；</li><li>CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。</li><li>实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。</li><li>但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。</li><li>同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。</li><li><strong>优点</strong>：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。</li><li><strong>缺点</strong>：技术实现相对难理解些。</li></ul><h3 id="CGlib-对接口实现代理？"><a href="#CGlib-对接口实现代理？" class="headerlink" title="CGlib 对接口实现代理？"></a>CGlib 对接口实现代理？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建代理类的工厂 该类要实现 MethodInterceptor 接口。</span></span><br><span class="line"><span class="comment"> * 该类中完成三样工作：</span></span><br><span class="line"><span class="comment"> * （1）声明目标类的成员变量，并创建以目标类对象为参数的构造器。用于接收目标对象</span></span><br><span class="line"><span class="comment"> * （2）定义代理的生成方法，用于创建代理对象。方法名是任意的。代理对象即目标类的子类</span></span><br><span class="line"><span class="comment"> * （3）定义回调接口方法。对目标类的增强这在这里完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明目标类的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGLibFactory</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义代理的生成方法,用于创建代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">myCGLibCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 为代理对象设置父类，即指定目标类</span></span><br><span class="line">        enhancer.setSuperclass(UserService.class);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置回调接口对象 注意，只所以在setCallback()方法中可以写上this，</span></span><br><span class="line"><span class="comment">         * 是因为MethodIntecepter接口继承自Callback，是其子接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (UserService) enhancer.create();<span class="comment">// create用以生成CGLib代理对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start invoke "</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"end invoke "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://juejin.im/post/5c1ca8df6fb9a049b347f55c" target="_blank" rel="noopener">Java 动态代理详解</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE代理,动态代理,cblib代理
    
    </summary>
    
      <category term="JavaSE" scheme="https://www.ysmjjsy.com/categories/JavaSE/"/>
    
      <category term="JavaSE代理" scheme="https://www.ysmjjsy.com/categories/JavaSE/JavaSE%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>学习路线v2.0</title>
    <link href="https://www.ysmjjsy.com/category/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>https://www.ysmjjsy.com/category/学习路线/</id>
    <published>2018-03-02T16:00:00.000Z</published>
    <updated>2019-09-17T10:29:31.425Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 18:30:24 GMT+0800 (GMT+08:00) --><h1 id="关于Java学习路线"><a href="#关于Java学习路线" class="headerlink" title="关于Java学习路线"></a>关于Java学习路线</h1><p><img src="/category/学习路线/1.png" alt="学习路线"><br>这条图可以说是比较新比较合适的，当然这不牵扯大数据部分。只能说在学习路线上来说属于主流。<br>自己在看了很多培训机构的学习视频之后也相对总结下来比较好的学习视频，以及学习路线。这里不涉及知识点，只是分享自己认为不错的视频</p><h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2><p>这一部分有些人选择看书。<br>《Head First Java》是一本入门比较好的书，通俗易懂，像看小儿书一样。<br>很多人都会推荐《Java编程思想》。但实际来说对于新手并不友好，甚至你没编程语言基础《Java核心技术卷》看都会比较吃力。当然这两本书在你有一定基础后看还是有很大的提升。<br>可以找一本Java程序设计之类的书先看着，学会基本语法，了解什么面向对象，再来啃上面两本书也不错。<br>之前在学校图书馆有看到很多类似的程序设计相关的。还有比较火的《Java从入门到精通》，太厚了。简直真的就是从入门到放弃。<br>自己当时在学校先学的C，当时虽然跟着敲，可敲的是什么，为什么会显示这样，还是云里雾里。所以可以自己在网上找找编程语言之类的介绍，了解一下这方面历史技术，这对于基础素质有很大帮助。要是懂一些计算机原理，网络原理，数据库原理那就更好了。<br>在JavaSE基础方面，还是需要下些功夫，可以看视频+书，当然比较费劲，建议视频过一遍，然后整理出笔记，再看一遍，最后看书贯通一下，这是最稳的。至于SE的路线，视频里书里也都可以了，学完之后看一下Java高并发，JUC，Java新特性了解一下。<br><strong>推荐视频：</strong><br>我自己看过的《传智刘意的JavaSE》虽然有些老了，但是基础是不会变的，看到有很多人推荐《马士兵》的视频，我觉得也不错。<br>看完还可以看看阿里云大学官网上的JavaSE视频，里面有些点讲的也是真的细真的好，当是补充。<br>同时可以看看张龙的java8新特性<br><strong>推荐书：</strong><br>《Head First Java》建议可以从零看<br>《Java核心技术卷一》<br>《Java核心技术卷二》<br>《Java编程思想》不建议一开始就看<br><strong>重点：</strong><br>面向对象原理<br>String、Object这两个类<br>Collection集合与Map容器以及底层<br>IO流<br>Java多线程<br>网络编程Socket<br>反射<br>注解<br>泛型<br>代理模式<br>JUC<br>NIO<br>Java8新特性：Lambda表达式，函数式编程等</p><p>这里可以接下数据结构和设计模式，也可以在之后回头来看</p><p>韩顺平的数据结构</p><h2 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><p>自己当然看完JavaSE之后陷入一点迷茫，接下来该学什么就不知道了，只能在网上找视频，找路线，找资料。当看到崔希凡的JavaWeb之后才知道原来路线是这样。<br>所以这里也推荐《崔希凡JavaWeb视频》，应该是东北人，讲话蛮有趣，很幽默<br>其实在最早期自己刚学Java就知道Java的三个版本：JavaSE、JavaEE、JavaME。<br>而对于一个Java开发工程师JavaWeb肯定是必学的，之后的SSH、SSM框架可以看作是对JavaWeb的一种封装。<br>这里没什么好说的，当学完JavaWeb学习模式基本自己已经摸索出来了，继续跟着学就行。<br>这里比较重点的：Http协议，Tomcat服务器，Servlet，Session，Cookie，Jsp，JDBC，监听器Listener，过滤器Filter，理解SpringMVC思想，其中崔希凡十四天课程必须好好看一遍，那讲了MVC分层思想。还可以着重看看邮件发送，文件上传下载。</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>当学JavaWeb的JDBC时候就会遇到数据库相关知识。这里推荐《尚硅谷周阳的Mysql高级》，如果时间多还可以看看书，推荐看看《数据库原理》，因为里面讲了一些思想，什么关系数据库第一范式、第二范式等，看看有利于以后数据库如何建立。可以自己找找Mysql基础。周阳的Mysql##高级主要讲了索引，explain关键字，主从复制等。<br>想想自己上大学学了sql server，Oracle在学习过程中，基本没用过，除了sql语句。当时数据库原理考了44分，太难了。听说Oracle撤离中国了，但是一些大型国企还在用，有时间可以看看，我一个平安工作的朋友也在用sql server</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>数据库学完就到了框架，虽然现在新生代基本是spring一站式，但是对于老企业的维护，以及不好变更的还是用的SSH框架，去年自己面试时候有些公司还不用框架，很多都用的SSH，然而2018年SSM早都火的不行了。springboot都开始普及了。<br>struts2这一个以前厉害的框架在经历安全问题后不再返，但是不妨碍我们去学习。<br>Hibernate是一门重量级orm框架，这里可以好好学学，记得自己看视频网上看资料，学习Hibernate入门简单，编写简单，优化难，这也是区分大佬与初级的分水岭<br>这里推荐的视频是黑马《SSH框架2016版》<br>Hibernate马士兵老师讲的也不错，尚学堂有</p><h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2><p>SSH框架完后可以学SSM框架，这个时候已经基本了解一些spring原理，可以看看spring底层原理，自己看视频，摸索摸索，推荐尚硅谷《spring注解驱动开发》。<br>至于使用xml还是注解根据自己喜好，当然注解在简化工作上肯定是优秀的，但也不是绝对的。<br>关于SSM框架可以看看黑马的springmvc和mybatis视频，我当时看的时候还是xml配置，自己也找了很久注解开发，可太少了，这里也可以看尚硅谷的SSM视频。</p><h2 id="JPA、SringData"><a href="#JPA、SringData" class="headerlink" title="JPA、SringData"></a>JPA、SringData</h2><p>因为自己在学习视频里有看到这两个，不得不说java提出的这个规范还是很不错的。可以简化持久层的操作，通过注解完成持久化对象等。<br>这里推荐尚硅谷视频</p><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>这里推荐MyBatisPlus和通用Mapper，国人开发，简化mybatis开发，还可以看看逆向工程。<br>这里推荐尚硅谷视频</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>尚硅谷或黑马都可以</p><h2 id="RBAC权限"><a href="#RBAC权限" class="headerlink" title="RBAC权限"></a>RBAC权限</h2><p>一种概念，可以看看，关于用户角色权限如何实现<br>尚硅谷的视频里整合RBAC用ssm方式，可以参考</p><h2 id="Git-amp-SVN"><a href="#Git-amp-SVN" class="headerlink" title="Git &amp; SVN"></a>Git &amp; SVN</h2><p>尚硅谷和黑马的都可以，不过黑马的git没找到</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>学习Java后端的不懂Linux可不行，<br>我看的尚硅谷的《linux》，如果自己想加深可以看看《鸟哥私房菜》、《Linux权威指南》这两本书</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>尚硅谷的</p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>这里再次推荐尚硅谷《SpringBoot》</p><h2 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h2><p>尚硅谷<br>关于安全框架，看不懂也没关系，springboot里继承了自己的安全框架，直接调用即可</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>《尚硅谷周阳》<br>不得不说周阳讲的真的很易于理解</p><h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><p>周阳的</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>这里自己在b站搜的，以及在网上找的博客</p><h2 id="Dubbo-amp-Zookeeper"><a href="#Dubbo-amp-Zookeeper" class="headerlink" title="Dubbo&amp;Zookeeper"></a>Dubbo&amp;Zookeeper</h2><p>分布式也可以看尚硅谷的，最好在网上看些博客，如何搭建集群</p><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>自己有保存一些springcloud微服务的视频，但是看的还是周阳的</p><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>这里推荐张龙的Netty，虽然有点啰嗦，但是还是很不错的</p><p>虽然知识很多，精通全部根本不可能，但是利于以后发展</p><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><p>可以看看尚硅谷的大数据</p><p>感觉再给尚硅谷打广告，主要是自己找视频确实这个比较良心一点，资料和源代码。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      自己的分享
    
    </summary>
    
      <category term="学习路线" scheme="https://www.ysmjjsy.com/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
    
      <category term="学习路线" scheme="https://www.ysmjjsy.com/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-反射</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E5%8F%8D%E5%B0%84/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-反射/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2019-09-16T09:12:32.335Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 16 2019 17:55:59 GMT+0800 (GMT+08:00) --><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><blockquote><p>Java 反射机制在程序<strong>运行时</strong>，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 <strong>动态的获取信息</strong> 以及 <strong>动态调用对象的方法</strong> 的功能称为 <strong>java 的反射机制</strong>。</p></blockquote><p>反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 <code>.class</code> 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 <code>.class</code> 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。</p><p><strong>要想剖析一个类，必须先要获取到该类的字节码文件对象，而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象</strong></p><p>反射库提供了一个非常丰富且精心设计的工具集，以便编写能够动态操作Java代码的程序.。</p><p>能够分析类能力的程序称为反射，反射机制的功能极其强大，反射机制可以用来:</p><ul><li>在运行中分析类的能力</li><li>在运行中查看对象</li><li>实现通用的数组操作代码</li><li>利用Method对象。</li></ul><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>在程序运行期间，Java运行时系统始终未所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。</p><p>然后，可以通过专门的Java类访问这些信息。保存这些信息的类被称为Class，这个名字很容易让人混淆。<strong>Object类中的getClass()方法将会返回一个Class类型的实例。</strong></p><p>一个Class对象表示一个特定类的属性，<strong>getName()方法返回类的名字</strong>。</p><p>调用forName获得类名对应的Class对象,这个方法在类名保存在字符串中，并可在运行中改变就可以使用，只有在className是类名或接口名时才能够执行。否则将抛出一个checked exception(已检查异常)，所以无论何时使用这个方法，都应该提供一个异常处理器。</p><p>如果T是任意的Java类型，T.class将代表匹配的类对象，一个Class对象实际表示的是一个类型，而这个类型未必一定是一种类。虚拟机为每个类型管理一个Class对象，因此，可以利用==运算符实现两个类对象比较的操作符。newInstance()可以快速地创建一个类的实例。<strong>newInstance方法</strong>调用默认的构造器初始化新创建的对象，如果这个类没有默认的构造器，就会抛出一个异常。将forName与newInstance配合起来使用，可以根据存储在字符串中的类名创建一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = “java.util.Date”;</span><br><span class="line">Object m = Class.forName(s).newInstance();</span><br></pre></td></tr></table></figure><h2 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h2><p><strong>检查类的结构:</strong></p><p>在java.lang.reflect包中有三个类Field、Method和Constructor分别用于描述类的域、方法和构造器。</p><p>这三个类都有一个叫做getName的方法，用来返回项目的名称。</p><p>Field类有一个getType方法，用来返回描述域所属类型的Class对象。Method和Constructor类有能够报告参数类型的方法，</p><p>Method类还有一个可以报告返回类型的方法。</p><p>这三个类还有一个叫做getModifiers的方法，它将返回一个整形数值，用不同的位开关描述public和static这样的修饰符使用状况。</p><p>另外还有java.lang.reflect包中的Modifier类的静态方法分析getModifiers返回的整形数值。</p><p>还可以利用Modifier.toString方法将修饰符打印出来。</p><p>Class类中的getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员。</p><p>Class类的getDeclareFields、getDeclareMethods和getDeclaredConstructors方法将分别返回类中生命的全部域、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员。</p><p><strong>在运行时使用反射分析对象：</strong></p><p>如果f是一个Field类型的对象，obj是某个包含f域的类的对象，f.get(obj)。将返回一个对象，其值为obj域的当前值。</p><p>反射机制的默认行为受限于java的访问控制，然而，如果一个java程序没有收到安全管理器的控制，就可以覆盖访问控制，需要调用Field、Method或Construtor对象的setAsseccible方法</p><h2 id="类的加载和加载时机"><a href="#类的加载和加载时机" class="headerlink" title="类的加载和加载时机"></a>类的加载和加载时机</h2><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><ul><li>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化</li><li>加载<ul><li>就是指将class文件读入内存，并为之创建一个Class对象</li><li>任何类被使用时系统都会建立有个Class对象</li></ul></li><li>连接<ul><li>验证：是否有正确的内部结构，并和其它类协调一致</li><li>准备：负责为类的静态成员分配内存，并设置默认初始化值</li><li>解析：将类的二进制数据中的符号引用替换为直接引用</li></ul></li><li>初始化</li></ul><h3 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h3><ol><li>创建类的实例</li><li>访问类的静态变量，或者为静态变量赋值</li><li>掉用类的静态方法</li><li>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</li><li>初始化某个类的子类</li><li>直接使用java.exe命令来运行某个主类</li></ol><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>负责将.class文件加载到内存中，并为之生成对应的Class对象</p><p><strong>类加载器的组成</strong></p><p><strong>Bootstrap ClassLoader根类加载器</strong></p><ul><li>也被称为引导类加载器，负责Java核心类的加载<ul><li>比如System.String等，在JDK中JRE的lib目录下rt.jar文件中</li></ul></li></ul><p><strong>Extension ClassLoader扩展类加载器</strong></p><ul><li>负责JRE的扩展目录中jar包的加载<ul><li>在JDK中JRE的lib目录下的ext目录</li></ul></li></ul><p><strong>System CLassLoader系统类加载器</strong></p><ul><li>负责在JVM启动时加载来自Java命令的class文件，以及classpath环境变量所指定的jar包和类路径</li></ul><h2 id="反射的基本应用"><a href="#反射的基本应用" class="headerlink" title="反射的基本应用"></a>反射的基本应用</h2><p>反射可以用于判断任意对象所属的类，获得 Class 对象，构造任意一个对象以及调用一个对象。(反射相关的类一般都在 java.lang.relfect 包里)。</p><h3 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h3><ul><li><p>使用Class类的forName静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line"><span class="comment">//比如在 JDBC 开发中常用此方法加载数据库驱动:</span></span><br><span class="line">Class.forName(driver);</span><br></pre></td></tr></table></figure></li><li><p>直接获取某一个对象的class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; klass = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;?&gt; classInt = Integer.TYPE;</span><br></pre></td></tr></table></figure></li><li><p>调用某个对象的getClass()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">Class&lt;?&gt; klass = str.getClass();</span><br></pre></td></tr></table></figure></li></ul><h3 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h3><p>一般地，我们用 <code>instanceof</code> 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的 <code>isInstance()</code> 方法来判断是否为某个类的实例，它是一个 native 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>通过反射来生成对象主要有两种方式。</p><ul><li><p>使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure></li><li><p>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"23333"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取类的构造方法"><a href="#获取类的构造方法" class="headerlink" title="获取类的构造方法"></a>获取类的构造方法</h3><h4 id="获取无参构造"><a href="#获取无参构造" class="headerlink" title="获取无参构造"></a>获取无参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forNmae(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"><span class="comment">//获取构造方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public Constructor[] getConstructors();所有公共构造方法</span></span><br><span class="line"><span class="comment">public Constructor[] getDeclaredConstructors();所有构造方法</span></span><br><span class="line"><span class="comment">Constructor[] cons = c.getDeclaredConstructors();</span></span><br><span class="line"><span class="comment">for(Constructor con : cons)&#123;</span></span><br><span class="line"><span class="comment">System.out.println(con);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单个构造方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">参数表示的是:你要获取的构造方法的构造参数个数及数据类型的class字节码文件对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Constructor con = c.getConstructor();<span class="comment">//返回的是构造方法对象</span></span><br><span class="line"><span class="comment">//Student s = new Student();</span></span><br><span class="line"><span class="comment">//System.out.println(s);</span></span><br><span class="line"><span class="comment">//public T newInstance(Object... initargs)</span></span><br><span class="line"><span class="comment">//使用此Constructor对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例</span></span><br><span class="line">Object obj = con.newInstance();</span><br><span class="line">System.out.println(obj);</span><br><span class="line"><span class="comment">//Student s = (Student)obj;</span></span><br><span class="line"><span class="comment">//s.show();</span></span><br></pre></td></tr></table></figure><h4 id="获取带参构造"><a href="#获取带参构造" class="headerlink" title="获取带参构造"></a>获取带参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public Student(String name,int age,String address)</span></span><br><span class="line"><span class="comment">Student s = new Student("张三","18","西安");</span></span><br><span class="line"><span class="comment">System.out.println(s);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//获取字节码文件对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"><span class="comment">//获取带参构造方法对象</span></span><br><span class="line"><span class="comment">//public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">Constructor con = c.getConstructor(String.classs,<span class="keyword">int</span>.class,String.class);</span><br><span class="line"><span class="comment">//获取带参构造方法对象创建对象</span></span><br><span class="line"><span class="comment">//public T new Instance(Object... initargs);</span></span><br><span class="line">Objec obj = con.newInstance(<span class="string">"张三"</span>,<span class="string">"18"</span>,<span class="string">"西安"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><h4 id="获取私有构造"><a href="#获取私有构造" class="headerlink" title="获取私有构造"></a>获取私有构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">private Student(String name)&#123;&#125;</span></span><br><span class="line"><span class="comment">Student s = new Student("李四");</span></span><br><span class="line"><span class="comment">System.out.println(s);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//获取字节码文件对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"><span class="comment">//获取私有构造方法对象</span></span><br><span class="line"><span class="comment">//NoSuchMethodException:没有这个方法异常</span></span><br><span class="line"><span class="comment">//原因是一开始我们使用的方法只能获取公共的，下面这种方法就可以</span></span><br><span class="line">Constructor con = c.getDeclaredConstructor(String.class);</span><br><span class="line"><span class="comment">//用该私有构造方法创建对象</span></span><br><span class="line"><span class="comment">//IllegalAcessException:非法访问异常</span></span><br><span class="line"><span class="comment">//暴力访问</span></span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);<span class="comment">//值为true则指示反射的对象在使用时应该取消Java语言访问检查</span></span><br><span class="line">Object obj = con.newInstance(<span class="string">"李四"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><h3 id="获取类的成员变量"><a href="#获取类的成员变量" class="headerlink" title="获取类的成员变量"></a>获取类的成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有成员</span></span><br><span class="line">getFields.getDeclaredFields();</span><br><span class="line"><span class="comment">//获取单个成员</span></span><br><span class="line">getFields.getDeclaredField();</span><br><span class="line"><span class="comment">//修改成员的值</span></span><br><span class="line">set(Object obj,Object value);</span><br><span class="line"><span class="comment">//将指定对象变量上此Field对象表示的字段设置为指定的新值</span></span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取字节码文件对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"><span class="comment">//获取所有成员变量</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Field[] fields = c.getFields();</span></span><br><span class="line"><span class="comment">Field[] fields = c.getDeclaredFiedls();</span></span><br><span class="line"><span class="comment">for(Field field:fields)&#123;</span></span><br><span class="line"><span class="comment">System.out.println(field);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//Student s = new Student();s.address="上海";</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过无参构造方法创建对象</span></span><br><span class="line">Constructor con = c.getConstructor();</span><br><span class="line">Object obj = con.newInstance();</span><br><span class="line">System.out.println(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单个的成员</span></span><br><span class="line"><span class="comment">//获取address并对其赋值</span></span><br><span class="line">Field addressField = c.getField(<span class="string">"address"</span>);</span><br><span class="line"><span class="comment">//public void set(obj,Object value)</span></span><br><span class="line"><span class="comment">//将指定此对象变量上此Field对象表示的字段设置为指定的新值</span></span><br><span class="line">addressField.set(obj,<span class="string">"上海"</span>);<span class="comment">//给obj对象的addrrssField字段设置值</span></span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><p><strong>对于基本类型的静态常量，JVM 在编译阶段会把引用此常量的代码替换成具体的常量值</strong>。</p><p>这么说来，在实际开发中，如果我们想修改某个类的常量值，恰好那个常量是基本类型的，岂不是无能为力了？反正我个人认为除非修改源码，否则真没办法！</p><p>这里所谓的无能为力是指：<strong>我们在程序运行时刻依然可以使用反射修改常量的值（后面会代码验证），但是 JVM 在编译阶段得到的 .class 文件已经将常量优化为具体的值，在运行阶段就直接使用具体的值了，所以即使修改了常量的值也已经毫无意义了</strong>。</p><h3 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h3><h4 id="获取无参无返回值的成员方法"><a href="#获取无参无返回值的成员方法" class="headerlink" title="获取无参无返回值的成员方法"></a>获取无参无返回值的成员方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取字节码文件对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有的方法</span></span><br><span class="line"><span class="comment">//Method[] methods = c.getMethods();//获取自己的包括父亲的公共方法</span></span><br><span class="line"><span class="comment">//Method[] methods = c.getDeclareMethods();//获取自己的所有的方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(Method method:methods)&#123;</span></span><br><span class="line"><span class="comment">System.out.println(method);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Constructor con = c.getConstructor();</span><br><span class="line">Object obj = con.newInstance();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Student s = new Student(); s.show();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单个方法并使用</span></span><br><span class="line"><span class="comment">//public void show()</span></span><br><span class="line"><span class="comment">//public Method getMethod(String name,Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">//第一个参数表示的方法名，第二个参数表示的是方法的参数的class类型</span></span><br><span class="line">Methdo m1 = c.getMethod(<span class="string">"show"</span>);</span><br><span class="line"><span class="comment">//public Object invoke(Object obj,Object... args)</span></span><br><span class="line">m1.invole(obj);</span><br></pre></td></tr></table></figure><h4 id="获取带参带返回值成员的方法"><a href="#获取带参带返回值成员的方法" class="headerlink" title="获取带参带返回值成员的方法"></a>获取带参带返回值成员的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public void method(String s)</span></span><br><span class="line">Method m2 = c.getMethod(<span class="string">"method"</span>,String.class);</span><br><span class="line">m2.invoke(obj,<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//public String getString(String s,int i)</span></span><br><span class="line">Method m3 = c.getMethod(<span class="string">"getString"</span>,String.class,<span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//private void function()</span></span><br><span class="line">Method m3 = c.getDeclaredMethod(<span class="string">"function"</span>);</span><br><span class="line">m4.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">m4.invoke(obj);</span><br></pre></td></tr></table></figure><h3 id="通过反射越过泛型检查"><a href="#通过反射越过泛型检查" class="headerlink" title="通过反射越过泛型检查"></a>通过反射越过泛型检查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">Class c = array.getClass();<span class="comment">//集合ArrayList的class对象</span></span><br><span class="line">Method m = c.getMethod(<span class="string">"add"</span>,Object.class);</span><br><span class="line">m.invoke(array,<span class="string">"hello"</span>);<span class="comment">//调用array的add方法，传入的值是hello</span></span><br></pre></td></tr></table></figure><h2 id="反射源码解析"><a href="#反射源码解析" class="headerlink" title="反射源码解析"></a>反射源码解析</h2><p>当我们懂得了如何使用反射后，今天我们就来看看 JDK 源码中是如何实现反射的。或许大家平时没有使用过反射，但是在开发 Web 项目的时候会遇到过下面的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException </span><br><span class="line">...</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</span><br></pre></td></tr></table></figure><p>可以看到异常堆栈指出了异常在 Method 的第 497 的 invoke 方法中，其实这里指的 invoke 方法就是我们反射调用方法中的 invoke。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = clz.getMethod(<span class="string">"setPrice"</span>, <span class="keyword">int</span>.class); </span><br><span class="line">method.invoke(object, <span class="number">4</span>);   <span class="comment">//就是这里的invoke方法</span></span><br></pre></td></tr></table></figure><p>例如我们经常使用的 Spring 配置中，经常会有相关 Bean 的配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.chenshuyi.Apple"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>当我们在 XML 文件中配置了上面这段配置之后，Spring 便会在启动的时候利用反射去加载对应的 Apple 类。而当 Apple 类不存在或发生启发异常时，异常堆栈便会将异常指向调用的 invoke 方法。</p><p>从这里可以看出，我们平常很多框架都使用了反射，而反射中最最终的就是 Method 类的 invoke 方法了。</p><p>下面我们来看看 JDK 的 invoke 方法到底做了些什么。</p><p>进入 Method 的 invoke 方法我们可以看到，一开始是进行了一些权限的检查，最后是调用了 MethodAccessor 类的 invoke 方法进行进一步处理，如下图红色方框所示。</p><p><img src="/category/JavaSE-反射/f1.png" alt="fanshe"></p><p>那么 MethodAccessor 又是什么呢？</p><p>其实 MethodAccessor 是一个接口，定义了方法调用的具体操作，而它有三个具体的实现类：</p><ul><li>sun.reflect.DelegatingMethodAccessorImpl</li><li>sun.reflect.MethodAccessorImpl</li><li>sun.reflect.NativeMethodAccessorImpl</li></ul><p>而要看 ma.invoke() 到底调用的是哪个类的 invoke 方法，则需要看看 MethodAccessor 对象返回的到底是哪个类对象，所以我们需要进入 acquireMethodAccessor() 方法中看看。</p><p><img src="/category/JavaSE-反射/f2.png" alt="fanshe">从 acquireMethodAccessor() 方法我们可以看到，代码先判断是否存在对应的 MethodAccessor 对象，如果存在那么就复用之前的 MethodAccessor 对象，否则调用 ReflectionFactory 对象的 newMethodAccessor 方法生成一个 MethodAccessor 对象。</p><p><img src="/category/JavaSE-反射/f3.png" alt="fanshe">在 ReflectionFactory 类的 newMethodAccessor 方法里，我们可以看到首先是生成了一个 NativeMethodAccessorImpl 对象，再这个对象作为参数调用 DelegatingMethodAccessorImpl 类的构造方法。</p><p>这里的实现是使用了代理模式，将 NativeMethodAccessorImpl 对象交给 DelegatingMethodAccessorImpl 对象代理。我们查看 DelegatingMethodAccessorImpl 类的构造方法可以知道，其实是将 NativeMethodAccessorImpl 对象赋值给 DelegatingMethodAccessorImpl 类的 delegate 属性。</p><p><img src="/category/JavaSE-反射/f4.png" alt="fanshe">所以说ReflectionFactory 类的 newMethodAccessor 方法最终返回 DelegatingMethodAccessorImpl 类对象。所以我们在前面的 ma.invoke() 里，其将会进入 DelegatingMethodAccessorImpl 类的 invoke 方法中。</p><p><img src="/category/JavaSE-反射/f6.png" alt="fanshe">进入 DelegatingMethodAccessorImpl 类的 invoke 方法后，这里调用了 delegate 属性的 invoke 方法，它又有两个实现类，分别是：DelegatingMethodAccessorImpl 和 NativeMethodAccessorImpl。按照我们前面说到的，这里的 delegate 其实是一个 NativeMethodAccessorImpl 对象，所以这里会进入 NativeMethodAccessorImpl 的 invoke 方法。</p><p><img src="/category/JavaSE-反射/f7.png" alt="fanshe">而在 NativeMethodAccessorImpl 的 invoke 方法里，其会判断调用次数是否超过阀值（numInvocations）。如果超过该阀值，那么就会生成另一个MethodAccessor 对象，并将原来 DelegatingMethodAccessorImpl 对象中的 delegate 属性指向最新的 MethodAccessor 对象。</p><p>到这里，其实我们可以知道 MethodAccessor 对象其实就是具体去生成反射类的入口。通过查看源码上的注释，我们可以了解到 MethodAccessor 对象的一些设计信息。</p><blockquote><p>“Inflation” mechanism. Loading bytecodes to implement Method.invoke() and Constructor.newInstance() currently costs 3-4x more than an invocation via native code for the first invocation (though subsequent invocations have been benchmarked to be over 20x faster).Unfortunately this cost increases startup time for certain applications that use reflection intensively (but only once per class) to bootstrap themselves.</p><p>Inflation 机制。初次加载字节码实现反射，使用 Method.invoke() 和 Constructor.newInstance() 加载花费的时间是使用原生代码加载花费时间的 3 - 4 倍。这使得那些频繁使用反射的应用需要花费更长的启动时间。</p><p>To avoid this penalty we reuse the existing JVM entry points for the first few invocations of Methods and Constructors and then switch to the bytecode-based implementations. Package-private to be accessible to NativeMethodAccessorImpl and NativeConstructorAccessorImpl.</p><p>为了避免这种痛苦的加载时间，我们在第一次加载的时候重用了 JVM 的入口，之后切换到字节码实现的实现。</p></blockquote><p>就像注释里说的，实际的 MethodAccessor 实现有两个版本，一个是 Native 版本，一个是 Java 版本。</p><p>Native 版本一开始启动快，但是随着运行时间边长，速度变慢。Java 版本一开始加载慢，但是随着运行时间边长，速度变快。正是因为两种存在这些问题，所以第一次加载的时候我们会发现使用的是 NativeMethodAccessorImpl 的实现，而当反射调用次数超过 15 次之后，则使用 MethodAccessorGenerator 生成的 MethodAccessorImpl 对象去实现反射。</p><p>Method 类的 invoke 方法整个流程可以表示成如下的时序图：</p><p><img src="/category/JavaSE-反射/f8.png" alt="fanshe"> invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE反射概述以及使用
    
    </summary>
    
      <category term="JavaSE" scheme="https://www.ysmjjsy.com/categories/JavaSE/"/>
    
      <category term="JavaSE反射" scheme="https://www.ysmjjsy.com/categories/JavaSE/JavaSE%E5%8F%8D%E5%B0%84/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-JVM</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-jvm/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-jvm/</id>
    <published>2017-12-15T16:00:00.000Z</published>
    <updated>2019-09-16T09:11:31.108Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 16 2019 17:55:59 GMT+0800 (GMT+08:00) --><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>推荐周志明的《<a href="https://github.com/doocs/jvm/blob/master/book/jvm.pdf" target="_blank" rel="noopener">深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)</a>》</p><p>推荐：</p><p><a href="https://github.com/doocs/jvm" target="_blank" rel="noopener">Java 虚拟机底层原理知识总结</a></p><p><a href="https://zhuanlan.zhihu.com/p/34426768" target="_blank" rel="noopener">关于Jvm知识看这一篇就够了</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE-JVM
    
    </summary>
    
      <category term="JavaSE" scheme="https://www.ysmjjsy.com/categories/JavaSE/"/>
    
      <category term="JavaSE-JVM" scheme="https://www.ysmjjsy.com/categories/JavaSE/JavaSE-JVM/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
