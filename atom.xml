<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余生梦见皆是缘</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ysmjjsy.com/"/>
  <updated>2019-09-17T09:28:50.452Z</updated>
  <id>https://www.ysmjjsy.com/</id>
  
  <author>
    <name>Goya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSE-java8新特性</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-java8新特性/</id>
    <published>2018-09-09T16:00:00.000Z</published>
    <updated>2019-09-17T09:28:50.452Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:29:31 GMT+0800 (GMT+08:00) --><h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><p>底层数据结构发生改变，更快<br>底层内存结构发生改变：<br>方法区是堆内存中永久区的一部分，1.8之后去掉方法区的永久区，方法区改为元空间。</p><p><img src="/category/JavaSE-java8新特性/d1.png" alt="i"></p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="为什么使用Lambda表达式"><a href="#为什么使用Lambda表达式" class="headerlink" title="为什么使用Lambda表达式"></a>为什么使用Lambda表达式</h3><blockquote><p>Lambda 是一个匿名函数，我们可以把 Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p></blockquote><h3 id="Lambda表达式-1"><a href="#Lambda表达式-1" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>有一个实现要求:</p><p>SAM（Single AbstractMethod）只有一个抽象方法，除此之外没有其他方法</p><p>@FunctionalInterface 函数式接口</p><p>方法没有参数：（）-&gt;{};</p><p>方法有参数：（参数，参数）-&gt;{};</p><p>如果现在只有一行语句返回:(参数，参数)-&gt;语句</p><h4 id="从匿名类到-Lambda-的转换"><a href="#从匿名类到-Lambda-的转换" class="headerlink" title="从匿名类到 Lambda 的转换"></a>从匿名类到 Lambda 的转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Runnable r1= <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"HelloWorld!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda表达式</span></span><br><span class="line">Runnable r1 = () -&gt; System.out.println(<span class="string">"HelloWorld!"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来使用匿名内部类作为参数传递</span></span><br><span class="line">TreeSet&lt;String&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1,String o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(o1.length().o2.length());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda表达式作为参数传递</span></span><br><span class="line">TreeSet&lt;String&gt; ts2 = <span class="keyword">new</span> TreeSet&lt;&gt;(</span><br><span class="line">(o1,o2) -&gt; Integer.compare(o1.length(),o2.length())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式语法"><a href="#Lambda表达式语法" class="headerlink" title="Lambda表达式语法"></a>Lambda表达式语法</h3><p>Lambda 表达式在Java 语言中引入了一个新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称<br>为 Lambda 操作符或剪头操作符。</p><p>它将 Lambda 分为两个部分：</p><p>左侧：指定了 Lambda 表达式需要的所有参数</p><p>右侧：指定了 Lambda 体，即 Lambda 表达式要执行的功能。</p><p><strong>语法格式1：</strong></p><p>无参，无返回值，Lambda体只需要一条语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnabe r1 = () -&gt; System.out.println(<span class="string">"HelloWorld!"</span>);</span><br></pre></td></tr></table></figure><p><strong>语法格式2：</strong></p><p>Lambda需要一个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; fun = (args) -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式3：</strong></p><p>Lambda只需要一个参数时，参数的小括号可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; fun = args -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式4：</strong></p><p>Lambda需要两个参数，并且有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo = (x,y) -&gt;&#123;</span><br><span class="line">  System.out.println(<span class="string">"实现函数接口方法"</span>);</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>语法格式5：</strong></p><p>当Lambda体只有一条语句时，return与大括号可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo = (x,y) -&gt; x + y;</span><br></pre></td></tr></table></figure><p><strong>语法格式6：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo = (Long x, Long y) -&gt;&#123;<span class="comment">//数据类型可以省略，因为可由编译器推断得出，称为"类型推断"</span></span><br><span class="line">  System.out.println(<span class="string">"实现函数接口方法"</span>);</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><ul><li>只包含一个抽象方法的接口，称为函数式接口。</li><li>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。</li></ul><ul><li>我们可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</li></ul><h3 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyNumber</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数式接口中使用泛型:</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunc</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作为参数传递Lambda表达式"><a href="#作为参数传递Lambda表达式" class="headerlink" title="作为参数传递Lambda表达式"></a>作为参数传递Lambda表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperString</span><span class="params">(MyFunc&lt;String&gt; mf,String str)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mf.getValue(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为参数传递Lambda表达式:</span></span><br><span class="line"></span><br><span class="line">String newStr = toUpperString(</span><br><span class="line">(str) -&gt; str.toUpperCase(),<span class="string">"abcdef"</span>);</span><br><span class="line">System.out.println(newStr);</span><br></pre></td></tr></table></figure><p>作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。</p><h3 id="Java内置四大核心函数式接口"><a href="#Java内置四大核心函数式接口" class="headerlink" title="Java内置四大核心函数式接口"></a>Java内置四大核心函数式接口</h3><div class="table-container"><table><thead><tr><th style="text-align:center">函数式接口</th><th style="text-align:center">参数类型</th><th style="text-align:center">返回类型</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center"><code>Consumer&lt;T&gt;</code><br>消费型接口</td><td style="text-align:center">T</td><td style="text-align:center">void</td><td style="text-align:center">对类型为T的对象应用操作，<br>包含方法：<code>void accept(T t);</code></td></tr><tr><td style="text-align:center"><code>Supplier&lt;T&gt;</code><br>供给型接口</td><td style="text-align:center">无</td><td style="text-align:center">T</td><td style="text-align:center">返回类型为T的对象，<br>包含方法：<code>T get();</code></td></tr><tr><td style="text-align:center"><code>Function&lt;T,R&gt;</code></td><td style="text-align:center">T</td><td style="text-align:center">R</td><td style="text-align:center">对类型为T的对象应用操作，并返回结果，结果是R类型的对象，包含方法：<code>R apply(T t);</code></td></tr><tr><td style="text-align:center"><code>Predicate&lt;T&gt;</code></td><td style="text-align:center">T</td><td style="text-align:center">boolean</td><td style="text-align:center">确定类型为T的对象是否满足某约束，并返回boolean值。包含方法：<code>boolean test(T t);</code></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th></tr></thead><tbody><tr><td><code>BiFunction&lt;T,U,R&gt;</code></td><td>T,U</td><td>R</td><td>对类型为T,U参数应用操作，返回R类型的结果，<br>包含方法为<code>R apply(T t,U u);</code></td></tr><tr><td><code>UnaryOperator&lt;T&gt;</code><br>（Function子接口）</td><td>T</td><td>T</td><td>对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为<code>T apply(T t);</code></td></tr><tr><td><code>BinaryOperator&lt;T&gt;</code><br>(BigFunction子接口)</td><td>T，T</td><td>T</td><td>对类型为T的对象进行二元运算，并返回T类型的结果，包含方法为<code>T apply(T t1,T t2);</code></td></tr><tr><td><code>BigConsumer&lt;T,U&gt;</code></td><td>T,U</td><td>void</td><td>对类型为T,U参数应用操作，包含方法为<code>void accept(T t,U u)</code></td></tr><tr><td><code>ToIntFunction&lt;T&gt;</code><br><code>ToLongFunction&lt;T&gt;</code><br><code>ToDoubleFunction</code></td><td>T</td><td>int,long,double</td><td>分别计算int,long,double值的函数</td></tr><tr><td><code>IntFunction&lt;R&gt;</code><br><code>LongFunction&lt;R&gt;</code><br>DoubleFunction<r></r></td><td>int,long,double</td><td>R</td><td>参数分别为int，long，double类型的参数</td></tr></tbody></table></div><h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！<br>（实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致！）<br>方法引用：使用操作符 “::” 将方法名和对象或类的名字分隔开来。<br>如下三种主要使用情况：</p><ul><li>对象::实例方法</li><li>类::静态方法</li><li>类::实例方法</li></ul><p><strong>例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(x) -&gt; System.out.println(x);</span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line">System.out::println;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Double&gt; bo = (x,y) -&gt; Math.pow(x,y);</span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line">BinaryOperator&lt;Double&gt; bo = Math::pow;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compare((x,y) -&gt; x.equals(y),<span class="string">"abcdef"</span>,<span class="string">"abcdef"</span>);</span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line">comare(String::equals,<span class="string">"abc"</span>,<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><p>注意：当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引<br>用方法的第二个参数(或无参数)时：ClassName::methodName</p><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>格式： <code>ClassName::new</code><br>与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，与构造器参数列表要与接口中抽象方法的参数列表一致！</p><p><strong>例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,MyClass&gt; fun = (n) -&gt; <span class="keyword">new</span> MyClass(n);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Function&lt;Integer,MyClass&gt; fun = MyClass::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><p>格式： <code>type[] :: new</code></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,Integer[]&gt; fun = (n) -&gt; <span class="keyword">new</span> Integer[n];</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Function&lt;Integer,Integer[]&gt; fun = Integer[]::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><h2 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h2><blockquote><p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API(java.util.stream.*)。</p><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，</p><p>Stream API 提供了一种高效且易于使用的处理数据的方式。</p></blockquote><p><strong>流(Stream) 到底是什么呢？</strong><br>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br>“集合讲的是数据，流讲的是计算！”</p><p><strong>注意：</strong></p><ol><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol><h3 id="Strean的操作三个步骤"><a href="#Strean的操作三个步骤" class="headerlink" title="Strean的操作三个步骤"></a>Strean的操作三个步骤</h3><ul><li><p><strong>创建Stream</strong></p><p>一个数据源(如：集合、数组),获取一个流</p></li><li><p><strong>中间操作</strong></p><p>一个中间操作链，对数据源的数据进行处理</p></li><li><p><strong>终止操作(终端操作)</strong></p><p>一个终止操作，执行中间操作链，并产生结果</p></li></ul><p><img src="/category/JavaSE-java8新特性/1.png" alt="stream"></p><h4 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h4><p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream <span class="title">stream</span><span class="params">()</span></span>; <span class="comment">//返回一个顺序流</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream <span class="title">parallelStream</span><span class="params">()</span></span>; <span class="comment">//返回一个并行流</span></span><br></pre></td></tr></table></figure><h5 id="由数组创建流"><a href="#由数组创建流" class="headerlink" title="由数组创建流"></a>由数组创建流</h5><p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span>  Stream <span class="title">stream</span><span class="params">(T[] array)</span></span>;<span class="comment">//返回一个流</span></span><br></pre></td></tr></table></figure><p>重载形式，能够处理对应基本类型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">stream</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LongStream <span class="title">stream</span><span class="params">(<span class="keyword">long</span>[] array)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleStream <span class="title">stream</span><span class="params">(<span class="keyword">double</span>[] array)</span></span></span><br></pre></td></tr></table></figure><h5 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h5><p>可以使用静态方法 Stream.of(), 通过显示值创建一个流。它可以接收任意数量的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span></span>; <span class="comment">//返回一个流</span></span><br></pre></td></tr></table></figure><h5 id="由函数创建流：创建无限流"><a href="#由函数创建流：创建无限流" class="headerlink" title="由函数创建流：创建无限流"></a>由函数创建流：创建无限流</h5><p>可以使用静态方法 Stream.iterate() 和Stream.generate(), 创建无限流。</p><p>迭代<br><code>public static Stream iterate(final T seed, finalUnaryOperator f)</code><br>生成<br><code>public static Stream generate(Supplier s）</code></p><h4 id="Stream的中间操作"><a href="#Stream的中间操作" class="headerlink" title="Stream的中间操作"></a>Stream的中间操作</h4><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p><h5 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>filter(Predicate p)</code></td><td>接收Lembda，从流中排除某些元素</td></tr><tr><td><code>distinct()</code></td><td>筛选，通过流所生成元素的hashCode()和equals()去除重复元素</td></tr><tr><td><code>limit(long maxSize)</code></td><td>截断流，使其元素不超过给定数量</td></tr><tr><td><code>skip(long n)</code></td><td>跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，则返回一个空流，与limit(n)互补</td></tr></tbody></table></div><h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>map(Function f)</code></td><td>接收一函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</td></tr><tr><td><code>mapToDouble(ToDoubleFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream</td></tr><tr><td><code>mapToInt(ToIntFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream</td></tr><tr><td><code>mapToLong(ToLongFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream</td></tr><tr><td><code>flatMap(Function f)</code></td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td></tr></tbody></table></div><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sorted()</td><td>产生一个新流，其中按自然顺序排序</td></tr><tr><td>sorted(Comparator comp)</td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table></div><h4 id="Sream的终止操作"><a href="#Sream的终止操作" class="headerlink" title="Sream的终止操作"></a>Sream的终止操作</h4><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</p><h5 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>allMath(Predicate p)</td><td>检查是否匹配所有元素</td></tr><tr><td>antMath(Predicate p)</td><td>检查是否至少匹配一个元素</td></tr><tr><td>noneMath(Predicate p)</td><td>检查是否没有匹配所有元素</td></tr><tr><td>findFirst()</td><td>返回第一个元素</td></tr><tr><td>findAny()</td><td>返回当前流中的任意元素</td></tr><tr><td>count()</td><td>返回流中元素总数</td></tr><tr><td>max(Comparator c)</td><td>返回流中最大值</td></tr><tr><td>min(Coparator c)</td><td>返回流中最小值</td></tr><tr><td>forEach(Consumer c)</td><td>内部迭代(使用Collection接口需要用户去做迭代，称为外部迭代，相反，StreamAPI使用内部迭代—-它帮你把迭代做了)</td></tr></tbody></table></div><h5 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>reduce(T iden,BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回T</td></tr><tr><td>reduce(BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值，返回<code>Optional&lt;T&gt;</code></td></tr></tbody></table></div><h5 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h5><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>collect(Collector c)</td><td>将流转换为其他形式，接收一个Collector接口的实现，用于给Steam中元素做汇总工作</td></tr></tbody></table></div><p>Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">toList  List&lt;T&gt;  <span class="comment">//把流中元素收集到List  </span></span><br><span class="line">List&lt;Employee&gt; emps = list.stream().collect(Collectors.tolist());  </span><br><span class="line"></span><br><span class="line">toSet Set&lt;T&gt; <span class="comment">//把流中元素收集到Set</span></span><br><span class="line">Set&lt;Employee emps = list.stream().collect(Collectors.toSet());  </span><br><span class="line"></span><br><span class="line">toCollection Collection&lt;T&gt; <span class="comment">//把流中元素收集到创建的集合</span></span><br><span class="line">Collection&lt;Employee&gt; empls = list.stream().collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">counting Long <span class="comment">//计算流中元素的个数</span></span><br><span class="line"><span class="keyword">long</span> count = list.stream().collect(Collectors.counting());</span><br><span class="line"></span><br><span class="line">summingInt Integer <span class="comment">//对流中元素的整数属性求和</span></span><br><span class="line">inttotal = list.stream().collect(Collectors.summingInt(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">averaginInt Double <span class="comment">// 计算流中元素Integer属性的平均值</span></span><br><span class="line">doubleavg = list.stream().collect(Collectors.averagingInt(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">summarrizingInt IntSummartStatistics <span class="comment">//收集流中Integer属性的统计值，如平均值</span></span><br><span class="line">IntSummaryStatisticsiss = list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">joining String <span class="comment">//连接流中每个字符串</span></span><br><span class="line">String str = list.stream().map(Employee::getName).collect(Collectors.joining());</span><br><span class="line"></span><br><span class="line">maxBy Optional&lt;T&gt; <span class="comment">//根据比较器选择最大值</span></span><br><span class="line">Optional&lt;Emp&gt; max = list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</span><br><span class="line">minBy Optional&lt;T&gt; <span class="comment">//根据比较器选择最小值</span></span><br><span class="line">Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</span><br><span class="line"></span><br><span class="line">reducing 归约产生的类型 <span class="comment">//从一个作为累加器的初始值开始，利用BinaryOperator流中元素逐个结合，从而归约成单个值</span></span><br><span class="line">inttotal=list.stream().collect(Collectors.reducing(<span class="number">0</span>, Employee::getSalar, Integer::sum));</span><br><span class="line"></span><br><span class="line">collectingAndThen 转换函数返回的类型 <span class="comment">//包裹另一个收集器，对其结果转换函数</span></span><br><span class="line">inthow= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</span><br><span class="line"></span><br><span class="line">groupingBy Map&lt;K, List&lt;T&gt;&gt; <span class="comment">//根据某属性值对流分组，属性为K，结果为V</span></span><br><span class="line">Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));</span><br><span class="line"></span><br><span class="line">partitioningBy Map&lt;Boolean, List&lt;T&gt;&gt; <span class="comment">//根据true或false进行分区</span></span><br><span class="line">Map&lt;Boolean,List&lt;Emp&gt;&gt;vd=</span><br><span class="line">list.stream().collect(Collectors.partitioningBy(Employee::getManage));</span><br></pre></td></tr></table></figure><h3 id="并行流与串行流"><a href="#并行流与串行流" class="headerlink" title="并行流与串行流"></a>并行流与串行流</h3><p>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。</p><p>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与sequential() 在并行流与顺序流之间进行切换。</p><h3 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork/Join 框架"></a>Fork/Join 框架</h3><p>Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总.</p><p><img src="/category/JavaSE-java8新特性/2.png" alt="java8"></p><h4 id="Fork-Join-框架与传统线程池的区别"><a href="#Fork-Join-框架与传统线程池的区别" class="headerlink" title="Fork/Join 框架与传统线程池的区别"></a>Fork/Join 框架与传统线程池的区别</h4><blockquote><p>采用 “工作窃取”模式（work-stealing）：</p><p>当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p><p>相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间,提高了性能.</p></blockquote><h2 id="新时间日期API"><a href="#新时间日期API" class="headerlink" title="新时间日期API"></a>新时间日期API</h2><h3 id="使用-LocalDate、LocalTime、LocalDateTime"><a href="#使用-LocalDate、LocalTime、LocalDateTime" class="headerlink" title="使用 LocalDate、LocalTime、LocalDateTime"></a>使用 LocalDate、LocalTime、LocalDateTime</h3><p>LocalDate、LocalTime、LocalDateTime 类的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。</p><p>注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法</p><p><img src="/category/JavaSE-java8新特性/3.png" alt="java8"></p><h3 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant 时间戳"></a>Instant 时间戳</h3><p>用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算</p><h3 id="Duration-和-Period"><a href="#Duration-和-Period" class="headerlink" title="Duration 和 Period"></a>Duration 和 Period</h3><ul><li>Duration:用于计算两个“时间”间隔</li><li>Period:用于计算两个“日期”间隔</li></ul><h3 id="日期的操纵"><a href="#日期的操纵" class="headerlink" title="日期的操纵"></a>日期的操纵</h3><p>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。</p><ul><li>TemporalAdjusters : 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现。</li></ul><p>例如获取下个周日：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate nextSunday = LocalDate.now().with(</span><br><span class="line">TemporalAdjusters.next(DayOfWeek.SUNDAY)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="解析与格式化"><a href="#解析与格式化" class="headerlink" title="解析与格式化"></a>解析与格式化</h3><p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p><ul><li>预定义的标准格式</li><li>语言环境相关的格式</li><li>自定义的格式</li></ul><h3 id="时区的处理"><a href="#时区的处理" class="headerlink" title="时区的处理"></a>时区的处理</h3><p>Java8 中加入了对时区的支持，带时区的时间为分别为：<br>ZonedDate、ZonedTime、ZonedDateTime<br>其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式<br>例如 ：Asia/Shanghai 等<br>ZoneId：该类中包含了所有的时区信息<br>getAvailableZoneIds() : 可以获取所有时区时区信息<br>of(id) : 用指定的时区信息获取 ZoneId 对象</p><h3 id="与传统日期处理的转换"><a href="#与传统日期处理的转换" class="headerlink" title="与传统日期处理的转换"></a>与传统日期处理的转换</h3><p><img src="/category/JavaSE-java8新特性/4.png" alt="java8"></p><h2 id="接口中的默认方法与静态方法"><a href="#接口中的默认方法与静态方法" class="headerlink" title="接口中的默认方法与静态方法"></a>接口中的默认方法与静态方法</h2><p>Java 8中允许接口中包含具有具体实现的方法，该方法称为“默认方法”，默认方法使用 default 关键字修饰。</p><p><strong>例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunc</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">defalut String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello Java8"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口默认方法的”类优先”原则</strong></p><p>若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时</p><ul><li>选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。</li></ul><ul><li>接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunc</span></span>&#123;</span><br><span class="line">  <span class="function">defalut String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello Java8"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span></span>&#123;</span><br><span class="line">  <span class="function">defalut String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello Java"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyFunc</span>,<span class="title">Named</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Named.<span class="keyword">super</span>,getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口中的静态方法"><a href="#接口中的静态方法" class="headerlink" title="接口中的静态方法"></a>接口中的静态方法</h4><p>Java8 中，接口中允许添加静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">myFun</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello java"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h2><h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><p>Optional 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p><p><strong>常用方法：</strong><br><code>Optional.of(T t)</code> : 创建一个 Optional 实例<br><code>Optional.empty()</code> : 创建一个空的 Optional 实例<br><code>Optional.ofNullable(T t)</code>:若 t 不为 null,创建 Optional 实例,否则创建空实例<br><code>isPresent()</code> : 判断是否包含值<br><code>orElse(T t)</code> : 如果调用对象包含值，返回该值，否则返回t<br><code>orElseGet(Supplier s)</code> :如果调用对象包含值，返回该值，否则返回 s 获取的值<br><code>map(Function f)</code>: 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()<br><code>flatMap(Function mapper)</code>:与 map 类似，要求返回值必须是Optional</p><h3 id="重复注解与类型注解"><a href="#重复注解与类型注解" class="headerlink" title="重复注解与类型注解"></a>重复注解与类型注解</h3><p>Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations&#123;</span><br><span class="line">  MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repetable</span>(MyAnnotations.class)</span><br><span class="line"><span class="meta">@Target</span>(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,ElementType.TYPE_PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetemtionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation</span>(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="meta">@MyANnotation</span>(<span class="string">"World"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(@MyAnnotation(<span class="string">"abc"</span>)</span>String str)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>在 Java 5.0 提供了 java.util.concurrent （简称JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。提供可调的、灵活的线程池。还提供了设计用于多线程上下文中的 Collection 实现等。</p><h3 id="volatile关键字-内存可见性"><a href="#volatile关键字-内存可见性" class="headerlink" title="volatile关键字 内存可见性"></a>volatile关键字 内存可见性</h3><p><strong>内存可见性</strong></p><p>内存可见性（Memory Visibility）是指当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p><ul><li>可见性错误是指当读操作与写操作在不同的线程中执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。</li></ul><ul><li>我们可以通过同步来保证对象被安全地发布。除此之外我们也可以使用一种更加轻量级的 volatile 变量。</li></ul><p><strong>volatile 关键字</strong></p><p>Java 提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。可以将 volatile 看做一个轻量级的锁，但是又与锁有些不同：</p><ul><li>对于多线程，不是一种互斥关系</li><li>不能保证变量状态的“原子性操作”</li></ul><h3 id="原子变量-CAS算法"><a href="#原子变量-CAS算法" class="headerlink" title="原子变量 CAS算法"></a>原子变量 CAS算法</h3><p><strong>CAS算法</strong></p><ul><li>CAS (Compare-And-Swap) 是一种硬件对并发的支持，针对多处理器操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。</li><li>CAS 是一种无锁的非阻塞算法的实现。</li><li>CAS 包含了 3 个操作数：<ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul></li><li>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作。</li></ul><p><strong>原子变量</strong></p><ul><li>类的小工具包，支持在单个变量上解除锁的线程安全编程。事实上，此包中的类可将 volatile 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类。</li><li>类 AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 的实例各自提供对相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。</li><li>AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray 类进一步扩展了原子操作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方面也引人注目，这对于普通数组来说是不受支持的。</li><li><strong>核心方法：boolean compareAndSet(expectedValue, updateValue)</strong></li><li>java.util.concurrent.atomic 包下提供了一些原子操作的常用类:<ul><li>AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference</li><li>AtomicIntegerArray 、AtomicLongArray</li><li>AtomicMarkableReference</li><li>AtomicReferenceArray</li><li>AtomicStampedReference</li></ul></li></ul><h3 id="ConcurrentHashMap-锁分段机制"><a href="#ConcurrentHashMap-锁分段机制" class="headerlink" title="ConcurrentHashMap 锁分段机制"></a>ConcurrentHashMap 锁分段机制</h3><p><strong>ConcurrentHashMap</strong></p><p>Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。</p><ul><li>ConcurrentHashMap 同步容器类是Java 5 增加的一个线程安全的哈希表。对与多线程的操作，介于 HashMap 与 Hashtable 之间。内部采用“锁分段”机制替代 Hashtable 的独占锁。进而提高性能。</li><li>此包还提供了设计用于多线程上下文中的 Collection 实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap，ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。</li></ul><h3 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch 闭锁"></a>CountDownLatch 闭锁</h3><ul><li>Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。</li></ul><ul><li>CountDownLatch 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</li></ul><ul><li>闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行：<ul><li>确保某个计算在其需要的所有资源都被初始化之后才继续执行;</li><li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动;</li><li>等待直到某个操作所有参与者都准备就绪再继续执行。</li></ul></li></ul><h3 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h3><ul><li>Java 5.0 在 java.util.concurrent 提供了一个新的创建执行线程的方式：Callable 接口</li></ul><ul><li>Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常。</li></ul><ul><li>Callable 需要依赖FutureTask ，FutureTask 也可以用作闭锁。</li></ul><h3 id="Lock-同步锁"><a href="#Lock-同步锁" class="headerlink" title="Lock 同步锁"></a>Lock 同步锁</h3><p><strong>显示锁 Lock</strong></p><ul><li>在 Java 5.0 之前，协调共享对象的访问时可以使用的机制只有 synchronized 和 volatile 。Java 5.0 后增加了一些新的机制，但并不是一种替代内置锁的方法，而是当内置锁不适用时，作为一种可选择的高级功能。</li></ul><ul><li>ReentrantLock 实现了 Lock 接口，并提供了与synchronized 相同的互斥性和内存可见性。但相较于synchronized 提供了更高的处理锁的灵活性。</li></ul><h3 id="Condition-控制线程通信"><a href="#Condition-控制线程通信" class="headerlink" title="Condition 控制线程通信"></a>Condition 控制线程通信</h3><p><strong>Condition</strong></p><ul><li>Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。</li></ul><ul><li>在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是await、signal 和 signalAll。</li></ul><ul><li>Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得Condition 实例，请使用其 newCondition() 方法。</li></ul><h3 id="线程按序交替"><a href="#线程按序交替" class="headerlink" title="线程按序交替"></a>线程按序交替</h3><p>编写一个程序，开启 3 个线程，这三个线程的 ID 分别为A、B、C，每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出的结果必须按顺序显示。<br>如：ABCABCABC…… 依次递归</p><h3 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h3><ul><li>ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。。</li></ul><ul><li>ReadWriteLock 读取操作通常不会改变共享资源，但执行写入操作时，必须独占方式来获取锁。对于读取操作占多数的数据结构。 ReadWriteLock 能提供比独占锁更高的并发性。而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作。</li></ul><h3 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h3><ul><li>一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法</li></ul><ul><li>锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</li></ul><ul><li>加个普通方法后发现和同步锁无关</li><li>换成两个对象后，不是同一把锁了，情况立刻变化。</li><li>都换成静态同步方法后，情况又变化</li><li>所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</li></ul><ul><li>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li>第四种获取线程的方法：线程池，一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。</li></ul><ul><li>线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。</li></ul><ul><li>为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 ：</li></ul><ul><li>Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）</li><li>Executors.newFixedThreadPool(int)（固定大小线程池）</li><li>Executors.newSingleThreadExecutor()（单个后台线程）它们均为大多数使用场景预定义了设置。</li></ul><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p><strong>ScheduledExecutorService</strong></p><p>一个 ExecutorService，可安排在给定的延迟后运行或定期执行的命令。</p><h3 id="ForkJoinPool-分支-合并框架-工作窃取"><a href="#ForkJoinPool-分支-合并框架-工作窃取" class="headerlink" title="ForkJoinPool 分支/合并框架 工作窃取"></a>ForkJoinPool 分支/合并框架 工作窃取</h3><p><strong>Fork/Join 框架</strong></p><p>Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总。</p><p><img src="/category/JavaSE-java8新特性/5.png" alt="juc"></p><p><strong>Fork/Join 框架与线程池的区别</strong></p><ul><li>采用 “工作窃取”模式（work-stealing）：当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</li></ul><ul><li>相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间，提高了性能。</li></ul><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</p><p><strong>Java NIO 与 IO 的主要区别</strong></p><p><img src="/category/JavaSE-java8新特性/6.png" alt="nio"></p><h3 id="通道（Channel）与缓冲区（Buffer）"><a href="#通道（Channel）与缓冲区（Buffer）" class="headerlink" title="通道（Channel）与缓冲区（Buffer）"></a>通道（Channel）与缓冲区（Buffer）</h3><p>Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</p><p><strong>简而言之，Channel 负责传输， Buffer 负责存储</strong></p><h4 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h4><ul><li>缓冲区（Buffer）：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。</li></ul><ul><li>Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的。</li></ul><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。都是通过如下方法获取一个 Buffer对象：</p><p><strong>static XxxBuffer allocate(int capacity) : 创建一个容量为 capacity 的 XxxBuffer 对象</strong></p><h5 id="缓冲区的基本属性"><a href="#缓冲区的基本属性" class="headerlink" title="缓冲区的基本属性"></a>缓冲区的基本属性</h5><p>Buffer 中的重要概念：</p><ul><li>容量 (capacity) ：表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。</li></ul><ul><li>限制 (limit)：第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量。</li></ul><ul><li>位置 (position)：下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制</li></ul><ul><li>标记 (mark)与重置 (reset)：标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position.</li></ul><p>标记、位置、限制、容量遵守以下不变式： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p><p><img src="/category/JavaSE-java8新特性/7.png" alt="nio"></p><h5 id="Buffer的常用方法"><a href="#Buffer的常用方法" class="headerlink" title="Buffer的常用方法"></a>Buffer的常用方法</h5><p><img src="/category/JavaSE-java8新特性/8.png" alt="nio"></p><h5 id="缓冲区的数据操作"><a href="#缓冲区的数据操作" class="headerlink" title="缓冲区的数据操作"></a>缓冲区的数据操作</h5><ul><li>Buffer 所有子类提供了两个用于数据操作的方法：get()与 put() 方法<ul><li>获取 Buffer 中的数据<ul><li>get() ：读取单个字节</li><li>get(byte[] dst)：批量读取多个字节到 dst 中</li><li>get(int index)：读取指定索引位置的字节(不会移动 position)</li></ul></li><li>放入数据到 Buffer 中<ul><li>put(byte b)：将给定单个字节写入缓冲区的当前位置</li><li>put(byte[] src)：将 src 中的字节写入缓冲区的当前位置</li><li>put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 position)</li></ul></li></ul></li></ul><h5 id="直接与非直接缓冲区"><a href="#直接与非直接缓冲区" class="headerlink" title="直接与非直接缓冲区"></a>直接与非直接缓冲区</h5><ul><li>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。</li></ul><ul><li>直接字节缓冲区可以通过调用此类的 allocateDirect() 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。</li></ul><ul><li>直接字节缓冲区还可以通过 FileChannel 的 map() 方法 将文件区域直接映射到内存中来创建。该方法返回MappedByteBuffer 。Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。</li></ul><ul><li>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。</li></ul><p><strong>非直接缓冲区</strong></p><p><img src="/category/JavaSE-java8新特性/a1.png" alt="nio"></p><p><strong>直接缓冲区</strong></p><p><img src="/category/JavaSE-java8新特性/a2.png" alt="nio"></p><h4 id="通道（Channel）"><a href="#通道（Channel）" class="headerlink" title="通道（Channel）"></a>通道（Channel）</h4><p>通道（Channel）：由 java.nio.channels 包定义的。Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据，Channel 只能与Buffer 进行交互。</p><p><img src="/category/JavaSE-java8新特性/b1.png" alt="nio"></p><p><img src="/category/JavaSE-java8新特性/b2.png" alt="nio"></p><p><img src="/category/JavaSE-java8新特性/b3.png" alt="nio"></p><p>Java 为 Channel 接口提供的最主要实现类如下：</p><ul><li>FileChannel：用于读取、写入、映射和操作文件的通道。</li><li>DatagramChannel：通过 UDP 读写网络中的数据通道。</li><li>SocketChannel：通过 TCP 读写网络中的数据。</li><li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><h5 id="获取通道"><a href="#获取通道" class="headerlink" title="获取通道"></a>获取通道</h5><p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul><p>获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道。</p><h5 id="通道的数据传输"><a href="#通道的数据传输" class="headerlink" title="通道的数据传输"></a>通道的数据传输</h5><p>将 Buffer 中数据写入 Channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Buffer中数据写入Channel中</span></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure><p>从 Channel 读取数据到 Buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从Channel读取数据到Buffer</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure><h4 id="分散-Scatter-和聚集-Gather"><a href="#分散-Scatter-和聚集-Gather" class="headerlink" title="分散(Scatter)和聚集(Gather)"></a>分散(Scatter)和聚集(Gather)</h4><p><strong>分散读取（Scattering Reads）是指从 Channel 中读取的数据“分散”到多个 Buffer 中。</strong></p><p><img src="/category/JavaSE-java8新特性/c1.png" alt="nio"></p><p>注意：按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满。</p><p><strong>聚集写入（Gathering Writes）是指将多个 Buffer 中的数据“聚集”到 Channel。</strong></p><p><img src="/category/JavaSE-java8新特性/c2.png" alt="nio"></p><p>注意：按照缓冲区的顺序，写入 position 和 limit 之间的数据到 Channel 。</p><h4 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h4><p>将数据从源通道传输到其他 Channel 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/fromFile.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line"><span class="comment">//获取FileChannel</span></span><br><span class="line">FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/toFile.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义传输位置</span></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最多传输的字节数</span></span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据从源通道传输到另一个通道</span></span><br><span class="line">toChannel.transferFrom(fromChannel,count,position);</span><br></pre></td></tr></table></figure><h4 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h4><p>将数据从源通道传输到其他 Channel 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/fromFile.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line"><span class="comment">//获取FileChannel</span></span><br><span class="line">FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/toFile.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义传输位置</span></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最多传输的字节数</span></span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据从源通道传输到另一个通道</span></span><br><span class="line">fromChannel.transferTo(position,count,toChannel);</span><br></pre></td></tr></table></figure><h4 id="FileChannel-的常用方法"><a href="#FileChannel-的常用方法" class="headerlink" title="FileChannel 的常用方法"></a>FileChannel 的常用方法</h4><p><img src="/category/JavaSE-java8新特性/11.png" alt="nio"></p><h3 id="NIO-的非阻塞式网络通信"><a href="#NIO-的非阻塞式网络通信" class="headerlink" title="NIO 的非阻塞式网络通信"></a>NIO 的非阻塞式网络通信</h3><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><ul><li>传统的 IO 流都是阻塞式的。也就是说，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行 IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。</li></ul><ul><li>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO 可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。</li></ul><h4 id="选择器（Selector）"><a href="#选择器（Selector）" class="headerlink" title="选择器（Selector）"></a>选择器（Selector）</h4><ul><li>选择器（Selector） 是 SelectableChannle 对象的多路复用器，Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心。</li></ul><ul><li>SelectableChannle 的结构如下图：</li></ul><p><img src="/category/JavaSE-java8新特性/12.png" alt="nio"></p><h4 id="选择器（Selector）的应用"><a href="#选择器（Selector）的应用" class="headerlink" title="选择器（Selector）的应用"></a>选择器（Selector）的应用</h4><p>创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><p>向选择器注册通道：SelectableChannel.register(Selector sel, int ops)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Socket套接字</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Sokcet(InetAddress.getByName(<span class="string">"127.0.0.1"</span>),<span class="number">9898</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取SocketChannel</span></span><br><span class="line">SocketChannel channel = scoket.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将SocketChannel切换到非阻塞模式</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向Selector注册Channel</span></span><br><span class="line">SelectionKey key = channel.register(selector,SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h4><ul><li>当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器</li></ul><p>对通道的监听事件，需要通过第二个参数 ops 指定。</p><ul><li>可以监听的事件类型（可使用 SelectionKey 的四个常量表示）：<ul><li>读 : SelectionKey.OP_READ （1）</li><li>写 : SelectionKey.OP_WRITE （4）</li><li>连接 : SelectionKey.OP_CONNECT （8）</li><li>接收 : SelectionKey.OP_ACCEPT （16）</li></ul></li></ul><ul><li>若注册时不止监听一个事件，则可以使用“位或”操作符连接。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册"监听事件"</span></span><br><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ|SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><p>SelectionKey：表示 SelectableChannel 和 Selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。</p><p><img src="/category/JavaSE-java8新特性/21.png" alt="nio"></p><h4 id="Selector-的常用方法"><a href="#Selector-的常用方法" class="headerlink" title="Selector 的常用方法"></a>Selector 的常用方法</h4><p><img src="/category/JavaSE-java8新特性/22.png" alt="nio"></p><h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。</p><p>操作步骤：</p><ul><li>打开 SocketChannel</li><li>读写数据</li><li>关闭 SocketChannel</li></ul><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道，就像标准IO中的ServerSocket一样。</p><h4 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h4><p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。<br>操作步骤：</p><ul><li>打开 DatagramChannel</li><li>接收/发送数据</li></ul><h4 id="管道-Pipe"><a href="#管道-Pipe" class="headerlink" title="管道 (Pipe)"></a>管道 (Pipe)</h4><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</p><p><img src="/category/JavaSE-java8新特性/23.png" alt="nio"></p><h5 id="向管道写数据"><a href="#向管道写数据" class="headerlink" title="向管道写数据"></a>向管道写数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">  String str = <span class="string">"测试数据"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建管道</span></span><br><span class="line">  Pipe pipe = Pipe.open();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//向管道写输入</span></span><br><span class="line">  Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//通过SinkChannel的write()方法写数据</span></span><br><span class="line">  ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">  buf.clear();</span><br><span class="line">  buf.put(str.getBytes());</span><br><span class="line">  buf.flip();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">    sinkChannel.write(buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a>从管道读取数据</h5><p>从读取管道的数据，需要访问source通道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从管道读取数据</span></span><br><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br></pre></td></tr></table></figure><p>调用source通道的read()方法来读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用SourceChannel的read()方法读取数据</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">sourceChannel.read(buf);</span><br></pre></td></tr></table></figure><h3 id="NIO-2-–-Path、Paths、Files"><a href="#NIO-2-–-Path、Paths、Files" class="headerlink" title="NIO.2 – Path、Paths、Files"></a>NIO.2 – Path、Paths、Files</h3><h4 id="NIO-2"><a href="#NIO-2" class="headerlink" title="NIO.2"></a>NIO.2</h4><p>随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。</p><h4 id="Path-与-Paths"><a href="#Path-与-Paths" class="headerlink" title="Path 与 Paths"></a>Path 与 Paths</h4><ul><li>java.nio.file.Path 接口代表一个平台无关的平台路径，描述了目录结构中文件的位置。</li><li>Paths 提供的 get() 方法用来获取 Path 对象：<ul><li>Path get(String first, String … more) : 用于将多个字符串串连成路径。</li></ul></li></ul><ul><li>Path 常用方法：<ul><li>boolean endsWith(String path) : 判断是否以 path 路径结束</li><li>boolean startsWith(String path) : 判断是否以 path 路径开始</li><li>boolean isAbsolute() : 判断是否是绝对路径</li><li>Path getFileName() : 返回与调用 Path 对象关联的文件名</li><li>Path getName(int idx) : 返回的指定索引位置 idx 的路径名称</li><li>int getNameCount() : 返回Path 根目录后面元素的数量</li><li>Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</li><li>Path getRoot() ：返回调用 Path 对象的根路径</li><li>Path resolve(Path p) :将相对路径解析为绝对路径</li><li>Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</li><li>String toString() ： 返回调用 Path 对象的字符串表示形式</li></ul></li></ul><h4 id="Files-类"><a href="#Files-类" class="headerlink" title="Files 类"></a>Files 类</h4><ul><li>java.nio.file.Files 用于操作文件或目录的工具类。</li><li>Files常用方法：<ul><li>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</li><li>Path createDirectory(Path path, FileAttribute … attr) : 创建一个目录</li><li>Path createFile(Path path, FileAttribute … arr) : 创建一个文件</li><li>void delete(Path path) : 删除一个文件</li><li>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</li><li>long size(Path path) : 返回 path 指定文件的大小</li></ul></li><li>Files常用方法：用于判断<ul><li>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</li><li>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</li><li>boolean isExecutable(Path path) : 判断是否是可执行文件</li><li>boolean isHidden(Path path) : 判断是否是隐藏文件</li><li>boolean isReadable(Path path) : 判断文件是否可读</li><li>boolean isWritable(Path path) : 判断文件是否可写</li><li>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</li><li><code>public static &lt;A extends BasicFileAttributes&gt; A readAttributes(Path path,Class&lt;A&gt; type,LinkOption...options)</code> : 获取与 path 指定的文件相关联的属性。</li></ul></li></ul><ul><li>Files常用方法：用于操作内容<ul><li>SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式</li><li>DirectoryStream newDirectoryStream(Path path) : 打开 path 指定的目录</li><li>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</li><li>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象]()</li></ul></li></ul><h4 id="自动资源管理"><a href="#自动资源管理" class="headerlink" title="自动资源管理"></a>自动资源管理</h4><p>Java 7 增加了一个新特性，该特性提供了另外一种管理资源的方式，这种方式能自动关闭文件。这个特性有时被称为自动资源管理(Automatic Resource Management, ARM)， 该特性以 try 语句的扩展版为基础。自动资源管理主要用于，当不再需要文件（或其他资源）时，可以防止无意中忘记释放它们。</p><p>自动资源管理基于 try 语句的扩展形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(需要关闭的资源声明)&#123;</span><br><span class="line"><span class="comment">//可能发生异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 变量名)&#123;</span><br><span class="line"><span class="comment">//异常的处理语句</span></span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//一定执行的语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当 try 代码块结束时，自动释放资源。因此不需要显示的调用 close() 方法。该形式也称为“带资源的 try 语句”。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">1. try 语句中声明的资源被隐式声明为 final ，资源的作用局限于带资源的 try 语句</span></span><br><span class="line"><span class="comment">2. 可以在一条 try 语句中管理多个资源，每个资源以“;” 隔开即可。</span></span><br><span class="line"><span class="comment">3. 需要关闭的资源，必须实现了 AutoCloseable 接口或其自接口 Closeable</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE-java8新特性,JUC,NIO
    
    </summary>
    
      <category term="JavaSE" scheme="https://www.ysmjjsy.com/categories/JavaSE/"/>
    
      <category term="JavaSE-java8新特性" scheme="https://www.ysmjjsy.com/categories/JavaSE/JavaSE-java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>从零开始Intellij的使用</title>
    <link href="https://www.ysmjjsy.com/category/Intelij/"/>
    <id>https://www.ysmjjsy.com/category/Intelij/</id>
    <published>2018-08-28T16:00:00.000Z</published>
    <updated>2019-09-17T04:21:34.568Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 12:22:04 GMT+0800 (GMT+08:00) --><h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><h2 id="IDEA的主要优势-相较于Eclipse而言"><a href="#IDEA的主要优势-相较于Eclipse而言" class="headerlink" title="IDEA的主要优势(相较于Eclipse而言)"></a>IDEA的主要优势(相较于Eclipse而言)</h2><ol><li>强大的整合能力，比如Git、Maven、Spring等</li><li>提示功能的快速、便捷</li><li>提示功能的范围广</li><li>好用的快捷键和代码模板</li><li>精准搜索</li><li>…</li></ol><h2 id="IDEA的目录结构"><a href="#IDEA的目录结构" class="headerlink" title="IDEA的目录结构"></a>IDEA的目录结构</h2><ul><li>bin：容器，执行文件和启动参数</li><li>help：快捷键文档和其他帮助文档</li><li>jre64：64位java运行环境</li><li>lib：idea依赖的类库</li><li>license：各个插件许可</li><li>plugin：插件</li></ul><p><strong>设置目录结构：</strong></p><p><img src="/category/Intelij/1.png" alt="idea"></p><ul><li>config目录是Intellij个性化设置目录</li><li>system目录是Intellij系统文件目录</li></ul><h2 id="IDEA的使用"><a href="#IDEA的使用" class="headerlink" title="IDEA的使用"></a>IDEA的使用</h2><h3 id="如何调整VM配置文件"><a href="#如何调整VM配置文件" class="headerlink" title="如何调整VM配置文件"></a>如何调整VM配置文件</h3><p><img src="/category/Intelij/2.png" alt="idea"></p><h3 id="创建Java工程"><a href="#创建Java工程" class="headerlink" title="创建Java工程"></a>创建Java工程</h3><p><img src="/category/Intelij/3.png" alt="idea"></p><ul><li>Create New Project：创建一个新的工程</li><li>Import Project：导入一个现有工程</li><li>Open：打开一个已有工程</li><li>Check out form Version Control： 可以通过服务器上的项目地址 check out Github 上面项目或其他 Git 托管服务器上的项目</li></ul><h3 id="设置显示常见的视图"><a href="#设置显示常见的视图" class="headerlink" title="设置显示常见的视图"></a>设置显示常见的视图</h3><p><img src="/category/Intelij/4.png" alt="idea"></p><h3 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module:模块"></a>Module:模块</h3><p>在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module。一个 Project IntelliJ IDEA 的安装、配置与使用 可以有多个 Module。目前主流的大型项目都是分布式部署的，结构都是类似这 种多 Module 结构。</p><p><img src="/category/Intelij/5.png" alt="idea"></p><p>这类项目一般是这样划分的，比如：core Module、web Module、plugin Module、 solr Module 等等，模块之间彼此可以相互依赖。通过这些 Module 的命名也可 以看出，他们之间都是处于同一个项目业务下的模块，彼此之间是有不可分割的 业务关系的。</p><p>相比较于多 Module 项目，小项目就无需搞得这么复杂。只有一个 Module 的 结构 IntelliJ IDEA 也是支持的，并且 IntelliJ IDEA 创建项目的时候，默认就是单 IntelliJ IDEA 的安装、配置与使用 Module 的结构的。</p><h4 id="如何删除模块"><a href="#如何删除模块" class="headerlink" title="如何删除模块"></a>如何删除模块</h4><p><img src="/category/Intelij/6.png" alt="idea"></p><p><img src="/category/Intelij/61.png" alt="idea"></p><p><img src="/category/Intelij/62.png" alt="idea"></p><p><img src="/category/Intelij/63.png" alt="idea"></p><h3 id="查看项目配置："><a href="#查看项目配置：" class="headerlink" title="查看项目配置："></a>查看项目配置：</h3><p><img src="/category/Intelij/7.png" alt="idea"></p><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p><img src="/category/Intelij/8.png" alt="idea"></p><h4 id="Appearance-amp-Behavior"><a href="#Appearance-amp-Behavior" class="headerlink" title="Appearance &amp; Behavior"></a>Appearance &amp; Behavior</h4><h5 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h5><p><img src="/category/Intelij/a1.png" alt="idea"></p><h5 id="设置窗体及菜单的字体及字体大小-可忽略"><a href="#设置窗体及菜单的字体及字体大小-可忽略" class="headerlink" title="设置窗体及菜单的字体及字体大小(可忽略)"></a>设置窗体及菜单的字体及字体大小(可忽略)</h5><p><img src="/category/Intelij/a2.png" alt="idea"></p><h5 id="设置编辑区主题-可忽略"><a href="#设置编辑区主题-可忽略" class="headerlink" title="设置编辑区主题(可忽略)"></a>设置编辑区主题(可忽略)</h5><p>Idea默认提供了两个编辑区主题，可以通过如下的方式进行选择</p><p><img src="/category/Intelij/a3.png" alt="idea"></p><ul><li><p>如果想要更多的主题效果，可以到如下网站下载：</p><p><a href="http://www.riaway.com" target="_blank" rel="noopener">主题</a></p></li><li><p>下载以后，导入主题</p><p>file - &gt; import settings - &gt; 选中下载的主题jar文件 -&gt; 一路确认 - &gt; 重启</p></li></ul><h4 id="Editor-General"><a href="#Editor-General" class="headerlink" title="Editor - General"></a>Editor - General</h4><h5 id="设置鼠标滚轮修改字体大小-可忽略"><a href="#设置鼠标滚轮修改字体大小-可忽略" class="headerlink" title="设置鼠标滚轮修改字体大小(可忽略)"></a>设置鼠标滚轮修改字体大小(可忽略)</h5><p><img src="/category/Intelij/b1.png" alt="idea"></p><p>可以增加 <strong>Ctrl + 鼠标滚轮</strong> 快捷键来控制代码字体大小写显示</p><h5 id="设置鼠标悬浮提示"><a href="#设置鼠标悬浮提示" class="headerlink" title="设置鼠标悬浮提示"></a>设置鼠标悬浮提示</h5><p><img src="/category/Intelij/b2.png" alt="idea"></p><h5 id="设置自动导包功能"><a href="#设置自动导包功能" class="headerlink" title="设置自动导包功能"></a>设置自动导包功能</h5><p><img src="/category/Intelij/b3.png" alt="idea"></p><ul><li>Add unambiguous imports on the fly：自动导入不明确的结构</li><li>Optimize imports on the fly：自动帮我们优化导入的包</li></ul><h5 id="设置显示行号和方法间的分隔符"><a href="#设置显示行号和方法间的分隔符" class="headerlink" title="设置显示行号和方法间的分隔符"></a>设置显示行号和方法间的分隔符</h5><p><img src="/category/Intelij/b.png" alt="idea"></p><p>如上图红圈所示，可以勾选Show line numers：显示行数，建议一般勾选上</p><p>Show method separators：显示方法分隔线，有助于区分开方法，建议勾选</p><h5 id="忽略大小写提示"><a href="#忽略大小写提示" class="headerlink" title="忽略大小写提示"></a>忽略大小写提示</h5><p><img src="/category/Intelij/b4.png" alt="idea"></p><p>IDEA的代码提示和补充功能有一个特性，区分大小写，如上图标注所示，默认就是First letter区分大小写的。</p><p><strong>新版：2019-1-3这样修改</strong></p><p><img src="/category/Intelij/b5.png" alt="idea"></p><h5 id="设置取消单行显示tabs的操作"><a href="#设置取消单行显示tabs的操作" class="headerlink" title="设置取消单行显示tabs的操作"></a>设置取消单行显示tabs的操作</h5><p><img src="/category/Intelij/b6.png" alt="idea"></p><h4 id="Editor-Font"><a href="#Editor-Font" class="headerlink" title="Editor - Font"></a>Editor - Font</h4><h5 id="设置默认的字体、字体大小、字体行间距"><a href="#设置默认的字体、字体大小、字体行间距" class="headerlink" title="设置默认的字体、字体大小、字体行间距"></a>设置默认的字体、字体大小、字体行间距</h5><p><img src="/category/Intelij/b7.png" alt="idea"></p><h4 id="Editor-Color-Scheme"><a href="#Editor-Color-Scheme" class="headerlink" title="Editor - Color Scheme"></a>Editor - Color Scheme</h4><h5 id="修改当前字体、字体大小、字体行间距-可忽略"><a href="#修改当前字体、字体大小、字体行间距-可忽略" class="headerlink" title="修改当前字体、字体大小、字体行间距(可忽略)"></a>修改当前字体、字体大小、字体行间距(可忽略)</h5><p>如果当前主题不希望使用默认字体、字体大小、字体行间距、还可以单独设置</p><p><img src="/category/Intelij/b8.png" alt="idea"></p><h5 id="修改当前主题的控制台输出的字体及字体大小-可忽略"><a href="#修改当前主题的控制台输出的字体及字体大小-可忽略" class="headerlink" title="修改当前主题的控制台输出的字体及字体大小(可忽略)"></a>修改当前主题的控制台输出的字体及字体大小(可忽略)</h5><p><img src="/category/Intelij/b9.png" alt="idea"></p><h5 id="修改代码中注释的字体颜色"><a href="#修改代码中注释的字体颜色" class="headerlink" title="修改代码中注释的字体颜色"></a>修改代码中注释的字体颜色</h5><p><img src="/category/Intelij/b11.png" alt="idea"></p><p>Doc Comment-Text：修改文档注释的字体颜色</p><p>Block Comment：修改多行注释的字体颜色</p><p>Line Comment：修改单行注释的字体颜色</p><h4 id="Editor-Code-Style"><a href="#Editor-Code-Style" class="headerlink" title="Editor - Code Style"></a>Editor - Code Style</h4><h5 id="设置超过指定import个数，改为-，-可忽略"><a href="#设置超过指定import个数，改为-，-可忽略" class="headerlink" title="设置超过指定import个数，改为*，(可忽略)"></a>设置超过指定import个数，改为*，(可忽略)</h5><p><img src="/category/Intelij/b12.png" alt="idea"></p><h4 id="Editor-File-and-Code-Templates"><a href="#Editor-File-and-Code-Templates" class="headerlink" title="Editor - File and Code Templates"></a>Editor - File and Code Templates</h4><h5 id="修改类头的文档注释信息"><a href="#修改类头的文档注释信息" class="headerlink" title="修改类头的文档注释信息"></a>修改类头的文档注释信息</h5><p><img src="/category/Intelij/b13.png" alt="idea"></p><p><code>/** @author shkstart @create ${YEAR}-${MONTH}-${DAY} ${TIME} *///</code></p><p><strong>常用的预设的变量，这里直接贴出官网给的：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$&#123;PACKAGE_NAME&#125; - the name of the target <span class="keyword">package</span> where the <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="title">or</span> <span class="title">interface</span> <span class="title">will</span> <span class="title">be</span> <span class="title">created</span>. </span></span><br><span class="line"><span class="class">$</span>&#123;PROJECT_NAME&#125; - the name of the current project. </span><br><span class="line">$&#123;FILE_NAME&#125; - the name of the PHP file that will be created.</span><br><span class="line">$&#123;NAME&#125; - the name of the <span class="keyword">new</span> file which you specify in the New File dialog box during the file creation. </span><br><span class="line">$&#123;USER&#125; - the login name of the current user. </span><br><span class="line">$&#123;DATE&#125; - the current system date. </span><br><span class="line">$&#123;TIME&#125; - the current system time. </span><br><span class="line">$&#123;YEAR&#125; - the current year. </span><br><span class="line">$&#123;MONTH&#125; - the current month. </span><br><span class="line">$&#123;DAY&#125; - the current day of the month. </span><br><span class="line">$&#123;HOUR&#125; - the current hour. </span><br><span class="line">$&#123;MINUTE&#125; - the current minute. </span><br><span class="line">$&#123;PRODUCT_NAME&#125; - the name of the IDE in which the file will be created. </span><br><span class="line">$&#123;MONTH_NAME_SHORT&#125; - the first <span class="number">3</span> letters of the month name. Example: Jan, Feb, etc. </span><br><span class="line">$&#123;MONTH_NAME_FULL&#125; - full name of a month. Example: January, February, etc</span><br></pre></td></tr></table></figure><h4 id="Editor-File-Encodings"><a href="#Editor-File-Encodings" class="headerlink" title="Editor - File Encodings"></a>Editor - File Encodings</h4><h5 id="设置项目文件编码"><a href="#设置项目文件编码" class="headerlink" title="设置项目文件编码"></a>设置项目文件编码</h5><p><img src="/category/Intelij/c1.png" alt="idea"></p><p>说明：Transparent native-to-ascii conversion主要用于转换ascii，一般都要勾选，不然Properties文件中的注释信息显示的都不是中文</p><h4 id="Build-Execution-Deployment"><a href="#Build-Execution-Deployment" class="headerlink" title="Build,Execution,Deployment"></a>Build,Execution,Deployment</h4><h5 id="设置自动编译"><a href="#设置自动编译" class="headerlink" title="设置自动编译"></a>设置自动编译</h5><p><img src="/category/Intelij/c2.png" alt="idea"></p><h5 id="设置省电模式-可忽略"><a href="#设置省电模式-可忽略" class="headerlink" title="设置省电模式(可忽略)"></a>设置省电模式(可忽略)</h5><p><img src="/category/Intelij/c3.png" alt="idea"></p><h5 id="设置代码水平或垂直显示"><a href="#设置代码水平或垂直显示" class="headerlink" title="设置代码水平或垂直显示"></a>设置代码水平或垂直显示</h5><p><img src="/category/Intelij/c4.png" alt="idea"></p><h4 id="设置快捷键-Keymap"><a href="#设置快捷键-Keymap" class="headerlink" title="设置快捷键(Keymap)"></a>设置快捷键(Keymap)</h4><h5 id="设置快捷键为Eclipse快捷键"><a href="#设置快捷键为Eclipse快捷键" class="headerlink" title="设置快捷键为Eclipse快捷键"></a>设置快捷键为Eclipse快捷键</h5><p><img src="/category/Intelij/c5.png" alt="idea"></p><h5 id="通过快捷键功能修改快捷键设置"><a href="#通过快捷键功能修改快捷键设置" class="headerlink" title="通过快捷键功能修改快捷键设置"></a>通过快捷键功能修改快捷键设置</h5><p><img src="/category/Intelij/c6.png" alt="idea"></p><h5 id="通过指定快捷键，查找或修改其他功能"><a href="#通过指定快捷键，查找或修改其他功能" class="headerlink" title="通过指定快捷键，查找或修改其他功能"></a>通过指定快捷键，查找或修改其他功能</h5><p><img src="/category/Intelij/c7.png" alt="idea"></p><h5 id="导入已有的设置"><a href="#导入已有的设置" class="headerlink" title="导入已有的设置"></a>导入已有的设置</h5><p><img src="/category/Intelij/c8.png" alt="idea"></p><h3 id="关于模板-Templates"><a href="#关于模板-Templates" class="headerlink" title="关于模板(Templates)"></a>关于模板(Templates)</h3><p>(Editor - Live Templates 和 Editor - General - Postfix Completion)</p><h4 id="Live-Templates-实时代码模板-功能介绍"><a href="#Live-Templates-实时代码模板-功能介绍" class="headerlink" title="Live Templates(实时代码模板)功能介绍"></a>Live Templates(实时代码模板)功能介绍</h4><p>它的原理就是配置一些常用代码字母缩写，在输入简写时可以出现你预定义的固定模式的代码，使得开发效率大大提高，同时也可以增加个性化。最简单的例子 就是在 Java 中输入 sout 会出现 System.out.println();</p><h4 id="已有的常用模板"><a href="#已有的常用模板" class="headerlink" title="已有的常用模板"></a>已有的常用模板</h4><h5 id="Postfix-Completion默认如下"><a href="#Postfix-Completion默认如下" class="headerlink" title="Postfix Completion默认如下"></a>Postfix Completion默认如下</h5><p><img src="/category/Intelij/d1.png" alt="idea"></p><h5 id="Live-Templates默认如下"><a href="#Live-Templates默认如下" class="headerlink" title="Live Templates默认如下"></a>Live Templates默认如下</h5><p><img src="/category/Intelij/d2.png" alt="idea"></p><p>二者的区别：Live Templates可以自定义，而Postfix Completion不可以，同时，有些操作二者都提供了模板，Postfix Templates较Live Templates能快0.01s</p><p><strong>举例：</strong></p><p><strong>psvm：可生成main方法</strong></p><p><strong>sout：System.out.println()快捷输出</strong></p><p>类似的：</p><p>soutp = System.out.println(“方法形参名 = “ + 形参名);</p><p>soutv = System.out.println(“变量名 = “ + 变量);</p><p>soutm = System.out.println(“当前类名.当前方法”);</p><p>“abc”.sout =&gt; System.out.println(“abc”);</p><p><strong>fori：可生成for循环</strong></p><p>iter：可成增强for循环</p><p>itar：可生成普通for循环</p><p><strong>list.for：可生成集合list的for循环</strong></p><p><strong>ifn：可生成if(xxx = null)<em>**</em></strong></p><p><strong>prsf：可生成private static final</strong></p><p>类似的：</p><p>psf：可生成 public static final</p><p>psfi：可生成 pubic static final int</p><p>psfs：可生成 public static final String</p><h4 id="修改现有模板：Live-Templates"><a href="#修改现有模板：Live-Templates" class="headerlink" title="修改现有模板：Live Templates"></a>修改现有模板：Live Templates</h4><p>通过调用psvm调用不习惯，可以修改</p><h4 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h4><p><img src="/category/Intelij/d3.png" alt="idea"></p><p>先定义一个模板组：</p><p><img src="/category/Intelij/d4.png" alt="idea"></p><p><img src="/category/Intelij/d5.png" alt="idea"></p><p>选中自定义的模板组，点击”+”来定义模板</p><p><img src="/category/Intelij/d6.png" alt="idea"></p><ol><li>Abbreviation：模板的缩略名称</li><li>Description：模板的描述</li><li>Template text：模板的代码片段</li><li>应用范围，比如点击Define,选择如下</li></ol><p><img src="/category/Intelij/d7.png" alt="idea"></p><h3 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h3><p>在IDEA中配置Tomcat之前，需要保证已经安装并配置了Tomcat的环境变量</p><p><img src="/category/Intelij/d8.png" alt="idea"></p><p><img src="/category/Intelij/d9.png" alt="idea"></p><p><img src="/category/Intelij/e1.png" alt="idea"></p><p><img src="/category/Intelij/e2.png" alt="idea"></p><p><img src="/category/Intelij/e3.png" alt="idea"></p><p><img src="/category/Intelij/e4.png" alt="idea"></p><h3 id="关联数据库"><a href="#关联数据库" class="headerlink" title="关联数据库"></a>关联数据库</h3><h4 id="关联方式"><a href="#关联方式" class="headerlink" title="关联方式"></a>关联方式</h4><p><img src="/category/Intelij/e5.png" alt="idea"></p><p><img src="/category/Intelij/e6.png" alt="idea"></p><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><p><img src="/category/Intelij/e7.png" alt="idea"></p><h3 id="版本控制-Version-Control"><a href="#版本控制-Version-Control" class="headerlink" title="版本控制(Version Control)"></a>版本控制(Version Control)</h3><p>不管是个人开发还是团队开发，版本控制都会被使用，而IDEA也很好的集成了版本控制相关结果</p><p><img src="/category/Intelij/e8.png" alt="idea"></p><p>很多人认为Intellij自带了SVN或是Git等版本控制工具，认为只要安装了IntellijIDEa就可以完全使用版本控制应有的功能，这是一种完全错误的解读，Intellij IDEA是自带对这些版本控制工具的插件支持，但是该装什么版本控制客户端还是要照样装的</p><p><img src="/category/Intelij/f1.png" alt="idea"></p><p>Intellij IDEA对版本控制的支持是以插件化的方式来实现的，旗舰版默认支持目前主流的版本控制软件，CVS、Subversion(SVN)、Git、Mercurial、Perforce、TFS。又因为目前太多人使用Github进行协同或是项目版本管理，所以Intellij IDEA同时自带了Github插件，方便Checkout和管理你的Github项目</p><p>在实际开发中，发现IDEA中使用SVN经历不算愉快，经常会遇到很多问题，比如紧急下IDEA无法更新、提交等</p><h4 id="提前安装好Git客户端"><a href="#提前安装好Git客户端" class="headerlink" title="提前安装好Git客户端"></a>提前安装好Git客户端</h4><p><a href="https://git-scm.com/" target="_blank" rel="noopener">Git的msysGit官网下载</a></p><p><a href="http://download.tortoisegit.org/tgit/" target="_blank" rel="noopener">Git客户端TortoiseGit官网下载</a></p><h4 id="关联git-exe"><a href="#关联git-exe" class="headerlink" title="关联git.exe"></a>关联git.exe</h4><p><img src="/category/Intelij/f2.png" alt="idea"></p><h4 id="关联GitHub上的账户，并测试连接"><a href="#关联GitHub上的账户，并测试连接" class="headerlink" title="关联GitHub上的账户，并测试连接"></a>关联GitHub上的账户，并测试连接</h4><p><img src="/category/Intelij/f3.png" alt="idea"></p><h4 id="在Github上创建账户下的一个新的仓库作为测试"><a href="#在Github上创建账户下的一个新的仓库作为测试" class="headerlink" title="在Github上创建账户下的一个新的仓库作为测试"></a>在Github上创建账户下的一个新的仓库作为测试</h4><p><img src="/category/Intelij/f4.png" alt="idea"></p><h4 id="支持从当前登录的github账号上直接Checkout项目"><a href="#支持从当前登录的github账号上直接Checkout项目" class="headerlink" title="支持从当前登录的github账号上直接Checkout项目"></a>支持从当前登录的github账号上直接Checkout项目</h4><p><img src="/category/Intelij/f5.png" alt="idea"></p><h4 id="在IDEA中clone-Github上的仓库"><a href="#在IDEA中clone-Github上的仓库" class="headerlink" title="在IDEA中clone Github上的仓库"></a>在IDEA中clone Github上的仓库</h4><p><img src="/category/Intelij/f6.png" alt="idea"></p><p>这里需要在Github的自己账户下，复制项目仓库路径，填写上图git repository URL中</p><p><img src="/category/Intelij/f7.png" alt="idea"></p><h4 id="连接成功会下载github上的项目"><a href="#连接成功会下载github上的项目" class="headerlink" title="连接成功会下载github上的项目"></a>连接成功会下载github上的项目</h4><p><img src="/category/Intelij/f8.png" alt="idea"></p><p><img src="/category/Intelij/f9.png" alt="idea"></p><p>根据自己需要，选择本窗口还是开启一个新窗口</p><h4 id="除此之外，还可以通过如下方式连接GitHub"><a href="#除此之外，还可以通过如下方式连接GitHub" class="headerlink" title="除此之外，还可以通过如下方式连接GitHub"></a>除此之外，还可以通过如下方式连接GitHub</h4><p><img src="/category/Intelij/g1.png" alt="idea"></p><h4 id="本地代码分享到GitHub"><a href="#本地代码分享到GitHub" class="headerlink" title="本地代码分享到GitHub"></a>本地代码分享到GitHub</h4><p><img src="/category/Intelij/g2.png" alt="idea"></p><p><img src="/category/Intelij/g3.png" alt="idea"></p><p>此时会在github上创建一个新的仓库，而非更新已经存在的仓库</p><h4 id="Git的常用操作"><a href="#Git的常用操作" class="headerlink" title="Git的常用操作"></a>Git的常用操作</h4><p><img src="/category/Intelij/g4.png" alt="idea"></p><p>clone：拷贝远程仓库</p><p>commit：本地提交</p><p>push：远程提交</p><p>pull：更新到本地</p><h4 id="没有使用Git时本地历史记录的查看"><a href="#没有使用Git时本地历史记录的查看" class="headerlink" title="没有使用Git时本地历史记录的查看"></a>没有使用Git时本地历史记录的查看</h4><p><img src="/category/Intelij/g5.png" alt="idea"></p><p>即使我们项目没有使用版本控制功能，Intellij IDEA也给我们提供了本地文件历史记录</p><h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><h4 id="Debug的设置"><a href="#Debug的设置" class="headerlink" title="Debug的设置"></a>Debug的设置</h4><p><img src="/category/Intelij/g6.png" alt="idea"></p><p>设置Debug连接方式，默认时Socket，Shared memory是Windows特有的一个属性，一般在Windows系统下建议使用此设置，内存占用相对较少</p><h4 id="常用断点调试快捷键"><a href="#常用断点调试快捷键" class="headerlink" title="常用断点调试快捷键"></a>常用断点调试快捷键</h4><p><img src="/category/Intelij/g7.png" alt="idea"></p><h4 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h4><p><strong>说明：</strong></p><p>调试的时候，在循环里增加条件判断，可以极大的提高效率，心情也能愉悦</p><p><strong>具体操作：</strong></p><p>在断点处点击调出条件断点，可以在满足某个条件下，实施断点</p><p><strong>查看表达式的值(Ctrl+u)</strong></p><p>选择行 ctrl+u 还可以查看框中输入编写代码时的其他方法</p><p><img src="/category/Intelij/g8.png" alt="idea"></p><h3 id="配置Maven"><a href="#配置Maven" class="headerlink" title="配置Maven"></a>配置Maven</h3><h4 id="Mavan介绍"><a href="#Mavan介绍" class="headerlink" title="Mavan介绍"></a>Mavan介绍</h4><p>Maven -&gt; Ant -&gt; Maven -&gt; Gradle</p><p>Mave是Apache提供的一款自动化构建工具，用于自动化构建和依赖管理，开发团队基本不用花多少时间就能自动完成工程的基础构建配置，因为Maven使用了一个标准的目录结构和一个默认的构建生命周期。</p><p><strong>构建环节：</strong></p><p><img src="/category/Intelij/q1.png" alt="idea"></p><h4 id="Maven的配置"><a href="#Maven的配置" class="headerlink" title="Maven的配置"></a>Maven的配置</h4><p>maven下载-解压-配置(settings配置仓库reposiroty)</p><p><img src="/category/Intelij/q2.png" alt="idea"></p><ul><li>Maven home directory：可以指定本地Maven的安装目录所在，因为已经配置了M2_HOME系统参数，所以直接这样配置Intellij IDEA是可以找到的，但是加入没有配置，这里选择Maven安装目录，此外不建议使用IDEA默认的</li><li>User settings file/Local repository：我们还可以指定Maven的settings.xml位置和本地仓库位置</li></ul><p><img src="/category/Intelij/q3.png" alt="idea"></p><ul><li>Import Maven projects atuomaticallu：表示Intellij IDEA会实时监控项目的pom.xml文件，进行项目变动设置</li><li>Automatically download：在Maven导入依赖包时候，是否自动下载源码和文档，不建议勾选，因为会加快项目从外网导入依赖包的速度。Intellij支持直接从公网下载源码和文档，如果需要我们可以针对某个依赖包进行联网下载</li><li>VM options for importer：可以设置导入的VM参数，一般不需要主动该，除非项目真的导入太慢了我们再增大此参数</li></ul><h4 id="创建对应的Module"><a href="#创建对应的Module" class="headerlink" title="创建对应的Module"></a>创建对应的Module</h4><p><img src="/category/Intelij/q4.png" alt="idea"></p><p>Group：组织或公司域名，倒叙</p><p>Artiface：项目模块名称</p><p>Version：默认maven生成版本</p><p>其中常用的是clean、compile、package、install。</p><p>如果其他项目需要将这里的模块作为依赖使用，那就可以install安装到本地仓库的位置</p><p>maven下创建的web工程目录会和eclipse不一样，需要手动创建resource、java、test文件</p><h3 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h3><h4 id="生成javadoc"><a href="#生成javadoc" class="headerlink" title="生成javadoc"></a>生成javadoc</h4><p><img src="/category/Intelij/q5.png" alt="idea"></p><p>输入：</p><p>Locale：输入语言类型：zh_CN</p><p>Other command line arguments：-encoding UTF-8 -charset UTF-8</p><h4 id="缓存和索引的清理"><a href="#缓存和索引的清理" class="headerlink" title="缓存和索引的清理"></a>缓存和索引的清理</h4><p><img src="/category/Intelij/q6.png" alt="idea"></p><h4 id="取消更新"><a href="#取消更新" class="headerlink" title="取消更新"></a>取消更新</h4><p><img src="/category/Intelij/q7.png" alt="idea"></p><p><a href="https://blog.csdn.net/qq_42914528/article/details/89710864" target="_blank" rel="noopener">IDEA</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Intellij入门,环境配置,tomcat、mysql配置
    
    </summary>
    
      <category term="工具使用" scheme="https://www.ysmjjsy.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
      <category term="Intellij" scheme="https://www.ysmjjsy.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Intellij/"/>
    
    
      <category term="Intellij" scheme="https://www.ysmjjsy.com/tags/Intellij/"/>
    
  </entry>
  
  <entry>
    <title>路径问题</title>
    <link href="https://www.ysmjjsy.com/category/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.ysmjjsy.com/category/路径问题/</id>
    <published>2018-08-28T16:00:00.000Z</published>
    <updated>2019-09-17T09:16:19.183Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:16:56 GMT+0800 (GMT+08:00) --><h1 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h1><p>绝对路径：不可改变的路径<br>本地绝对路径：增加盘符的路径（e:/test/test.html）<br>网络绝对路径：增加协议，IP地址，端口号的路径（<a href="http://localhost:8080/test/test.html）" target="_blank" rel="noopener">http://localhost:8080/test/test.html）</a><br>相对路径：可以改变的路径，但是以基准路径为参考，查找其他路径<br>默认情况下，相对路径的基准路径是以当前资源的访问路径为基准<br>路径以斜杠开头，表示的特殊的相对路径，在不同的场景中，相对的位置会发生变化。<br>url : <a href="http://localhost:8080/atcrowdfunding-web/test/test.html" target="_blank" rel="noopener">http://localhost:8080/atcrowdfunding-web/test/test.html</a><br>前台路径：&lt;a href=rdquo;/sssssrdquo;&gt;&lt;img src=rdquo;rdquo;&gt;<br>相对服务器的根 ： <a href="http://localhost:8080/sssss" target="_blank" rel="noopener">http://localhost:8080/sssss</a><br>后台路径：forward（rdquo;/user.jsprdquo;）, xml<br>相对web应用的根：<a href="http://localhost:8080/atcrowdfunding-web/user.jsp" target="_blank" rel="noopener">http://localhost:8080/atcrowdfunding-web/user.jsp</a><br>监听器解决路径问题：</p><p><img src="/category/路径问题/1.png" alt="路径"></p><p><img src="/category/路径问题/2.png" alt="路径"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      绝对路径与相对路径
    
    </summary>
    
      <category term="Java相关" scheme="https://www.ysmjjsy.com/categories/Java%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Java相关" scheme="https://www.ysmjjsy.com/tags/Java%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>Maven的使用</title>
    <link href="https://www.ysmjjsy.com/category/maven/"/>
    <id>https://www.ysmjjsy.com/category/maven/</id>
    <published>2018-07-19T16:00:00.000Z</published>
    <updated>2019-09-17T06:19:47.697Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 14:20:56 GMT+0800 (GMT+08:00) --><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p><img src="/category/maven/1.png" alt="maven"></p><h2 id="目前的技术在开发中存在的问题"><a href="#目前的技术在开发中存在的问题" class="headerlink" title="目前的技术在开发中存在的问题"></a>目前的技术在开发中存在的问题</h2><ul><li><strong>一个项目就是一个工程</strong><ul><li>一个项目如果非常庞大，就不适合用package来划分模块，最好是每一个模块对应一个工程</li><li>借助于Maven就可以将一个项目拆分成多个工程</li></ul></li><li><strong>项目中需要的jar包必须手动”复制”、”粘贴”到WEB-INF/lib目录下</strong><ul><li>带来的问题：同样的jar包文件重复出现在不同的项目工程中，一方面浪费存储空间，另外让工程比较臃肿</li><li>借助Maven，可以将jar包仅仅保存在”仓库中”，有需要使用的工程”引用”这个文件接口，并不需要真的把jar包复制过来</li></ul></li><li><strong>jar包需要别人替我们准备好，或者到官网下载</strong><ul><li>不同技术的官网提供jar包下载的形式是五花八门的</li><li>有些技术的官网就是通过Maven或SVN等专门的工具来提供下载的</li><li>如果以不规范的方式下载的jar包，那么卡中的内容很可能也是不规范的</li><li>借助于Maven可以以一种规范的方式下载jar包，因为所有知名框架或第三方工具的jar包以及按照统一的规范放在了Maven的中央仓库的，以规范的方式下载的jar包，内容也是可靠的</li><li>“统一的规范”不仅是对IT开发领域非常重要，对于整个人类社会都是非常重要的</li></ul></li><li><strong>一个jar包依赖的其他jar包需要自己手动加入到项目中</strong><ul><li>FileUpload组件 -&gt; IO组件。commons-fileupload-1.3.jar依赖于commons-io-2.0.1.jar</li><li>如果所有的jar包之间的依赖关系都需要程序员自己非常清楚了解，那么就会增大学习成本</li><li>Maven会自动将依赖的jar包导入出来</li></ul></li></ul><h2 id="Maven是什么？"><a href="#Maven是什么？" class="headerlink" title="Maven是什么？"></a>Maven是什么？</h2><ul><li><strong>Maven是一款服务于java平台的自动化构建工具</strong><ul><li>Make-&gt;Ant-Maven-&gt;Gradle</li></ul></li><li><p><strong>构建</strong></p><ul><li><p>概念：以java源文件、框架配置文件、JSP、HTML、图片等资源为原材料去生产一个可以运行的项目的过程</p><ul><li>编译</li><li>部署</li><li>构建</li></ul></li><li><p>编译：java源文件-&gt;编译-&gt;Class字节码文件-&gt;交给JVM去执行</p></li><li><p>部署：一个BS项目最终运行的并不是动态Web工程本身，而是这个动态Web工程编译得结果</p><ul><li>动态Web工程—&gt;编译、部署—&gt;编译结果</li></ul></li><li><p>运行时环境</p><p><img src="/category/maven/2.png" alt="maven"></p></li><li><p>其实是一组jar包的引用，并没有把jar包本身复制到工程中，所以并不是目录</p><p><img src="/category/maven/3.png" alt="maven"></p></li><li><p>开发过程中，所有的路径或配置文件中的配置的类路径等都是以编译结果的目录结构为标准的</p></li></ul></li></ul><ul><li><strong>构建过程中的各个环节</strong><ul><li>清理：将以前编译得到的旧的class字节码文件删除，为下一次编译做准备</li><li>编译：将Java源程序编译成class字节码文件</li><li>测试：自动测试，自动调用junit程序</li><li>报告：测试程序执行的结果</li><li>打包：动态Web工程打war包，Java工程打jar包</li><li>安装：Maven特定的概念—将打包得到的文件复制到”仓库”中的指定位置</li><li>部署：将动态Web工程生成的war包复制到Servlet容器的指定目录下，使其可以运行</li></ul></li><li><strong>自动化构建</strong></li></ul><h2 id="安装Maven的核心程序"><a href="#安装Maven的核心程序" class="headerlink" title="安装Maven的核心程序"></a>安装Maven的核心程序</h2><ul><li>检查Java_Home环境变量</li><li>解压Maven核心程序的压缩包，放在一个非中文无空格路径下</li><li>配置Maven相关的环境变量<ul><li>MAVEN_HOME或M2_HOME</li><li>path:maven的bin目录</li></ul></li></ul><h2 id="Maven的核心概念"><a href="#Maven的核心概念" class="headerlink" title="Maven的核心概念"></a>Maven的核心概念</h2><ul><li><strong>约定的目录结构</strong></li><li><strong>POM</strong><ul><li>含义：Project Object Model项目对象模型</li><li>pom.xml对于Maven工程是核心配置文件，与构建过程相关的一切设置都在这个文件中进行配置</li></ul></li><li><p><strong>坐标</strong></p><ul><li><p>Maven中的坐标</p><ul><li><p>使用下面三个向量在仓库中定位一个Maven工程（gav）</p><ul><li>groupid：公司或组织域名倒叙+项目名</li><li>artifactid：模块名</li><li>version：版本</li></ul></li><li><p>Maven工程的坐标与仓库中路径的对应关系</p><p><img src="/category/maven/4.png" alt="maven"></p></li></ul></li></ul></li></ul><ul><li><strong>依赖</strong></li><li><p>仓库</p><ul><li><p>仓库的分类</p><ul><li>本地仓库：当前电脑上部署的仓库目录，为当前电脑上所有Maven工程服务</li><li><p>远程仓库：</p><ul><li><p>私服：架设在当前局域网环境下，为当前局域网范围内的所有Maven工程服务</p><p><img src="/category/maven/5.png" alt="maven"></p></li><li><p>中央仓库：架设在Internate上，为全世界所有Maven工程服务</p></li><li><p>中央仓库的镜像：架设在各大洲，为中央仓库分担流量，减轻中央仓库的压力，同时更快的响应用户请求</p></li></ul></li></ul></li></ul></li></ul><ul><li>生命周期/插件/目标</li><li>继承</li><li>聚合</li></ul><h2 id="第一个Maven工程"><a href="#第一个Maven工程" class="headerlink" title="第一个Maven工程"></a>第一个Maven工程</h2><ul><li><strong>创建约定的目录结构</strong><ul><li>根目录：工程名</li><li>src目录：源码</li><li>pom.xml文件：Maven工程的核心配置文件</li><li>main目录：存放主程序</li><li>test目录：存放测试程序</li><li>java目录：存放java源文件</li><li>resource目录：存放框架或其他工具的配置文件</li></ul></li><li><strong>为什么要遵守约定的目录结构？</strong><ul><li>Maven要负责我们这个项目的自动化构建，以编译为例，Maven要想自动进行编译，那么它必须知道java源文件保存在哪里</li><li>如果我们自定义的东西想要框架或工具知道，有两种办法：<ul><li>以配置的方式明确告诉框架</li><li>遵守框架已经存在的约定</li></ul></li><li>约定&gt;配置&gt;编码</li></ul></li><li><strong>常用Maven命令</strong><ul><li>注意：执行与构建过程相关的Maven命令，必须进入pom.xml所在目录<ul><li>与构建过程相关：编译、测试、打包、…</li></ul></li><li>常用命令：<ul><li>mvn clean：清理</li><li>mvn compile：编译主程序</li><li>mvn test-compile：编译测试程序</li><li>mvn test：执行测试</li><li>mvn package：打包</li><li>mvn install：安装</li><li>mvn site：生成站点</li></ul></li></ul></li><li>关于联网问题<ul><li>Maven的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须由特定的插件来完成。而插件本身并不包含在Maven的核心程序中</li><li>当我们执行的Maven命令需要用到某些插件式，Maven核心程序会首先到本地仓库中查找</li><li>本地仓库的默认位置：[系统中当前用户的家目录].m2\repository</li><li>Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网，到中央仓库下载</li><li>如果此时无法连接外网，则构建失败</li><li>修改默认本地仓库的位置，可以让Maven核心程序到我们事先准备好的目录下查找插件<ul><li>找到Maven解压目录\conf\settings.xml</li><li>在settings.xml文件中找到localRepository标签</li><li>将<localrepository>/path/to/local/repo</localrepository>从注释中取出</li><li>将标签体内容内容修改为已经准备好的Maven仓库目录</li></ul></li></ul></li></ul><ul><li><p>依赖</p><ul><li><p>Maven解析依赖信息时会到本地仓库中查找被依赖的 jar包</p><ul><li>对于我们自己开发的Maven工程。使用install命令安装后就可以进入仓库</li></ul></li><li><p>依赖的范围</p><p><img src="/category/maven/6.png" alt="maven"></p></li><li><p>compile范围依赖</p><p><img src="/category/maven/7.png" alt="maven"></p></li><li><p>对主程序是否有效：有效</p></li><li><p>对测试程序是否有效：有效</p></li><li><p>是否参与打包：参与</p></li><li><p>是否参与部署：参与</p></li></ul></li><li><p>test范围依赖</p><ul><li>对主程序是否有效：无效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：不参与</li><li>是否参与部署：不参与</li></ul></li><li><p>provided范围依赖</p><p><img src="/category/maven/8.png" alt="maven"></p><ul><li>对主程序是否有效：有效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：不参与</li><li>是否参与部署：不参与</li></ul></li></ul><ul><li>生命周期<ul><li>各个构建环节的执行顺序：不能打乱顺序，必须按照 既定的正确顺序来执行</li><li>Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的</li><li>Maven核心程序为了更好的实现自动化构建，按照这一特点执行生命周期中的各个阶段：不论现在要执行生命周期中的哪一个阶段，都是从这个生命周期最初的位置开始执行</li><li>插件和目标<ul><li>生命周期的各个阶段仅仅定义了要执行的任务是什么</li><li>各个阶段和插件的目标是对应的</li><li>相似的目标由特定的插件来完成的</li><li>可以将目标看作：调用插件功能的命令</li></ul></li></ul></li></ul><div class="table-container"><table><thead><tr><th>生命周期阶段</th><th>插件目标</th><th>插件</th></tr></thead><tbody><tr><td>compile</td><td>compile</td><td>maven-compiler-plugin</td></tr><tr><td>test-compile</td><td>testCompile</td><td>maven-compiler-plugin</td></tr></tbody></table></div><h2 id="Maven插件的使用"><a href="#Maven插件的使用" class="headerlink" title="Maven插件的使用"></a>Maven插件的使用</h2><ul><li><p>Eclipse中Maven插件的设置</p><ul><li>Maven插件：Eclipse内置<ul><li>installations：指定Maven核心程序的设置，不建议使用内置的</li><li>user settings：指定conf/settings.xml的位置，进而获取本地仓库的位置</li></ul></li><li>基本操作<ul><li>创建Maven版的Java工程</li><li>创建Maven版的Web工程</li><li>执行Maven命令</li></ul></li></ul></li><li><p>依赖</p><ul><li><p>依赖的传递性</p><p><img src="/category/maven/9.png" alt="maven"></p></li><li><p>好处：可以传递的依赖不必在每个模块中都重复声明，在”最下面”的工程中依赖一次即可</p></li><li><p>注意：非compile范围的依赖不能传递，所以在各个工程模块中如果需要就得重复声明依赖</p></li></ul></li><li><p>依赖的排除</p><ul><li><p>需要设置依赖排除的场合</p><p><img src="/category/maven/a1.png" alt="maven"></p></li><li><p>依赖排除的设置方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>依赖的原则</p><ul><li><p>作用：解决模块工程之间的jar包冲突问题</p></li><li><p>验证路径最短者原则</p><p><img src="/category/maven/a2.png" alt="maven"></p></li><li><p>路径相同时，先声明者优先（先声明指的是dependency标签的声明顺序）</p><p><img src="/category/maven/a3.png" alt="maven"></p></li></ul></li><li><p>统一管理依赖版本</p><ul><li><p>建议配置方式</p><ul><li><p>使用properties标签统一声明版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>                           <span class="tag">&lt;<span class="name">cj.spring.version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">cj.spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在需要统一版本的位置，使用${自定义标签名}引用声明的版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;cj.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>其实properties标签配合自定义标签声明数据的配置并不是只能用于声明依赖的版本号，凡是需要统一声明后再引用的场合都可以使用</p></li></ul></li></ul></li></ul></li><li><p>继承</p><p><img src="/category/maven/a4.png" alt="maven"></p><p><img src="/category/maven/a5.png" alt="maven"></p></li><li><p>聚合</p><p><img src="/category/maven/a6.png" alt="maven"></p></li></ul><p>推荐博文：</p><p><a href="https://www.cnblogs.com/best/p/9676515.html#_lab2_1_2" target="_blank" rel="noopener">一个小时学会Maven</a></p><p><a href="https://blog.csdn.net/qq_37859539/article/details/80182729" target="_blank" rel="noopener">Maven默认骨架</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      maven入门,详解
    
    </summary>
    
      <category term="Maven" scheme="https://www.ysmjjsy.com/categories/Maven/"/>
    
    
      <category term="Maven" scheme="https://www.ysmjjsy.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>国际化实现原理</title>
    <link href="https://www.ysmjjsy.com/category/%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://www.ysmjjsy.com/category/国际化实现原理/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2019-09-16T10:26:09.126Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 16 2019 18:26:38 GMT+0800 (GMT+08:00) --><h1 id="国际化程序实现原理"><a href="#国际化程序实现原理" class="headerlink" title="国际化程序实现原理"></a>国际化程序实现原理</h1><p>定义保存文字的文件信息<br>根据不同的区域语言的编码读取指定的资源信息</p><p>把与语言相关的所有字符串都写成变量<br>写两个配置文件，一个文件中存放中文信息、另一个存放英文信息</p><p><img src="/category/国际化实现原理/1.png" alt="guojihua"></p><h2 id="Locale类"><a href="#Locale类" class="headerlink" title="Locale类"></a>Locale类</h2><p>描述区域和语言编码的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Locale</span><span class="params">(String language)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Locale</span><span class="params">(String language,String country)</span></span>;</span><br><span class="line"></span><br><span class="line">Locale loc = <span class="keyword">new</span> Locale(<span class="string">"zh"</span>,<span class="string">"CN"</span>);  <span class="comment">//中文环境</span></span><br><span class="line"></span><br><span class="line">Locale.getDefault(): <span class="comment">//默认环境</span></span><br></pre></td></tr></table></figure><h2 id="读取资源文件：ResourceBundle"><a href="#读取资源文件：ResourceBundle" class="headerlink" title="读取资源文件：ResourceBundle"></a>读取资源文件：ResourceBundle</h2><p>获取ResourceBundle类对象的方法:</p><p><code>public static final ResourceBundle getBundle(String baseName);</code><br>baseName -&gt; 描述资源文件的名称，但是没有后缀<br><code>String getString()</code>:获取资源信息</p><blockquote><p>使用一个类，来通过语言环境，最终识别加载哪一个文件的信息：ResourceBundle</p><p>语言环境：Locale</p><p>new Locale(“zh”,”CN”);</p><p>Locale.getDefault();</p><p>Locale.CHINA</p></blockquote><h2 id="消息格式化"><a href="#消息格式化" class="headerlink" title="消息格式化"></a>消息格式化</h2><p><strong>MessageFormat类</strong></p><p>占位符 {0},<br><code>format()</code>:处理占位符信息</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取Locale，这是由客户端的浏览器提供的Locale</span><br><span class="line">创建ResourceBundle</span><br><span class="line">把所有语言信息使用rb.getString(<span class="string">"xxx"</span>)来替换</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      关于国际化实现原理
    
    </summary>
    
      <category term="Java相关" scheme="https://www.ysmjjsy.com/categories/Java%E7%9B%B8%E5%85%B3/"/>
    
      <category term="国际化实现原理" scheme="https://www.ysmjjsy.com/categories/Java%E7%9B%B8%E5%85%B3/%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Java相关" scheme="https://www.ysmjjsy.com/tags/Java%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-分享</title>
    <link href="https://www.ysmjjsy.com/category/JavaWeb%E5%AD%A6%E4%B9%A0%E5%88%86%E4%BA%AB/"/>
    <id>https://www.ysmjjsy.com/category/JavaWeb学习分享/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2019-09-17T09:06:46.089Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:12:06 GMT+0800 (GMT+08:00) --><h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://www.cnblogs.com/xdp-gacl/tag/JavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">JavaWeb学习总结</a></p><h2 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h2><p>崔希凡JavaWeb</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      推荐一些学习资料
    
    </summary>
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/categories/JavaWeb/"/>
    
      <category term="分享" scheme="https://www.ysmjjsy.com/categories/JavaWeb/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-注解</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E6%B3%A8%E8%A7%A3/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-注解/</id>
    <published>2018-03-21T16:00:00.000Z</published>
    <updated>2019-09-16T09:11:47.034Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 16 2019 17:55:59 GMT+0800 (GMT+08:00) --><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>语法：@注解名称<br>注解的作用：替代xml配置文件<br>servlet3.0就可以不使用web.xml,而是所有配置都使用注解<br>注解是由框架来读取使用的</p><blockquote><p>以前，『XML』是各大框架的青睐者，它以松耦合的方式完成了框架中几乎所有的配置，但是随着项目越来越庞大，『XML』的内容也越来越复杂，维护成本变高。</p><p>于是就有人提出来一种标记式高耦合的配置方式，『注解』。方法上可以进行注解，类上也可以注解，字段属性上也可以注解，反正几乎需要配置的地方都可以进行注解。</p><p>关于『注解』和『XML』两种不同的配置模式，争论了好多年了，各有各的优劣，注解可以提供更大的便捷性，易于维护修改，但耦合度高，而 XML 相对于注解则是相反的。</p><p>追求低耦合就要抛弃高效率，追求效率必然会遇到耦合。</p></blockquote><p>实际上Java注解与普通修饰符(public、static、void等)的使用方式并没有多大区别，下面的例子是常见的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//@Test注解修饰方法A</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个方法上可以拥有多个不同的注解</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"uncheck"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在方法上使用@Test注解后，在运行该方法时，测试框架会自动识别该方法并单独调用，@Test实际上是一种标记注解，起标记作用，运行时告诉测试框架该方法为测试方法。而对于@Deprecated和@SuppressWarnings(“uncheck”)，则是Java本身内置的注解，在代码中，可以经常看见它们，但这并不是一件好事，毕竟当方法或是类上面有@Deprecated注解时，说明该方法或是类都已经过期不建议再用，@SuppressWarnings 则表示忽略指定警告，比如@SuppressWarnings(“uncheck”)，这就是注解的最简单的使用方式</p><h2 id="注解的本质"><a href="#注解的本质" class="headerlink" title="注解的本质"></a>注解的本质</h2><p>「java.lang.annotation.Annotation」接口中有这么一句话，用来描述『注解』。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The common <span class="class"><span class="keyword">interface</span> <span class="title">extended</span> <span class="title">by</span> <span class="title">all</span> <span class="title">annotation</span> <span class="title">types</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//所有的注解类型都继承自这个普通的接口（<span class="title">Annotation</span>）</span></span><br></pre></td></tr></table></figure><p>这句话有点抽象，但却说出了注解的本质。我们看一个 JDK 内置注解的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是注解 @Override 的定义，其实它本质上就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Override</span> <span class="keyword">extends</span> <span class="title">Annotation</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，注解的本质就是一个继承了 Annotation 接口的接口。有关这一点，你可以去反编译任意一个注解类，你会得到结果的。</p><p><strong>一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有解析它的代码，它可能连注释都不如。</strong></p><p>而解析一个类或者方法的注解往往有两种形式，一种是编译期直接的扫描，一种是运行期反射。反射的事情我们待会说，而编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。</p><p>典型的就是注解 @Override，一旦编译器检测到某个方法被修饰了 @Override 注解，编译器就会检查当前方法的方法签名是否真正重写了父类的某个方法，也就是比较父类中是否具有一个同样的方法签名。</p><p>这一种情况只适用于那些编译器已经熟知的注解类，比如 JDK 内置的几个注解，而你自定义的注解，编译器是不知道你这个注解的作用的，当然也不知道该如何处理，往往只是会根据该注解的作用范围来选择是否编译进字节码文件，仅此而已。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>『元注解』是用于修饰注解的注解，通常用在注解的定义上，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们 @Override 注解的定义，你可以看到其中的 @Target，@Retention 两个注解就是我们所谓的『元注解』，『元注解』一般用于指定某个注解生命周期以及作用目标等信息。</p><p>JAVA 中有以下几个『元注解』：</p><ul><li>@Target：注解的作用目标</li><li>@Retention：注解的生命周期</li><li>@Documented：注解是否应当被包含在 JavaDoc 文档中</li><li>@Inherited：是否允许子类继承该注解</li></ul><p>其中，@Target 用于指明被修饰的注解最终可以作用的目标是谁，也就是指明，你的注解到底是用来修饰方法的？修饰类的？还是用来修饰字段属性的。</p><p>@Target 的定义如下：</p><p><img src="/category/JavaSE-注解/1.png" alt="注解"></p><p>我们可以通过以下的方式来为这个 value 传值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.FIELD&#125;)</span><br></pre></td></tr></table></figure><p>被这个 @Target 注解修饰的注解将只能作用在成员字段上，不能用于修饰方法或者类。其中，ElementType 是一个枚举类型，有以下一些值：</p><ul><li>ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上</li><li>ElementType.FIELD：允许作用在属性字段上</li><li>ElementType.METHOD：允许作用在方法上</li><li>ElementType.PARAMETER：允许作用在方法参数上</li><li>ElementType.CONSTRUCTOR：允许作用在构造器上</li><li>ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上</li><li>ElementType.ANNOTATION_TYPE：允许作用在注解上</li><li>ElementType.PACKAGE：允许作用在包上</li></ul><p>@Retention 用于指明当前注解的生命周期，它的基本定义如下：</p><p><img src="/category/JavaSE-注解/2.png" alt="注解"></p><p>同样的，它也有一个 value 属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME</span><br></pre></td></tr></table></figure><p>这里的 RetentionPolicy 依然是一个枚举类型，它有以下几个枚举值可取：</p><ul><li>RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件</li><li>RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件</li><li>RetentionPolicy.RUNTIME：永久保存，可以反射获取</li></ul><p>@Retention 注解指定了被修饰的注解的生命周期，一种是只能在编译期可见，编译后会被丢弃，一种会被编译器编译进 class 文件中，无论是类或是方法，乃至字段，他们都是有属性表的，而 JAVA 虚拟机也定义了几种注解属性表用于存储注解信息，但是这种可见性不能带到方法区，类加载时会予以丢弃，最后一种则是永久存在的可见性。</p><p>剩下两种类型的注解我们日常用的不多，也比较简单，这里不再详细的进行介绍了，你只需要知道他们各自的作用即可。@Documented 注解修饰的注解，当我们执行 JavaDoc 文档打包时会被保存进 doc 文档，反之将在打包时丢弃。@Inherited 注解修饰的注解是具有可继承性的，也就说我们的注解修饰了一个类，而该类的子类将自动继承父类的该注解。</p><h3 id="Java的内置三大注解"><a href="#Java的内置三大注解" class="headerlink" title="Java的内置三大注解"></a>Java的内置三大注解</h3><p>除了上述四种元注解外，JDK 还为我们预定义了另外三种注解，它们是：</p><ul><li>@Override</li><li>@Deprecated</li><li>@SuppressWarnings</li></ul><p>@Override 注解想必是大家很熟悉的了，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它没有任何的属性，所以并不能存储任何其他信息。它只能作用于方法之上，编译结束后将被丢弃。</p><p>所以你看，它就是一种典型的『标记式注解』，仅被编译器可知，编译器在对 java 文件进行编译成字节码的过程中，一旦检测到某个方法上被修饰了该注解，就会去匹对父类中是否具有一个同样方法签名的函数，如果不是，自然不能通过编译。</p><p>@Deprecated 的基本定义如下：</p><p><img src="/category/JavaSE-注解/3.png" alt="注解"></p><p>依然是一种『标记式注解』，永久存在，可以修饰所有的类型，作用是，标记当前的类或者方法或者字段等已经不再被推荐使用了，可能下一次的 JDK 版本就会删除。</p><p>当然，编译器并不会强制要求你做什么，只是告诉你 JDK 已经不再推荐使用当前的方法或者类了，建议你使用某个替代者。</p><p>@SuppressWarnings 主要用来压制 java 的警告，它的基本定义如下：</p><p><img src="/category/JavaSE-注解/4.png" alt="注解"></p><p>它有一个 value 属性需要你主动的传值，这个 value 代表一个什么意思呢，这个 value 代表的就是需要被压制的警告类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一段代码，程序启动时编译器会报一个警告。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning:(<span class="number">8</span>, <span class="number">21</span>) java: java.util.Date 中的 Date(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>) <span class="comment">//已过时</span></span><br></pre></td></tr></table></figure><p>而如果我们不希望程序启动时，编译器检查代码中过时的方法，就可以使用 @SuppressWarnings 注解并给它的 value 属性传入一个参数值来压制编译器的检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarning</span>(value = <span class="string">"deprecated"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样你就会发现，编译器不再检查 main 方法下是否有过时的方法调用，也就压制了编译器对于这种警告的检查。</p><p>当然，JAVA 中还有很多的警告类型，他们都会对应一个字符串，通过设置 value 属性的值即可压制对于这一类警告类型的检查。</p><p>自定义注解的相关内容就不再赘述了，比较简单，通过类似以下的语法即可自定义一个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InnotationName&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，自定义注解的时候也可以选择性的使用元注解进行修饰，这样你可以更加具体的指定你的注解的生命周期、作用范围等信息。</p><h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><h4 id="定义注解类"><a href="#定义注解类" class="headerlink" title="定义注解类"></a>定义注解类</h4><p>@Overrid：作用在方法上的注解，当方法不是重写父类的方法时会报错<br>@Deprecated：作用在方法伤害，标记该方法为作废方法（已过时）<br>@SuppressWarnings：作用在方法上，压制警告</p><p>定义注解使用@interface<br>public @interface MyAnn{}<br>所有的注解都是Annotation的子类</p><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><ul><li>注解的作用目标：<ul><li>类（接口、枚举）</li><li>属性</li><li>方法</li><li>构造器</li><li>参数</li><li>局部变量</li><li>包</li></ul></li></ul><h4 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h4><ul><li><p>定义属性</p><ul><li>格式：类型 属性名()</li></ul></li><li><p>使用注解时给属性赋值</p><ul><li>@MyAnno1(age=100,name=”zhangSan”)</li></ul></li><li><p>注解属性的默认值：在定义注解时，可以给注解指定默认值</p><ul><li>int age() default 100;</li><li>在使用注解时，可以不给带有默认值的属性赋值</li></ul></li><li><p>名为value的属性的特权</p><ul><li>当使用注解时，如果只给名为value的属性赋值时，可以省略”value=”<ul><li>例如：@MyAnno1(value=”hello”),可以书写成 @MyAnno1(“hello”)</li></ul></li></ul></li><li><p>注解属性的类型</p><ul><li>8种基本类型</li><li>String</li><li>Enum</li><li>Class</li><li>注解类型</li><li>以上类型的一维数组类型</li><li><p>当给数组类型的属性赋值时，若数组元素的个数为1时，可以省略大括号</p><p><img src="/category/JavaSE-注解/5.png" alt="注解"></p><p><img src="/category/JavaSE-注解/6.png" alt="注解"></p><h4 id="注解的作用目标限定以及保存策略限定"><a href="#注解的作用目标限定以及保存策略限定" class="headerlink" title="注解的作用目标限定以及保存策略限定"></a>注解的作用目标限定以及保存策略限定</h4></li></ul></li><li>让一个注解，它的作用目标只能在类上，不能再方法上，这就叫作用目标的限定<ul><li>再定义注解时，给注解添加注解，这个注解是@Target<br><img src="/category/JavaSE-注解/7.png" alt="注解"></li></ul></li><li>保留策略<ul><li>源代码文件(SOURCE)：只在源代码种存在，当编译时就被忽略了</li><li>字节码文件(CLASS)：注解在源代码中存在，然后编译时会把注解信息放到class文件，但jvm在加载类时，会忽略注解</li><li>JVM中(RUNTIME)：注解在源代码、字节码文件中存在，并且在JVM加载类时，会把注解加载到JVM内存中（它是唯一可反射注解)<br>限定注解的保留策略：使用Retention<br><img src="/category/JavaSE-注解/8.png" alt="注解"></li></ul></li></ul><h2 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h2><p>「注解的本质就是一个继承了 Annotation 接口的接口」，现在我们就来从虚拟机的层面看看，注解的本质到底是什么。</p><p>首先，我们自定义一个注解类型：</p><p><img src="/category/JavaSE-注解/9.png" alt="注解"></p><p>这里我们指定了 Hello 这个注解只能修饰字段和方法，并且该注解永久存活，以便我们反射获取。</p><p>之前我们说过，虚拟机规范定义了一系列和注解相关的属性表，也就是说，无论是字段、方法或是类本身，如果被注解修饰了，就可以被写进字节码文件。属性表有以下几种：</p><ul><li>RuntimeVisibleAnnotations：运行时可见的注解</li><li>RuntimeInVisibleAnnotations：运行时不可见的注解</li><li>RuntimeVisibleParameterAnnotations：运行时可见的方法参数注解</li><li>RuntimeInVisibleParameterAnnotations：运行时不可见的方法参数注解</li><li>AnnotationDefault：注解类元素的默认值</li></ul><p>给大家看虚拟机的这几个注解相关的属性表的目的在于，让大家从整体上构建一个基本的印象，注解在字节码文件中是如何存储的。</p><p>所以，对于一个类或者接口来说，Class 类中提供了以下一些方法用于反射注解。</p><ul><li>getAnnotation：返回指定的注解</li><li>isAnnotationPresent：判定当前元素是否被指定注解修饰</li><li>getAnnotations：返回所有的注解</li><li>getDeclaredAnnotation：返回本元素的指定注解</li><li>getDeclaredAnnotations：返回本元素的所有注解，不包含父类继承而来的</li></ul><p>方法、字段中相关反射注解的方法基本是类似的，这里不再赘述，我们下面看一个完整的例子。</p><p>首先，设置一个虚拟机启动参数，用于捕获 JDK 动态代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dsun.misc.ProxyGenerator.saveGeneratedFiles=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>然后 main 函数。</p><p><img src="/category/JavaSE-注解/10.png" alt="注解"></p><p>我们说过，注解本质上是继承了 Annotation 接口的接口，而当你通过反射，也就是我们这里的 getAnnotation 方法去获取一个注解类实例的时候，其实 JDK 是通过动态代理机制生成一个实现我们注解（接口）的代理类。</p><p>我们运行程序后，会看到输出目录里有这么一个代理类，反编译之后是这样的：</p><p><img src="/category/JavaSE-注解/11.png" alt="注解"></p><p><img src="/category/JavaSE-注解/12.png" alt="注解"></p><p>代理类实现接口 Hello 并重写其所有方法，包括 value 方法以及接口 Hello 从 Annotation 接口继承而来的方法。</p><p>而这个关键的 InvocationHandler 实例是谁？</p><p>AnnotationInvocationHandler 是 JAVA 中专门用于处理注解的 Handler， 这个类的设计也非常有意思。</p><p><img src="/category/JavaSE-注解/a1.png" alt="注解"></p><p>这里有一个 memberValues，它是一个 Map 键值对，键是我们注解属性名称，值就是该属性当初被赋上的值。</p><p><img src="/category/JavaSE-注解/a2.png" alt="注解"></p><p><img src="/category/JavaSE-注解/a3.png" alt="注解"></p><p>而这个 invoke 方法就很有意思了，大家注意看，我们的代理类代理了 Hello 接口中所有的方法，所以对于代理类中任何方法的调用都会被转到这里来。</p><p>var2 指向被调用的方法实例，而这里首先用变量 var4 获取该方法的简明名称，接着 switch 结构判断当前的调用方法是谁，如果是 Annotation 中的四大方法，将 var7 赋上特定的值。</p><p>如果当前调用的方法是 toString，equals，hashCode，annotationType 的话，AnnotationInvocationHandler 实例中已经预定义好了这些方法的实现，直接调用即可。</p><p>那么假如 var7 没有匹配上这四种方法，说明当前的方法调用的是自定义注解字节声明的方法，例如我们 Hello 注解的 value 方法。<strong>这种情况下，将从我们的注解 map 中获取这个注解属性对应的值。</strong></p><p>其实，JAVA 中的注解设计个人觉得有点反人类，明明是属性的操作，非要用方法来实现。当然，如果你有不同的见解，欢迎留言探讨。</p><p>最后我们再总结一下整个反射注解的工作原理：</p><p>首先，我们通过键值对的形式可以为注解属性赋值，像这样：@Hello（value = “hello”）。</p><p>接着，你用注解修饰某个元素，编译器将在编译期扫描每个类或者方法上的注解，会做一个基本的检查，你的这个注解是否允许作用在当前位置，最后会将注解信息写入元素的属性表。</p><p>然后，当你进行反射的时候，虚拟机将所有生命周期在 RUNTIME 的注解取出来放到一个 map 中，并创建一个 AnnotationInvocationHandler 实例，把这个 map 传递给它。</p><p>最后，虚拟机将采用 JDK 动态代理机制生成一个目标注解的代理类，并初始化好处理器。</p><p>那么这样，一个注解的实例就创建出来了，它本质上就是一个代理类，你应当去理解好 AnnotationInvocationHandler 中 invoke 方法的实现逻辑，这是核心。一句话概括就是，<strong>通过方法名返回注解属性值</strong>。</p><h2 id="Java8中注解增强"><a href="#Java8中注解增强" class="headerlink" title="Java8中注解增强"></a>Java8中注解增强</h2><h3 id="元注解-Repeatable"><a href="#元注解-Repeatable" class="headerlink" title="元注解@Repeatable"></a>元注解@Repeatable</h3><p>元注解@Repeatable是JDK1.8新加入的，它表示在同一个位置重复相同的注解。在没有该注解前，一般是无法在同一个类型上使用相同的注解的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java8前无法这样使用</span></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/update"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/add"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>Java8前如果是想实现类似的功能，我们需要在定义@FilterPath注解时定义一个数组元素接收多个值如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FilterPath &#123;</span><br><span class="line">    String [] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="meta">@FilterPath</span>(&#123;<span class="string">"/update"</span>,<span class="string">"/add"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>但在Java8新增了@Repeatable注解后就可以采用如下的方式定义并使用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.annotationdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Java8新增@Repeatable原注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Repeatable</span>(FilterPaths.class)<span class="comment">//参数指明接收的注解class</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FilterPath &#123;</span><br><span class="line">    <span class="function">String  <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> FilterPaths &#123;</span><br><span class="line">    FilterPath[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用案例</span></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/update"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/add"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/delete"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>我们可以简单理解为通过使用@Repeatable后，将使用@FilterPaths注解作为接收同一个类型上重复注解的容器，而每个@FilterPath则负责保存指定的路径串。为了处理上述的新增注解，Java8还在AnnotatedElement接口新增了getDeclaredAnnotationsByType() 和 getAnnotationsByType()两个方法并在接口给出了默认实现，在指定@Repeatable的注解时，可以通过这两个方法获取到注解相关信息。但请注意，旧版API中的getDeclaredAnnotation()和 getAnnotation()是不对@Repeatable注解的处理的(除非该注解没有在同一个声明上重复出现)。注意getDeclaredAnnotationsByType方法获取到的注解不包括父类，其实当 getAnnotationsByType()方法调用时，其内部先执行了getDeclaredAnnotationsByType方法，只有当前类不存在指定注解时，getAnnotationsByType()才会继续从其父类寻找，但请注意如果@FilterPath和@FilterPaths没有使用了@Inherited的话，仍然无法获取。下面通过代码来演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Java8新增@Repeatable原注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Repeatable</span>(FilterPaths.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FilterPath &#123;</span><br><span class="line">    <span class="function">String  <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> FilterPaths &#123;</span><br><span class="line">    FilterPath[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/list"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用案例</span></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/update"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/add"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/delete"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> <span class="keyword">extends</span> <span class="title">CC</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = AA.class;</span><br><span class="line">        <span class="comment">//通过getAnnotationsByType方法获取所有重复注解</span></span><br><span class="line">        FilterPath[] annotationsByType = clazz.getAnnotationsByType(FilterPath.class);</span><br><span class="line">        FilterPath[] annotationsByType2 = clazz.getDeclaredAnnotationsByType(FilterPath.class);</span><br><span class="line">        <span class="keyword">if</span> (annotationsByType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FilterPath filter : annotationsByType) &#123;</span><br><span class="line">                System.out.println(<span class="string">"1:"</span>+filter.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (annotationsByType2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FilterPath filter : annotationsByType2) &#123;</span><br><span class="line">                System.out.println(<span class="string">"2:"</span>+filter.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"使用getAnnotation的结果:"</span>+clazz.getAnnotation(FilterPath.class));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行结果(当前类拥有该注解FilterPath,则不会从CC父类寻找)</span></span><br><span class="line"><span class="comment">         1:/web/update</span></span><br><span class="line"><span class="comment">         1:/web/add</span></span><br><span class="line"><span class="comment">         1:/web/delete</span></span><br><span class="line"><span class="comment">         -----------------</span></span><br><span class="line"><span class="comment">         2:/web/update</span></span><br><span class="line"><span class="comment">         2:/web/add</span></span><br><span class="line"><span class="comment">         2:/web/delete</span></span><br><span class="line"><span class="comment">         使用getAnnotation的结果:null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从执行结果来看如果当前类拥有该注解@FilterPath,则getAnnotationsByType方法不会从CC父类寻找，下面看看另外一种情况，即AA类上没有@FilterPath注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Java8新增@Repeatable原注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">//添加可继承元注解</span></span><br><span class="line"><span class="meta">@Repeatable</span>(FilterPaths.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FilterPath &#123;</span><br><span class="line">    <span class="function">String  <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">//添加可继承元注解</span></span><br><span class="line"><span class="meta">@interface</span> FilterPaths &#123;</span><br><span class="line">    FilterPath[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/list"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/getList"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AA上不使用@FilterPath注解,getAnnotationsByType将会从父类查询</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> <span class="keyword">extends</span> <span class="title">CC</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = AA.class;</span><br><span class="line">        <span class="comment">//通过getAnnotationsByType方法获取所有重复注解</span></span><br><span class="line">        FilterPath[] annotationsByType = clazz.getAnnotationsByType(FilterPath.class);</span><br><span class="line">        FilterPath[] annotationsByType2 = clazz.getDeclaredAnnotationsByType(FilterPath.class);</span><br><span class="line">        <span class="keyword">if</span> (annotationsByType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FilterPath filter : annotationsByType) &#123;</span><br><span class="line">                System.out.println(<span class="string">"1:"</span>+filter.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (annotationsByType2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FilterPath filter : annotationsByType2) &#123;</span><br><span class="line">                System.out.println(<span class="string">"2:"</span>+filter.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"使用getAnnotation的结果:"</span>+clazz.getAnnotation(FilterPath.class));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行结果(当前类没有<span class="doctag">@FilterPath</span>,getAnnotationsByType方法从CC父类寻找)</span></span><br><span class="line"><span class="comment">         1:/web/list</span></span><br><span class="line"><span class="comment">         1:/web/getList</span></span><br><span class="line"><span class="comment">         -----------------</span></span><br><span class="line"><span class="comment">         使用getAnnotation的结果:null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意定义@FilterPath和@FilterPath时必须指明@Inherited，getAnnotationsByType方法否则依旧无法从父类获取@FilterPath注解，这是为什么呢，不妨看看getAnnotationsByType方法的实现源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口默认实现方法</span></span><br><span class="line"><span class="keyword">default</span> &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) &#123;</span><br><span class="line"><span class="comment">//先调用getDeclaredAnnotationsByType方法</span></span><br><span class="line">T[] result = getDeclaredAnnotationsByType(annotationClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前类获取到的注解数组是否为0</span></span><br><span class="line"><span class="keyword">if</span> (result.length == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span> <span class="keyword">instanceof</span> Class &amp;&amp; </span><br><span class="line"><span class="comment">//判断定义注解上是否使用了@Inherited元注解 </span></span><br><span class="line"> AnnotationType.getInstance(annotationClass).isInherited()) &#123; <span class="comment">// Inheritable</span></span><br><span class="line">        <span class="comment">//从父类获取</span></span><br><span class="line">       Class&lt;?&gt; superClass = ((Class&lt;?&gt;) <span class="keyword">this</span>).getSuperclass();</span><br><span class="line">   <span class="keyword">if</span> (superClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = superClass.getAnnotationsByType(annotationClass);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增的两种ElementType"><a href="#新增的两种ElementType" class="headerlink" title="新增的两种ElementType"></a>新增的两种ElementType</h3><p>在Java8中 ElementType 新增两个枚举成员，TYPE_PARAMETER 和 TYPE_USE ，在Java8前注解只能标注在一个声明(如字段、类、方法)上，Java8后，新增的TYPE_PARAMETER可以用于标注类型参数，而TYPE_USE则可以用于标注任意类型(不包括class)。如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TYPE_PARAMETER 标注在类型参数上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&lt;@<span class="title">Parameter</span> <span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TYPE_USE则可以用于标注任意类型(不包括class)</span></span><br><span class="line"><span class="comment">//用于父类或者接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> <span class="keyword">implements</span> @<span class="title">Rectangular</span> <span class="title">Shape</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于构造函数</span></span><br><span class="line"><span class="keyword">new</span> <span class="meta">@Path</span> String(<span class="string">"/usr/bin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于强制转换和instanceof检查,注意这些注解中用于外部工具，它们不会对类型转换或者instanceof的检查行为带来任何影响。</span></span><br><span class="line">String path=(<span class="meta">@Path</span> String)input;</span><br><span class="line"><span class="keyword">if</span>(input <span class="keyword">instanceof</span> <span class="meta">@Path</span> String)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于指定异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> @Localized IOException.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//用于通配符绑定</span></span></span><br><span class="line"><span class="function">List&lt;@ReadOnly ? extends Person&gt;</span></span><br><span class="line"><span class="function">List&lt;? extends @ReadOnly Person&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">@NotNull String.class <span class="comment">//非法，不能标注class</span></span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.lang.@NotNull String <span class="comment">//非法，不能标注import</span></span></span><br></pre></td></tr></table></figure><p>这里主要说明一下TYPE_USE，类型注解用来支持在Java的程序中做强类型检查，配合第三方插件工具（如Checker Framework），可以在编译期检测出runtime error（如UnsupportedOperationException、NullPointerException异常），避免异常延续到运行期才发现，从而提高代码质量，这就是类型注解的主要作用。总之Java 8 新增加了两个注解的元素类型ElementType.TYPE_USE 和ElementType.TYPE_PARAMETER ，通过它们，我们可以把注解应用到各种新场合中。</p><p>参考博文：</p><p><a href="https://blog.csdn.net/javazejian/article/details/71860633" target="_blank" rel="noopener">深入理解Java注解类型(@Annotation)</a>（Java8中注解增强）</p><p><a href="https://juejin.im/post/5b45bd715188251b3a1db54f" target="_blank" rel="noopener">JAVA 注解的基本原理</a></p><p>推荐博文：</p><p><a href="https://www.jianshu.com/p/5cac4cb9be54" target="_blank" rel="noopener">深入浅出Java注解</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE注解入门
    
    </summary>
    
      <category term="JavaSE" scheme="https://www.ysmjjsy.com/categories/JavaSE/"/>
    
      <category term="JavaSE注解" scheme="https://www.ysmjjsy.com/categories/JavaSE/JavaSE%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-JavaBean</title>
    <link href="https://www.ysmjjsy.com/category/JavaBean/"/>
    <id>https://www.ysmjjsy.com/category/JavaBean/</id>
    <published>2018-03-16T16:00:00.000Z</published>
    <updated>2019-09-17T09:04:48.315Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:12:06 GMT+0800 (GMT+08:00) --><h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><p>必须要为成员提供get/set方法（提供一个也可以）如果只有get方法，那么这个属性是只读属性必须要有默认构造器（没参）一般对于具有get/set方法的成员变量称之为属性其实就算一个属性没有对应的成员变量，只有get/set方法也是可以的属性的名称就是get/set方法去除get/set后，再把首字母小写</p><p>get/set决定属性名称</p><p>方法名称满足一定的规范，那么他就是属性</p><p>boolean类型的属性，他的读方法可以是is开头或是get开头</p><p><strong>JavaBean内省</strong><br>内省类 —&gt;Bean信息 —&gt;属性描述符 —&gt;属性的get/set对应的Method! —&gt;反射</p><p>commons-beanutils 依赖内省完成的<br>导包：<br>commons-beanutils.jar<br>commons-logging.jar<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="string">"cn.cj.domain.Person"</span>;</span><br><span class="line">Class clazz = Class.forName(className);</span><br><span class="line">Object bean = clazz.newInstance();</span><br><span class="line">BeanUtils.setProperty(bean,<span class="string">"name"</span>,<span class="string">"张三"</span>);</span><br><span class="line"></span><br><span class="line">String age = BeanUtils.getProperty(bean,<span class="string">"age"</span>);</span><br></pre></td></tr></table></figure><p></p><p>把map中的属性直接封装到一个bean中要求map的key与bean的属性名相同<br>BeanUtils.populate(user,map);</p><p>map转换成指定类型的javaBean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">toBean</span><span class="params">(Map map, Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    T bean = clazz.clazz.newInstance();</span><br><span class="line">    BeanUtils.populate(bean,map);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/category/JavaBean/1.png" alt="JavaBean"></p><p><strong>jsp中的javabean相关标签</strong></p><p><code>&lt;jsp:useBean&gt;</code> 创建或查询bean<br>在域中查找名为user1的bean，如果不存在，创建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id = <span class="string">"user1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.cj.domain.User"</span> scope=<span class="string">"page"</span>/&gt;创建保存</span><br><span class="line">&lt;jsp:useBean id = <span class="string">"user1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.cj.domain.User"</span> scope=<span class="string">"page"</span>/&gt;查找</span><br></pre></td></tr></table></figure><p><code>&lt;jsp:setProperty&gt;</code><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:setProperty property=<span class="string">"username"</span> name=<span class="string">"user1"</span> value=<span class="string">"admin"</span>/&gt;设置名为user1的javabean的username属性值为admin</span><br></pre></td></tr></table></figure><p></p><p><code>&lt;jsp:getProperty&gt;</code><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:getProperty property=<span class="string">"username"</span> name=<span class="string">"user1"</span>/&gt;获取名为user1的javabean的名为username属性值</span><br></pre></td></tr></table></figure><p></p><h2 id="JDBC分页-监听器"><a href="#JDBC分页-监听器" class="headerlink" title="JDBC分页-监听器"></a>JDBC分页-监听器</h2><p><strong>分页</strong></p><p>分页的优点：只查询一页，不查询所有页<br>分页数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数据都是从Servlet传递来的</span><br><span class="line">Servlet：</span><br><span class="line">    当前页：pageCode，pc</span><br><span class="line">        pc：如果页面没有传递当前页码，那么Servlet默认是第一页，或者按页面传递为准</span><br><span class="line">    总页数：totallPages。tp</span><br><span class="line">        tp：总记录数/每页记录数</span><br><span class="line">    总记录数：totallRecored，tr</span><br><span class="line">        tr：dao来获取，<span class="function">select <span class="title">count</span><span class="params">(*)</span> from t_customer</span>;</span><br><span class="line">    每页记录数：业务数据或叫系统数据</span><br><span class="line">    当前页数据：beanList</span><br><span class="line">    url</span><br></pre></td></tr></table></figure><p>数据的传递：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这些分页数据总要在各层之间来回传递</span><br><span class="line">把这些分页数据封装到一个javaBean中，就叫分页Bean，例如PageBean</span><br></pre></td></tr></table></figure><p></p><p>分页在各层中处理：</p><p>页面：给出分页相关的链接们</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    页面需要给Servlet传递当前页码pc</span><br><span class="line">Servlet：创建PageBean对象，给PageBean所有属性赋值，然后传递给页面</span><br><span class="line">    Servlet需要给Dao传递pc、ps</span><br><span class="line">Service：</span><br><span class="line">Dao：</span><br><span class="line">    tr：<span class="function">select <span class="title">count</span><span class="params">(*)</span> t_customer</span></span><br><span class="line"><span class="function">    beanList：select * from t_customer LIMIT x,y</span></span><br></pre></td></tr></table></figure><p><img src="/category/JavaBean/2.png" alt="JavaBean"></p><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>JavaWeb监听器：Listener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">监听器是一个接口，内容我们来实现</span><br><span class="line">监听器需要注册</span><br><span class="line">监听器的方法，会在特定事件发生时被调用</span><br></pre></td></tr></table></figure><p>观察者：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">事件源</span><br><span class="line">事件</span><br><span class="line">监听器</span><br></pre></td></tr></table></figure><p></p><p>事件源：三大域<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ServletContext：</span><br><span class="line">    生命周期监听：ServletContextListener：两个方法，一个出生时调用，一个死亡时调用</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span>：创建SErvletcontext时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span>：销毁SErvletcontext时</span></span><br><span class="line"><span class="function">    属性监听：ServletCcontextAttributeListener：三个方法，一个在添加属性时调用，一个在替换属性时调用，最后一个在移出属性时调用</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextEvent event)</span>：添加属性时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletContextEvent event)</span>：替换属性时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextEvent event)</span>：移除属性时</span></span><br><span class="line"><span class="function">    可以存放一些在tomcat启动时就要完成的代码</span></span><br><span class="line"><span class="function">HttpSesion：</span></span><br><span class="line"><span class="function">    生命周期监听：HttpSesionListener：两个方法，一个出生时调用，一个死亡时调用</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent se)</span>：创建session时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span>：销毁session时</span></span><br><span class="line"><span class="function">    属性监听：HttpSesionAttributeListener：三个方法，一个在添加属性时调用，一个在替换属性时调用，最后一个在移出属性时调用</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(HttpSessionBindingEvent event)</span>：添加属性时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(HttpSessionBindingEvent event)</span>：替换属性时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(HttpSessionBindingEvent event)</span>：移除属性时</span></span><br><span class="line"><span class="function">ServletRequest：</span></span><br><span class="line"><span class="function">    生命周期监听：ServletRequestListener：两个方法，一个出生时调用，一个死亡时调用</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span>：创建request时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span>：销毁request时</span></span><br><span class="line"><span class="function">    属性监听：ServletRequestAttributeListener：三个方法，一个在添加属性时调用，一个在替换属性时调用，最后一个在移出属性时调用</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletRequestEvent event)</span>：添加属性时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletRequestEvent event)</span>：替换属性时</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletRequestEventevent)</span>：移除属性时</span></span><br></pre></td></tr></table></figure><p></p><p>写一个监听器类：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">要求必须实现某个监听器接口</span><br><span class="line">注册，是在web.xml中配置来完成注册</span><br></pre></td></tr></table></figure><p></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>cn.cj.web.listener.AListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事件对象：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ServletContextEvent：<span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">HttpServletEvent：HttpSession <span class="title">getSession</span><span class="params">()</span></span></span><br><span class="line"><span class="function">ServletRequest：</span></span><br><span class="line"><span class="function">    ServletContext <span class="title">getServletContext</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">    ServletRequest <span class="title">getServletRequest</span><span class="params">()</span></span>;</span><br><span class="line">ServletContextAttributeEvent:</span><br><span class="line">    <span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span>：获取属性名</span></span><br><span class="line"><span class="function">    Object <span class="title">getValue</span><span class="params">()</span>：获取属性值</span></span><br><span class="line"><span class="function">HttpSessionBindingEvent</span></span><br><span class="line"><span class="function">    String <span class="title">getName</span><span class="params">()</span>：获取属性名</span></span><br><span class="line"><span class="function">    Object <span class="title">getValue</span><span class="params">()</span>：获取属性值</span></span><br><span class="line"><span class="function">ServletRequestEvent</span></span><br><span class="line"><span class="function">    String <span class="title">getName</span><span class="params">()</span>：获取属性名</span></span><br><span class="line"><span class="function">    Object <span class="title">getValue</span><span class="params">()</span>：获取属性值</span></span><br><span class="line"><span class="function">感知监听器（都与HttpSession相关）</span></span><br><span class="line"><span class="function">    用来添加到JavaBena上，而不是添加到三大域上</span></span><br><span class="line"><span class="function">    这两个监听器都不需要在web.xml中注册</span></span><br></pre></td></tr></table></figure><p></p><p>HttpSessionBindingListener：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">添加到javaBean上，javaBean就知道自己是否添加到Session中</span><br></pre></td></tr></table></figure><p></p><p>HttpSessionActivationListener：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tomcat会在session从时间不被使用时钝化session对象，所谓钝化session，就是把session通过序列化的方式保存到硬盘文件中。当用户再使用session时，Tomcat还会把钝化的对象再活化session，所谓活化就是把硬盘文件中的session在反序列化回内存。当session被Tomcat钝化时，session中存储的对象也被纯化，当session被活化时，也会把session中存储的对象活化。如果某个类实现了HttpSessionActiveationListener接口后，当对象随着session被钝化和活化时，下面两个方法就会被调用：</span><br></pre></td></tr></table></figure><p></p><p>public void sessionWillPassivate(HttpSessionEvent se)：当对象感知被活化时调用本方法；<br>public void sessionDidActivate(HttpSessionEvent se)：当对象感知被钝化时调用本方法；<br>HttpSessionActivationListener监听器与HttpSessionBindingListener监听器相似，都是感知型的监听器，例如让Person类实现了HttpSessionActivationListener监听器接口，并把Person对象添加到了session中后，当Tomcat钝化session时，同时也会钝化session中的Person对象，这时Person对象就会感知到自己被钝化了，其实就是调用Person对象的sessionWillPassivate()方法。当用户再次使用session时，Tomcat会活化session，这时Person会感知到自己被活化，其实就是调用Person对象的sessionDidActivate()方法。<br>注意，因为钝化和活化session，其实就是使用序列化和反序列化技术把session从内存保存到硬盘，和把session从硬盘加载到内存。这说明如果Person类没有实现Serializable接口，那么当session钝化时就不会钝化Person，而是把Person从session中移除再钝化！这也说明session活化后，session中就不在有Person对象了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaBean
    
    </summary>
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/categories/JavaWeb/"/>
    
      <category term="JavaBean" scheme="https://www.ysmjjsy.com/categories/JavaWeb/JavaBean/"/>
    
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-JSP</title>
    <link href="https://www.ysmjjsy.com/category/JSP/"/>
    <id>https://www.ysmjjsy.com/category/JSP/</id>
    <published>2018-03-14T16:00:00.000Z</published>
    <updated>2019-09-17T08:57:50.475Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:12:06 GMT+0800 (GMT+08:00) --><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><p>JSP就是一种包装的Servlet</p><h2 id="JSP和Servlet的分工"><a href="#JSP和Servlet的分工" class="headerlink" title="JSP和Servlet的分工"></a><strong>JSP和Servlet的分工</strong></h2><p><strong>JSP:</strong></p><ul><li>作为请求发起页面，例如显示表单、超链接</li><li>作为请求结束页面，例如显示数据</li></ul><p><strong>Servlet:</strong></p><ul><li>作为请求中处理数据的环节</li><li>获取JSP发送过来的请求参数</li><li>处理请求，得到处理后的数据</li><li>把结果保存到request域中</li><li>转发到显示结果的JSP</li></ul><h2 id="JSP的组成"><a href="#JSP的组成" class="headerlink" title="JSP的组成"></a><strong>JSP的组成</strong></h2><p>JSP=html+java脚本+jsp标签(指令)</p><h2 id="JSP九大内置对象"><a href="#JSP九大内置对象" class="headerlink" title="JSP九大内置对象"></a><strong>JSP九大内置对象</strong></h2><p>request—&gt;HttpServletRequest<br>response—&gt;HttpServletResponse<br>sessio—&gt;HttpSession<br>applicatio—&gt;servletContext类的对象<br>pageContext—&gt;页面上下文对象<br>config—&gt;ServletConfig<br>out—&gt;输出流，用来向客户端响应<br>page—&gt;当前jsp的”this”，真身Object<br>exception—&gt;Throwable</p><p><strong>pageContext</strong></p><p>Servlet中有三大域：request、response、application<br>Jsp中有四大域:request、response、application、pageContext<br>servletCotext:整个应用程序<br>session:整个会话（一个会话中只有一个用户）<br>request：一个请求链<br>pageContext：一个jsp页面！这个域是在当前jsp页面和当前jsp页面中使用的标签之间共享数据<br>域对象<br>代理其他域：pageContext.setAttribute(“xxx”,”xxx”,PageContext.SESSION.SCOPE);<br>全域查找：pageContext.findAttribute(“xxx”);从小到大，依赖查找<br>获取其他8个内置对象</p><h2 id="3种Java脚本"><a href="#3种Java脚本" class="headerlink" title="3种Java脚本"></a><strong>3种Java脚本</strong></h2><p>&lt;%…%&gt;java代码片段，用于定义0~N条Java语句。方法内写什么，它写什么<br>&lt;%= …%&gt;java表达式，用于输出，输出一条表达式的结果。response.getWrite().print(…)这里能放什么，它就能放什么<br>&lt;%!…%&gt;声明，用来创建类的成员和变量方法，class MyClass{}（类体）这里能放什么它放什么<br>JSP输出<br>&lt;%— … —%&gt;当服务器把JSP编译成java文件时已经忽略了注释部分</p><p>&lt;%@ …%&gt; jsp指令，也是一种特殊的标签</p><h2 id="JSP原理"><a href="#JSP原理" class="headerlink" title="JSP原理"></a><strong>JSP原理</strong></h2><p>JSP其实就是一种特殊的Servlet<br>当jsp页面第一次被访问时，服务器会把jsp编译成java文件（这个java其实是一个servlet)类<br>然后再把java编译成.class<br>然后创建该类对象<br>最后调用它的service()方法<br>第二次请求同一jsp时，直接调用service()方法</p><p>tomcat的work目录下可以找到jsp对应的.java源代码</p><h2 id="JSP标签"><a href="#JSP标签" class="headerlink" title="JSP标签"></a>JSP标签</h2><p><strong>JSP三大指令：</strong><br>指令格式:&lt;%@ … %&gt;</p><p><strong>page:最复杂</strong></p><ul><li>pageEncoding和ContentType：<ul><li>pageEncoding:指定当前jsp页面的编码，只要不说谎就不会乱码,在服务器要把jsp编译成.java需要使用pageEncoding</li><li>ContentType：添加一个响应头，等同于response.setContentType(“text/html;charset=utf-8”):</li></ul></li></ul><p>如果两个属性只提供一个，那么另一个的默认值为设置那一个。<br>如果两个都没设置，默认时iso</p><ul><li>import:导包</li><li><p>errorPage和isErrorPage：</p><ul><li>errorPage：当前页面抛出异常，那么要转发到哪一个页面，由errorPage来指定（请求转发）</li><li>isErrorPage：当前页面是否为处理错误的页面，当该属性为true时，这个页面会设置状态码为500，而且这个页面可以使用9大内置对象中的exception。</li></ul><p><strong>web.xml中配置错误页面</strong></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/error404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/error500.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.RuntimeException<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>autoFlush和buffer</strong></p><ul><li>autoFlush:指定jsp输出缓冲区满时，是否自动刷新，默认时true，如果为false，那么在缓冲区满时抛出异常</li><li>buffer:指定缓冲区大小，默认为8kb，通常不需要修改</li><li>isELIgnored:是否忽略el表达式，默认值为false，不忽略，支持</li><li>language:指定当前jsp编译后的语言类型，默认值为java</li><li>info：信息</li><li>isThreadSafe：默认为false，是否支持并发访问</li><li>session:当前页面是否支持session，如果false，则当前页面没有session内置对象</li><li>extends:让jsp生成的servlet去继承该属性指定的类</li></ul><p><strong>include:静态包含</strong><br>与RequestDispatcher的include()方法的功能相似<br><a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x25;&#64;&#105;&#x6e;&#99;&#108;&#117;&#x64;&#x65;&#x25;">&#x25;&#64;&#105;&#x6e;&#99;&#108;&#117;&#x64;&#x65;&#x25;</a>：它是在jsp编译成java文件时完成的，共同生成一个java文件（一个Servlet），再生成一个class<br>RequestDispatcher的include()方法：包含和被包含的是两个servlet，即两个.class它们只是把响应的内容在运行时合并了<br>作用：把不变的和变得分开</p><p><strong>taglib:导入标签库</strong><br>prefix:指定标签库在本页中的前缀，由我们自己来起名字<br>uri：指定标签库的位置</p><p><strong>JSP动作标签</strong><br>是由服务器来解释执行<br>html提供的标签由浏览器来执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward&gt;:与RequestDispatcher的forward方法是一样的，一个在Servlet中使用，一个在JSP中使用</span><br><span class="line">&lt;jsp:include&gt;:与RequestDispatcher的include方法是一样的，一个在Servlet中使用，一个在JSP中使用</span><br><span class="line">&lt;%<span class="meta">@include</span>%&gt;和&lt;jsp:include&gt;的不同，前者是两者包含在一起，后者是仅仅把输出结果合并</span><br><span class="line">&lt;jsp:param&gt;:作为forward和include的子标签，用来给转发或包含的页面传递参数</span><br></pre></td></tr></table></figure><p>tomcat cof目录下 context.xml<br><code>&lt;Context reloadable=&quot;true&quot;&gt;</code>:不用重启tomcat</p><p>JSP其实是一个servlet，在conf下的web.xml里看到有个JspServlet，调用jsp页面则是调用这个JspServlet，把jsp文件读取变成.java,然后编译成.class，然后创建其对象，调用其service方法</p><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>EL是JSP内置的表达式语言，可以全域查找${xxx}<br>如果查找不到，输出空字符串，不是null<br>（pageContext—&gt;request—&gt;session—&gt;application）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageContextScope.xxx&#125;</span><br><span class="line"></span><br><span class="line">$&#123;requestScope.xxx&#125;</span><br><span class="line"></span><br><span class="line">$&#123;session.xxx&#125;</span><br><span class="line"></span><br><span class="line">$&#123;application.xxx&#125;</span><br></pre></td></tr></table></figure><p>jsp2.0开始不让使用java脚本，而是使用el表达式和动态标签来替代java脚本<br>EL替代的是&lt;%=…%&gt;,也就是说EL只能做输出</p><p><strong>JavaBean导航：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;requestScope.emp.address.street&#125;得到这个bean里的街道</span><br><span class="line"></span><br><span class="line">&lt;!--request.getAttribute(<span class="string">"emp"</span>).getAddress().getStreet() --&gt;</span><br></pre></td></tr></table></figure><p>EL可以输出的东西都在11个内置对象中！11个内置对象，其中10个是Map，pageContext不是map，它就是PageContext类型</p><p>EL可以输出的东西都在11个内置对象中！11个内置对象，其中10个是Map，pageContext不是map，它就是PageContext类型</p><p>param和paramValues这两个内置对象是用来获取请求参数的<br><strong>param：</strong> <code>Map&lt;String,String&gt;</code>类型，param对象可以用来获取参数，与request.getParameter()方法相同 ，key时参数名，value是参数值，适用于单值的参数<br>map.key是el的语法<br>map[‘key’]也可以操作map<br><strong>paramValues：</strong> paramValues是<code>Map&lt;String,String[]&gt;</code>类型，当一个参数名，对应多个参数值时可以使用它</p><p><strong>header：</strong> 对应请求头，是一个Map，其中key表示头名称，value是个单个头值，适用于单值请求头<br>${header[‘User-Agent’]}<br><strong>headerValues：</strong> 对应请求头，是一个Map，其中key表示头名称，value是多个头值，适用于多值请求头</p><p><strong>initParam：</strong> 获取<code>&lt;context-param&gt;</code>内的参数</p><p><strong>Cookie：</strong> <code>Map&lt;String,Cookie&gt;</code>类型，key是Cooke的name，value是cookie对象<br>${cookie.username.value}获取值</p><p><strong>pageContext：</strong> 它是pageContext类型${pageContext.request.contextPath}</p><p><strong><em>EL函数库</em></strong><br>EL函数库是由第三方对EL的扩展，由JSTL提供<br>EL函数库就是定义一些有返回值的静态方法<br>因为是第三方，所以需要导入，导入需要talib指令<br>导入标签库<code>&lt;%@ taglib prefix=&quot;fu&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot;%&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">(String input)</span></span>;<span class="comment">//参数转大写</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">(Stirng input)</span></span>;<span class="comment">//参数转小写</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String input,String substring)</span></span>;<span class="comment">//大串输出小串位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String input,String substring)</span></span>;<span class="comment">//大串是否包含小串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsIgnoreCase</span><span class="params">(String input,String substring)</span></span>;<span class="comment">//忽略大小写，是否包含</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String input,String substring)</span></span>;<span class="comment">//是否以小串为前缀</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWIth</span><span class="params">(String input,String subString)</span></span>;<span class="comment">//是否以小串为后缀</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">subString</span><span class="params">(String input,<span class="keyword">int</span> beginIndex,<span class="keyword">int</span> endIndex)</span></span>;<span class="comment">//截取字串</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">subStringAfter</span><span class="params">(String input,String substring)</span></span>;<span class="comment">//获取大串中，小串在位置后面的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">subStringBefore</span><span class="params">(String input,String substring)</span></span>;<span class="comment">//获取大串中，小串所在位置前面的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">escapeXml</span><span class="params">(String input)</span>:把input中字符串的"&gt;""&lt;"<span class="comment">//转义</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">(String input)</span></span>;<span class="comment">//去除前后空格</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(String input,String substringBefore,String substringAfter)</span></span>;<span class="comment">//替换</span></span><br><span class="line"></span><br><span class="line">String[] split(String input,String delimiters);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(Object obj)</span></span>;<span class="comment">//可以获取字符串、数组、各种集合的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">join</span><span class="params">(String array[],String separator)</span></span>;<span class="comment">//联合字符串数组</span></span><br></pre></td></tr></table></figure><p><strong>自定义EL函数库</strong><br>写一个类，写一个有返回值的静态方法<br>编写<em>*</em>.tld文件，可以参数fn.tld文件来写，把xxx.tld文件放到/WEB-INF目录下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">function-class</span>&gt;</span>cn.cj.fn.MyFunction<span class="tag">&lt;/<span class="name">function-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">function-signature</span>&gt;</span>java.lang.String fun()<span class="tag">&lt;/<span class="name">function-signature</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在页面中添加taglib指令，导入自定义标签库<br>${cj: fun()};</p><h2 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h2><ol><li><p>jstl的概述</p><ul><li>apache的东西，依赖EL</li><li>使用jstl需要导入jstl1.2.jar</li><li>四大库：<blockquote><p>core：核心库，重点<br>fmt：格式化：日期、数字<br>sql：过时<br>xml：过时</p></blockquote></li></ul></li><li><p>导入标签库</p><ul><li>jar包</li><li>在jsp页面中：&lt;%@taglib prefix=”前缀” uri=”路径”%&gt;</li></ul></li></ol><p>core —&gt; c标签！</p><ol><li><p>out和set</p><ul><li><c:out>：输出<blockquote><p>value：可以是字符串常量，也可以是EL表达式<br>default：当要输出的内容为null时，会输出default指定的值<br>escapeXml：默认值为true，表示转义！</p></blockquote></c:out></li><li><c:set>：设置(创建域的属性)<blockquote><p>var：变量名<br>value：变量值，可以是EL表达式<br>scope：域，默认为page，可选值：page、request、session、application</p></blockquote></c:set></li></ul></li><li><p>remove</p><ul><li><remove>：删除域变量<blockquote><p>var：变量名<br>scope：如果不给出scope，表示删除所有域中的该名称的变量；如果指定了域，那么只删除该域的变量。</p></blockquote></remove></li></ul></li><li><p>url</p><ul><li><p>value：指定一个路径！它会在路径前面自动添加项目名。<br>&lt;&gt; <code>&lt;c:url value=&quot;/index.jsp&quot;/&gt;</code>，它会输出/day13_1/index.jsp</p></li><li><p>子标签：<code>&lt;c:param&gt;</code>，用来给url后面添加参数，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:url value=<span class="string">"/index.jsp"</span>&gt;</span><br><span class="line">  &lt;c:param name=<span class="string">"username"</span> value=<span class="string">"张三"</span>/&gt;  <span class="xml"><span class="comment">&lt;!--可以对参数进行url编码！！--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">c:url</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>结果为：/day13_1/index.jsp?username=%ED%2C%3F%ED%2C%3F</p></li><li><p>var：指定变量名，一旦添加了这个属性，那么url标签就不会再输出到页面，而是把生成url保存到域中。</p></li><li><p>scope：它与var一起使用，用来保存url。</p></li></ul></li><li><p>if：对应java中的if语句</p><ul><li><code>&lt;c:if test=&quot;布尔类型&quot;&gt;...&lt;/c:if&gt;</code>，当test为值时，执行标签体内容！</li></ul></li><li><p>choose：它对应java中的if/else if/ … /else</p><ul><li><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c:choose</span><br><span class="line">  &lt;c:when test=<span class="string">""</span>&gt;.../c:when</span><br><span class="line">  &lt;c:when test=<span class="string">""</span>&gt;.../c:when</span><br><span class="line">  &lt;c:when test=<span class="string">""</span>&gt;.../c:when</span><br><span class="line">   ... </span><br><span class="line">  c:otherwise .../c:otherwise</span><br><span class="line">/c:choose</span><br></pre></td></tr></table></figure><p>等同与<br>if(…) {<br>} else if( ….) {<br>} else if( ….) {<br>} else if( ….) {<br>} …<br>else { …}</p></li></ul></li><li><p>forEach<br>它用来循环遍历数组、集合！<br>它还可以用来计数方式来循环！</p><p>计数方式：</p><p>for(int i = 1; i &lt;= 10; i++) {<br>…<br>}</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"i"</span> begin=<span class="string">"1"</span> end=<span class="string">"10"</span>&gt;</span><br><span class="line">  $&#123;i&#125;</span><br><span class="line">&lt;<span class="regexp">/c:forEach&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>var：循环变量</li><li>begin：设置循环变量从几开始。</li><li>end：设置循环变量到几结束。</li><li>step：设置步长！等同与java中的i++，或i+=2。step默认为1</li></ul></li></ol><p>用来输出数组、集合！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">"$&#123;strs &#125;"</span> <span class="keyword">var</span>=<span class="string">"str"</span>&gt;</span><br><span class="line"> $&#123;str &#125;&lt;br/&gt;</span><br><span class="line">&lt;<span class="regexp">/c:forEach&gt;</span></span><br></pre></td></tr></table></figure><p>等同于</p><p>for(String str : strs) {<br>…<br>}</p><p>属性：</p><ul><li>items：指定要循环谁，它可以是一个数组或一个集合</li><li>var：把数组或集合中的每个元素赋值给var指定的变量。</li></ul><p>循环状态</p><p>可以使用varStatus来创建循环状态变量！</p><p>循环状态变量有如下属性：</p><ul><li>count：循环元素的个数</li><li>index：循环元素的下标</li><li>first：是否为第一个元素</li><li>last：是否为最后一个元素</li><li>current：当前元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">"$&#123;list &#125;"</span> <span class="keyword">var</span>=<span class="string">"ele"</span> varStatus=<span class="string">"vs"</span>&gt;</span><br><span class="line">    $&#123;vs.index&#125; $&#123;vs.count &#125; $&#123;vs.first &#125; $&#123;vs.last &#125; $&#123;vs.current &#125;&lt;br/&gt;</span><br><span class="line">&lt;<span class="regexp">/c:forEach&gt;</span></span><br></pre></td></tr></table></figure><p>fmt库<br>它是格式化库</p><p><code>&lt;fmt:formatDate value=&quot;&quot; pattern=&quot;&quot;&gt;</code></p><p>value：指定一个Date类型的变量<br>pattern：用来指定输出的模板！例如：yyyy-MM-dd HH:mm:ss</p><p><code>&lt;fmt:formatNumber value=&quot;${num1}&quot; pattern=&quot;0.00&quot;&gt;</code><br>保留小数点后2位，它会四舍五入！如果不足2位，以0补位！</p><p><code>&lt;fmt:formatNumber value=&quot;${num1}&quot; pattern=&quot;#.##&quot;&gt;</code><br>保留小数点后2位，它会四舍五入！如果不足2位，不补位！</p><p><strong>自定义标签</strong></p><ol><li><p>步骤</p><ul><li>标签处理类（标签也是一个对象，那么就需要先有类！）</li><li>tld文件，它是一个xml</li><li>页面中使用<code>&lt;%@taglib%&gt;</code>来指定tld文件的位置</li></ul></li><li><p>标签处理类<br>SimpleTag接口：</p><ul><li>void doTag()：每次执行标签时都会调用这个方法；</li><li>JspTag getParent()：返回父标签（非生命周期方法）</li><li>void setParent(JspTag)：设置父标签</li><li>void setJspBody(JspFragment)：设置标签体</li><li>void seetJspContext(JspContext)：设置jsp上下文对象，它儿子是PageContext</li></ul></li></ol><p>其中doTag()会在其他三个方法之后被tomcat调用。</p><ol><li>配置tld文件</li></ol><p>tld文件一般都放到WEB-INF之下，这样保证客户端访问不到！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>myTag1<span class="tag">&lt;/<span class="name">name</span>&gt;</span> 指定当前标签的名称</span><br><span class="line"><span class="tag">&lt;<span class="name">tag-class</span>&gt;</span>cn.itcast.tag.MyTag1<span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span> 指定当前标签的标签处理类！</span><br><span class="line"><span class="tag">&lt;<span class="name">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span> 指定标签体的类型，我们这里使用的是空标签！</span><br><span class="line"><span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>页面中指定tld文件位置</li></ol><p>&lt;%@ taglib prefix=”it” uri=”/WEB-INF/tlds/itcast-tag.tld” %&gt;<br>导标签库，就是为页面指定tld文件的位置！</p><p>进阶</p><p>标签体内容</p><ul><li>empty：无标签体！</li><li>JSP：jsp2.0已经不在支持这个类型了！表示标签体内容可以是：java脚本，可以是标签，可以是el表达式</li><li>scriptless：只能是EL表达式，也可以是其他的标签！</li><li>tagdependent：标签体内容不会被执行，而是直接赋值标签处理类！</li></ul><p>不在执行标签下面内容的标签！</p><p>在标签处理类中的doTag()中使用SkipPageException来结束！<br>Tomcat会调用标签处理类的doTag()方法，然后Tomcat会得到SkipPageException，它会跳过本页面其他内容！</p><p>标签属性</p><p>步骤：</p><ol><li><p>给你的标签处理类添加属性！<br>为标签处理类添加属性，属性至少要且一个set方法！这个set方法会在doTag()方法之前被tomcat执行！所在doTag()中就可以使用属性了。</p></li><li><p>在tld文件中对属性进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">attribute</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!--指定属性名--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">required</span>&gt;</span>true<span class="tag">&lt;/<span class="name">required</span>&gt;</span> <span class="comment">&lt;!--指定属性是否为必需的--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">rtexprvalue</span>&gt;</span>true<span class="tag">&lt;/<span class="name">rtexprvalue</span>&gt;</span> <span class="comment">&lt;!--指定属性是否可以使用EL--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">attribute</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>推荐博文：</p><p><a href="https://www.cnblogs.com/xdp-gacl/tag/JavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">JavaWeb</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JSP
    
    </summary>
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/categories/JavaWeb/"/>
    
      <category term="JSP" scheme="https://www.ysmjjsy.com/categories/JavaWeb/JSP/"/>
    
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-MVC</title>
    <link href="https://www.ysmjjsy.com/category/MVC/"/>
    <id>https://www.ysmjjsy.com/category/MVC/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2019-09-17T08:38:04.543Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:12:06 GMT+0800 (GMT+08:00) --><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p><img src="/category/MVC/1.png" alt="MVC"></p><p>不是java独有，所有的B/S结构都使用的它<br>M—Model模型<br>V—View视图（jsp）<br>C—Cotroller控制器（Servlet）<br>JSP Model1</p><p><img src="/category/MVC/2.png" alt="MVC"></p><p>JSP Model1</p><p><img src="/category/MVC/3.png" alt="MVC"></p><p>JSP Model2</p><p><img src="/category/MVC/4.png" alt="MVC"></p><p><strong><em>JavaWeb三层框架</em></strong><br>Web层 —&gt;与web相关的内容（Servlet，JSP，Servlet相关API:request,response,session,ServletContext）<br>业务层 —&gt;业务对象(service)<br>数据层 —&gt;操作数据库（DAO Data Access Object)(所有对数据库的操作不能跳出到DAO之外)<br><img src="/category/MVC/5.png" alt="MVC"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      MVC
    
    </summary>
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/categories/JavaWeb/"/>
    
      <category term="MVC" scheme="https://www.ysmjjsy.com/categories/JavaWeb/MVC/"/>
    
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-Servlet</title>
    <link href="https://www.ysmjjsy.com/category/Servlet/"/>
    <id>https://www.ysmjjsy.com/category/Servlet/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2019-09-17T09:10:26.352Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:12:06 GMT+0800 (GMT+08:00) --><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>每个Servlet都是唯一的，它们处理的请求都是不同的<br>浏览器把请求发送给不同的Servlet。Servlet是异步的线程不安全的。<br>单例，一个类只有一个对象</p><h2 id="Servlet调用过程？"><a href="#Servlet调用过程？" class="headerlink" title="Servlet调用过程？"></a><strong>Servlet调用过程？</strong></h2><ol><li>在浏览器输入地址，浏览器先去查找hosts文件，将主机名翻译为ip地址，如果找不到就再去查询dns服务器将主机名翻译成ip地址。</li><li>浏览器根据ip地址和端口号访问服务器，组织http请求信息发送给服务器。</li><li>服务器收到请求后首先根据Host请求头判断当前访问的是哪台虚拟主机。</li><li>服务器根据http请求头中的请求URI判断当前访问的是哪个web应用。</li><li>服务器根据http请求头中的请求URI判断当前访问的是web应用中的哪个web资源。</li><li>检查web应用的web.xml文件，如果根据路径找到具体的servlet处理类的全路径名交给该servlet处理,如果找不到就交给缺省servlet处理。</li><li>这个过程中浏览器只知道自己发出来http请求，不久就收到了http响应，浏览器不知道也不关心服务器内部是如何处理的。浏览器和服务器之间的关系是非常单纯的，只有HTTP协议。</li><li>解析请求、封装RequestResponse对象、创建Servlet、调用Service方法都是服务器自动进行的，开发人员只需要写好Servlet配置进容器中即可，无需操心具体的底层实现。</li></ol><h2 id="实现Servlet的方式："><a href="#实现Servlet的方式：" class="headerlink" title="实现Servlet的方式："></a><strong>实现Servlet的方式：</strong></h2><p>实现javax.servlet.Servlet接口</p><h2 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a><strong>生命周期方法</strong></h2><p>init(); 会在Servlet对象创建之后马上执行，并且执行一次<br>service()； 会被调用多次，每次处理请求都是在调用这个方法<br>destroy()；会在Servlet被销毁之前调用，并且只会被调用一次<br>ServletConfig()；获取Servlet配置信息<br>getServletInfo()；获取Servlet的信息<br>继承javax.servlet.GenericServlet类<br>继承javax.servlet.http.HttpServlet类<br>Servlet中的方法大多数不由我们来调用，而是由Tomcat来调用，并且Servlet的对象也由Tomcat来创建</p><h2 id="如何让浏览器访问Servlet"><a href="#如何让浏览器访问Servlet" class="headerlink" title="如何让浏览器访问Servlet"></a><strong>如何让浏览器访问Servlet</strong></h2><p>给Servlet指定一个Servlet路径（让Servlet与一个路径绑定在一起）<br>需要在web.xml中队Servlet进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>AServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>java.test.web.AServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>v1<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>AServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/AServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器访问Servlet路径</p><h2 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a><strong>ServletConfig</strong></h2><p>1个ServletConfig对象，对应一段web.xml中Servlet的配置信息<br>String getServletName():获取 <code>&lt;servlet-name&gt;&lt;/servlet-name&gt;</code><br>ServletContext getServletContext():获取Servlet上下文对象<br>String getInitParameter(String name):通过名称获取指定初始化参数的值<br>Enumeration getInitParameterNames()：获取所有初始化参数的名称</p><h2 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a><strong>GenericServlet</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServletConfig config;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest arg0, ServletResponse arg1)</span> throwsServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.config.getInitParameter(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">super</span>.getInitParameterNames();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.config;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.config.getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">super</span>.getServletInfo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.config.getServletName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.config=config;</span><br><span class="line">         init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CServlet</span> <span class="keyword">extends</span> <span class="title">BServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest arg0, ServletResponse arg1)</span> throwsServletException, IOException </span>&#123;</span><br><span class="line">         String value = <span class="keyword">super</span>.getInitParameter(<span class="string">"p1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a><strong>HttpServlet</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HttpServlet extends GenderServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest,ServletResponse)</span>--&gt;生命周期方法</span></span><br><span class="line"><span class="function">    <span class="comment">//强转两个参数为http协议相关的类型</span></span></span><br><span class="line"><span class="function">    <span class="comment">//调用本类的</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest,HttpServletResponse)</span>--&gt;参数已经是Http协议相关的，使用起来更加方便</span></span><br><span class="line"><span class="function">    <span class="comment">//它会通过request得到当前请求方式，例如：GET或POST</span></span></span><br><span class="line"><span class="function">    <span class="comment">//根据请求方式再调用doGet()或doPost()方法</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">doGet</span><span class="params">()</span></span>&#123;...&#125;重写</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doPost</span><span class="params">()</span></span>&#123;...&#125;重写</span><br><span class="line">    <span class="comment">//doGet和doPost由自己覆盖，如果没有覆盖，并且它们被调用了，那么会出现405</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Servlet细节"><a href="#Servlet细节" class="headerlink" title="Servlet细节"></a><strong>Servlet细节</strong></h2><p>Servlet只有一个实例对象，那么就有可能出现一个Servlet同时处理多个请求，那么Servlet就不是线程安全的，这说明Servlet的工作效率很高，但也存在线程安全问题<br>所以我们不应该Servlet中创建成员变量，因为可能会存在一个线程对这个成员进行写操作，另外一个线程对这个成员进行读操作<br>可以创建局部变量<br>可以创建无状态成员<br>可以创建有状态成员，但成员是可读的（去掉set方法）</p><p>让服务器在启动时就创建Servlet<br>默认情况下，服务器会在某个Servlet第一次请求时创建它，也可以在web.xml中对Servlet进行配置，使服务器启动时就创建Servlet<br>在<code>&lt;servlet&gt;</code>中配置<code>&lt;load-on-startup&gt;</code>(一个非负整数)<code>&lt;/load-on-startup&gt;</code></p><p><code>&lt;url-pattern&gt;&lt;/url-pattern&gt;</code><br>早期达到过滤功能给出多个url-pattern<br>通配符：路径匹配 ：/serlvet/<em> ，可以匹配任何前缀后缀<br>扩展名匹配 </em>.do<br>/<em> ：都匹配<br>“</em> “ 只能在两端不能在中间</p><h2 id="conf下的web-xml"><a href="#conf下的web-xml" class="headerlink" title="conf下的web.xml"></a><strong>conf下的web.xml</strong></h2><p>default:优先级最低，如果一个请求没人处理，它处理—&gt;404<br>jsp是jspServlet处理的<br>session的过期时间是30min</p><h2 id="Servlet与反射"><a href="#Servlet与反射" class="headerlink" title="Servlet与反射"></a><strong>Servlet与反射</strong></h2><p>访问Servlet，通过url-pattern找到，然后name匹配找到地址，反射拿到class</p><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a><strong>ServletContext</strong></h2><p>一个项目只有一个ServletContext对象<br>我们可以在多个Servlet中来获取这个唯一的对象，使用它可以给多个Servlet传递数据<br>在tomcat启动时创建，在tomcat关闭死去<br>服务器为每个应用创建一个ServletContext对象：</p><p>ServletContext对象的创建是在服务器启动时完成的<br>ServletContext对象的销毁是在服务器关闭时完成的<br>在整个web应用的动态资源之间共享数据<br>获取ServletContext对象</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getServletConfig.getServletContext();</span><br><span class="line"><span class="keyword">this</span>.getServletContext();</span><br><span class="line">       </span><br><span class="line">ServletConfig#getServletContext();</span><br><span class="line">GenericServletContext()#getServletContext();</span><br><span class="line">HttpSession#getServletContext();</span><br><span class="line">ServletContextEvent#getServletContext();</span><br></pre></td></tr></table></figure><h2 id="域对象的功能"><a href="#域对象的功能" class="headerlink" title="域对象的功能"></a><strong>域对象的功能</strong></h2><p>ServletContext是JavaWeb四大域对象之一，域对象就是用来在多个Servlet中传递数据，域对象必须有要存储数据的功能，有取数据的功能<br>四大域对象：PageContext,ServletRequest,HttpSession,ServletContext<br>域对象内部有一个Map，用来存储数据<br>ServletContext操作数据的方法：<br>void setAttribute(String name Object value):用来存储一个对象，也可以称之为存储一个域属性，如果多次调用该方法，并且使用相同的name，那么会覆盖上一次的值，这一特性与Map相同<br>Object getAttribute(String name):用来获取ServletContext中的数据<br>void removeAttribute(String name):用来移出ServletContext中的域属性，如果不存在，则什么都不做<br>Enumeration getAttributeNames():获取所有域属性的名称</p><h2 id="获取应用初始化参数"><a href="#获取应用初始化参数" class="headerlink" title="获取应用初始化参数"></a><strong>获取应用初始化参数</strong></h2><p>Servlet也可以获取初始化参数，但是它是局部参数，也就是说，一个Servlet只能获取自己的初始化参数，不能获取别人的，即初始化参数只为一个Servlet准备<br>可以配置公共的初始化参数，为所有的Servlet而用，使用ServletContext使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parm-name</span>&gt;</span><span class="tag">&lt;/<span class="name">parm-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parm-value</span>&gt;</span><span class="tag">&lt;/<span class="name">parm-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>得到ServletContext<br>调用getInitParameter(String)得到初始化参数</p><h2 id="获取资源路径"><a href="#获取资源路径" class="headerlink" title="获取资源路径"></a><strong>获取资源路径</strong></h2><p>获取真实路径<br>String path = this.getServletContext().getRealPath(“”);<br>得到的是有盘符的路径F:/xxx/xxx/xx<br>获取资源的路径后，创建流对象<br>this.getServletContext().getResourceAsStream(“/index.jsp”);<br>获取当前路径下所有资源的路径<br>this.getServletContext().getResourcePaths(“/WEB-INF”)</p><h2 id="获取类路径下的资源"><a href="#获取类路径下的资源" class="headerlink" title="获取类路径下的资源"></a><strong>获取类路径下的资源</strong></h2><p>获取类路径资源，对javaweb项目而言，就是/WEB-INF/classes和/WEB-INF/lib/每个jar包<br>得到ClassLoader</p><p>先得到CLass，再得到ClassLoader<br>调用其getResourceAsStream();得到一个InputStream<br>相对当前.class文件所在目录<br>加/相对于classes下</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p><strong>在web.xml中<code>&lt;url-pattren&gt;</code>路径</strong></p><p>Servlet路径<br>要么以”* “开头，要么以”/“开头</p><p><strong>转发和包含路径</strong><br>以”/“开头，相对当前项目路径</p><p><strong>重定向路径(客户端路径)</strong><br>以”/“开头，相对当前主机</p><p><strong>页面中超链接和表单路径</strong><br>与重定向相同，都是客户端路径，需要添加项目名</p><p><strong>ServletContext获取资源路径</strong><br>相对当前项目目录，即当前index.jsp所在目录</p><p><strong>ClassLoader获取资源路径</strong><br>相对classes目录</p><p><strong>Class获取资源路径</strong><br>以”/“开头相对classes目录<br>不以”/“开头，相对当前.class文件所在目录</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>常见的字符编码：iso-8859-1（不支持中文）<br>gbk（系统默认编码，中国的国际码）<br>utf-8（万国码，支持全世界的编码）</p><p><strong><em>响应编码</em></strong></p><ul><li>当使用respnse.getWrite()向客户端发送字符数据时，如果在之前没有设置编码，那么默认使用iso，因为iso不支持中文，一定乱码</li><li>在使用response.getWrite()之前使用response.setCharacterEncoding()来设置字符流的编码为gbk或utf-8，通常选择utf-8</li><li>在使用response.getWrite()之前使用response.setHeader(“Content-type”,”text/html;charset=utf-8”)来设置响应头，通知浏览器服务器这边使用的编码格式，并设置字符流编码</li><li>在getWrite()之前使用：<ul><li>setHeader(“Content-type”,”text/html;charset=utf-8”)的快捷方法是：setContentType(“text/html;charset=utf-8”)</li></ul></li></ul><p>就不会乱码</p><p><strong><em>请求编码</em></strong><br>客户端发送给服务器的请求参数，在请求这个页面时，服务器响应的编码是什么，那么客户端发送请求时的编码就是什么<br>服务器端默认使用ISO-8859-1来解码<br>请求编码处理分为两种：</p><p>GET和POST：GET请求参数不在请求体中，而POST请求参数在请求体中，所以它们的处理方式是不同的</p><p><strong>GET请求编码处理：</strong></p><blockquote><p>String username = new String(request.getParameter(“iso-8859-1”),”utf-8”);</p><p>在/cof/servler.xml中&lt;Connector port中，URIEncoding=:UTF-8”/&gt;配置URIEncoding=utf-8(不让用）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">反编回来</span><br><span class="line"><span class="keyword">byte</span>[] bytes[] = name.getBytes(<span class="string">"ISO-8859-1"</span>);</span><br><span class="line">name = <span class="keyword">new</span> String(bytes,<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure><p><u>URL最大长度2048，发送数据是URL一 部分，安全性较差</u></p><p><strong>POST请求编码处理：</strong><br>String username = new String(request.getParameter(“iso-8859-1”),”utf-8”);<br>在获取参数之前调用request.setCharacterEncoding(“utf-8”);</p><p><strong>URL编码</strong></p><p>表单的类型：Content-Type:application/x-www-form-urlencoded，就是把中文转换成%后面跟随两位的16进制<br>在客户端和服务器之间传递中文时需要把它转换成网络适合的方式<br>它不是字符编码<br>它是用来在客户端与服务器之间传递参数用的一种方式<br>URL编码需要先指定一个字符编码，把字符串解码后，得到byte[]，然后把小于0的字节+256，再转换成16进制，前面再添加%<br>POST请求默认使用URL编码，tomcat会自动使用URL解码<br>URL编码：String username = URLEncoder.encode(username,”utf-8”);<br>URL解码：String username = URLDecoder.decode(username,”utf-9”);</p><h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><ol><li>get请求用来从服务器上获得资源，而post是用来向服务器提交数据；</li><li>get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；</li><li>get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据， POST数据是没有限制的，上传文件通常要使用post方式；</li><li>使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</li><li>get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。</li><li>Jsp页面中的FORM标签里的method属性为get时调用doGet()，为post时调用doPost()。</li></ol><h2 id="在JS中-和-的区别？"><a href="#在JS中-和-的区别？" class="headerlink" title="在JS中==和===的区别？"></a>在JS中==和===的区别？</h2><hr><p>简单来说： == 代表相同， ===代表严格相同,为啥这么说呢，</p><p>这么理解： 当进行双等号比较时候：先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较，而===比较时， 如果类型不同，直接就是false.</p><h2 id="自动刷新-定时刷新"><a href="#自动刷新-定时刷新" class="headerlink" title="自动刷新,定时刷新"></a>自动刷新,定时刷新</h2><p>自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如：</p><p>Response.setHeader(“Refresh”,”1000;URL=<a href="http://localhost:8080/servlet/example.htm" target="_blank" rel="noopener">http://localhost:8080/servlet/example.htm</a>“);</p><p>其中1000为时间，单位为毫秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现没过一秒自动刷新本页面一次）</p><p>推荐博文：</p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3760336.html" target="_blank" rel="noopener">Servlet(一)</a></p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3763559.html" target="_blank" rel="noopener">Servlet(二)</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Servlet
    
    </summary>
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/categories/JavaWeb/"/>
    
      <category term="Servlet" scheme="https://www.ysmjjsy.com/categories/JavaWeb/Servlet/"/>
    
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-Tomcat</title>
    <link href="https://www.ysmjjsy.com/category/tomcat/"/>
    <id>https://www.ysmjjsy.com/category/tomcat/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2019-09-17T08:15:26.140Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:12:06 GMT+0800 (GMT+08:00) --><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p><a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br><strong><em>Tomcat目录</em></strong><br>bin：包含一些jar，bat文件<br>conf：tomcat的配置、server.xml、web.xml<br>lib：tomcat运行所需要的jar文件<br>logs：运行的日志文件<br>temp：临时文件<br>webapps：发布在tomcat服务器上的项目，就存放在这个目录<br>把这下面的每一个文件夹当成一个项目<br>在浏览器里访问资源，需要把资源放到webapps文件夹下。<br>work：jsp翻译成java文件存放地<br><strong>配置虚拟路径发布资源到服务器</strong><br>在con/server.xml找到host元素节点<br>加入:<br>&lt;Context docBase=”E:*<strong> path=”/a”&gt;<context><br>docBase：项目的路径地址<br>path：对应的访问方式：<a href="http://localhost:8080/a/???" target="_blank" rel="noopener">http://localhost:8080/a/???</a>;</context></strong>配置虚拟路径2**<br>在apache-tomcat-7.0.92\conf\Catalina\localhost/文件夹下新建一个xml文件，名字可以自己定义 ??.xml</p><p>在这个文件里面写入:<br>&lt;?xml version=’1,0’ encoding=’UTF-8’?&gt;<br><context dobase="??:\???"></context></p><h2 id="Tomcat顶层架构"><a href="#Tomcat顶层架构" class="headerlink" title="Tomcat顶层架构"></a>Tomcat顶层架构</h2><p><img src="/category/tomcat/1.png" alt="tomcat"></p><p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，用于具体提供服务。</p><p>Service主要包含两个部分：Connector和Container。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下：</p><ol><li><strong>Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化;</strong></li><li><strong>Container用于封装和管理Servlet，以及具体处理Request请求；</strong></li></ol><p>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接,示意图如下（Engine、Host、Context下边会说到）：<img src="/category/tomcat/2.png" alt="tomcat"></p><p>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由 Server 控制。</p><p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的server.xml配置文件中看出，下图是删除了注释内容之后的一个完整的server.xml配置文件（Tomcat版本为8.5）</p><p><img src="/category/tomcat/3.png" alt="tomcat"></p><p>详细的配置文件文件内容可以到<a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html" target="_blank" rel="noopener">Tomcat官网</a>查看</p><p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p><p><img src="/category/tomcat/4.png" alt="tomcat"></p><p>Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置，一个Service有多个，Service左边的内容都属于Container的，Service下边是Connector。</p><h3 id="Tomcat顶层架构小结："><a href="#Tomcat顶层架构小结：" class="headerlink" title="Tomcat顶层架构小结："></a>Tomcat顶层架构小结：</h3><ol><li>Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；</li><li>Server掌管着整个Tomcat的生死大权；</li><li>Service 是对外提供服务的；</li><li>Connector用于接受请求并将请求封装成Request和Response来具体处理；</li><li>Container用于封装和管理Servlet，以及具体处理request请求；</li></ol><p>知道了整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下Connector和Container。</p><h3 id="Connector和Container的微妙关系"><a href="#Connector和Container的微妙关系" class="headerlink" title="Connector和Container的微妙关系"></a>Connector和Container的微妙关系</h3><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！</p><p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！</p><p>Tomcat既然处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！</p><h3 id="Connector架构分析"><a href="#Connector架构分析" class="headerlink" title="Connector架构分析"></a>Connector架构分析</h3><p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。</p><p>因此，我们可以把Connector分为四个方面进行理解：</p><ol><li>Connector如何接受请求的？</li><li>如何将请求封装成Request和Response的？</li><li>封装完之后的Request和Response如何交给Container进行处理的？</li><li>Container处理完之后如何交给Connector并返回给客户端的？</li></ol><p>首先看一下Connector的结构图，如下所示：</p><p><img src="/category/tomcat/5.png" alt="tomcat"></p><p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。</p><p>其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。</p><ol><li>Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。</li><li>Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。</li><li>Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。</li></ol><p>至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？</p><h3 id="Container架构分析"><a href="#Container架构分析" class="headerlink" title="Container架构分析"></a>Container架构分析</h3><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器，结构图如下：</p><p><img src="/category/tomcat/6.png" alt="tomcat"></p><p>4个子容器的作用分别是：</p><ol><li>Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；</li><li>Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；</li><li>Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；</li><li>Wrapper：每一Wrapper封装着一个Servlet；</li></ol><p>下面找一个Tomcat的文件目录对照一下，如下图所示：</p><p><img src="/category/tomcat/7.png" alt="tomcat"></p><p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。</p><p>我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：www.goya.com,如果是Host（webapps）下的其他应用，则可以使用www.goya.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。</p><p>看到这里我们知道Container是什么，但是还是不知道Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！</p><h3 id="Container如何处理请求的"><a href="#Container如何处理请求的" class="headerlink" title="Container如何处理请求的"></a>Container如何处理请求的</h3><p>Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意）</p><p>Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。<br><img src="/category/tomcat/8.png" alt="tomcat"></p><p>但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p><ol><li>每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做BaseValve，BaseValve是不可删除的；</li></ol><ol><li>在上层容器的管道的BaseValve中会调用下层容器的管道。</li></ol><p>我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve。Pipeline的处理流程图如下</p><p><img src="/category/tomcat/9.png" alt="tomcat"></p><ol><li>Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）；</li><li>在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。</li><li>当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！</li><li>当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</li></ol><p>推荐博文：</p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3734395.html" target="_blank" rel="noopener">Tomcat(一)</a></p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3744053.html" target="_blank" rel="noopener">Tomcat(二)</a></p><p><a href="https://blog.csdn.net/yangwenxue_admin/article/details/72845360" target="_blank" rel="noopener">Tomcat集群</a></p><p><a href="https://blog.csdn.net/Ediwal/article/details/47779971" target="_blank" rel="noopener">Nginx+Tomcat集群搭建</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      tomcat
    
    </summary>
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/categories/JavaWeb/"/>
    
      <category term="Tomcat" scheme="https://www.ysmjjsy.com/categories/JavaWeb/Tomcat/"/>
    
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-Http协议</title>
    <link href="https://www.ysmjjsy.com/category/Http/"/>
    <id>https://www.ysmjjsy.com/category/Http/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2019-09-17T08:15:36.710Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 17:12:06 GMT+0800 (GMT+08:00) --><p><strong>请求头</strong></p><p>请求行<br>多个请求头信息:头名称:头值<br>空行<br>请求体</p><p><strong>响应头</strong></p><p>响应行(协议/版本 状态码 状态码的解析)<br>响应头(key/value格式)<br>空行<br>响应正文</p><p><strong>正文</strong></p><p>表单是一大堆内容，而发送给服务器的只有一行字符串</p><p>POST请求可以有体，GET请求不能有请求体</p><p>Referer: 请求来自哪个页面</p><p>Content-Type:application/x-www-form-urlencoded</p><p>表单数据类型，说明会使用url格式编码数据；url编码的数据都是以%为前缀，后面跟随两位的16进制</p><p>Content-Length:13:</p><p>请求体的长度</p><p>keyword = hello;</p><p>请求体内容</p><p>200：请求成功<br>404：请求的资源没有找到，说明客户端错误的请求了不存在的资源<br>500：请求资源找到了，但是服务器内部出现了错误<br>302：重定向，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应体Location，它指定了新请求的URL地址</p><p><strong>什么是http协议：</strong></p><p>HTTP协议就是一套基于tcp/ip协议的应用层协议<br>。简单来说，就是一个基于应用层的通信规范，双方要进行通信，大家都要遵守一个规范，这个规范就是HTTP协议。它规定了客户端（通常是浏览器）和服务器之间的通信方式。</p><p><strong>HTTP协议工作原理？</strong></p><p>HTTP协议基于请求响应模型。</p><p>一次请求对应一次响应。</p><p>首先客户端发送一个请求(request)给服务器，服务器在接收到这个请求后将生成一个响应(response)返回给客户端。</p><p><strong>HTTP协议的特点是什么 ?</strong></p><ol><li>它是一个无状态的协议，服务器端在处理相应请求后不会保留任何客户端的信息，每次请求都是独立的</li><li>客户端与服务器端的每一次数据交互，都要经过一次请求/响应的过程。</li><li>服务器端无法识别能够出发客户端请求的方法。</li><li>一个典型的HTTP请求分为 一个请求行 若干请求头 一个空行 实体内容。</li></ol><p><strong>get和post请求的区别？</strong></p><ol><li>get请求用来从服务器上获得资源，而post是用来向服务器提交数据；</li><li>get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；</li><li>get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据， POST数据是没有限制的，上传文件通常要使用post方式；</li><li>使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</li><li>get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。</li><li>Jsp页面中的FORM标签里的method属性为get时调用doGet()，为post时调用doPost()</li></ol><p><strong>Http和Https的区别？</strong></p><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>推荐博文：</p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3729033.html" target="_blank" rel="noopener">WEB开发入门</a></p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3751277.html" target="_blank" rel="noopener">Http协议</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Http协议
    
    </summary>
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/categories/JavaWeb/"/>
    
      <category term="Http协议" scheme="https://www.ysmjjsy.com/categories/JavaWeb/Http%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="JavaWeb" scheme="https://www.ysmjjsy.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>学习路线v2.0</title>
    <link href="https://www.ysmjjsy.com/category/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>https://www.ysmjjsy.com/category/学习路线/</id>
    <published>2018-03-02T16:00:00.000Z</published>
    <updated>2019-09-17T10:29:31.425Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 17 2019 18:30:24 GMT+0800 (GMT+08:00) --><h1 id="关于Java学习路线"><a href="#关于Java学习路线" class="headerlink" title="关于Java学习路线"></a>关于Java学习路线</h1><p><img src="/category/学习路线/1.png" alt="学习路线"><br>这条图可以说是比较新比较合适的，当然这不牵扯大数据部分。只能说在学习路线上来说属于主流。<br>自己在看了很多培训机构的学习视频之后也相对总结下来比较好的学习视频，以及学习路线。这里不涉及知识点，只是分享自己认为不错的视频</p><h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2><p>这一部分有些人选择看书。<br>《Head First Java》是一本入门比较好的书，通俗易懂，像看小儿书一样。<br>很多人都会推荐《Java编程思想》。但实际来说对于新手并不友好，甚至你没编程语言基础《Java核心技术卷》看都会比较吃力。当然这两本书在你有一定基础后看还是有很大的提升。<br>可以找一本Java程序设计之类的书先看着，学会基本语法，了解什么面向对象，再来啃上面两本书也不错。<br>之前在学校图书馆有看到很多类似的程序设计相关的。还有比较火的《Java从入门到精通》，太厚了。简直真的就是从入门到放弃。<br>自己当时在学校先学的C，当时虽然跟着敲，可敲的是什么，为什么会显示这样，还是云里雾里。所以可以自己在网上找找编程语言之类的介绍，了解一下这方面历史技术，这对于基础素质有很大帮助。要是懂一些计算机原理，网络原理，数据库原理那就更好了。<br>在JavaSE基础方面，还是需要下些功夫，可以看视频+书，当然比较费劲，建议视频过一遍，然后整理出笔记，再看一遍，最后看书贯通一下，这是最稳的。至于SE的路线，视频里书里也都可以了，学完之后看一下Java高并发，JUC，Java新特性了解一下。<br><strong>推荐视频：</strong><br>我自己看过的《传智刘意的JavaSE》虽然有些老了，但是基础是不会变的，看到有很多人推荐《马士兵》的视频，我觉得也不错。<br>看完还可以看看阿里云大学官网上的JavaSE视频，里面有些点讲的也是真的细真的好，当是补充。<br>同时可以看看张龙的java8新特性<br><strong>推荐书：</strong><br>《Head First Java》建议可以从零看<br>《Java核心技术卷一》<br>《Java核心技术卷二》<br>《Java编程思想》不建议一开始就看<br><strong>重点：</strong><br>面向对象原理<br>String、Object这两个类<br>Collection集合与Map容器以及底层<br>IO流<br>Java多线程<br>网络编程Socket<br>反射<br>注解<br>泛型<br>代理模式<br>JUC<br>NIO<br>Java8新特性：Lambda表达式，函数式编程等</p><p>这里可以接下数据结构和设计模式，也可以在之后回头来看</p><p>韩顺平的数据结构</p><h2 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><p>自己当然看完JavaSE之后陷入一点迷茫，接下来该学什么就不知道了，只能在网上找视频，找路线，找资料。当看到崔希凡的JavaWeb之后才知道原来路线是这样。<br>所以这里也推荐《崔希凡JavaWeb视频》，应该是东北人，讲话蛮有趣，很幽默<br>其实在最早期自己刚学Java就知道Java的三个版本：JavaSE、JavaEE、JavaME。<br>而对于一个Java开发工程师JavaWeb肯定是必学的，之后的SSH、SSM框架可以看作是对JavaWeb的一种封装。<br>这里没什么好说的，当学完JavaWeb学习模式基本自己已经摸索出来了，继续跟着学就行。<br>这里比较重点的：Http协议，Tomcat服务器，Servlet，Session，Cookie，Jsp，JDBC，监听器Listener，过滤器Filter，理解SpringMVC思想，其中崔希凡十四天课程必须好好看一遍，那讲了MVC分层思想。还可以着重看看邮件发送，文件上传下载。</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>当学JavaWeb的JDBC时候就会遇到数据库相关知识。这里推荐《尚硅谷周阳的Mysql高级》，如果时间多还可以看看书，推荐看看《数据库原理》，因为里面讲了一些思想，什么关系数据库第一范式、第二范式等，看看有利于以后数据库如何建立。可以自己找找Mysql基础。周阳的Mysql##高级主要讲了索引，explain关键字，主从复制等。<br>想想自己上大学学了sql server，Oracle在学习过程中，基本没用过，除了sql语句。当时数据库原理考了44分，太难了。听说Oracle撤离中国了，但是一些大型国企还在用，有时间可以看看，我一个平安工作的朋友也在用sql server</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>数据库学完就到了框架，虽然现在新生代基本是spring一站式，但是对于老企业的维护，以及不好变更的还是用的SSH框架，去年自己面试时候有些公司还不用框架，很多都用的SSH，然而2018年SSM早都火的不行了。springboot都开始普及了。<br>struts2这一个以前厉害的框架在经历安全问题后不再返，但是不妨碍我们去学习。<br>Hibernate是一门重量级orm框架，这里可以好好学学，记得自己看视频网上看资料，学习Hibernate入门简单，编写简单，优化难，这也是区分大佬与初级的分水岭<br>这里推荐的视频是黑马《SSH框架2016版》<br>Hibernate马士兵老师讲的也不错，尚学堂有</p><h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2><p>SSH框架完后可以学SSM框架，这个时候已经基本了解一些spring原理，可以看看spring底层原理，自己看视频，摸索摸索，推荐尚硅谷《spring注解驱动开发》。<br>至于使用xml还是注解根据自己喜好，当然注解在简化工作上肯定是优秀的，但也不是绝对的。<br>关于SSM框架可以看看黑马的springmvc和mybatis视频，我当时看的时候还是xml配置，自己也找了很久注解开发，可太少了，这里也可以看尚硅谷的SSM视频。</p><h2 id="JPA、SringData"><a href="#JPA、SringData" class="headerlink" title="JPA、SringData"></a>JPA、SringData</h2><p>因为自己在学习视频里有看到这两个，不得不说java提出的这个规范还是很不错的。可以简化持久层的操作，通过注解完成持久化对象等。<br>这里推荐尚硅谷视频</p><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>这里推荐MyBatisPlus和通用Mapper，国人开发，简化mybatis开发，还可以看看逆向工程。<br>这里推荐尚硅谷视频</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>尚硅谷或黑马都可以</p><h2 id="RBAC权限"><a href="#RBAC权限" class="headerlink" title="RBAC权限"></a>RBAC权限</h2><p>一种概念，可以看看，关于用户角色权限如何实现<br>尚硅谷的视频里整合RBAC用ssm方式，可以参考</p><h2 id="Git-amp-SVN"><a href="#Git-amp-SVN" class="headerlink" title="Git &amp; SVN"></a>Git &amp; SVN</h2><p>尚硅谷和黑马的都可以，不过黑马的git没找到</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>学习Java后端的不懂Linux可不行，<br>我看的尚硅谷的《linux》，如果自己想加深可以看看《鸟哥私房菜》、《Linux权威指南》这两本书</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>尚硅谷的</p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>这里再次推荐尚硅谷《SpringBoot》</p><h2 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h2><p>尚硅谷<br>关于安全框架，看不懂也没关系，springboot里继承了自己的安全框架，直接调用即可</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>《尚硅谷周阳》<br>不得不说周阳讲的真的很易于理解</p><h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><p>周阳的</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>这里自己在b站搜的，以及在网上找的博客</p><h2 id="Dubbo-amp-Zookeeper"><a href="#Dubbo-amp-Zookeeper" class="headerlink" title="Dubbo&amp;Zookeeper"></a>Dubbo&amp;Zookeeper</h2><p>分布式也可以看尚硅谷的，最好在网上看些博客，如何搭建集群</p><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>自己有保存一些springcloud微服务的视频，但是看的还是周阳的</p><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>这里推荐张龙的Netty，虽然有点啰嗦，但是还是很不错的</p><p>虽然知识很多，精通全部根本不可能，但是利于以后发展</p><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><p>可以看看尚硅谷的大数据</p><p>感觉再给尚硅谷打广告，主要是自己找视频确实这个比较良心一点，资料和源代码。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      自己的分享
    
    </summary>
    
      <category term="学习路线" scheme="https://www.ysmjjsy.com/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
    
      <category term="学习路线" scheme="https://www.ysmjjsy.com/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-代理</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E4%BB%A3%E7%90%86/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-代理/</id>
    <published>2018-03-02T16:00:00.000Z</published>
    <updated>2019-09-16T09:12:18.807Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 16 2019 17:55:59 GMT+0800 (GMT+08:00) --><h1 id="Java三种代理"><a href="#Java三种代理" class="headerlink" title="Java三种代理"></a>Java三种代理</h1><h2 id="代理模式介绍"><a href="#代理模式介绍" class="headerlink" title="代理模式介绍"></a>代理模式介绍</h2><p>代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p><p>通过使用代理，通常有两个优点，并且能够分别与我们提到的微商代理的两个特点对应起来：</p><p>优点一：可以隐藏委托类的实现;</p><p>优点二：可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。</p><p><strong>代理模式</strong>：给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。</p><p>代理模式角色分为 3 种：</p><p><strong>Subject（抽象主题角色）</strong>：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</p><p><strong>RealSubject（真实主题角色</strong>）：真正实现业务逻辑的类；</p><p><strong>Proxy（代理主题角色）</strong>：用来代理和封装真实主题；</p><p>代理模式的结构比较简单，其核心是代理类，为了让客户端能够<strong>一致性地对待</strong>真实对象和代理对象，在代理模式中引入了抽象层</p><p><strong>代理模式UML类图</strong></p><p><img src="/category/JavaSE-代理/1.png" alt="代理"></p><p>代理模式<strong>按照职责</strong>（使用场景）来分类，至少可以分为以下几类：1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理等等。</p><p>如果<strong>根据字节码的创建时机</strong>来分类，可以分为静态代理和动态代理：</p><ul><li>所谓<strong>静态</strong>也就是在<strong>程序运行前</strong>就已经存在代理类的<strong>字节码文件</strong>，代理类和真实主题角色的关系在运行前就确定了。</li><li>而动态代理的源码是在程序运行期间由<strong>JVM</strong>根据反射等机制<strong>动态的生成</strong>，所以在运行前并不存在代理类的字节码文件</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p><ol><li>当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</li></ol><ul><li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong></li><li>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong></li></ul><ol><li>当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护</strong>。</li></ol><p>编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"查询 selectById"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新 update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将通过静态代理对 UserServiceImpl 进行功能增强，在调用 <code>select</code> 和 <code>update</code> 之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserService proxy = <span class="keyword">new</span> UserServiceProxy(userServiceImpl);</span><br><span class="line"></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>]</span><br></pre></td></tr></table></figure><p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><strong>为什么类可以动态的生成？</strong></p><p>这就涉及到Java虚拟机的<strong>类加载机制</strong>了，推荐翻看《深入理解Java虚拟机》7.3节 类加载的过程。</p><p>Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下3件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据访问入口</li></ol><p>由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，<strong>获取类的二进制字节流</strong>（class字节码）就有很多途径：</p><ul><li>从ZIP包获取，这是JAR、EAR、WAR等格式的基础</li><li>从网络中获取，典型的应用是 Applet</li><li><strong>运行时计算生成</strong>，这种场景使用最多的是动态代理技术，在 java.lang.reflect.Proxy 类中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流</li><li>由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类</li><li>从数据库中获取等等</li></ul><p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。</p><h4 id="常见的字节码操作类库"><a href="#常见的字节码操作类库" class="headerlink" title="常见的字节码操作类库"></a>常见的字节码操作类库</h4><blockquote><p>这里有一些介绍：<a href="https://link.juejin.im?target=https%3A%2F%2Fjava-source.net%2Fopen-source%2Fbytecode-libraries" target="_blank" rel="noopener">java-source.net/open-source…</a></p><p>Apache BCEL (Byte Code Engineering Library)：是Java classworking广泛使用的一种框架，它可以深入到JVM汇编语言进行类操作的细节。</p><p>ObjectWeb ASM：是一个Java字节码操作框架。它可以用于直接以二进制形式动态生成stub根类或其他代理类，或者在加载时动态修改类。</p><p>CGLIB(Code Generation Library)：是一个功能强大，高性能和高质量的代码生成库，用于扩展JAVA类并在运行时实现接口。</p><p>Javassist：是Java的加载时反射系统，它是一个用于在Java中编辑字节码的类库; 它使Java程序能够在运行时定义新类，并在JVM加载之前修改类文件。</p><p>…</p></blockquote><h4 id="实现动态代理的思考方向"><a href="#实现动态代理的思考方向" class="headerlink" title="实现动态代理的思考方向"></a>实现动态代理的思考方向</h4><p>为了让生成的代理类与目标对象（真实主题角色）保持一致性，从现在开始将介绍以下两种最常见的方式：</p><ol><li>通过实现接口的方式 -&gt; JDK动态代理</li><li>通过继承类的方式 -&gt; CGLIB动态代理</li></ol><p>注：使用ASM对使用者要求比较高，使用Javassist会比较麻烦</p><h4 id="newProxyInstance"><a href="#newProxyInstance" class="headerlink" title="newProxyInstance"></a>newProxyInstance</h4><p><img src="/category/JavaSE-代理/2.png" alt="daili"><br>在运行时，动态实现一组指定的接口的实现类对象（在运行时，创建实现了指定的一组接口的对象）</p><p><code>Object proxyObject = Poxy.newProxyInstance(ClassLoader classLoader,Class[] interfaces,InvocationHandler h)</code><br>ClassLoader：类加载器<br>用来加载类的，把.class文件加载到内存，形成Class对象<br>Class[] interfaces：指定要实现的接口们<br>InvocationHandler：代理对象的所有方法（个别不执行，getClass()）都会调用InvocationHandler的invoke()方法</p><h4 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h4><p><code>public Object invoke(Object proxy,Method method,Object[] args);</code><br>这个invoke方法在什么时候被调用！<br>在调用代理对象所实现接口中的方法时调用<br>Object proxy：当前对象，在调用谁的方法<br>Method method：当前被调用的方法（目标方法）<br>Object[] args：实参！</p><p><img src="/category/JavaSE-代理/3.png" alt="daili"></p><p><img src="/category/JavaSE-代理/4.png" alt="daili"></p><p><img src="/category/JavaSE-代理/5.png" alt="daili"></p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code>，我们仍然通过案例来学习</p><p>编写一个调用逻辑处理器 LogHandler 类，提供日志增强功能，并实现 InvocationHandler 接口；在 LogHandler 中维护一个目标对象，这个对象是被代理的对象（真实主题角色）；在 <code>invoke</code> 方法中编写方法调用的逻辑处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Object target;  <span class="comment">// 被代理的对象，实际的方法执行者</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = method.invoke(target, args);  <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之前执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之后执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写客户端，获取动态生成的代理类的对象须借助 Proxy 类的 newProxyInstance 方法，具体步骤可见代码和注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"><span class="keyword">import</span> proxy.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span></span><br><span class="line">        <span class="comment">// System.getProperties().setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");</span></span><br><span class="line">        <span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class="line">        UserServiceImpl userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        <span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class="line">        Class[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class="line">        <span class="comment">//     这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span></span><br><span class="line">        InvocationHandler logHandler = <span class="keyword">new</span> LogHandler(userServiceImpl);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">   5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class="line"><span class="comment">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class="line"><span class="comment">               b.然后根据相应的字节码转换成对应的class，</span></span><br><span class="line"><span class="comment">               c.然后调用newInstance()创建代理实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line">        <span class="comment">// 调用代理的方法</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">        <span class="comment">// ProxyUtils.generateClassFile(userServiceImpl.getClass(), "UserServiceProxy");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>] </span><br><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>]</span><br></pre></td></tr></table></figure><p>InvocationHandler 和 Proxy 的主要方法介绍如下：</p><p><strong>java.lang.reflect.InvocationHandler</strong></p><p><code>Object invoke(Object proxy, Method method, Object[] args)</code> 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</p><p><strong>java.lang.reflect.Proxy</strong></p><p><code>static InvocationHandler getInvocationHandler(Object proxy)</code> 用于获取指定代理对象所关联的调用处理器</p><p><code>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</code> 返回指定接口的代理类</p><p><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code> 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</p><p><code>static boolean isProxyClass(Class&lt;?&gt; cl)</code> 返回 cl 是否为一个代理类</p><h4 id="代理类的调用过程"><a href="#代理类的调用过程" class="headerlink" title="代理类的调用过程"></a>代理类的调用过程</h4><p>生成的代理类到底长什么样子呢？借助下面的工具类，把代理类保存下来再探个究竟<br>（通过设置环境变量sun.misc.ProxyGenerator.saveGeneratedFiles=true也可以保存代理类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.ProxyGenerator;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将根据类信息动态生成的二进制字节码保存到硬盘中，默认的是clazz目录下</span></span><br><span class="line"><span class="comment">     * params: clazz 需要生成动态代理类的类</span></span><br><span class="line"><span class="comment">     * proxyName: 为动态生成的代理类的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateClassFile</span><span class="params">(Class clazz, String proxyName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据类信息和提供的代理类名称，生成字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces());</span><br><span class="line">        String paths = clazz.getResource(<span class="string">"."</span>).getPath();</span><br><span class="line">        System.out.println(paths);</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//保留到硬盘中</span></span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(paths + proxyName + <span class="string">".class"</span>);</span><br><span class="line">            out.write(classFile);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Client2 测试类的main的最后面加入一行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">ProxyUtils.generateClassFile(userServiceImpl.getClass(), <span class="string">"UserServiceProxy"</span>);</span><br></pre></td></tr></table></figure><p>IDEA 再次运行之后就可以在 target 的类路径下找到 UserServiceProxy.class，双击后IDEA的反编译插件会将该二进制class文件</p><p><img src="/category/JavaSE-代理/6.png" alt="daili"></p><p>UserServiceProxy 的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">"proxy.UserService"</span>).getMethod(<span class="string">"select"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"proxy.UserService"</span>).getMethod(<span class="string">"update"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 UserServiceProxy 的代码中我们可以发现：</p><ul><li>UserServiceProxy 继承了 Proxy 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法</li><li>由于 UserServiceProxy 继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器</li><li>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</li><li>每个方法都有一个 Method 对象来描述，Method 对象在static静态代码块中创建，以 <code>m + 数字</code> 的格式命名</li><li>调用方法的时候通过 <code>super.h.invoke(this, m1, (Object[])null);</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 LogHandler 对象，它继承 InvocationHandler 类，负责实际的调用处理逻辑</li></ul><p>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    before();</span><br><span class="line">    Object result = method.invoke(target, args);       <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">    after();</span><br><span class="line">    <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK动态代理执行方法调用的过程简图如下：</p><p><img src="/category/JavaSE-代理/7.png" alt="daili"></p><h4 id="动态代理的秘密"><a href="#动态代理的秘密" class="headerlink" title="动态代理的秘密"></a>动态代理的秘密</h4><p>一定有同学对于为什么 Proxy 能够动态产生不同接口类型的代理感兴趣，我的猜测是肯定通过传入进去的接口然后通过反射动态生成了一个接口实例。<br>比如 SellWine 是一个接口，那么 Proxy.newProxyInstance() 内部肯定会有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SellWine();</span><br></pre></td></tr></table></figure><p>这样相同作用的代码，不过它是通过反射机制创建的。那么事实是不是这样子呢？直接查看它们的源码好了。需要说明的是，我当前查看的源码是 1.8 版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>newProxyInstance 的确创建了一个实例，它是通过 cl 这个 Class 文件的构造方法反射生成。cl 由 getProxyClass0() 方法获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接通过缓存获取，如果获取不到，注释说会通过 ProxyClassFactory 生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A factory function that generates, defines and returns the proxy class given</span></span><br><span class="line"><span class="comment">     * the ClassLoader and array of interfaces.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Proxy class 的前缀是 “$Proxy”，</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next number to use for generation of unique proxy class names</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Verify that the class loader resolves the name of this</span></span><br><span class="line"><span class="comment">                 * interface to the same Class object.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Verify that the Class object actually represents an</span></span><br><span class="line"><span class="comment">                 * interface.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Verify that this interface is not a duplicate.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">            <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Record the package of a non-public proxy interface so that the</span></span><br><span class="line"><span class="comment">             * proxy class will be defined in the same package.  Verify that</span></span><br><span class="line"><span class="comment">             * all non-public proxy interfaces are in the same package.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">                <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">                <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                    accessFlags = Modifier.FINAL;</span><br><span class="line">                    String name = intf.getName();</span><br><span class="line">                    <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                    String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        proxyPkg = pkg;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">                proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">            String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces, accessFlags);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                    proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">                 * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">                 * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">                 * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">                 * exceeded).</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个类的注释说，通过指定的 ClassLoader 和 接口数组 用工厂方法生成 proxy class。 然后这个 proxy class 的名字是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Proxy class 的前缀是 “$Proxy”，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line"></span><br><span class="line">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br></pre></td></tr></table></figure><p>所以，动态生成的代理类名称是<strong>包名+$Proxy+id序号</strong>。</p><p>生成的过程，核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces, accessFlags);</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line"><span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                    proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br></pre></td></tr></table></figure><p>这两个方法，我没有继续追踪下去，defineClass0() 甚至是一个 native 方法。我们只要知道，动态创建代理这回事就好了。</p><p>现在我们还需要做一些验证，我要检测一下动态生成的代理类的名字是不是<strong>包名+$Proxy+id序号</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">MaotaiJiu maotaijiu = <span class="keyword">new</span> MaotaiJiu();</span><br><span class="line"></span><br><span class="line">Wuliangye wu = <span class="keyword">new</span> Wuliangye();</span><br><span class="line"></span><br><span class="line">Furongwang fu = <span class="keyword">new</span> Furongwang();</span><br><span class="line"></span><br><span class="line">InvocationHandler jingxiao1 = <span class="keyword">new</span> GuitaiA(maotaijiu);</span><br><span class="line">InvocationHandler jingxiao2 = <span class="keyword">new</span> GuitaiA(wu);</span><br><span class="line"></span><br><span class="line">InvocationHandler jingxiao3 = <span class="keyword">new</span> GuitaiA(fu);</span><br><span class="line"></span><br><span class="line">SellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),</span><br><span class="line">MaotaiJiu.class.getInterfaces(), jingxiao1);</span><br><span class="line">SellWine dynamicProxy1 = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),</span><br><span class="line">MaotaiJiu.class.getInterfaces(), jingxiao2);</span><br><span class="line"></span><br><span class="line">dynamicProxy.mainJiu();</span><br><span class="line"></span><br><span class="line">dynamicProxy1.mainJiu();</span><br><span class="line"></span><br><span class="line">SellCigarette dynamicProxy3 = (SellCigarette) Proxy.newProxyInstance(Furongwang.class.getClassLoader(),</span><br><span class="line">Furongwang.class.getInterfaces(), jingxiao3);</span><br><span class="line"></span><br><span class="line">dynamicProxy3.sell();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"dynamicProxy class name:"</span>+dynamicProxy.getClass().getName());</span><br><span class="line">System.out.println(<span class="string">"dynamicProxy1 class name:"</span>+dynamicProxy1.getClass().getName());</span><br><span class="line">System.out.println(<span class="string">"dynamicProxy3 class name:"</span>+dynamicProxy3.getClass().getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">销售开始  柜台是： GuitaiA</span><br><span class="line">我卖得是茅台酒。</span><br><span class="line">销售结束</span><br><span class="line">销售开始  柜台是： GuitaiA</span><br><span class="line">我卖得是五粮液。</span><br><span class="line">销售结束</span><br><span class="line">销售开始  柜台是： GuitaiA</span><br><span class="line">售卖的是正宗的芙蓉王，可以扫描条形码查证。</span><br><span class="line">销售结束</span><br><span class="line"></span><br><span class="line">dynamicProxy class name:com.sun.proxy.$Proxy0</span><br><span class="line">dynamicProxy1 class name:com.sun.proxy.$Proxy0</span><br><span class="line">dynamicProxy3 class name:com.sun.proxy.$Proxy1</span><br></pre></td></tr></table></figure><p>SellWine 接口的代理类名是：com.sun.proxy.$Proxy0<br>SellCigarette 接口的代理类名是：com.sun.proxy.$Proxy1</p><p>这说明动态生成的 proxy class 与 Proxy 这个类同一个包。</p><p>下面用一张图让大家记住动态代理涉及到的角色。<br><img src="/category/JavaSE-代理/10.png" alt="daili"></p><p>红框中 <code>$Proxy0</code>就是通过 Proxy 动态生成的。<br><code>$Proxy0</code>实现了要代理的接口。<br><code>$Proxy0</code>通过调用 <code>InvocationHandler</code>来执行任务。</p><h2 id="cglib代理"><a href="#cglib代理" class="headerlink" title="cglib代理"></a>cglib代理</h2><p><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">cglib</a> (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。</p><p><strong>cglib特点</strong></p><ul><li>JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。<br>如果想代理没有实现接口的类，就可以使用CGLIB实现。</li><li>CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。<br>它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。</li><li>CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。<br>不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉。</li></ul><p>cglib与动态代理最大的<strong>区别</strong>就是</p><ul><li>使用动态代理的对象必须实现一个或多个接口</li><li>使用cglib代理的对象则无需实现接口，达到代理类无侵入。</li></ul><p>使用cglib需要引入<a href="https://repo1.maven.org/maven2/cglib/cglib/3.2.5/cglib-3.2.5.jar" target="_blank" rel="noopener">cglib的jar包</a>，如果你已经有spring-core的jar包，则无需引入，因为spring中包含了cglib。</p><ul><li>cglib的Maven坐标</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>maven引入CGLIB包，然后编写一个UserDao类，它没有接口，只有两个方法，select() 和 update()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDao 查询 selectById"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDao 更新 update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个 LogInterceptor ，继承了 MethodInterceptor，用于方法的拦截回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 表示要进行增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 表示拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);   <span class="comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DaoProxy daoProxy = <span class="keyword">new</span> DaoProxy(); </span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Dao.class);  <span class="comment">// 设置超类，cglib是通过继承来实现的</span></span><br><span class="line">        enhancer.setCallback(daoProxy);</span><br><span class="line"></span><br><span class="line">        Dao dao = (Dao)enhancer.create();   <span class="comment">// 创建代理类</span></span><br><span class="line">        dao.update();</span><br><span class="line">        dao.select();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>] </span><br><span class="line">log start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>]</span><br></pre></td></tr></table></figure><p>还可以进一步多个 MethodInterceptor 进行过滤筛选</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor2</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log2 start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log2 end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调过滤器: 在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFilter</span> <span class="keyword">implements</span> <span class="title">CallbackFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"select"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// Callback 列表第1个拦截器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// Callback 列表第2个拦截器，return 2 则为第3个，以此类推</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LogInterceptor logInterceptor = <span class="keyword">new</span> LogInterceptor();</span><br><span class="line">        LogInterceptor2 logInterceptor2 = <span class="keyword">new</span> LogInterceptor2();</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserDao.class);   <span class="comment">// 设置超类，cglib是通过继承来实现的</span></span><br><span class="line">        enhancer.setCallbacks(<span class="keyword">new</span> Callback[]&#123;logInterceptor, logInterceptor2, NoOp.INSTANCE&#125;);   <span class="comment">// 设置多个拦截器，NoOp.INSTANCE是一个空拦截器，不做任何处理</span></span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> DaoFilter());</span><br><span class="line"></span><br><span class="line">        UserDao proxy = (UserDao) enhancer.create();   <span class="comment">// 创建代理类</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>] </span><br><span class="line">log2 start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log2 end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>]</span><br></pre></td></tr></table></figure><p>CGLIB 创建动态代理类的模式是：</p><ol><li>查找目标类上的所有非final 的public类型的方法定义；</li><li>将这些方法的定义转换成字节码；</li><li>将组成的字节码转换成相应的代理的class对象；</li><li>实现 MethodInterceptor接口，用来处理对代理类上所有方法的请求</li></ol><h2 id="JDK动态代理与CGLIB动态代理对比"><a href="#JDK动态代理与CGLIB动态代理对比" class="headerlink" title="JDK动态代理与CGLIB动态代理对比"></a>JDK动态代理与CGLIB动态代理对比</h2><p>JDK动态代理：基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。</p><p>cglib动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。</p><p>JDK Proxy 的优势：</p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</li><li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li><li>代码实现简单。</li></ul><p>基于类似 cglib 框架的优势：</p><ul><li>无需实现接口，达到代理类无侵入</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li><li>高性能</li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p><strong>描述动态代理的几种实现方式？分别说出相应的优缺点</strong></p><p>代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK动态代理” 和 “CGLIB动态代理” 实现。</p><p><strong>静态代理</strong>：代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object</p><ul><li><strong>优点</strong>：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。</li><li><strong>缺点</strong>：不同的接口要有不同的代理类实现，会很冗余</li></ul><p><strong>JDK 动态代理</strong>：</p><ul><li>为了解决静态代理中，生成大量的代理类造成的冗余；</li><li>JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，</li><li>jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象</li><li>jdk动态代理之所以<strong>只能代理接口</strong>是因为<strong>代理类本身已经extends了Proxy，而java是不允许多重继承的</strong>，但是允许实现多个接口</li><li><strong>优点</strong>：解决了静态代理中冗余的代理实现类问题。</li><li><strong>缺点</strong>：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</li></ul><p><strong>CGLIB 代理</strong>：</p><ul><li>由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；</li><li>CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。</li><li>实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。</li><li>但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。</li><li>同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。</li><li><strong>优点</strong>：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。</li><li><strong>缺点</strong>：技术实现相对难理解些。</li></ul><h3 id="CGlib-对接口实现代理？"><a href="#CGlib-对接口实现代理？" class="headerlink" title="CGlib 对接口实现代理？"></a>CGlib 对接口实现代理？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建代理类的工厂 该类要实现 MethodInterceptor 接口。</span></span><br><span class="line"><span class="comment"> * 该类中完成三样工作：</span></span><br><span class="line"><span class="comment"> * （1）声明目标类的成员变量，并创建以目标类对象为参数的构造器。用于接收目标对象</span></span><br><span class="line"><span class="comment"> * （2）定义代理的生成方法，用于创建代理对象。方法名是任意的。代理对象即目标类的子类</span></span><br><span class="line"><span class="comment"> * （3）定义回调接口方法。对目标类的增强这在这里完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明目标类的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGLibFactory</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义代理的生成方法,用于创建代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">myCGLibCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 为代理对象设置父类，即指定目标类</span></span><br><span class="line">        enhancer.setSuperclass(UserService.class);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置回调接口对象 注意，只所以在setCallback()方法中可以写上this，</span></span><br><span class="line"><span class="comment">         * 是因为MethodIntecepter接口继承自Callback，是其子接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (UserService) enhancer.create();<span class="comment">// create用以生成CGLib代理对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start invoke "</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"end invoke "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://juejin.im/post/5c1ca8df6fb9a049b347f55c" target="_blank" rel="noopener">Java 动态代理详解</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE代理,动态代理,cblib代理
    
    </summary>
    
      <category term="JavaSE" scheme="https://www.ysmjjsy.com/categories/JavaSE/"/>
    
      <category term="JavaSE代理" scheme="https://www.ysmjjsy.com/categories/JavaSE/JavaSE%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-反射</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E5%8F%8D%E5%B0%84/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-反射/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2019-09-16T09:12:32.335Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 16 2019 17:55:59 GMT+0800 (GMT+08:00) --><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><blockquote><p>Java 反射机制在程序<strong>运行时</strong>，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 <strong>动态的获取信息</strong> 以及 <strong>动态调用对象的方法</strong> 的功能称为 <strong>java 的反射机制</strong>。</p></blockquote><p>反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 <code>.class</code> 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 <code>.class</code> 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。</p><p><strong>要想剖析一个类，必须先要获取到该类的字节码文件对象，而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象</strong></p><p>反射库提供了一个非常丰富且精心设计的工具集，以便编写能够动态操作Java代码的程序.。</p><p>能够分析类能力的程序称为反射，反射机制的功能极其强大，反射机制可以用来:</p><ul><li>在运行中分析类的能力</li><li>在运行中查看对象</li><li>实现通用的数组操作代码</li><li>利用Method对象。</li></ul><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>在程序运行期间，Java运行时系统始终未所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。</p><p>然后，可以通过专门的Java类访问这些信息。保存这些信息的类被称为Class，这个名字很容易让人混淆。<strong>Object类中的getClass()方法将会返回一个Class类型的实例。</strong></p><p>一个Class对象表示一个特定类的属性，<strong>getName()方法返回类的名字</strong>。</p><p>调用forName获得类名对应的Class对象,这个方法在类名保存在字符串中，并可在运行中改变就可以使用，只有在className是类名或接口名时才能够执行。否则将抛出一个checked exception(已检查异常)，所以无论何时使用这个方法，都应该提供一个异常处理器。</p><p>如果T是任意的Java类型，T.class将代表匹配的类对象，一个Class对象实际表示的是一个类型，而这个类型未必一定是一种类。虚拟机为每个类型管理一个Class对象，因此，可以利用==运算符实现两个类对象比较的操作符。newInstance()可以快速地创建一个类的实例。<strong>newInstance方法</strong>调用默认的构造器初始化新创建的对象，如果这个类没有默认的构造器，就会抛出一个异常。将forName与newInstance配合起来使用，可以根据存储在字符串中的类名创建一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = “java.util.Date”;</span><br><span class="line">Object m = Class.forName(s).newInstance();</span><br></pre></td></tr></table></figure><h2 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h2><p><strong>检查类的结构:</strong></p><p>在java.lang.reflect包中有三个类Field、Method和Constructor分别用于描述类的域、方法和构造器。</p><p>这三个类都有一个叫做getName的方法，用来返回项目的名称。</p><p>Field类有一个getType方法，用来返回描述域所属类型的Class对象。Method和Constructor类有能够报告参数类型的方法，</p><p>Method类还有一个可以报告返回类型的方法。</p><p>这三个类还有一个叫做getModifiers的方法，它将返回一个整形数值，用不同的位开关描述public和static这样的修饰符使用状况。</p><p>另外还有java.lang.reflect包中的Modifier类的静态方法分析getModifiers返回的整形数值。</p><p>还可以利用Modifier.toString方法将修饰符打印出来。</p><p>Class类中的getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员。</p><p>Class类的getDeclareFields、getDeclareMethods和getDeclaredConstructors方法将分别返回类中生命的全部域、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员。</p><p><strong>在运行时使用反射分析对象：</strong></p><p>如果f是一个Field类型的对象，obj是某个包含f域的类的对象，f.get(obj)。将返回一个对象，其值为obj域的当前值。</p><p>反射机制的默认行为受限于java的访问控制，然而，如果一个java程序没有收到安全管理器的控制，就可以覆盖访问控制，需要调用Field、Method或Construtor对象的setAsseccible方法</p><h2 id="类的加载和加载时机"><a href="#类的加载和加载时机" class="headerlink" title="类的加载和加载时机"></a>类的加载和加载时机</h2><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><ul><li>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化</li><li>加载<ul><li>就是指将class文件读入内存，并为之创建一个Class对象</li><li>任何类被使用时系统都会建立有个Class对象</li></ul></li><li>连接<ul><li>验证：是否有正确的内部结构，并和其它类协调一致</li><li>准备：负责为类的静态成员分配内存，并设置默认初始化值</li><li>解析：将类的二进制数据中的符号引用替换为直接引用</li></ul></li><li>初始化</li></ul><h3 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h3><ol><li>创建类的实例</li><li>访问类的静态变量，或者为静态变量赋值</li><li>掉用类的静态方法</li><li>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</li><li>初始化某个类的子类</li><li>直接使用java.exe命令来运行某个主类</li></ol><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>负责将.class文件加载到内存中，并为之生成对应的Class对象</p><p><strong>类加载器的组成</strong></p><p><strong>Bootstrap ClassLoader根类加载器</strong></p><ul><li>也被称为引导类加载器，负责Java核心类的加载<ul><li>比如System.String等，在JDK中JRE的lib目录下rt.jar文件中</li></ul></li></ul><p><strong>Extension ClassLoader扩展类加载器</strong></p><ul><li>负责JRE的扩展目录中jar包的加载<ul><li>在JDK中JRE的lib目录下的ext目录</li></ul></li></ul><p><strong>System CLassLoader系统类加载器</strong></p><ul><li>负责在JVM启动时加载来自Java命令的class文件，以及classpath环境变量所指定的jar包和类路径</li></ul><h2 id="反射的基本应用"><a href="#反射的基本应用" class="headerlink" title="反射的基本应用"></a>反射的基本应用</h2><p>反射可以用于判断任意对象所属的类，获得 Class 对象，构造任意一个对象以及调用一个对象。(反射相关的类一般都在 java.lang.relfect 包里)。</p><h3 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h3><ul><li><p>使用Class类的forName静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line"><span class="comment">//比如在 JDBC 开发中常用此方法加载数据库驱动:</span></span><br><span class="line">Class.forName(driver);</span><br></pre></td></tr></table></figure></li><li><p>直接获取某一个对象的class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; klass = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;?&gt; classInt = Integer.TYPE;</span><br></pre></td></tr></table></figure></li><li><p>调用某个对象的getClass()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">Class&lt;?&gt; klass = str.getClass();</span><br></pre></td></tr></table></figure></li></ul><h3 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h3><p>一般地，我们用 <code>instanceof</code> 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的 <code>isInstance()</code> 方法来判断是否为某个类的实例，它是一个 native 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>通过反射来生成对象主要有两种方式。</p><ul><li><p>使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure></li><li><p>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"23333"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取类的构造方法"><a href="#获取类的构造方法" class="headerlink" title="获取类的构造方法"></a>获取类的构造方法</h3><h4 id="获取无参构造"><a href="#获取无参构造" class="headerlink" title="获取无参构造"></a>获取无参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forNmae(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"><span class="comment">//获取构造方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public Constructor[] getConstructors();所有公共构造方法</span></span><br><span class="line"><span class="comment">public Constructor[] getDeclaredConstructors();所有构造方法</span></span><br><span class="line"><span class="comment">Constructor[] cons = c.getDeclaredConstructors();</span></span><br><span class="line"><span class="comment">for(Constructor con : cons)&#123;</span></span><br><span class="line"><span class="comment">System.out.println(con);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单个构造方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">参数表示的是:你要获取的构造方法的构造参数个数及数据类型的class字节码文件对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Constructor con = c.getConstructor();<span class="comment">//返回的是构造方法对象</span></span><br><span class="line"><span class="comment">//Student s = new Student();</span></span><br><span class="line"><span class="comment">//System.out.println(s);</span></span><br><span class="line"><span class="comment">//public T newInstance(Object... initargs)</span></span><br><span class="line"><span class="comment">//使用此Constructor对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例</span></span><br><span class="line">Object obj = con.newInstance();</span><br><span class="line">System.out.println(obj);</span><br><span class="line"><span class="comment">//Student s = (Student)obj;</span></span><br><span class="line"><span class="comment">//s.show();</span></span><br></pre></td></tr></table></figure><h4 id="获取带参构造"><a href="#获取带参构造" class="headerlink" title="获取带参构造"></a>获取带参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public Student(String name,int age,String address)</span></span><br><span class="line"><span class="comment">Student s = new Student("张三","18","西安");</span></span><br><span class="line"><span class="comment">System.out.println(s);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//获取字节码文件对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"><span class="comment">//获取带参构造方法对象</span></span><br><span class="line"><span class="comment">//public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">Constructor con = c.getConstructor(String.classs,<span class="keyword">int</span>.class,String.class);</span><br><span class="line"><span class="comment">//获取带参构造方法对象创建对象</span></span><br><span class="line"><span class="comment">//public T new Instance(Object... initargs);</span></span><br><span class="line">Objec obj = con.newInstance(<span class="string">"张三"</span>,<span class="string">"18"</span>,<span class="string">"西安"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><h4 id="获取私有构造"><a href="#获取私有构造" class="headerlink" title="获取私有构造"></a>获取私有构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">private Student(String name)&#123;&#125;</span></span><br><span class="line"><span class="comment">Student s = new Student("李四");</span></span><br><span class="line"><span class="comment">System.out.println(s);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//获取字节码文件对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"><span class="comment">//获取私有构造方法对象</span></span><br><span class="line"><span class="comment">//NoSuchMethodException:没有这个方法异常</span></span><br><span class="line"><span class="comment">//原因是一开始我们使用的方法只能获取公共的，下面这种方法就可以</span></span><br><span class="line">Constructor con = c.getDeclaredConstructor(String.class);</span><br><span class="line"><span class="comment">//用该私有构造方法创建对象</span></span><br><span class="line"><span class="comment">//IllegalAcessException:非法访问异常</span></span><br><span class="line"><span class="comment">//暴力访问</span></span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);<span class="comment">//值为true则指示反射的对象在使用时应该取消Java语言访问检查</span></span><br><span class="line">Object obj = con.newInstance(<span class="string">"李四"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><h3 id="获取类的成员变量"><a href="#获取类的成员变量" class="headerlink" title="获取类的成员变量"></a>获取类的成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有成员</span></span><br><span class="line">getFields.getDeclaredFields();</span><br><span class="line"><span class="comment">//获取单个成员</span></span><br><span class="line">getFields.getDeclaredField();</span><br><span class="line"><span class="comment">//修改成员的值</span></span><br><span class="line">set(Object obj,Object value);</span><br><span class="line"><span class="comment">//将指定对象变量上此Field对象表示的字段设置为指定的新值</span></span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取字节码文件对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"><span class="comment">//获取所有成员变量</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Field[] fields = c.getFields();</span></span><br><span class="line"><span class="comment">Field[] fields = c.getDeclaredFiedls();</span></span><br><span class="line"><span class="comment">for(Field field:fields)&#123;</span></span><br><span class="line"><span class="comment">System.out.println(field);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//Student s = new Student();s.address="上海";</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过无参构造方法创建对象</span></span><br><span class="line">Constructor con = c.getConstructor();</span><br><span class="line">Object obj = con.newInstance();</span><br><span class="line">System.out.println(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单个的成员</span></span><br><span class="line"><span class="comment">//获取address并对其赋值</span></span><br><span class="line">Field addressField = c.getField(<span class="string">"address"</span>);</span><br><span class="line"><span class="comment">//public void set(obj,Object value)</span></span><br><span class="line"><span class="comment">//将指定此对象变量上此Field对象表示的字段设置为指定的新值</span></span><br><span class="line">addressField.set(obj,<span class="string">"上海"</span>);<span class="comment">//给obj对象的addrrssField字段设置值</span></span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><p><strong>对于基本类型的静态常量，JVM 在编译阶段会把引用此常量的代码替换成具体的常量值</strong>。</p><p>这么说来，在实际开发中，如果我们想修改某个类的常量值，恰好那个常量是基本类型的，岂不是无能为力了？反正我个人认为除非修改源码，否则真没办法！</p><p>这里所谓的无能为力是指：<strong>我们在程序运行时刻依然可以使用反射修改常量的值（后面会代码验证），但是 JVM 在编译阶段得到的 .class 文件已经将常量优化为具体的值，在运行阶段就直接使用具体的值了，所以即使修改了常量的值也已经毫无意义了</strong>。</p><h3 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h3><h4 id="获取无参无返回值的成员方法"><a href="#获取无参无返回值的成员方法" class="headerlink" title="获取无参无返回值的成员方法"></a>获取无参无返回值的成员方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取字节码文件对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.goya.Student"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有的方法</span></span><br><span class="line"><span class="comment">//Method[] methods = c.getMethods();//获取自己的包括父亲的公共方法</span></span><br><span class="line"><span class="comment">//Method[] methods = c.getDeclareMethods();//获取自己的所有的方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(Method method:methods)&#123;</span></span><br><span class="line"><span class="comment">System.out.println(method);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Constructor con = c.getConstructor();</span><br><span class="line">Object obj = con.newInstance();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Student s = new Student(); s.show();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单个方法并使用</span></span><br><span class="line"><span class="comment">//public void show()</span></span><br><span class="line"><span class="comment">//public Method getMethod(String name,Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">//第一个参数表示的方法名，第二个参数表示的是方法的参数的class类型</span></span><br><span class="line">Methdo m1 = c.getMethod(<span class="string">"show"</span>);</span><br><span class="line"><span class="comment">//public Object invoke(Object obj,Object... args)</span></span><br><span class="line">m1.invole(obj);</span><br></pre></td></tr></table></figure><h4 id="获取带参带返回值成员的方法"><a href="#获取带参带返回值成员的方法" class="headerlink" title="获取带参带返回值成员的方法"></a>获取带参带返回值成员的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public void method(String s)</span></span><br><span class="line">Method m2 = c.getMethod(<span class="string">"method"</span>,String.class);</span><br><span class="line">m2.invoke(obj,<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//public String getString(String s,int i)</span></span><br><span class="line">Method m3 = c.getMethod(<span class="string">"getString"</span>,String.class,<span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//private void function()</span></span><br><span class="line">Method m3 = c.getDeclaredMethod(<span class="string">"function"</span>);</span><br><span class="line">m4.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">m4.invoke(obj);</span><br></pre></td></tr></table></figure><h3 id="通过反射越过泛型检查"><a href="#通过反射越过泛型检查" class="headerlink" title="通过反射越过泛型检查"></a>通过反射越过泛型检查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">Class c = array.getClass();<span class="comment">//集合ArrayList的class对象</span></span><br><span class="line">Method m = c.getMethod(<span class="string">"add"</span>,Object.class);</span><br><span class="line">m.invoke(array,<span class="string">"hello"</span>);<span class="comment">//调用array的add方法，传入的值是hello</span></span><br></pre></td></tr></table></figure><h2 id="反射源码解析"><a href="#反射源码解析" class="headerlink" title="反射源码解析"></a>反射源码解析</h2><p>当我们懂得了如何使用反射后，今天我们就来看看 JDK 源码中是如何实现反射的。或许大家平时没有使用过反射，但是在开发 Web 项目的时候会遇到过下面的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException </span><br><span class="line">...</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</span><br></pre></td></tr></table></figure><p>可以看到异常堆栈指出了异常在 Method 的第 497 的 invoke 方法中，其实这里指的 invoke 方法就是我们反射调用方法中的 invoke。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = clz.getMethod(<span class="string">"setPrice"</span>, <span class="keyword">int</span>.class); </span><br><span class="line">method.invoke(object, <span class="number">4</span>);   <span class="comment">//就是这里的invoke方法</span></span><br></pre></td></tr></table></figure><p>例如我们经常使用的 Spring 配置中，经常会有相关 Bean 的配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.chenshuyi.Apple"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>当我们在 XML 文件中配置了上面这段配置之后，Spring 便会在启动的时候利用反射去加载对应的 Apple 类。而当 Apple 类不存在或发生启发异常时，异常堆栈便会将异常指向调用的 invoke 方法。</p><p>从这里可以看出，我们平常很多框架都使用了反射，而反射中最最终的就是 Method 类的 invoke 方法了。</p><p>下面我们来看看 JDK 的 invoke 方法到底做了些什么。</p><p>进入 Method 的 invoke 方法我们可以看到，一开始是进行了一些权限的检查，最后是调用了 MethodAccessor 类的 invoke 方法进行进一步处理，如下图红色方框所示。</p><p><img src="/category/JavaSE-反射/f1.png" alt="fanshe"></p><p>那么 MethodAccessor 又是什么呢？</p><p>其实 MethodAccessor 是一个接口，定义了方法调用的具体操作，而它有三个具体的实现类：</p><ul><li>sun.reflect.DelegatingMethodAccessorImpl</li><li>sun.reflect.MethodAccessorImpl</li><li>sun.reflect.NativeMethodAccessorImpl</li></ul><p>而要看 ma.invoke() 到底调用的是哪个类的 invoke 方法，则需要看看 MethodAccessor 对象返回的到底是哪个类对象，所以我们需要进入 acquireMethodAccessor() 方法中看看。</p><p><img src="/category/JavaSE-反射/f2.png" alt="fanshe">从 acquireMethodAccessor() 方法我们可以看到，代码先判断是否存在对应的 MethodAccessor 对象，如果存在那么就复用之前的 MethodAccessor 对象，否则调用 ReflectionFactory 对象的 newMethodAccessor 方法生成一个 MethodAccessor 对象。</p><p><img src="/category/JavaSE-反射/f3.png" alt="fanshe">在 ReflectionFactory 类的 newMethodAccessor 方法里，我们可以看到首先是生成了一个 NativeMethodAccessorImpl 对象，再这个对象作为参数调用 DelegatingMethodAccessorImpl 类的构造方法。</p><p>这里的实现是使用了代理模式，将 NativeMethodAccessorImpl 对象交给 DelegatingMethodAccessorImpl 对象代理。我们查看 DelegatingMethodAccessorImpl 类的构造方法可以知道，其实是将 NativeMethodAccessorImpl 对象赋值给 DelegatingMethodAccessorImpl 类的 delegate 属性。</p><p><img src="/category/JavaSE-反射/f4.png" alt="fanshe">所以说ReflectionFactory 类的 newMethodAccessor 方法最终返回 DelegatingMethodAccessorImpl 类对象。所以我们在前面的 ma.invoke() 里，其将会进入 DelegatingMethodAccessorImpl 类的 invoke 方法中。</p><p><img src="/category/JavaSE-反射/f6.png" alt="fanshe">进入 DelegatingMethodAccessorImpl 类的 invoke 方法后，这里调用了 delegate 属性的 invoke 方法，它又有两个实现类，分别是：DelegatingMethodAccessorImpl 和 NativeMethodAccessorImpl。按照我们前面说到的，这里的 delegate 其实是一个 NativeMethodAccessorImpl 对象，所以这里会进入 NativeMethodAccessorImpl 的 invoke 方法。</p><p><img src="/category/JavaSE-反射/f7.png" alt="fanshe">而在 NativeMethodAccessorImpl 的 invoke 方法里，其会判断调用次数是否超过阀值（numInvocations）。如果超过该阀值，那么就会生成另一个MethodAccessor 对象，并将原来 DelegatingMethodAccessorImpl 对象中的 delegate 属性指向最新的 MethodAccessor 对象。</p><p>到这里，其实我们可以知道 MethodAccessor 对象其实就是具体去生成反射类的入口。通过查看源码上的注释，我们可以了解到 MethodAccessor 对象的一些设计信息。</p><blockquote><p>“Inflation” mechanism. Loading bytecodes to implement Method.invoke() and Constructor.newInstance() currently costs 3-4x more than an invocation via native code for the first invocation (though subsequent invocations have been benchmarked to be over 20x faster).Unfortunately this cost increases startup time for certain applications that use reflection intensively (but only once per class) to bootstrap themselves.</p><p>Inflation 机制。初次加载字节码实现反射，使用 Method.invoke() 和 Constructor.newInstance() 加载花费的时间是使用原生代码加载花费时间的 3 - 4 倍。这使得那些频繁使用反射的应用需要花费更长的启动时间。</p><p>To avoid this penalty we reuse the existing JVM entry points for the first few invocations of Methods and Constructors and then switch to the bytecode-based implementations. Package-private to be accessible to NativeMethodAccessorImpl and NativeConstructorAccessorImpl.</p><p>为了避免这种痛苦的加载时间，我们在第一次加载的时候重用了 JVM 的入口，之后切换到字节码实现的实现。</p></blockquote><p>就像注释里说的，实际的 MethodAccessor 实现有两个版本，一个是 Native 版本，一个是 Java 版本。</p><p>Native 版本一开始启动快，但是随着运行时间边长，速度变慢。Java 版本一开始加载慢，但是随着运行时间边长，速度变快。正是因为两种存在这些问题，所以第一次加载的时候我们会发现使用的是 NativeMethodAccessorImpl 的实现，而当反射调用次数超过 15 次之后，则使用 MethodAccessorGenerator 生成的 MethodAccessorImpl 对象去实现反射。</p><p>Method 类的 invoke 方法整个流程可以表示成如下的时序图：</p><p><img src="/category/JavaSE-反射/f8.png" alt="fanshe"> invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE反射概述以及使用
    
    </summary>
    
      <category term="JavaSE" scheme="https://www.ysmjjsy.com/categories/JavaSE/"/>
    
      <category term="JavaSE反射" scheme="https://www.ysmjjsy.com/categories/JavaSE/JavaSE%E5%8F%8D%E5%B0%84/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-JVM</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-jvm/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-jvm/</id>
    <published>2017-12-15T16:00:00.000Z</published>
    <updated>2019-09-16T09:11:31.108Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 16 2019 17:55:59 GMT+0800 (GMT+08:00) --><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>推荐周志明的《<a href="https://github.com/doocs/jvm/blob/master/book/jvm.pdf" target="_blank" rel="noopener">深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)</a>》</p><p>推荐：</p><p><a href="https://github.com/doocs/jvm" target="_blank" rel="noopener">Java 虚拟机底层原理知识总结</a></p><p><a href="https://zhuanlan.zhihu.com/p/34426768" target="_blank" rel="noopener">关于Jvm知识看这一篇就够了</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE-JVM
    
    </summary>
    
      <category term="JavaSE" scheme="https://www.ysmjjsy.com/categories/JavaSE/"/>
    
      <category term="JavaSE-JVM" scheme="https://www.ysmjjsy.com/categories/JavaSE/JavaSE-JVM/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-数组</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E6%95%B0%E7%BB%84/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-数组/</id>
    <published>2017-09-14T16:00:00.000Z</published>
    <updated>2019-09-16T09:56:57.866Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 16 2019 17:57:24 GMT+0800 (GMT+08:00) --><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是一种数据结构，用来存储同一类型值的集合。通过一个整型下标可以访问数组中的每一个值。</p><p>int[]a = new int[3];</p><p>new int[3]:在堆内存空间创建一个int类型数组，数组有三个元素，有一个唯一地址值</p><p>a:int类型数组，（引用类型），引用int[]a数组在堆内存创建的内存空间的唯一地址值</p><p>int:指定数组类型</p><p>数组在定义的时候必须进行初始化（静态初始化或者动态初始化）否则会报错。</p><p>int类型数组默认初始化值为0</p><p>String类型数组默认初始化值为null</p><p>boolean类型数组默认初始化值为false</p><p>double类型数组默认初始化值为0.0</p><p>快速创建数组：</p><p>int[]a = {1,2,3};</p><h2 id="数组的定义格式"><a href="#数组的定义格式" class="headerlink" title="数组的定义格式"></a>数组的定义格式</h2><p>声明数组变量时，需要指出数组类型和数组变量的名字</p><p><code>int[] a;</code></p><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>动态初始化：初始化时只指定数组长度，由系统为数组分配初始化值</p><p>静态初始化：初始化时指定每个数组元素的初始化值，由系统决定数组长度</p><ul><li>动态初始化</li></ul><p>只给长度，系统给出默认值。</p><p><code>int [] arr = new int [3];</code></p><ul><li>静态初始化</li></ul><p>给出值，系统决定长度</p><p><code>int[] arr = new int[] {1,2,3};</code></p><p><code>int [] arr = {1,2,3};</code></p><h2 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h2><p>Java有一种功能很强的循环结构，可以用来依次处理数组中的每个元素</p><p><code>for(variable: collection) statement</code></p><h2 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h2><p>在Java中允许将一个数组变量拷贝给另一个数组变量。这时两个变量将引用同一个数组</p><p><code>int[] luckyNumbers = smallPrimes;</code></p><p><code>luckyNumbers[5] = 12 //smallPrimes[5] = 12</code></p><p>如果希望将一个数组的所有值拷贝到一个新的数字组中去，则要使用Arrays类的copyTo方法。</p><p><code>int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers.length);</code></p><p>第二个参数是新数组的长度。</p><p>增加数组的大小:</p><p><code>luckyNumbers = Arrays.copyOf(luckyNumbers,2 * luckyNumbers.length) ;</code></p><p>如果数组元素是数值型，那么多余的元素将被赋值为0，如果数组元素是布尔值，则为false，如果长度小于原始数组的长度，则只拷贝最前 面的数据元素</p><p><code>Arrays.copyOf(数组,数组长度);</code></p><p>如果数组元素是数值型，那么多余的元素将被赋值为0；如果数组元素是布尔型，则将赋值为false。相反，如果长度小于原始数组的长度，则只拷贝最前面的数据元素.</p><h2 id="Java的内存分配"><a href="#Java的内存分配" class="headerlink" title="Java的内存分配"></a>Java的内存分配</h2><ul><li>栈</li></ul><p>存储局部变量</p><ul><li>堆</li></ul><p>存储所有new出来的东西</p><ul><li>方法区</li><li>本地方法区（系统相关）</li><li>寄存器（cpu使用）</li><li>栈内存和堆内存的区别</li></ul><p>栈：数据使用完毕就消失</p><p>堆：每一个new出来的东西都有地址、每一个变量都有默认值</p><p>数据使用完毕后，在垃圾回收器空闲的时候回收。</p><ul><li>一个数组内存图</li></ul><p><img src="/category/JavaSE-数组/1.png" alt="shuzu"></p><p><img src="/category/JavaSE-数组/2.png" alt="shuzu"></p><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p><code>Arrays.sort(数组);</code>优化的快速排序算法</p><p><code>static String toString(type[] a)</code>:返回包含a中数据元素的字符串，这些数据元素被放在括号内，并用逗号分隔.</p><p><code>statictype copyOf(type[] a,int length)</code>:</p><p><code>static type copyOf(type[] a,int start,int end)</code>:</p><p>返回与a类型相同的一个数组，其长度为length或者end-start，数组元素为a的值</p><p>拷贝的数据元素长度如果大于原数据元素长度，结果为0或false</p><p><code>static void sort(type[] a);</code></p><p><code>static int binarySearch(type[] a,type v)</code>:</p><p><code>static int binarySearch(type[] a,int start,int end,type v)</code></p><p>利用二分搜索算法查找值V，如果查找成功，则返回相应的下标值，否则，返回一个负数r</p><p><code>static void fill(type[] a,type v)</code>:将数组的所有数据元素值设置为v</p><p><code>static boolean equals(type[] a,type[] b)</code>:如果两个数组大小，下标相同的元素都对应相等，返回true.</p><h2 id="数组常见操作"><a href="#数组常见操作" class="headerlink" title="数组常见操作"></a>数组常见操作</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>方式一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x&lt;arr.length; x++)&#123;</span><br><span class="line">    System.out.println(arr[x]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"["</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;arr.length;x++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">      System.out.println(arr[x]+<span class="string">"]"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      System.out.println(arr[x]+<span class="string">","</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h3><p>最大值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; arr.length; x++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[x] &gt; max)&#123;</span><br><span class="line">      max = arr[x];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x =<span class="number">1</span>; x &lt; arr.length;x++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[x] &gt; max)&#123;</span><br><span class="line">      max = arr[x];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length/<span class="number">2</span>; x++)&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[x];</span><br><span class="line">    arr[x] = arr[arr.length-<span class="number">1</span>-x];</span><br><span class="line">    arr[arr.length-<span class="number">1</span>-x] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查表"><a href="#查表" class="headerlink" title="查表"></a>查表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String[] strArray,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strArray[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本查找"><a href="#基本查找" class="headerlink" title="基本查找"></a>基本查找</h3><p>方式一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x &lt; arr.length; x++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[x] == value)&#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex2</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x&lt; arr.length;x++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[x] == value)&#123;</span><br><span class="line">      index = x;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> idex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组是元素是一维数组的数组。</p><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据类型[][] 数组名 = <span class="keyword">new</span> 数组类型[m][n];</span><br><span class="line"></span><br><span class="line">数据类型[][] 数组名 = <span class="keyword">new</span> 数组类型[m][];</span><br><span class="line"></span><br><span class="line">数据类型[][] 数组名 = <span class="keyword">new</span> 数组类型[][]&#123;&#123;…&#125;,&#123;…&#125;,&#123;…&#125;&#125;;</span><br><span class="line"></span><br><span class="line">数据类型[][] 数组名 = &#123;&#123;…&#125;,&#123;…&#125;,&#123;…&#125;&#125;;</span><br></pre></td></tr></table></figure><h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray3</span><span class="params">(<span class="keyword">int</span>[][] arr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x= <span class="number">0</span>; x&lt;arr.length;x++)&#123;</span><br><span class="line">    System.out.println(arr[x][y]+<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组的求和"><a href="#二维数组的求和" class="headerlink" title="二维数组的求和"></a>二维数组的求和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">22</span>,<span class="number">33</span>,<span class="number">23</span>&#125;,&#123;<span class="number">45</span>,<span class="number">65</span>,<span class="number">85</span>&#125;,&#123;<span class="number">52</span>,<span class="number">77</span>,<span class="number">969</span>&#125;,&#123;<span class="number">55</span>,<span class="number">44</span>,<span class="number">11</span>&#125;&#125;</span><br><span class="line"><span class="comment">//定义一个求和变量sum，初始化值是0</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//通过遍历就可以得到每一个二维数组的元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x= <span class="number">0</span>;x&lt;arr.length;x++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>;y&lt;arr[x].length;y++)&#123;</span><br><span class="line">    sum += arr[x][y];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"请输入一个数据:"</span>);</span><br><span class="line"><span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;arr.length;x++)&#123;</span><br><span class="line">  arr[x][<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">  arr[x][x] =<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x =<span class="number">2</span>;x&lt;arr.length;x++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y =<span class="number">1</span>;y&lt;=x-<span class="number">1</span>;y++)&#123;</span><br><span class="line">    arr[x][y] = arr[x-<span class="number">1</span>][y-<span class="number">1</span>]+arr[x-<span class="number">1</span>][y];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;arr.length;x++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>;y&lt;arr[x].length;y++)&#123;</span><br><span class="line">    System.out.println(arr[x][y]+<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>char类型与其他基本引用类型不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> x[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    print(x);</span><br><span class="line">    newLine();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//println方法会直接输出char数组的值</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span></span>&#123;</span><br><span class="line">  String s = String.valueOf(x);</span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    print(s);</span><br><span class="line">    newLine();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他类型：syste.out.print方法会打印出数组的地址值</span></span><br></pre></td></tr></table></figure><h2 id="数组的高级二分查找"><a href="#数组的高级二分查找" class="headerlink" title="数组的高级二分查找"></a>数组的高级二分查找</h2><p>查找：</p><p>基本查找：数组元素无序(从头找到尾)</p><p>二分查找(折半查找)：数组元素有序</p><p><img src="/category/JavaSE-数组/3.png" alt="数组"></p><p><img src="/category/JavaSE-数组/4.png" alt="数组"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="/category/JavaSE-数组/5.png" alt="数组"></p><p><img src="/category/JavaSE-数组/6.png" alt="数组"></p><p>相邻位置比较，从小到大顺序，如果小就往前放，如果大就往后放</p><p>外层循环控制轮数</p><p><code>for(inti = 0;i&lt;a.length-1;j++)</code></p><p>内层循环控制：比大小，换位置</p><p><code>for(intj = 0;j&lt;a.length-1-i;j++)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] a = &#123;<span class="number">5</span>,<span class="number">456</span>,<span class="number">654</span>,<span class="number">855</span>,<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length-<span class="number">1</span>-i; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(Arrays.toString(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内层循环控制一个数和几个数比</p><p>外层循环控制你内层循环循环几次，你比几次</p><p>i&lt;a.length-1:循环a数组长度-1（元素个数的循环次数，最后一次可以不用比）</p><p>j&lt;a.length-1-i:循环a数组-1（下标数）-i（最后不用循环多次，次数在递减）</p><p><code>new Scanner(System.in).nextInt()</code></p><p>nextInt()方法有一个默认值，为10</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE数组,二维数组,数组排序
    
    </summary>
    
      <category term="JavaSE" scheme="https://www.ysmjjsy.com/categories/JavaSE/"/>
    
      <category term="JavaSE数组" scheme="https://www.ysmjjsy.com/categories/JavaSE/JavaSE%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-枚举</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E6%9E%9A%E4%B8%BE/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-枚举/</id>
    <published>2017-09-06T10:35:42.000Z</published>
    <updated>2019-09-16T04:56:20.899Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 16 2019 12:57:18 GMT+0800 (GMT+08:00) --><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举类型是Java 5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。</p><p><strong>枚举实现原理</strong></p><p>实际上在使用关键字enum创建枚举类型并编译后，编译器会为我们生成一个相关的类，这个类继承了Java API中的java.lang.Enum类，也就是说通过关键字enum创建枚举类型在编译后事实上也是一个类类型而且该类继承自java.lang.Enum类。下面我们编译前面定义的EnumDemo.java并查看生成的class文件来验证这个结论：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看目录下的java文件</span></span><br><span class="line">zejian<span class="meta">@zejiandeMBP</span> enumdemo$ ls</span><br><span class="line">EnumDemo.java</span><br><span class="line"><span class="comment">//利用javac命令编译EnumDemo.java</span></span><br><span class="line">zejian<span class="meta">@zejiandeMBP</span> enumdemo$ javac EnumDemo.java </span><br><span class="line"><span class="comment">//查看生成的class文件，注意有Day.class和EnumDemo.class 两个</span></span><br><span class="line">zejian<span class="meta">@zejiandeMBP</span> enumdemo$ ls</span><br><span class="line">Day.class  EnumDemo.class  EnumDemo.java</span><br></pre></td></tr></table></figure><p>利用javac编译前面定义的EnumDemo.java文件后分别生成了Day.class和EnumDemo.class文件，而Day.class就是枚举类型，这也就验证前面所说的使用关键字enum定义枚举类型并编译后，编译器会自动帮助我们生成一个与枚举相关的类。我们再来看看反编译Day.class文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反编译Day.class</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Day</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的values()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Day[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Day[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Day <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Day)Enum.valueOf(com/zejian/enumdemo/Day, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//前面定义的7种枚举实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day MONDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day TUESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day WEDNESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day THURSDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day FRIDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SATURDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SUNDAY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Day $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//实例化枚举实例</span></span><br><span class="line">        MONDAY = <span class="keyword">new</span> Day(<span class="string">"MONDAY"</span>, <span class="number">0</span>);</span><br><span class="line">        TUESDAY = <span class="keyword">new</span> Day(<span class="string">"TUESDAY"</span>, <span class="number">1</span>);</span><br><span class="line">        WEDNESDAY = <span class="keyword">new</span> Day(<span class="string">"WEDNESDAY"</span>, <span class="number">2</span>);</span><br><span class="line">        THURSDAY = <span class="keyword">new</span> Day(<span class="string">"THURSDAY"</span>, <span class="number">3</span>);</span><br><span class="line">        FRIDAY = <span class="keyword">new</span> Day(<span class="string">"FRIDAY"</span>, <span class="number">4</span>);</span><br><span class="line">        SATURDAY = <span class="keyword">new</span> Day(<span class="string">"SATURDAY"</span>, <span class="number">5</span>);</span><br><span class="line">        SUNDAY = <span class="keyword">new</span> Day(<span class="string">"SUNDAY"</span>, <span class="number">6</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> Day[] &#123;</span><br><span class="line">            MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反编译的代码可以看出编译器确实帮助我们生成了一个Day类(注意该类是final类型的，将无法被继承)而且该类继承自java.lang.Enum类，该类是一个抽象类(稍后我们会分析该类中的主要方法)，除此之外，编译器还帮助我们生成了7个Day类型的实例对象分别对应枚举中定义的7个日期，这也充分说明了我们前面使用关键字enum定义的Day类型中的每种日期枚举常量也是实实在在的Day实例对象，只不过代表的内容不一样而已。注意编译器还为我们生成了两个静态方法，分别是values()和 valueOf()，稍后会分析它们的用法，到此我们也就明白了，使用关键字enum定义的枚举类型，在编译期后，也将转换成为一个实实在在的类，而在该类中，会存在每个在枚举类型中定义好变量的对应实例对象，如上述的MONDAY枚举类型对应public static final Day MONDAY;，同时编译器会为该类创建两个方法，分别是values()和valueOf()。</p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><ol><li>在某些情况下，一个类的对象时有限且固定的，如季节类，它只有春夏秋冬4个对象这种实例有限且固定的类，在 Java 中被称为枚举类；</li><li>在 Java 中使用 enum 关键字来定义枚举类，其地位与 class、interface 相同；</li><li>枚举类是一种特殊的类，它和普通的类一样，有自己的成员变量、成员方法、构造器 (只能使用 private 访问修饰符，所以无法从外部调用构造器，构造器只在构造枚举值时被调用)；</li><li>一个 Java 源文件中最多只能有一个 public 类型的枚举类，且该 Java 源文件的名字也必须和该枚举类的类名相同，这点和类是相同的；</li><li>使用 enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口;</li><li>所有的枚举值都是 public static final 的，且非抽象的枚举类不能再派生子类；</li><li>枚举类的所有实例(枚举值)必须在枚举类的第一行显式地列出，否则这个枚举类将永远不能产生实例。列出这些实例(枚举值)时，系统会自动添加 public static final 修饰，无需程序员显式添加。</li></ol><h3 id="定义枚举类"><a href="#定义枚举类" class="headerlink" title="定义枚举类"></a>定义枚举类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个星期的枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> WeekEnum &#123;</span><br><span class="line">    <span class="comment">// 在第一行显式地列出7个枚举实例(枚举值)，系统会自动添加 public static final 修饰</span></span><br><span class="line">    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类的成员变量、成员方法、构造器"><a href="#枚举类的成员变量、成员方法、构造器" class="headerlink" title="枚举类的成员变量、成员方法、构造器"></a>枚举类的成员变量、成员方法、构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> WeekEnum &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为已经定义了带参数的构造器，所以在列出枚举值时必须传入对应的参数</span></span><br><span class="line">    SUNDAY(<span class="string">"星期日"</span>), MONDAY(<span class="string">"星期一"</span>), TUESDAY(<span class="string">"星期二"</span>), WEDNESDAY(<span class="string">"星期三"</span>), </span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>), FRIDAY(<span class="string">"星期五"</span>), SATURDAY(<span class="string">"星期六"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个 private 修饰的实例变量</span></span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个带参数的构造器，枚举类的构造器只能使用 private 修饰</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WeekEnum</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 get set 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举的常见方法"><a href="#枚举的常见方法" class="headerlink" title="枚举的常见方法"></a>枚举的常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span><span class="title">compareTo</span><span class="params">(E o)</span><span class="comment">//比较此枚举与指定对象的顺序,同一个枚举实例只能与相同类型的枚举实例比较。如果该枚举对象位于指定枚举对象之后，则返回正整数；反之返回负整数；否则返回零；</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span><span class="title">equals</span><span class="params">(Object other)</span><span class="comment">//当指定对象等于此枚举常量时，返回 true。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Class&lt;?&gt;<span class="title">getDeclaringClass</span><span class="params">()</span><span class="comment">//返回与此枚举常量的枚举类型相对应的 Class 对象</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String<span class="title">name</span><span class="params">()</span><span class="comment">//返回此枚举常量的名称，在其枚举声明中对其进行声明</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span><span class="title">ordinal</span><span class="params">()</span><span class="comment">//返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零）</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String<span class="title">toString</span><span class="params">()</span><span class="comment">//返回枚举常量的名称，它包含在声明中</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>&lt;T extends Enum&lt;T&gt;&gt; T<span class="keyword">static</span> <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType, String name)</span><span class="comment">//返回带指定名称的指定枚举类型的枚举常量。</span></span></span><br></pre></td></tr></table></figure><p>这里主要说明一下ordinal()方法，该方法获取的是枚举变量在枚举类中声明的顺序，下标从0开始，如日期中的MONDAY在第一个位置，那么MONDAY的ordinal值就是0，如果MONDAY的声明位置发生变化，那么ordinal方法获取到的值也随之变化，注意在大多数情况下我们都不应该首先使用该方法，毕竟它总是变幻莫测的。compareTo(E o)方法则是比较枚举的大小，注意其内部实现是根据每个枚举的ordinal值大小进行比较的。name()方法与toString()几乎是等同的，都是输出变量的字符串形式。至于valueOf(Class<t>enumType, String name)方法则是根据枚举类的Class对象和枚举名称获取枚举常量，注意该方法是静态的，</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(WeekEnum.FRIDAY.compareTo(WeekEnum.MONDAY));</span><br><span class="line">        System.out.println(WeekEnum.FRIDAY.compareTo(WeekEnum.SUNDAY));</span><br><span class="line">        System.out.println(WeekEnum.FRIDAY.compareTo(WeekEnum.SATURDAY));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有重写 toString 方法</span></span><br><span class="line"><span class="comment">//static values()： 返回一个包含全部枚举值的数组，可以用来遍历所有枚举值；</span></span><br><span class="line"><span class="keyword">for</span> (WeekEnum we : WeekEnum.values()) &#123;</span><br><span class="line">            System.out.println(we);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SUNDAY</span></span><br><span class="line"><span class="comment">MONDAY</span></span><br><span class="line"><span class="comment">TUESDAY</span></span><br><span class="line"><span class="comment">WEDNESDAY</span></span><br><span class="line"><span class="comment">THURSDAY</span></span><br><span class="line"><span class="comment">FRIDAY</span></span><br><span class="line"><span class="comment">SATURDAY</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String toString()： 返回枚举值的名称，与 name 方法类似，更常用；</span></span><br><span class="line"><span class="comment">// 定义一个星期的枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> WeekEnum &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为已经定义了带参数的构造器，所以在列出枚举值时必须传入对应的参数</span></span><br><span class="line">    SUNDAY(<span class="string">"星期日"</span>), MONDAY(<span class="string">"星期一"</span>), TUESDAY(<span class="string">"星期二"</span>), WEDNESDAY(<span class="string">"星期三"</span>), </span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>), FRIDAY(<span class="string">"星期五"</span>), SATURDAY(<span class="string">"星期六"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个 private 修饰的实例变量</span></span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个带参数的构造器，枚举类的构造器只能使用 private 修饰</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WeekEnum</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义 get set 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写 toString() 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写了 toString 方法</span></span><br><span class="line"><span class="keyword">for</span> (WeekEnum we : WeekEnum.values()) &#123;</span><br><span class="line">            System.out.println(we);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">星期日</span></span><br><span class="line"><span class="comment">星期一</span></span><br><span class="line"><span class="comment">星期二</span></span><br><span class="line"><span class="comment">星期三</span></span><br><span class="line"><span class="comment">星期四</span></span><br><span class="line"><span class="comment">星期五</span></span><br><span class="line"><span class="comment">星期六</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int ordinal()： 返回枚举值在枚举类中的索引值(从0开始)，即枚举值在枚举声明中的顺序，这个顺序根据枚举值声明的顺序而定；</span></span><br><span class="line">System.out.println(WeekEnum.SUNDAY.ordinal());</span><br><span class="line">System.out.println(WeekEnum.FRIDAY.ordinal());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static valueOf()： 返回带指定名称的指定枚举类型的枚举常量，名称必须与在此类型中声明枚举常量所用的标识符完全匹配(不允许使用额外的空白字符)。这个方法与toString相对应，因此重写 toString() 方法，一定要重写 valueOf() 方法(我们可以重写 toString() 方法，但不能自己重写 valueOf() 方法，当我们重写 toString() 方法时，valueOf() 方法会自动重写，不用我们理会。)；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(WeekEnum.valueOf(WeekEnum.class, <span class="string">"MONDAY"</span>));</span><br><span class="line">        System.out.println(WeekEnum.valueOf(WeekEnum.class, <span class="string">"FRIDAY"</span>));</span><br><span class="line">        System.out.println(WeekEnum.valueOf(WeekEnum.class, <span class="string">"SUNDAY"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">MONDAY</span></span><br><span class="line"><span class="comment">FRIDAY</span></span><br><span class="line"><span class="comment">SUNDAY</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="使用枚举类实现接口"><a href="#使用枚举类实现接口" class="headerlink" title="使用枚举类实现接口"></a>使用枚举类实现接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenderDescription</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了一个接口，该接口有一个 info() 方法，凡是实现该接口的类都需要实现该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Gender implements GenderDescription &#123;</span><br><span class="line">    </span><br><span class="line">    MALE,FEMALE;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个用于定义性别的枚举类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Gender.MALE.info();</span><br><span class="line">        Gender.FEMALE.info();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">这是一个用于定义性别的枚举类</span></span><br><span class="line"><span class="comment">这是一个用于定义性别的枚举类</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="包含抽象方法的枚举类"><a href="#包含抽象方法的枚举类" class="headerlink" title="包含抽象方法的枚举类"></a>包含抽象方法的枚举类</h3><p>定义一个 Operation 枚举类，有4个枚举值PLUS、MINUS、TIMES、DIVIDE，分别代表加、减、乘、除，该枚举类有一个 calculate() 方法，用于完成计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于执行加法运算</span></span><br><span class="line">    PLUS &#123; <span class="comment">// 花括号部分其实是一个匿名内部子类</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于执行减法运算</span></span><br><span class="line">    MINUS &#123; <span class="comment">// 花括号部分其实是一个匿名内部子类</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">            <span class="keyword">return</span> x - y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于执行乘法运算</span></span><br><span class="line">    TIMES &#123; <span class="comment">// 花括号部分其实是一个匿名内部子类</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x * y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于执行除法运算</span></span><br><span class="line">    DIVIDE &#123; <span class="comment">// 花括号部分其实是一个匿名内部子类</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x / y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为该枚举类定义一个抽象方法，枚举类中所有的枚举值都必须实现这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"6 + 3 = "</span> + Operation.PLUS.calculate(<span class="number">6</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">"6 - 2 = "</span> + Operation.MINUS.calculate(<span class="number">6</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(<span class="string">"6 * 2 = "</span> + Operation.TIMES.calculate(<span class="number">6</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(<span class="string">"6 / 2 = "</span> + Operation.DIVIDE.calculate(<span class="number">6</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">6+3=9.0</span></span><br><span class="line"><span class="comment">6-2=4.0</span></span><br><span class="line"><span class="comment">6*2=12.0</span></span><br><span class="line"><span class="comment">6/2=3.0</span></span><br></pre></td></tr></table></figure><h3 id="编译器生成的Values方法与ValueOf方法"><a href="#编译器生成的Values方法与ValueOf方法" class="headerlink" title="编译器生成的Values方法与ValueOf方法"></a>编译器生成的Values方法与ValueOf方法</h3><p>values()方法和valueOf(String name)方法是编译器生成的static方法，因此从前面的分析中，在Enum类中并没出现values()方法，但valueOf()方法还是有出现的，只不过编译器生成的valueOf()方法需传递一个name参数，而Enum自带的静态方法valueOf()则需要传递两个方法，从前面反编译后的代码可以看出，编译器生成的valueOf方法最终还是调用了Enum类的valueOf方法，下面通过代码来演示这两个方法的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Day[] days2 = Day.values();</span><br><span class="line">System.out.println(<span class="string">"day2:"</span>+Arrays.toString(days2));</span><br><span class="line">Day day = Day.valueOf(<span class="string">"MONDAY"</span>);</span><br><span class="line">System.out.println(<span class="string">"day:"</span>+day);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 输出结果:</span></span><br><span class="line"><span class="comment"> day2:[MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY]</span></span><br><span class="line"><span class="comment"> day:MONDAY</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>从结果可知道，values()方法的作用就是获取枚举类中的所有变量，并作为数组返回，而valueOf(String name)方法与Enum类中的valueOf方法的作用类似根据名称获取枚举变量，只不过编译器生成的valueOf方法更简洁些只需传递一个参数。这里我们还必须注意到，由于values()方法是由编译器插入到枚举类中的static方法，所以如果我们将枚举实例向上转型为Enum，那么values()方法将无法被调用，因为Enum类中并没有values()方法，valueOf()方法也是同样的道理，注意是一个参数的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//正常使用</span></span><br><span class="line">Day[] ds=Day.values();</span><br><span class="line"><span class="comment">//向上转型Enum</span></span><br><span class="line">Enum e = Day.MONDAY;</span><br><span class="line"><span class="comment">//无法调用,没有此方法</span></span><br><span class="line"><span class="comment">//e.values();</span></span><br></pre></td></tr></table></figure><h3 id="枚举与Class对象"><a href="#枚举与Class对象" class="headerlink" title="枚举与Class对象"></a>枚举与Class对象</h3><p>上述我们提到当枚举实例向上转型为Enum类型后，values()方法将会失效，也就无法一次性获取所有枚举实例变量，但是由于Class对象的存在，即使不使用values()方法，还是有可能一次获取到所有枚举实例变量的，在Class对象中存在如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[]getEnumConstants()<span class="comment">//返回该枚举类型的所有元素，如果Class对象不是枚举类型，则返回null。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span><span class="title">isEnum</span><span class="params">()</span><span class="comment">//当且仅当该类声明为源代码中的枚举时返回 true</span></span></span><br></pre></td></tr></table></figure><p>因此通过getEnumConstants()方法，同样可以轻而易举地获取所有枚举实例变量下面通过代码来演示这个功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常使用</span></span><br><span class="line">Day[] ds=Day.values();</span><br><span class="line"><span class="comment">//向上转型Enum</span></span><br><span class="line">Enum e = Day.MONDAY;</span><br><span class="line"><span class="comment">//无法调用,没有此方法</span></span><br><span class="line"><span class="comment">//e.values();</span></span><br><span class="line"><span class="comment">//获取class对象引用</span></span><br><span class="line">Class&lt;?&gt; clasz = e.getDeclaringClass();</span><br><span class="line"><span class="keyword">if</span>(clasz.isEnum()) &#123;</span><br><span class="line">    Day[] dsz = (Day[]) clasz.getEnumConstants();</span><br><span class="line">    System.out.println(<span class="string">"dsz:"</span>+Arrays.toString(dsz));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   输出结果:</span></span><br><span class="line"><span class="comment">   dsz:[MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="枚举的进阶用法"><a href="#枚举的进阶用法" class="headerlink" title="枚举的进阶用法"></a>枚举的进阶用法</h2><p>在前面的分析中，我们都是基于简单枚举类型的定义，也就是在定义枚举时只定义了枚举实例类型，并没定义方法或者成员变量，实际上使用关键字enum定义的枚举类，除了不能使用继承(因为编译器会自动为我们继承Enum抽象类而Java只支持单继承，因此枚举类是无法手动实现继承的)，可以把enum类当成常规类，也就是说我们可以向enum类中添加方法和变量，甚至是mian方法，下面就来感受一把。</p><h3 id="向enum类添加方法与自定义构造函数"><a href="#向enum类添加方法与自定义构造函数" class="headerlink" title="向enum类添加方法与自定义构造函数"></a>向enum类添加方法与自定义构造函数</h3><p>重新定义一个日期枚举类，带有desc成员变量描述该日期的对于中文描述，同时定义一个getDesc方法，返回中文描述内容，自定义私有构造函数，在声明枚举实例时传入对应的中文描述，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.enumdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/5/8.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day2 &#123;</span><br><span class="line">    MONDAY(<span class="string">"星期一"</span>),</span><br><span class="line">    TUESDAY(<span class="string">"星期二"</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">"星期三"</span>),</span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>),</span><br><span class="line">    FRIDAY(<span class="string">"星期五"</span>),</span><br><span class="line">    SATURDAY(<span class="string">"星期六"</span>),</span><br><span class="line">    SUNDAY(<span class="string">"星期日"</span>);<span class="comment">//记住要用分号结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//中文描述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造,防止被外部调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day2</span><span class="params">(String desc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc=desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义方法,返回描述,跟常规类的定义没区别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Day2 day:Day2.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"name:"</span>+day.name()+</span><br><span class="line">                    <span class="string">",desc:"</span>+day.getDesc());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     输出结果:</span></span><br><span class="line"><span class="comment">     name:MONDAY,desc:星期一</span></span><br><span class="line"><span class="comment">     name:TUESDAY,desc:星期二</span></span><br><span class="line"><span class="comment">     name:WEDNESDAY,desc:星期三</span></span><br><span class="line"><span class="comment">     name:THURSDAY,desc:星期四</span></span><br><span class="line"><span class="comment">     name:FRIDAY,desc:星期五</span></span><br><span class="line"><span class="comment">     name:SATURDAY,desc:星期六</span></span><br><span class="line"><span class="comment">     name:SUNDAY,desc:星期日</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可知，在enum类中确实可以像定义常规类一样声明变量或者成员方法。但是我们必须注意到，如果打算在enum类中定义方法，务必在声明完枚举实例后使用分号分开，倘若在枚举实例前定义任何方法，编译器都将会报错，无法编译通过，同时即使自定义了构造函数且enum的定义结束，我们也永远无法手动调用构造函数创建枚举实例，毕竟这事只能由编译器执行。</p><h3 id="关于覆盖enum类方法"><a href="#关于覆盖enum类方法" class="headerlink" title="关于覆盖enum类方法"></a>关于覆盖enum类方法</h3><p>既然enum类跟常规类的定义没什么区别（实际上enum还是有些约束的），那么覆盖父类的方法也不会是什么难说，可惜的是父类Enum中的定义的方法只有toString方法没有使用final修饰，因此只能覆盖toString方法，如下通过覆盖toString省去了getDesc方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.enumdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/5/8.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day2 &#123;</span><br><span class="line">    MONDAY(<span class="string">"星期一"</span>),</span><br><span class="line">    TUESDAY(<span class="string">"星期二"</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">"星期三"</span>),</span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>),</span><br><span class="line">    FRIDAY(<span class="string">"星期五"</span>),</span><br><span class="line">    SATURDAY(<span class="string">"星期六"</span>),</span><br><span class="line">    SUNDAY(<span class="string">"星期日"</span>);<span class="comment">//记住要用分号结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//中文描述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造,防止被外部调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day2</span><span class="params">(String desc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc=desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Day2 day:Day2.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"name:"</span>+day.name()+</span><br><span class="line">                    <span class="string">",desc:"</span>+day.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     输出结果:</span></span><br><span class="line"><span class="comment">     name:MONDAY,desc:星期一</span></span><br><span class="line"><span class="comment">     name:TUESDAY,desc:星期二</span></span><br><span class="line"><span class="comment">     name:WEDNESDAY,desc:星期三</span></span><br><span class="line"><span class="comment">     name:THURSDAY,desc:星期四</span></span><br><span class="line"><span class="comment">     name:FRIDAY,desc:星期五</span></span><br><span class="line"><span class="comment">     name:SATURDAY,desc:星期六</span></span><br><span class="line"><span class="comment">     name:SUNDAY,desc:星期日</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举与单例模式"><a href="#枚举与单例模式" class="headerlink" title="枚举与单例模式"></a>枚举与单例模式</h3><p>单例模式可以说是最常使用的设计模式了，它的作用是确保某个类只有一个实例，自行实例化并向整个系统提供这个实例。在实际应用中，线程池、缓存、日志对象、对话框对象常被设计成单例，总之，选择单例模式就是为了避免不一致状态，下面我们将会简单说明单例模式的几种主要编写方式，从而对比出使用枚举实现单例模式的优点。首先看看饿汉式的单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by wuzejian on 2017/5/9.</span></span><br><span class="line"><span class="comment"> * 饿汉式（基于classloder机制避免了多线程的同步问题）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHungry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonHungry instance = <span class="keyword">new</span> SingletonHungry();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonHungry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonHungry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这种写法比较简单，但问题是无法做到延迟创建对象，事实上如果该单例类涉及资源较多，创建比较耗时间时，我们更希望它可以尽可能地延迟加载，从而减小初始化的负载，于是便有了如下的懒汉式单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by wuzejian on 2017/5/9..</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式（适合多线程安全）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonLazy instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法能够在多线程中很好的工作避免同步问题，同时也具备lazy loading机制，遗憾的是，由于synchronized的存在，效率很低，在单线程的情景下，完全可以去掉synchronized，为了兼顾效率与性能问题，改进后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种编写方式被称为“双重检查锁”，主要在getSingleton()方法中，进行两次null检查。这样可以极大提升并发度，进而提升性能。毕竟在单例中new的情况非常少，绝大多数都是可以并行的读操作，因此在加锁前多进行一次null检查就可以减少绝大多数的加锁操作，也就提高了执行效率。但是必须注意的是volatile关键字，该关键字有两层语义。第一层语义是可见性，可见性是指在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以其它线程会马上读取到已修改的值，关于工作内存和主内存可简单理解为高速缓存（直接与CPU打交道）和主存（日常所说的内存条），注意工作内存是线程独享的，主存是线程共享的。volatile的第二层语义是禁止指令重排序优化，我们写的代码（特别是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同，这在单线程并没什么问题，然而一旦引入多线程环境，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题，值得关注的是volatile的禁止指令重排序优化功能在Java 1.5后才得以实现，因此1.5前的版本仍然是不安全的，即使使用了volatile关键字。或许我们可以利用静态内部类来实现更安全的机制，静态内部类单例模式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by wuzejian on 2017/5/9.</span></span><br><span class="line"><span class="comment"> * 静态内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SingletonInner singleton = <span class="keyword">new</span> SingletonInner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonInner</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonInner <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上述代码所展示的，我们把Singleton实例放到一个静态内部类中，这样可以避免了静态实例在Singleton类的加载阶段（类加载过程的其中一个阶段的，此时只创建了Class对象，关于Class对象可以看博主另外一篇博文， 深入理解Java类型信息(Class对象)与反射机制）就创建对象，毕竟静态变量初始化是在SingletonInner类初始化时触发的，并且由于静态内部类只会被加载一次，所以这种写法也是线程安全的。从上述4种单例模式的写法中，似乎也解决了效率与懒加载的问题，但是它们都有两个共同的缺点：</p><ul><li>序列化可能会破坏单例模式，比较每次反序列化一个序列化的对象实例时都会创建一个新的实例，解决方案如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试例子(四种写解决方式雷同)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;     </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();     </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">//反序列时直接返回当前INSTANCE</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">            <span class="keyword">return</span> INSTANCE;     </span><br><span class="line">      &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用反射强行调用私有构造器，解决方式可以修改构造器，让它在创建第二个实例的时候抛异常，如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();     </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span>  <span class="keyword">boolean</span>  flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    flag = <span class="keyword">false</span>;   </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The instance  already exists ！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所述，问题确实也得到了解决，但问题是我们为此付出了不少努力，即添加了不少代码，还应该注意到如果单例类维持了其他对象的状态时还需要使他们成为transient的对象，这种就更复杂了，那有没有更简单更高效的呢？当然是有的，那就是枚举单例了，先来看看如何实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by wuzejian on 2017/5/9.</span></span><br><span class="line"><span class="comment"> * 枚举单利</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码相当简洁，我们也可以像常规类一样编写enum类，为其添加变量和方法，访问方式也更简单，使用SingletonEnum.INSTANCE进行访问，这样也就避免调用getInstance方法，更重要的是使用枚举单例的写法，我们完全不用考虑序列化和反射的问题。枚举序列化是由jvm保证的，每一个枚举类型和定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定：在序列化时Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的并禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法，从而保证了枚举实例的唯一性，这里我们不妨再次看看Enum类的valueOf方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              String name)</span> </span>&#123;</span><br><span class="line">      T result = enumType.enumConstantDirectory().get(name);</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">"No enum constant "</span> + enumType.getCanonicalName() + <span class="string">"."</span> + name);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实际上通过调用enumType(Class对象的引用)的enumConstantDirectory方法获取到的是一个Map集合，在该集合中存放了以枚举name为key和以枚举实例变量为value的Key&amp;Value数据，因此通过name的值就可以获取到枚举实例，看看enumConstantDirectory方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Map&lt;String, T&gt; <span class="title">enumConstantDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enumConstantDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//getEnumConstantsShared最终通过反射调用枚举类的values方法</span></span><br><span class="line">            T[] universe = getEnumConstantsShared();</span><br><span class="line">            <span class="keyword">if</span> (universe == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    getName() + <span class="string">" is not an enum type"</span>);</span><br><span class="line">            Map&lt;String, T&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span> * universe.length);</span><br><span class="line">            <span class="comment">//map存放了当前enum类的所有枚举实例变量，以name为key值</span></span><br><span class="line">            <span class="keyword">for</span> (T constant : universe)</span><br><span class="line">                m.put(((Enum&lt;?&gt;)constant).name(), constant);</span><br><span class="line">            enumConstantDirectory = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enumConstantDirectory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Map&lt;String, T&gt; enumConstantDirectory = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>到这里我们也就可以看出枚举序列化确实不会重新创建新实例，jvm保证了每个枚举实例变量的唯一性。再来看看反射到底能不能创建枚举，下面试图通过反射获取构造器并创建枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException </span>&#123;</span><br><span class="line">  <span class="comment">//获取枚举类的构造函数(前面的源码已分析过)</span></span><br><span class="line">   Constructor&lt;SingletonEnum&gt; constructor=SingletonEnum.class.getDeclaredConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">   constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">   <span class="comment">//创建枚举</span></span><br><span class="line">   SingletonEnum singleton=constructor.newInstance(<span class="string">"otherInstance"</span>,<span class="number">9</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>执行报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalArgumentException: Cannot reflectively create <span class="keyword">enum</span> objects</span><br><span class="line">    at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">417</span>)</span><br><span class="line">    at zejian.SingletonEnum.main(SingletonEnum.java:<span class="number">38</span>)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">144</span>)</span><br></pre></td></tr></table></figure><p>显然告诉我们不能使用反射创建枚举类，这是为什么呢？不妨看看newInstance方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">              IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">               Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">               checkAccess(caller, clazz, <span class="keyword">null</span>, modifiers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//这里判断Modifier.ENUM是不是枚举修饰符，如果是就抛异常</span></span><br><span class="line">       <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br><span class="line">       ConstructorAccessor ca = constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">       <span class="keyword">if</span> (ca == <span class="keyword">null</span>) &#123;</span><br><span class="line">           ca = acquireConstructorAccessor();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">       T inst = (T) ca.newInstance(initargs);</span><br><span class="line">       <span class="keyword">return</span> inst;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>源码很了然，确实无法使用反射创建枚举实例，也就是说明了创建枚举实例只有编译器能够做到而已。显然枚举单例模式确实是很不错的选择，因此我们推荐使用它。但是这总不是万能的，对于android平台这个可能未必是最好的选择，在android开发中，内存优化是个大块头，而使用枚举时占用的内存常常是静态变量的两倍还多，因此android官方在内存优化方面给出的建议是尽量避免在android中使用enum。但是不管如何，关于单例，我们总是应该记住：线程安全，延迟加载，序列化与反序列化安全，反射安全是很重重要的。</p><p>参考</p><p><a href="https://blog.csdn.net/javazejian/article/details/71333103" target="_blank" rel="noopener">深入理解Java枚举类型(enum)</a></p><p>关于EnumMap与EnumSet也可以看上面的博客</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE枚举
    
    </summary>
    
      <category term="JavaSE" scheme="https://www.ysmjjsy.com/categories/JavaSE/"/>
    
      <category term="JavaSE枚举" scheme="https://www.ysmjjsy.com/categories/JavaSE/JavaSE%E6%9E%9A%E4%B8%BE/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-泛型</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E6%B3%9B%E5%9E%8B/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-泛型/</id>
    <published>2017-09-05T16:00:00.000Z</published>
    <updated>2019-09-16T04:30:16.237Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 16 2019 12:31:36 GMT+0800 (GMT+08:00) --><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型，参数化类型，把类型当作参数一样的传递。</p><p>Java容器能够容纳任何类型的对象，这一点表面上是通过泛型机制完成，Java泛型不是什么神奇的东西，只是编译器为我们提供的一个“语法糖”，泛型本身并不需要Java虚拟机的支持，只需要在编译阶段做一下简单的字符串替换即可。实质上Java的单继承机制才是保证这一特性的根本，因为所有的对象都是Object的子类，容器里只要能够存放Object对象就行了。</p><p>事实上，所有容器的内部存放的都是Object对象，泛型机制只是简化了编程，由编译器自动帮我们完成了强制类型转换而已。JDK 1.4以及之前版本不支持泛型，类型转换需要程序员显式完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK 1.4 or before</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Monday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Tuesday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Wensday"</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">    String weekday = (String)list.get(i);<span class="comment">//显式类型转换</span></span><br><span class="line">    System.out.println(weekday.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK 1.5 or latter</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//参数化类型</span></span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Monday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Tuesday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Wensday"</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">    String weekday = list.get(i);<span class="comment">//隐式类型转换，编译器自动完成</span></span><br><span class="line">    System.out.println(weekday.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java泛型类"><a href="#Java泛型类" class="headerlink" title="Java泛型类"></a>Java泛型类</h2><p>类结构是面向对象中最基本的元素，如果我们的类需要有很好的扩展性，那么我们可以将其设置成泛型的。假设我们需要一个数据的包装类，通过传入不同类型的数据，可以存储相应类型的数据。我们看看这个简单的泛型类的设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataHolder</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类定义时只需要在类名后面加上类型参数即可，当然你也可以添加多个参数，类似于<k ,v>,<t ,e,k>等。这样我们就可以在类里面使用定义的类型参数。</t></k></p><p>泛型类最常用的使用场景就是“元组”的使用。我们知道方法return返回值只能返回单个对象。如果我们定义一个泛型类，定义2个甚至3个类型参数，这样我们return对象的时候，构建这样一个“元组”数据，通过泛型传入多个对象，这样我们就可以一次性方法多个数据了。</p><h2 id="Java泛型方法"><a href="#Java泛型方法" class="headerlink" title="Java泛型方法"></a>Java泛型方法</h2><p>泛型方法既可以存在于泛型类中，也可以存在于普通的类中。如果使用泛型方法可以解决问题，那么应该尽量使用泛型方法。下面我们通过例子来看一下泛型方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataHolder</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">PrinterInfo</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">AAAAA</span></span><br><span class="line"><span class="comment">8.88</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从上面的例子中，我们看到我们是在一个泛型类里面定义了一个泛型方法printInfo。通过传入不同的数据类型，我们都可以打印出来。在这个方法里面，我们定义了类型参数E。这个E和泛型类里面的T两者之间是没有关系的。哪怕我们将泛型方法设置成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">PrinterInfo</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">DataHolder&lt;String&gt; dataHolder=<span class="keyword">new</span> DataHolder&lt;&gt;();</span><br><span class="line">dataHolder.PrinterInfo(<span class="number">1</span>);</span><br><span class="line">dataHolder.PrinterInfo(<span class="string">"AAAAA"</span>);</span><br><span class="line">dataHolder.PrinterInfo(<span class="number">8.88f</span>);</span><br></pre></td></tr></table></figure><p>这个泛型方法依然可以传入Double、Float等类型的数据。泛型方法里面的类型参数T和泛型类里面的类型参数是不一样的类型，从上面的调用方式，我们也可以看出，泛型方法printInfo不受我们DataHolder中泛型类型参数是String的影响。我们来总结下泛型方法的几个基本特征：</p><ul><li>public与返回值中间非常重要，可以理解为声明此方法为泛型方法。</li><li>只有声明了的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</li><li>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</li><li>与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</li></ul><h2 id="Java泛型接口"><a href="#Java泛型接口" class="headerlink" title="Java泛型接口"></a>Java泛型接口</h2><p>Java泛型接口的定义和Java泛型类基本相同，下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处有两点需要注意：</p><ul><li>泛型接口未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中。例子如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 即：class DataHolder implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class DataHolder implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果泛型接口传入类型参数时，实现该泛型接口的实现类，则所有使用泛型的地方都要替换成传入的实参类型。例子如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataHolder</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子我们看到，实现类里面的所有T的地方都需要实现为String。</p><h2 id="Java泛型擦除及其相关内容"><a href="#Java泛型擦除及其相关内容" class="headerlink" title="Java泛型擦除及其相关内容"></a>Java泛型擦除及其相关内容</h2><p>我们下面看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1=<span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">Class&lt;?&gt; class2=<span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">System.out.println(class1);<span class="comment">//class java.util.ArrayList</span></span><br><span class="line">System.out.println(class2);<span class="comment">//class java.util.ArrayList</span></span><br><span class="line">System.out.println(class1.equals(class2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>我们看输出发现，class1和class2居然是同一个类型ArrayList，在运行时我们传入的类型变量String和Integer都被丢掉了。Java语言泛型在设计的时候为了兼容原来的旧代码，Java的泛型机制使用了“擦除”机制。我们来看一个更彻底的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>&lt;<span class="title">Q</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Particle</span>&lt;<span class="title">POSITION</span>, <span class="title">MOMENTUM</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">//调用代码及输出</span></span><br><span class="line">List&lt;Table&gt; tableList = <span class="keyword">new</span> ArrayList&lt;Table&gt;();</span><br><span class="line">Map&lt;Room, Table&gt; maps = <span class="keyword">new</span> HashMap&lt;Room, Table&gt;();</span><br><span class="line">House&lt;Room&gt; house = <span class="keyword">new</span> House&lt;Room&gt;();</span><br><span class="line">Particle&lt;Long, Double&gt; particle = <span class="keyword">new</span> Particle&lt;Long, Double&gt;();</span><br><span class="line">System.out.println(Arrays.toString(tableList.getClass().getTypeParameters()));</span><br><span class="line">System.out.println(Arrays.toString(maps.getClass().getTypeParameters()));</span><br><span class="line">System.out.println(Arrays.toString(house.getClass().getTypeParameters()));</span><br><span class="line">System.out.println(Arrays.toString(particle.getClass().getTypeParameters()));</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">[E]</span></span><br><span class="line"><span class="comment">[K, V]</span></span><br><span class="line"><span class="comment">[Q]</span></span><br><span class="line"><span class="comment">[POSITION, MOMENTUM]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>上面的代码里，我们想在运行时获取类的类型参数，但是我们看到返回的都是“形参”。在运行期我们是获取不到任何已经声明的类型信息的。</p><p>注意：</p><p>编译器虽然会在编译过程中移除参数的类型信息，但是会保证类或方法内部参数类型的一致性。</p><p>泛型参数将会被擦除到它的第一个边界（边界可以有多个，重用 extends 关键字，通过它能给与参数类型添加一个边界）。编译器事实上会把类型参数替换为它的第一个边界的类型。如果没有指明边界，那么类型参数将被擦除到Object。下面的例子中，可以把泛型参数T当作HasF类型来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HasF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extend关键字后后面的类型信息决定了泛型参数能保留的信息。Java类型擦除只会擦除到HasF类型。</p><h2 id="Java泛型擦除的原理"><a href="#Java泛型擦除的原理" class="headerlink" title="Java泛型擦除的原理"></a>Java泛型擦除的原理</h2><p>我们通过例子来看一下，先看一个非泛型的版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleHolder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHolder holder = <span class="keyword">new</span> SimpleHolder();</span><br><span class="line">        holder.setObj(<span class="string">"Item"</span>);</span><br><span class="line">        String s = (String) holder.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SimpleHolder.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleHolder</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getObj</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: getfield      #2                  // Field obj:Ljava/lang/Object;</span><br><span class="line">       <span class="number">4</span>: areturn       </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: aload_1       </span><br><span class="line">       2: putfield      #2                  // Field obj:Ljava/lang/Object;</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #3                  // class SimpleHolder</span><br><span class="line">       <span class="number">3</span>: dup           </span><br><span class="line">       4: invokespecial #4                  // Method "&lt;init&gt;":()V</span><br><span class="line">       <span class="number">7</span>: astore_1      </span><br><span class="line">       <span class="number">8</span>: aload_1       </span><br><span class="line">       9: ldc           #5                  // String Item</span><br><span class="line">      11: invokevirtual #6                  // Method setObj:(Ljava/lang/Object;)V</span><br><span class="line">      <span class="number">14</span>: aload_1       </span><br><span class="line">      15: invokevirtual #7                  // Method getObj:()Ljava/lang/Object;</span><br><span class="line">      18: checkcast     #8                  // class java/lang/String</span><br><span class="line">      <span class="number">21</span>: astore_2      </span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们给出一个泛型的版本，从字节码的角度来看看:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GenericHolder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;String&gt; holder = <span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br><span class="line">        holder.setObj(<span class="string">"Item"</span>);</span><br><span class="line">        String s = holder.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GenericHolder.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T obj;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GenericHolder</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: getfield      #2                  // Field obj:Ljava/lang/Object;</span><br><span class="line">       <span class="number">4</span>: areturn       </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: aload_1       </span><br><span class="line">       2: putfield      #2                  // Field obj:Ljava/lang/Object;</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #3                  // class GenericHolder</span><br><span class="line">       <span class="number">3</span>: dup           </span><br><span class="line">       4: invokespecial #4                  // Method "&lt;init&gt;":()V</span><br><span class="line">       <span class="number">7</span>: astore_1      </span><br><span class="line">       <span class="number">8</span>: aload_1       </span><br><span class="line">       9: ldc           #5                  // String Item</span><br><span class="line">      11: invokevirtual #6                  // Method setObj:(Ljava/lang/Object;)V</span><br><span class="line">      <span class="number">14</span>: aload_1       </span><br><span class="line">      15: invokevirtual #7                  // Method getObj:()Ljava/lang/Object;</span><br><span class="line">      18: checkcast     #8                  // class java/lang/String</span><br><span class="line">      <span class="number">21</span>: astore_2      </span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译过程中，类型变量的信息是能拿到的。所以，set方法在编译器可以做类型检查，非法类型不能通过编译。但是对于get方法，由于擦除机制，运行时的实际引用类型为Object类型。为了“还原”返回结果的类型，编译器在get之后添加了类型转换。所以，在GenericHolder.class文件main方法主体第18行有一处类型转换的逻辑。它是编译器自动帮我们加进去的。</p><p>所以在泛型类对象读取和写入的位置为我们做了处理，为代码添加约束。</p><h3 id="Java泛型擦除的缺陷及补救措施"><a href="#Java泛型擦除的缺陷及补救措施" class="headerlink" title="Java泛型擦除的缺陷及补救措施"></a>Java泛型擦除的缺陷及补救措施</h3><p>泛型类型不能显式地运用在运行时类型的操作当中，例如：转型、instanceof 和 new。因为在运行时，所有参数的类型信息都丢失了。类似下面的代码都是无法通过编译的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> T) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        T <span class="keyword">var</span> = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE];</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        T[] array = (T) <span class="keyword">new</span> Object[SIZE];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们有什么办法来补救呢？下面介绍几种方法来一一解决上面出现的问题。</p><p><strong>类型判断问题</strong></p><p>我们可以通过下面的代码来解决泛型的类型信息由于擦除无法进行类型判断的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型类型判断封装类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Class&lt;?&gt; classType;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericType</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        classType=type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classType.isInstance(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法我们可以这样调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GenericType&lt;A&gt; genericType=<span class="keyword">new</span> GenericType&lt;&gt;(A.class);</span><br><span class="line">System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">System.out.println(genericType.isInstance(<span class="keyword">new</span> A()));</span><br><span class="line">System.out.println(genericType.isInstance(<span class="keyword">new</span> B()));</span><br></pre></td></tr></table></figure><h5 id="创建类型实例"><a href="#创建类型实例" class="headerlink" title="创建类型实例"></a>创建类型实例</h5><p>泛型代码中不能new T()的原因有两个，一是因为擦除，不能确定类型；而是无法确定T是否包含无参构造函数。<br>为了避免这两个问题，我们使用显式的工厂模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用工厂方法来创建实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creater</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T instance;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends Factory&lt;T&gt;&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    instance=f.create();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer integer=<span class="keyword">new</span> Integer(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> integer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过工厂模式+泛型方法来创建实例对象，上面代码中我们创建了一个IntegerFactory工厂，用来创建Integer实例，以后代码有变动的话，我们可以添加新的工厂类型即可。<br>调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Creater&lt;Integer&gt; creater=<span class="keyword">new</span> Creater&lt;&gt;();</span><br><span class="line">System.out.println(creater.newInstance(<span class="keyword">new</span> IntegerFactory()));</span><br></pre></td></tr></table></figure><h5 id="创建泛型数组"><a href="#创建泛型数组" class="headerlink" title="创建泛型数组"></a>创建泛型数组</h5><p>一般不建议创建泛型数组。尽量使用ArrayList来代替泛型数组。但是在这里还是给出一种创建泛型数组的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArrayWithTypeToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = (T[]) Array.newInstance(type, sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用的还是传参数类型，利用类型的newInstance方法创建实例的方式。</p><h2 id="Java泛型通配符"><a href="#Java泛型通配符" class="headerlink" title="Java泛型通配符"></a>Java泛型通配符</h2><p><strong>泛型通配符&lt;?&gt;</strong></p><p>任意类型，如果没有明确，那么就是Objet以及任意的Java类</p><p><strong>? extends E</strong></p><p>向下限定，E及其子类</p><p><strong>? super E</strong></p><p>向上限定，E及其父类</p><h3 id="上界通配符-lt-extends-T-gt"><a href="#上界通配符-lt-extends-T-gt" class="headerlink" title="上界通配符&lt;? extends T&gt;"></a>上界通配符&lt;? extends T&gt;</h3><p>我们先来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>现在我们定义一个盘子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们定义一个水果盘子，理论上水果盘子里，当然可以存在苹果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple());</span><br></pre></td></tr></table></figure><p>你会发现这段代码无法进行编译。装苹果的盘子”无法转换成“装水果的盘子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert from Plate&lt;Apple&gt; to Plate&lt;Fruit&gt;</span><br></pre></td></tr></table></figure><p>从上面代码我们知道，就算容器中的类型之间存在继承关系，但是Plate和Plate两个容器之间是不存在继承关系的。 在这种情况下，Java就设计成Plate&lt;? extend Fruit&gt;来让两个容器之间存在继承关系。我们上面的代码就可以进行赋值了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? extends Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple());</span><br></pre></td></tr></table></figure><p>Plate&lt;? extend Fruit&gt;是Plate&lt; Fruit &gt;和Plate&lt; Apple &gt;的基类。<br>我们通过一个更加详细的例子来看一下上界的界限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meat</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pork</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beef</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedApple</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenApple</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在上面这个类层次中，Plate&lt;? extend Fruit&gt;，覆盖下面的蓝色部分：</p><p><img src="/category/JavaSE-泛型/1.png" alt="fanxing"></p><p>如果我们往盘子里面添加数据，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.set(<span class="keyword">new</span> Fruit());</span><br><span class="line">p.set(<span class="keyword">new</span> Apple());</span><br></pre></td></tr></table></figure><p>你会发现无法往里面设置数据，按道理说我们将泛型类型设置为? extend Fruit。按理说我们往里面添加Fruit的子类应该是可以的。但是Java编译器不允许这样操作。&lt;? extends Fruit&gt;会使往盘子里放东西的set()方法失效。但取东西get()方法还有效<br>原因是：</p><p>Java编译期只知道容器里面存放的是Fruit和它的派生类，具体是什么类型不知道，可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在后面看到Plate&lt; Apple &gt;赋值以后，盘子里面没有标记为“苹果”。只是标记了一个占位符“CAP#1”，来表示捕获一个Fruit或者Fruit的派生类，具体是什么类型不知道。所有调用代码无论往容器里面插入Apple或者Meat或者Fruit编译器都不知道能不能和这个“CAP#1”匹配，所以这些操作都不允许。</p><p>最新理解：</p><p>一个Plate&lt;? extends Fruit&gt;的引用，指向的可能是一个Plate类型的盘子，要往这个盘子里放Banana当然是不被允许的。我的一个理解是：Plate&lt;? extends Fruit&gt;代表某个只能放某种类型水果的盘子，而不是什么水果都能往里放的盘子</p><p>但是上界通配符是允许读取操作的。例如代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fruit fruit=p.get();</span><br><span class="line">Object object=p.get();</span><br></pre></td></tr></table></figure><p>这个我们很好理解，由于上界通配符设定容器中只能存放Fruit及其派生类，那么获取出来的我们都可以隐式的转为其基类（或者Object基类）。所以上界描述符Extends适合频繁读取的场景。</p><h3 id="下界通配符-lt-super-T-gt"><a href="#下界通配符-lt-super-T-gt" class="headerlink" title="下界通配符&lt;? super T&gt;"></a>下界通配符&lt;? super T&gt;</h3><p>下界通配符的意思是容器中只能存放T及其T的基类类型的数据。我们还是以上面类层次的来看，&lt;? super Fruit&gt;覆盖下面的红色部分：</p><p><img src="/category/JavaSE-泛型/2.png" alt="fanxing"></p><p>下界通配符&lt;? super T&gt;不影响往里面存储，但是读取出来的数据只能是Object类型。</p><p>原因是：</p><p>下界通配符规定了元素最小的粒度，必须是T及其基类，那么我往里面存储T及其派生类都是可以的，因为它都可以隐式的转化为T类型。但是往外读就不好控制了，里面存储的都是T及其基类，无法转型为任何一种类型，只有Object基类才能装下。</p><h4 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h4><p>最后简单介绍下Effective Java这本书里面介绍的PECS原则。</p><ul><li><p>上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。</p></li><li><p>下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。</p></li></ul><h4 id="lt-gt-无限通配符"><a href="#lt-gt-无限通配符" class="headerlink" title="&lt;?&gt;无限通配符"></a>&lt;?&gt;无限通配符</h4><p>无界通配符 意味着可以使用任何对象，因此使用它类似于使用原生类型。但它是有作用的，原生类型可以持有任何类型，而无界通配符修饰的容器持有的是某种具体的类型。举个例子，在List&lt;\?&gt;类型的引用中，不能向其中添加Object, 而List类型的引用就可以添加Object类型的变量。<br>最后提醒一下的就是，List&lt;\Object&gt;与List&lt;?&gt;并不等同，List&lt;\Object&gt;是List&lt;?&gt;的子类。还有不能往List&lt;?&gt; list里添加任意对象，除了null。</p><p>参考文章：</p><p><a href="https://juejin.im/post/5b614848e51d45355d51f792" target="_blank" rel="noopener">深入理解Java泛型</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE泛型概述
    
    </summary>
    
      <category term="JavaSE" scheme="https://www.ysmjjsy.com/categories/JavaSE/"/>
    
      <category term="JavaSE泛型" scheme="https://www.ysmjjsy.com/categories/JavaSE/JavaSE%E6%B3%9B%E5%9E%8B/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
