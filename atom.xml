<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余生梦见皆是缘</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ysmjjsy.com/"/>
  <updated>2019-08-16T01:51:57.084Z</updated>
  <id>https://www.ysmjjsy.com/</id>
  
  <author>
    <name>Goya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HelloJava</title>
    <link href="https://www.ysmjjsy.com/category/HelloJava!/"/>
    <id>https://www.ysmjjsy.com/category/HelloJava!/</id>
    <published>2018-07-12T13:27:05.000Z</published>
    <updated>2019-08-16T01:51:57.084Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 16 2019 09:52:47 GMT+0800 (GMT+08:00) --><h1 id="gt-HelloJava"><a href="#gt-HelloJava" class="headerlink" title="-&gt;HelloJava!"></a>-&gt;HelloJava!</h1><blockquote><p>Goya：<br>Java是一门伟大的艺术，至少在我看来是的了，也许如果没有Java出现会出现别的类似编程语言，但是因为它的存在，促进了互联网的&gt;发展。<br>当我第一次接触Java是在初中，那时候有的塞班系统的手机上会出现一个Java的一些小游戏或者小应用，回忆中的样子应该是如此。<br>到了大学，大二开始学习Java知道了这门著名的编程语言。<br>那时候老师也不会将很多学习Java先要了解的一些知识，只是告诉你James Gosling发明了Java，并且在Sun公司，之后Sun被Oracle收购等等一些常识。然后便开始了Java语言的学习，那时候只知道按部就班的安装那些必备软件，然后开始敲。</p></blockquote><p>学习Java我认为首先需要了解一下什么是Java？它用来干什么？它怎么实现的？它发展是什么？<br>我想在这个大时代背景下，程序员，编程，代码几乎人人皆知。而退十年来讲，都是陌生的。<br>随着时代的发展，让这些一部分人知道的事务变成众人皆知的事务，这就是互联网的进步以及大时代的笼罩下造成的氛围。你离开了这些就仿佛一个原始人，这么说也许太片面，但离了这些产品那真的会回退一个时代。<br>很多人都说互联网时代已经告去，大数据人工智能时代来临并飞速发展，那么怎么来，靠什么发展。我想这就是为什么电子信息专业的火爆以及许多人认为的“高薪资”。</p><hr><h1 id="那什么是Java"><a href="#那什么是Java" class="headerlink" title="那什么是Java"></a>那什么是Java</h1><ul><li><p>在1990年代之前，比较熟知的C、C++、SQL等著名语言被开发</p></li><li><p>在1990年代，推动编程语言发展的思想则是“提升程序员的生产力”，出现了很多快速应用程序开发，这些语言大都有相应的集成开发环境，也大多是面向对象的编程语言。像Java、Python、Ruby、Visual Basic、JavaScript、PHP等。而Java的出现则更加保守。</p></li></ul><p>所以Java的产生可以理解为一门可以提高程序员生产力的语言。<br>而那时候的Java叫Oak，是为了服务家用电器等小型系统的编程语言。<br>但那时候这种智能化电器则不像现在般火爆。于是Sun便开始改造。</p><blockquote><p>摘自维基百科：<br>Java编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在Java SE 1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装/拆箱特性。Sun对Java语言的解释是：“Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”<br>Java不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了Java程序的运行效率。但在J2SE1.4.2发布后，Java的运行速度有了大幅提升。<br>与传统类型不同，Sun公司在推出Java时就将其作为开放的技术。全球的Java开发公司被要求所设计的Java软件必须相互兼容。“Java语言靠群体的力量而非公司的力量”是Sun公司的口号之一，并获得了广大软件开发商的认同。这与微软公司所倡导的注重精英和封闭式的模式完全不同，此外，微软公司后来推出了与之竞争的.NET平台以及模仿Java的C#语言。后来Sun公司被甲骨文公司并购，Java也随之成为甲骨文公司的产品。</p></blockquote><p>总结下来就是Java是一个面向对象的拥有“简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”这些特点的语言。并且是一门开源语言（开放源代码全世界人学习或者修改加入自己的想法，但是Sun公司拥有Java的一部分权力）</p><p>那么首先我们可以分析一下，什么是编程语言：</p><blockquote><p>编程语言是用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。</p></blockquote><p><strong>所以Java就是一门我们可以根据Java的语法规则写出来的代码，它来编译成计算机识别的指令来操作计算机或者其他设备的语言。</strong></p><h2 id="那么Java如何识别我们写的代码再编译成计算机识别的指令呢？"><a href="#那么Java如何识别我们写的代码再编译成计算机识别的指令呢？" class="headerlink" title="那么Java如何识别我们写的代码再编译成计算机识别的指令呢？"></a>那么Java如何识别我们写的代码再编译成计算机识别的指令呢？</h2><p>举一个例子：我们写一个<strong>HelloWorld.java</strong><br><em>这个时候可以不用纠结这些看不懂</em><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"HelloWorld!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后通过控制台执行javac<br><img src="/category/HelloJava!/javac.png" alt="javac"></p><p>可以看到在HelloWorld.java同级目录生成一个.class文件<br><img src="/category/HelloJava!/javaclass.png" alt="classlocation"></p><p>接着执行java命令<br><img src="/category/HelloJava!/java.png" alt="java"></p><p>可以看到我们写的代码被计算机所解释编译执行，输出HelloWorld</p><h3 id="那么这个javac是什么呢？"><a href="#那么这个javac是什么呢？" class="headerlink" title="那么这个javac是什么呢？"></a>那么这个javac是什么呢？</h3><ul><li>当安装好jdk后可以在jdk安装目录bin文件夹下看到这个脚本。</li><li>它是用来编译java程序的源代码，但是它本质是基于jdk标准类库中的javac类库实现，所以java的编译器实质是一个java程序</li><li>javac又被称为前端编译器，仅负责源代码与字节码之间的转换，而在jvm内部还存在一个后置编译器（根据热点探测技术，可以将最有价值的字节码转换为机器码执行从而提升java程序的运行效率）</li><li>javac 的意义就在于 将源码编译为字节码，同时做一些词法，语法，语义上的检查，最后生成可供jvm运行的字节码文件。</li><li>可以在lib中的tools jar包中sun.tools.javac;包下管理者java前端编译器的class文件，Main类中的main方法执行的是javac程序的执行入口。</li><li>同时在bin目录下可以看到很多脚本文件，比如java、javaw等</li></ul><h3 id="那这个-class文件又是什么呢？"><a href="#那这个-class文件又是什么呢？" class="headerlink" title="那这个.class文件又是什么呢？"></a>那这个.class文件又是什么呢？</h3><p>.class文件又称<strong>字节码文件</strong>，它就是java帮我们进行的第一道翻译工作后的结果，这道翻译工作就是javac，可以理解为将源码编译为字节码，同时做一些词法，语法，语义上的检查，最后生成的.class文件供jvm运行。这一过程就叫<strong>编译</strong>，更准确的是称为<strong>前端编译</strong>。.class文件也就是<strong>前端编译</strong>产生的代码。</p><h3 id="前端编译："><a href="#前端编译：" class="headerlink" title="前端编译："></a>前端编译：</h3><p><img src="/category/HelloJava!/before.png" alt="Alt text"><br><strong>词法分析</strong>：词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，将字符序列转换为标记（token）序列的过程。这里的标记是一个字符串，是构成源代码的最小单位。在这个过程中，词法分析器还会对标记进行分类 。<br>词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。<br><strong>语法分析</strong>：语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述。<br><strong>将源代码中的字符流构造成抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方法。填充符号表： 符号表是一组符号地址和符号信息构成的表格。</strong><br><strong>注解处理器处理</strong>：我们平时使用的Java注解，本质就是用来对语法树做出修改，处理器的任务便是在编译是识别出这些注解同时修改抽象语法树。<br><strong>语义分析与字节码生成</strong>：<br>语义分析是编译过程的一个逻辑阶段， 语义分析的任务是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。<br>语义分析的一个重要部分就是类型检查。比如很多语言要求数组下标必须为整数，如果使用浮点数作为下标，编译器就必须报错。再比如，很多语言允许某些类型转换，称为自动类型转换。</p><ul><li>标注检查：语义分析的第一个步骤，用来检查包括诸如使用的变量是否已经声明、变量与赋值之间的数据类型是否能够匹配。其中有一个重要的步骤就是常量折叠<br>如：int a = 3 + 2， javap查看生成的class字节码，iconst指令向操作数栈中压入的是常量值5，这样在运行时期就不会CPU的运算量重新计算。</li><li>数据及控制流分析<br>用于检查诸如局部变量在使用前是否已经赋值，方法的每条路径上是否都有返回值，受查异常是否都被正常处理等问题。</li><li>解语法糖（desugar）<br>Java中我们经常使用的语法糖有泛型、自动装箱/拆箱、遍历循环、条件编译等.. 由于这些语法在运行时无法被识别，因此需要在编译阶段就将他们还原回简单的基础语法结构。</li><li>泛型<br>泛型的本质是参数化类型的应用，参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。<br>在Java中，泛型只在源码中存在，一旦经常编译，就会替换成原来的原生类型并且在相应的地方加上了强制类型转换代码。这一过程也叫做类型擦除</li><li>自动装箱/拆箱<br>基本类型自动装箱成包装类型，包装类型拆箱成基本类型，大多数Java程序员都已经了解。只是使用上有些地方需要注意，比方包装类型在使用“==”进行比较时，只有遇到算术运算时才会自动拆箱。</li><li>遍历循环<br>诸如 for(int i : list) {} 这样的loop循环在编译后都会转换成对数据结构iterator的调用</li><li>条件编译<br>对于if和常量搭配使用，在编译器发现不会执行到的语句块，将不会出现在编译之后的class文件当中</li><li>生成字节码class文件<br>在Compiler生成class文件时，不仅仅将前面步骤生成的信息转化成字节码，还会进行少量的代码添加和转换工作，如<init>和<clinit>就是在该阶段添加进class文件当中，如果Compiler发现代码中没有任何构造器，那么将会添加一个无参数的、访问性与当前类一致的构造器（也即经常所说的默认无参构造器）</clinit></init></li></ul><h3 id="后端编译"><a href="#后端编译" class="headerlink" title="后端编译"></a>后端编译</h3><p>在Java中，javac执行的结果就是得到一个字节码，而这个字节码其实就是一种中间代码。</p><p>然后得到的class文件并不能被机器所识别。这个时候就通过JVM来解释字节码，将其翻译成对应的机器指令，逐条读入，逐条解释执行，这是传统的JVM解释器的功能，为了解决这种效率问题，引入了JIT技术。（即使编译器）<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html" target="_blank" rel="noopener">深入浅出JIT编译</a></p><p>当JVM通过类加载器加载class文件里的字节码后，会通过解释器解释称汇编指令最终再转译成CPU可以识别的机器指令，解释器是软件来实现的，主要是为了实现同一份 Java 字节码可以在不同的硬件平台上运行，而将汇编指令转换成机器指令由硬件直接实现。<br><img src="/category/HelloJava!/later.png" alt="later"><br>从软件层面上， class 文件被加载进虚拟机后，类信息会存放在方法区，在实际运行的时候会执行方法区中的代码，在 JVM 中所有的线程共享堆内存和方法区，而每个线程有自己独立的 Java 方法栈，本地方法栈（面向 native 方法），PC寄存器（存放线程执行位置），当调用一个方法的时候， Java 虚拟机会在当前线程对应的方法栈中压入一个栈帧，用来存放 Java 字节码操作数以及局部变量，这个方法执行完会弹出栈帧，一个线程会连续执行多个方法，对应不同的栈帧的压入和弹出，压入栈帧后就是 JVM 解释执行的过程了。</p><p>JAVA程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p><p>HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。</p><p>当 JVM 执行代码时，它并不立即开始编译代码。首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。</p><p>在机器上，执行java -version命令就可以看到自己安装的JDK中JIT是哪种模式:<br><img src="/category/HelloJava!/javaversion.png" alt="-version"></p><h4 id="热点检测"><a href="#热点检测" class="headerlink" title="热点检测"></a>热点检测</h4><p>上面我们说过，要想触发JIT，首先需要识别出热点代码。目前主要的热点代码识别方式是热点探测（Hot Spot Detection），有以下两种：</p><ol><li>基于采样的方式探测（Sample Based Hot Spot Detection) ：周期性检测各个线程的栈顶，发现某个方法经常出险在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因干扰热点探测。</li><li>基于计数器的热点探测（Counter Based Hot Spot Detection)。采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。<br>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。<br>方法计数器。顾名思义，就是记录一个方法被调用次数的计数器。<br>回边计数器。是记录方法中的for或者while的运行次数的计数器。</li></ol><h4 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h4><p>前面提到过，JIT除了具有缓存的功能外，还会对代码做各种优化。说到这里，不得不佩服HotSpot的开发者，他们在JIT中对于代码优化真的算是面面俱到了。</p><p><strong>经过前端编译与后端编译，最终我们的java文件被机器所执行。</strong></p><h2 id="JDK、JRE与JVM："><a href="#JDK、JRE与JVM：" class="headerlink" title="JDK、JRE与JVM："></a>JDK、JRE与JVM：</h2><p><img src="/category/HelloJava!/jdk.png" alt="JDK"></p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>Java Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。<br>最主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了属于自己的JDK。<br>JDK有以下三种版本：<br>J2SE， standard edition，标准版，是我们通常用的一个版本<br>J2EE， enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序<br>J2ME，micro edtion，主要用于移动设备、嵌入式设备上的java应用程序</p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>Java Runtime Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>我们刚生成的.class文件就是通过jvm来编译执行<br>Java Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的组成包括 JVM 指令集，符号表以及一些补助信息。</p><h2 id="至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。"><a href="#至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。" class="headerlink" title="至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。"></a>至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 16 2019 09:52:47 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;gt-HelloJava&quot;&gt;&lt;a href=&quot;#gt-HelloJava&quot; class=&quot;headerlink&quot; title=&quot;-&amp;g
      
    
    </summary>
    
      <category term="Java入门" scheme="https://www.ysmjjsy.com/categories/Java%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Java学习入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-基础语法</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-基础语法/</id>
    <published>2017-08-16T13:33:02.000Z</published>
    <updated>2019-08-16T01:44:15.551Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 16 2019 09:44:21 GMT+0800 (GMT+08:00) --><h1 id="JavaSE-基础语法"><a href="#JavaSE-基础语法" class="headerlink" title="JavaSE-基础语法"></a>JavaSE-基础语法</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>被Java语言赋予特定含义的单词</p><p>特点：全部小写，goto和const作为保留字存在</p><div class="table-container"><table><thead><tr><th style="text-align:center">abstract</th><th style="text-align:center">assert</th><th style="text-align:center">boolean</th><th style="text-align:center">break</th><th style="text-align:center">byte</th></tr></thead><tbody><tr><td style="text-align:center"><strong>case</strong></td><td style="text-align:center"><strong>catch</strong></td><td style="text-align:center"><strong>char</strong></td><td style="text-align:center"><strong>class</strong></td><td style="text-align:center"><strong>const</strong></td></tr><tr><td style="text-align:center"><strong>continue</strong></td><td style="text-align:center"><strong>default</strong></td><td style="text-align:center"><strong>do</strong></td><td style="text-align:center"><strong>double</strong></td><td style="text-align:center"><strong>else</strong></td></tr><tr><td style="text-align:center"><strong>enum</strong></td><td style="text-align:center"><strong>extends</strong></td><td style="text-align:center"><strong>final</strong></td><td style="text-align:center"><strong>finally</strong></td><td style="text-align:center"><strong>float</strong></td></tr><tr><td style="text-align:center"><strong>for</strong></td><td style="text-align:center"><strong>goto</strong></td><td style="text-align:center"><strong>if</strong></td><td style="text-align:center"><strong>implements</strong></td><td style="text-align:center"><strong>import</strong></td></tr><tr><td style="text-align:center"><strong>instanceof</strong></td><td style="text-align:center"><strong>int</strong></td><td style="text-align:center"><strong>interface</strong></td><td style="text-align:center"><strong>long</strong></td><td style="text-align:center"><strong>native</strong></td></tr><tr><td style="text-align:center"><strong>new</strong></td><td style="text-align:center"><strong>package</strong></td><td style="text-align:center"><strong>private</strong></td><td style="text-align:center"><strong>protected</strong></td><td style="text-align:center"><strong>public</strong></td></tr><tr><td style="text-align:center"><strong>return</strong></td><td style="text-align:center"><strong>strictfp</strong></td><td style="text-align:center"><strong>short</strong></td><td style="text-align:center"><strong>static</strong></td><td style="text-align:center"><strong>super</strong></td></tr><tr><td style="text-align:center"><strong>switch</strong></td><td style="text-align:center"><strong>synchronized</strong></td><td style="text-align:center"><strong>this</strong></td><td style="text-align:center"><strong>throw</strong></td><td style="text-align:center"><strong>throws</strong></td></tr><tr><td style="text-align:center"><strong>transient</strong></td><td style="text-align:center"><strong>try</strong></td><td style="text-align:center"><strong>void</strong></td><td style="text-align:center"><strong>volatile</strong></td><td style="text-align:center"><strong>while</strong></td></tr></tbody></table></div><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>给类、接口、方法、变量等起名的字符序列</p><p>组成规则：数字、字母、下划线和$（见名知意），不能以数字开头，不能是java中的关键字，区分大小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> size01 = <span class="number">25.0F</span>;</span><br><span class="line"><span class="keyword">double</span> size_02 = <span class="number">30.23</span>;</span><br><span class="line"><span class="keyword">char</span> size$<span class="number">03</span> = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>在程序执行过程中，其值不发生改变的量，常量在编译阶段会存入到调用这个常量的方法所在类的常量池中。并且调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。</p><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><p>“a”、”hello”、等双引号括起来的常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><h4 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h4><p>1、2、123等数值类型常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="小数常量"><a href="#小数常量" class="headerlink" title="小数常量"></a>小数常量</h4><p>12.345等小数形式常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">12.32F</span>;</span><br></pre></td></tr></table></figure><h4 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h4><p>‘a’、’A’、’0’等用单引号括起来的常量</p><p>可与是英文字母、数字、标点符号以及由转义序列来表示的特殊字符。’\u0000’表示一个空白字符，即在单引号之间没有任何字符，之所以能这样表示，是因为Java采用Unicode字符集，Unicode字符以\u开头，空白字符在Unicode码表中对应的值为’\u0000’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">'A'</span>;</span><br></pre></td></tr></table></figure><h4 id="布尔常量"><a href="#布尔常量" class="headerlink" title="布尔常量"></a>布尔常量</h4><p>只有两种值类型的常量：true/false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="自定义常量"><a href="#自定义常量" class="headerlink" title="自定义常量"></a>自定义常量</h3><p>利用关键字final指示常量，表示这个变量只能被赋值一次，且常量名建议使用全大写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量就是程序运行中可变的量，定义格式：数据类型 变量名 = 初始化值;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>在Java中，每一个变量属于一种数据类型，在生命变量时，变量所属的类型位于变量之前，变量就是指在程序执行过程中值在某个范围内可以发生改变的量。声明一个变量后，必须使用赋值语句对变量进行显示初始化，变量的声明尽可能靠近变量第一次使用的地方。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h3><p>Java种基本数据类型有4类8种</p><p>分别为：</p><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">0</td><td style="text-align:center">8bit == 1byte</td><td style="text-align:center">-128~127</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">0</td><td style="text-align:center">16bit == 2byte</td><td style="text-align:center">-32768~32767</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">0</td><td style="text-align:center">32bit == 4byte</td><td style="text-align:center">-2147483648~2147483647</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">0L</td><td style="text-align:center">64bit == 8byte</td><td style="text-align:center">-9223372036854775808~9223372036854775807</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">8L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b4 = <span class="number">3</span> + <span class="number">4</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里不报错是因为右边先进行计算，得到数值然后进行判断，是否在byte的范围内，</span></span><br><span class="line"><span class="comment">如果在就不报错，如果不在就报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//byte b5 = 100+150; 报错</span></span><br></pre></td></tr></table></figure><h4 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">0.0f</td><td style="text-align:center">32bit == 4byte</td><td style="text-align:center">1.4E-45~3.4028235E38</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">0.0</td><td style="text-align:center">64bit == 8byte</td><td style="text-align:center">4.9E-324~1.7976931348623157E308</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浮点数</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">4.0F</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//float f2 = 3.14; 报错</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以看到这里会报错，是因为在定义浮点类型数据的时候如果不加修饰符默认是double类型</span></span><br><span class="line"><span class="comment">当double赋值给float，大类型转小类型则会报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">float</span> f3 = <span class="number">3.1415F</span>;</span><br><span class="line"><span class="keyword">float</span> f4 = (<span class="keyword">float</span>) <span class="number">3.1415</span>; <span class="comment">//这里加了强制类型转换，所以也不报错</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">那f3、f4有什么区别吗？</span></span><br><span class="line"><span class="comment">f3定义的是一个float类型，f4最初定义的是一个double类型，然后强制转换成float类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">‘\u0000’</td><td style="text-align:center">16bit == 2byte</td><td style="text-align:center">0~6553</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符类型</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">布尔类型</td><td style="text-align:center">false</td><td style="text-align:center">8bit == 1byte</td><td style="text-align:center">true/false</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布尔类型</span></span><br><span class="line"><span class="keyword">boolean</span> bool = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>数据类型转换:(隐式转换)<br>byte、short、char —&gt; int —&gt; long —&gt; float —&gt; double<br>byte、short、char之间不参与相互转换，直接转换成int类型参与运算<br>强制类型转换:(强制转换)<br>格式:<br>目标数据类型 变量名 = (目标数据类型) (被转换的数据)<br>强制类型转换会损失精度。</p><h3 id="2、引用类型"><a href="#2、引用类型" class="headerlink" title="2、引用类型"></a>2、引用类型</h3><p>底层结构和基本类型差别较大</p><ul><li>类类型</li></ul><p>当传入的值是一个类类型时，需要传入的是该类的对象</p><ul><li>接口类型</li></ul><p>当传入值是一个接口类型时，需要传入的是该接口的实现类对象</p><ul><li>数组类型</li><li>枚举</li><li>注解</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>+、-、*、/、%、++、—</p><p>++在前，先自增再运算，++在后先运算再自增</p><p>—同理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span>；</span><br><span class="line">b = <span class="number">4</span>；</span><br><span class="line">b = a++;<span class="comment">//在这里，++在后，先赋值再自增</span></span><br><span class="line">System.out.println(<span class="string">"a: "</span>+ a+<span class="string">"b: "</span>+b);<span class="comment">//a = 4 , b = 4</span></span><br><span class="line">c = a;</span><br><span class="line">c = ++b;</span><br><span class="line">System.out.println(<span class="string">"b: "</span>+ b+<span class="string">"c: "</span>+c);<span class="comment">//b = 5 , c = 5</span></span><br><span class="line">d = c;</span><br><span class="line">d = --a + b--;</span><br><span class="line">System.out.println(<span class="string">"a: "</span>+ a+<span class="string">"b: "</span>+b+<span class="string">"d "</span>+d);<span class="comment">//a = 3 , b = 4 , d = 8</span></span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>=、+=、-=、*=、/=、%=</p><p>=代表赋值运算符，将右边的值赋给左边</p><p>在这里需要注意+=、-=、<em>=、/=、%=。这代表的是一个运算符，相对于+、-、</em>、/，如果在等号两边数据类型不一致时，+=会进行自动类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">2</span>;</span><br><span class="line">a = a + b; <span class="comment">//这里会报错，因为a和b是byte类型，执行完相加赋值给a时会自动转为int类型，而a是byte类型，就会出现类型不匹配问题这里相当于 a = (int) a + b;</span></span><br><span class="line">a += b; <span class="comment">//这里不会报错，+=在运算时会自动进行类型转换</span></span><br></pre></td></tr></table></figure><p><strong>总结：+ 、+=举例</strong></p><p>+：在编译将右边表达式结果计算出来后，和左边的变量类型比较精度，如果左边的精度低于右边的结果的精度，编译器会显式的报错，告诉程序员去强制转型。所以（a = a+b;）会报错，最后将表达式的结果复制到变量所在的内存区</p><p>+=：编译器自动隐式直接将+=运算符后面的操作数强制装换为前面变量的类型，然后在变量所在的内存区上直接根据右边的操作数修改左边变量内存存储的二进制数值所以 （a += b;）不报错最后达到和赋值运算符相同的目的。与前者相比，由于后者是位操作，效率也较前者高。</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>==、！=、&gt;、&lt;、&gt;=、&lt;=</p><p>==代表判断是否相等，比较运算符返回值都是boolean类型</p><p>在这里需要注意的是，==比较基本数据类型时比较的是值，比较引用类型时比较的是两个对象的地址值</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>&amp;、|、^、!、&amp;&amp;、||</p><p>逻辑运算符用来连接boolean类型的表达式</p><p>&amp;(逻辑与)：有false则false</p><p>|(逻辑或)：有true则true</p><p>^(异或)：相同则false，不同则true</p><p>!(非)：非true则false，非false则true</p><p>&amp;&amp;(短路与)：和&amp;相同，不过有短路效果，左边是false，右边不执行</p><p>||(短路或)：和|相同，有短路效果，左边是true，右边不执行</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>操作二进制</p><p>&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;、&amp;、|、^、~</p><ul><li>&lt;&lt;：左移，空位补0，被移除的最高位丢弃<ul><li>3 &lt;&lt; 2 = 12 ——- 3 <em>2 </em>2 = 12</li></ul></li><li>.&gt;&gt;：右移，被移位的二进制最高位是0，右移后，空缺位补0，最高位是1.最高位补1<ul><li>3 &gt;&gt; 1 = 1 ——- 3/2=1</li></ul></li><li>.&gt;&gt;&gt;：无符号右移，被移位二进制最高位无论是0或者是1，空缺位都用0补<ul><li>3 &gt;&gt;&gt; 1 = 1 ——- 3/2=1</li></ul></li><li>&amp;：与运算，任何二进制位和0进行&amp;运算，结果是0，和1进行&amp;运算结果是原值<ul><li>6&amp;3=2</li></ul></li><li>|：或运算，任何二进制位和0进行|运算，结果是原值，和1进行|运算结果是1<ul><li>6|3=7</li></ul></li><li>^：异或运算，任何相同二进制位进行^运算，结果是0，不相同二进制位^运算结果是1<ul><li>6^3=5</li><li>一个数据对另外一个数据异或两次，该数不变</li></ul></li><li>~：反码<ul><li>~6=-7</li></ul></li></ul><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>格式：比较表达式?表达式1:表达式2;</p><p>执行流程：首先计算比较表达式的值，是true就执行表达式1，是false就执行表达式2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">a &gt; b ? ++a : ++b;</span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>If(condition) statement</p><p>这里的条件必须用括号括起来</p><p>If(condition) statement1 else statement2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">    a++;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a == b)&#123;</span><br><span class="line">    a--;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    b++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>当条件是true时，while循环执行一条语句。</p><p>While(condition) statement</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"这是一个死循环"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><p>先执行语句，再检测循环条件</p><p>Do statement while (condition);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我数到第"</span>+n+<span class="string">"个数了"</span>);</span><br><span class="line">  &#125;<span class="keyword">while</span>(n&gt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="确定循环"><a href="#确定循环" class="headerlink" title="确定循环"></a>确定循环</h3><p>for(初始化语句;判断条件语句;控制条件语句){循环体语句;}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//九九乘法表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">9</span>; x++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= x; y++) &#123;</span><br><span class="line">    System.out.println(x + <span class="string">"*"</span> + y + <span class="string">"="</span> + x * y + <span class="string">"\t"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h4><p>Java有一种功能很强的循环结构，可以用来依次处理数组中的每个元素</p><p>for(variable: collection) statement</p><h3 id="多重选择"><a href="#多重选择" class="headerlink" title="多重选择"></a>多重选择</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Switch (chioce)<span class="comment">//这里可选择数据类型有：基本数据类型，引用类型String，以及枚举和基本类型的封装类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">…</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">…</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">defalut:</span><br><span class="line">…</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在这里简单说一下break、continue、return三者的区别？</strong></p><p><strong>break语句</strong>的使用场合主要是switch语句和循环结构。在循环结构中使用break语句，如果执行了break语句，那么就退出循环，接着执行循环结构下面的第一条语句。如果在多重嵌套循环中使用break语句，当执行break语句的时候，退出的是它所在的循环结构，对外层循环没有任何影响。如果循环结构里有switch语句，并且在switch语句中使用了break语句，当执行switch语句中的break语句时，仅退出switch语句，不会退出外面的循环结构。</p><p>break可以跳出单层循环，也可以跳出多层循环（需要标签语句配合）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"我数到第"</span>+n+<span class="string">"个数了"</span>);</span><br><span class="line">  <span class="keyword">break</span>;<span class="comment">//这里可以看到，break跳出do-while循环，接着执行while循环</span></span><br><span class="line">&#125;<span class="keyword">while</span>(n&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(n&lt;<span class="number">100</span>)&#123;</span><br><span class="line">  System.out.println(<span class="string">"这是一个循环"</span>);</span><br><span class="line">  n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我数到第1个数了</span></span><br><span class="line"><span class="comment">这是一个循环</span></span><br><span class="line"><span class="comment">这是一个循环</span></span><br><span class="line"><span class="comment">这是一个循环</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>continue语句</strong>是最特殊的，因为它并没有真的退出循环，而是只结束本次循环体的执行，所以在使用continue的时候要注意这一点。</p><p>在for循环中，首先执行表达式1（注意表达式1在整个循环中仅执行一次），接着执行表达式2，如果满足条件，那么执行循环体，如果在循环体中执行了continue语句，那么就跳转到表达式3处执行，接下进行下一次循环，执行表达式2，看是否满足条件；在while循环中，如果执行了continue语句，那么就直接跳转到表达式处，开始下一次的循环判断；在do while循环体中如果执行了continue语句，那么就跳转到表达式处进行下一次的循环判断，</p><p><strong>return语句</strong>，如果在程序中遇到return语句，那么代码就退出该函数的执行，返回到函数的调用处，如果是main()函数，那么结束整个程序的运行。</p><p><a href="https://www.infoq.cn/article/HPohK0NfIssFx41yO*e2" target="_blank" rel="noopener">JavaSE12扩展Switch语句</a></p><h2 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h2><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类:BigInteger和BigDecimal。前者实现了任意精度的整数运算，后者实现了任意精度的浮点数运算。</p><p>使用静态的valueOf方法可以将普通的数值转换为大数值</p><p>处理大数值用大数值类中的add和multiply方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a = BigInteger.valueOf(<span class="number">100</span>);</span><br><span class="line">BigInteger c = a.add(b);  <span class="comment">//c=a+b;</span></span><br><span class="line">BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="number">2</span>)));<span class="comment">//d=c*(b+2)</span></span><br></pre></td></tr></table></figure><ul><li>BigInteger：任意精度的整数运算</li></ul><ul><li>BigDecimal：任意精度的浮点数运算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 下面的方法都来自：java.math.BigInteger 包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">mod</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回这个大整数和另一个大整数 other 的和、差、积、商以及余数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 如果这个大整数与另一个大整数 other 相等，返回 0；</span></span></span><br><span class="line"><span class="function"><span class="comment">如果这个大整数小于另一个大整数 other，返回负数；否则，返回正数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigInteger <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回值等于 x 的大整数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">add</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">subtract</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">multiply</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">divide</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回这个大实数和另一个大实数 other 的和、差、积、商。</span></span></span><br><span class="line"><span class="function"><span class="comment">在此，需要注意的是：想要计算商，必须给出舍入方式，例如  RoundingModel.HALF_UP */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 如果这个大实数与另一个大实数 other 相等，返回 0；</span></span></span><br><span class="line"><span class="function"><span class="comment">如果这个大实数小于另一个大实数 other，返回负数；否则，返回正数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigDecimal <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigDecimal <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> scale)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回值等于 x 或者 x/10^(scale) 的大实数 */</span></span></span><br></pre></td></tr></table></figure><h2><a href="#" class="headerlink"></a></h2><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><p>进制也就是进位制，是人们规定的一种进位方法。<br>对于任何一种进制—-X进制，就表示某一位置上的数运算时是逢X进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x进制就是逢x进位。</p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p><img src="/category/JavaSE-基础语法/二进制.png" alt="二进制"></p><p>用8个这样的信号来表示一个数据，这个数据的单位叫做：字节</p><p>1 byte = 8 bit</p><p>1k = 1024byte</p><p>1m = 1024k</p><p>通过数字1,0来表示开关，这样由1,0组成的数据就是二进制数据</p><p>二进制数有两个特点：它由两个基本数字0，1组成，二进制数运算规律是逢二进一。</p><p>为区别于其它进制数，二进制数的书写通常在数的右下方注上基数2，或加后面加B表示。</p><p>例如：二进制数10110011可以写成（10110011）2，或写成10110011B</p><h3 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h3><p>把二进制的数据，从右开始，每三位一组合，最左边不够的时候，补0。然后分别计算出对应的十进制数值，最后，再把每个十进制数据组合起来，就是一个八进制数据。</p><p><img src="/category/JavaSE-基础语法/八进制.png" alt="八进制"></p><h3 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h3><p>人们通常使用的是十进制。它的特点有两个：有0，1，2….9十个基本数字组成，十进制数运算是按“逢十进一”的规则进行的.</p><h3 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h3><p>把二进制的数据从右开始，每四位一组合，最左边不够的时候补0.然后分别进算出对应的的十进制数值，最后，再把每个十进制数据组合起来，就是一个十六进制数据。</p><p><img src="/category/JavaSE-基础语法/十六进制.png" alt="十六进制"></p><h3 id="不同进制的组成"><a href="#不同进制的组成" class="headerlink" title="不同进制的组成"></a>不同进制的组成</h3><div class="table-container"><table><thead><tr><th><strong>二进制</strong></th><th><strong>由0,1组成，以0b开头</strong></th></tr></thead><tbody><tr><td><strong>八进制</strong></td><td><strong>由0,1…7组成，以0开头</strong></td></tr><tr><td><strong>十进制</strong></td><td><strong>由0,1…9组成，整数默认是十进制</strong></td></tr><tr><td><strong>十六进制</strong></td><td><strong>由0,1…9,a,b,c,d,e,f(大小均可)组成，以0x开头</strong></td></tr></tbody></table></div><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><h4 id="其他进制到十进制的转换"><a href="#其他进制到十进制的转换" class="headerlink" title="其他进制到十进制的转换"></a>其他进制到十进制的转换</h4><p><img src="/category/JavaSE-基础语法/toten.png" alt="十进制"></p><p><img src="/category/JavaSE-基础语法/twoten.png" alt="进制转换"></p><h4 id="十进制到其他进制的转换"><a href="#十进制到其他进制的转换" class="headerlink" title="十进制到其他进制的转换"></a>十进制到其他进制的转换</h4><p><img src="/category/JavaSE-基础语法/tento.png" alt="十进制"></p><h4 id="8421码（进制的快速转换）"><a href="#8421码（进制的快速转换）" class="headerlink" title="8421码（进制的快速转换）"></a>8421码（进制的快速转换）</h4><p><img src="/category/JavaSE-基础语法/8421.png" alt="8421"></p><h3 id="有符号数据表示"><a href="#有符号数据表示" class="headerlink" title="有符号数据表示"></a>有符号数据表示</h3><p>在计算机内，有符号数由3种表示法：原码、反码和补码。所有的数据的运算都是采用补码进行的。</p><ul><li><strong>原码</strong><ul><li>就是二进制定点表示法，即最高位为符号位，”0“表示正，”1“表示负，其余位表示数值大小。</li></ul></li><li><strong>反码</strong><ul><li>正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。</li></ul></li><li><strong>补码</strong><ul><li>正数的补码与其原码相同；负数的补码是在其反码的末位+1。</li></ul></li></ul><p><strong>+7、-7的原码反码补码表示：</strong></p><p><img src="/category/JavaSE-基础语法/71.png" alt="原码"></p><p><img src="/category/JavaSE-基础语法/72.png" alt="反码"></p><p><img src="/category/JavaSE-基础语法/73.png" alt="补码"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE基础语法
    
    </summary>
    
      <category term="JavaSE基础语法" scheme="https://www.ysmjjsy.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>HelloJava</title>
    <link href="https://www.ysmjjsy.com/category/HelloJava/"/>
    <id>https://www.ysmjjsy.com/category/HelloJava/</id>
    <published>2017-08-06T01:23:12.000Z</published>
    <updated>2019-08-06T01:29:36.159Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 06 2019 09:30:03 GMT+0800 (GMT+08:00) --><h1 id="gt-HelloJava"><a href="#gt-HelloJava" class="headerlink" title="-&gt;HelloJava!"></a>-&gt;HelloJava!</h1><blockquote><p>Goya：<br>Java是一门伟大的艺术，至少在我看来是的了，也许如果没有Java出现会出现别的类似编程语言，但是因为它的存在，促进了互联网的&gt;发展。<br>当我第一次接触Java是在初中，那时候有的塞班系统的手机上会出现一个Java的一些小游戏或者小应用，回忆中的样子应该是如此。<br>到了大学，大二开始学习Java知道了这门著名的编程语言。<br>那时候老师也不会将很多学习Java先要了解的一些知识，只是告诉你James Gosling发明了Java，并且在Sun公司，之后Sun被Oracle收购等等一些常识。然后便开始了Java语言的学习，那时候只知道按部就班的安装那些必备软件，然后开始敲。</p></blockquote><p>学习Java我认为首先需要了解一下什么是Java？它用来干什么？它怎么实现的？它发展是什么？<br>我想在这个大时代背景下，程序员，编程，代码几乎人人皆知。而退十年来讲，都是陌生的。<br>随着时代的发展，让这些一部分人知道的事务变成众人皆知的事务，这就是互联网的进步以及大时代的笼罩下造成的氛围。你离开了这些就仿佛一个原始人，这么说也许太片面，但离了这些产品那真的会回退一个时代。<br>很多人都说互联网时代已经告去，大数据人工智能时代来临并飞速发展，那么怎么来，靠什么发展。我想这就是为什么电子信息专业的火爆以及许多人认为的“高薪资”。</p><hr><h1 id="那什么是Java"><a href="#那什么是Java" class="headerlink" title="那什么是Java"></a>那什么是Java</h1><ul><li><p>在1990年代之前，比较熟知的C、C++、SQL等著名语言被开发</p></li><li><p>在1990年代，推动编程语言发展的思想则是“提升程序员的生产力”，出现了很多快速应用程序开发，这些语言大都有相应的集成开发环境，也大多是面向对象的编程语言。像Java、Python、Ruby、Visual Basic、JavaScript、PHP等。而Java的出现则更加保守。</p></li></ul><p>所以Java的产生可以理解为一门可以提高程序员生产力的语言。<br>而那时候的Java叫Oak，是为了服务家用电器等小型系统的编程语言。<br>但那时候这种智能化电器则不像现在般火爆。于是Sun便开始改造。</p><blockquote><p>摘自维基百科：<br>Java编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在Java SE 1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装/拆箱特性。Sun对Java语言的解释是：“Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”<br>Java不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了Java程序的运行效率。但在J2SE1.4.2发布后，Java的运行速度有了大幅提升。<br>与传统类型不同，Sun公司在推出Java时就将其作为开放的技术。全球的Java开发公司被要求所设计的Java软件必须相互兼容。“Java语言靠群体的力量而非公司的力量”是Sun公司的口号之一，并获得了广大软件开发商的认同。这与微软公司所倡导的注重精英和封闭式的模式完全不同，此外，微软公司后来推出了与之竞争的.NET平台以及模仿Java的C#语言。后来Sun公司被甲骨文公司并购，Java也随之成为甲骨文公司的产品。</p></blockquote><p>总结下来就是Java是一个面向对象的拥有“简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”这些特点的语言。并且是一门开源语言（开放源代码全世界人学习或者修改加入自己的想法，但是Sun公司拥有Java的一部分权力）</p><p>那么首先我们可以分析一下，什么是编程语言：</p><blockquote><p>编程语言是用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。</p></blockquote><p><strong>所以Java就是一门我们可以根据Java的语法规则写出来的代码，它来编译成计算机识别的指令来操作计算机或者其他设备的语言。</strong></p><h2 id="那么Java如何识别我们写的代码再编译成计算机识别的指令呢？"><a href="#那么Java如何识别我们写的代码再编译成计算机识别的指令呢？" class="headerlink" title="那么Java如何识别我们写的代码再编译成计算机识别的指令呢？"></a>那么Java如何识别我们写的代码再编译成计算机识别的指令呢？</h2><p>举一个例子：我们写一个<strong>HelloWorld.java</strong><br><em>这个时候可以不用纠结这些看不懂</em><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"HelloWorld!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后通过控制台执行javac<br><img src="/category/HelloJava/javac.png" alt="javac"></p><p>可以看到在HelloWorld.java同级目录生成一个.class文件<br><img src="/category/HelloJava/javaclass.png" alt="classlocation"></p><p>接着执行java命令<br><img src="/category/HelloJava/java.png" alt="java"></p><p>可以看到我们写的代码被计算机所解释编译执行，输出HelloWorld</p><h3 id="那么这个javac是什么呢？"><a href="#那么这个javac是什么呢？" class="headerlink" title="那么这个javac是什么呢？"></a>那么这个javac是什么呢？</h3><ul><li>当安装好jdk后可以在jdk安装目录bin文件夹下看到这个脚本。</li><li>它是用来编译java程序的源代码，但是它本质是基于jdk标准类库中的javac类库实现，所以java的编译器实质是一个java程序</li><li>javac又被称为前端编译器，仅负责源代码与字节码之间的转换，而在jvm内部还存在一个后置编译器（根据热点探测技术，可以将最有价值的字节码转换为机器码执行从而提升java程序的运行效率）</li><li>javac 的意义就在于 将源码编译为字节码，同时做一些词法，语法，语义上的检查，最后生成可供jvm运行的字节码文件。</li><li>可以在lib中的tools jar包中sun.tools.javac;包下管理者java前端编译器的class文件，Main类中的main方法执行的是javac程序的执行入口。</li><li>同时在bin目录下可以看到很多脚本文件，比如java、javaw等</li></ul><h3 id="那这个-class文件又是什么呢？"><a href="#那这个-class文件又是什么呢？" class="headerlink" title="那这个.class文件又是什么呢？"></a>那这个.class文件又是什么呢？</h3><p>.class文件又称<strong>字节码文件</strong>，它就是java帮我们进行的第一道翻译工作后的结果，这道翻译工作就是javac，可以理解为将源码编译为字节码，同时做一些词法，语法，语义上的检查，最后生成的.class文件供jvm运行。这一过程就叫<strong>编译</strong>，更准确的是称为<strong>前端编译</strong>。.class文件也就是<strong>前端编译</strong>产生的代码。</p><h3 id="前端编译："><a href="#前端编译：" class="headerlink" title="前端编译："></a>前端编译：</h3><p><img src="/category/HelloJava/before.png" alt="Alt text"><br><strong>词法分析</strong>：词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，将字符序列转换为标记（token）序列的过程。这里的标记是一个字符串，是构成源代码的最小单位。在这个过程中，词法分析器还会对标记进行分类 。<br>词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。<br><strong>语法分析</strong>：语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述。<br><strong>将源代码中的字符流构造成抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方法。填充符号表： 符号表是一组符号地址和符号信息构成的表格。</strong><br><strong>注解处理器处理</strong>：我们平时使用的Java注解，本质就是用来对语法树做出修改，处理器的任务便是在编译是识别出这些注解同时修改抽象语法树。<br><strong>语义分析与字节码生成</strong>：<br>语义分析是编译过程的一个逻辑阶段， 语义分析的任务是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。<br>语义分析的一个重要部分就是类型检查。比如很多语言要求数组下标必须为整数，如果使用浮点数作为下标，编译器就必须报错。再比如，很多语言允许某些类型转换，称为自动类型转换。</p><ul><li>标注检查：语义分析的第一个步骤，用来检查包括诸如使用的变量是否已经声明、变量与赋值之间的数据类型是否能够匹配。其中有一个重要的步骤就是常量折叠<br>如：int a = 3 + 2， javap查看生成的class字节码，iconst指令向操作数栈中压入的是常量值5，这样在运行时期就不会CPU的运算量重新计算。</li><li>数据及控制流分析<br>用于检查诸如局部变量在使用前是否已经赋值，方法的每条路径上是否都有返回值，受查异常是否都被正常处理等问题。</li><li>解语法糖（desugar）<br>Java中我们经常使用的语法糖有泛型、自动装箱/拆箱、遍历循环、条件编译等.. 由于这些语法在运行时无法被识别，因此需要在编译阶段就将他们还原回简单的基础语法结构。</li><li>泛型<br>泛型的本质是参数化类型的应用，参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。<br>在Java中，泛型只在源码中存在，一旦经常编译，就会替换成原来的原生类型并且在相应的地方加上了强制类型转换代码。这一过程也叫做类型擦除</li><li>自动装箱/拆箱<br>基本类型自动装箱成包装类型，包装类型拆箱成基本类型，大多数Java程序员都已经了解。只是使用上有些地方需要注意，比方包装类型在使用“==”进行比较时，只有遇到算术运算时才会自动拆箱。</li><li>遍历循环<br>诸如 for(int i : list) {} 这样的loop循环在编译后都会转换成对数据结构iterator的调用</li><li>条件编译<br>对于if和常量搭配使用，在编译器发现不会执行到的语句块，将不会出现在编译之后的class文件当中</li><li>生成字节码class文件<br>在Compiler生成class文件时，不仅仅将前面步骤生成的信息转化成字节码，还会进行少量的代码添加和转换工作，如<init>和<clinit>就是在该阶段添加进class文件当中，如果Compiler发现代码中没有任何构造器，那么将会添加一个无参数的、访问性与当前类一致的构造器（也即经常所说的默认无参构造器）</clinit></init></li></ul><h3 id="后端编译"><a href="#后端编译" class="headerlink" title="后端编译"></a>后端编译</h3><p>在Java中，javac执行的结果就是得到一个字节码，而这个字节码其实就是一种中间代码。</p><p>然后得到的class文件并不能被机器所识别。这个时候就通过JVM来解释字节码，将其翻译成对应的机器指令，逐条读入，逐条解释执行，这是传统的JVM解释器的功能，为了解决这种效率问题，引入了JIT技术。（即使编译器）<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html" target="_blank" rel="noopener">深入浅出JIT编译</a></p><p>当JVM通过类加载器加载class文件里的字节码后，会通过解释器解释称汇编指令最终再转译成CPU可以识别的机器指令，解释器是软件来实现的，主要是为了实现同一份 Java 字节码可以在不同的硬件平台上运行，而将汇编指令转换成机器指令由硬件直接实现。<br><img src="/category/HelloJava/later.png" alt="later"><br>从软件层面上， class 文件被加载进虚拟机后，类信息会存放在方法区，在实际运行的时候会执行方法区中的代码，在 JVM 中所有的线程共享堆内存和方法区，而每个线程有自己独立的 Java 方法栈，本地方法栈（面向 native 方法），PC寄存器（存放线程执行位置），当调用一个方法的时候， Java 虚拟机会在当前线程对应的方法栈中压入一个栈帧，用来存放 Java 字节码操作数以及局部变量，这个方法执行完会弹出栈帧，一个线程会连续执行多个方法，对应不同的栈帧的压入和弹出，压入栈帧后就是 JVM 解释执行的过程了。</p><p>JAVA程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p><p>HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。</p><p>当 JVM 执行代码时，它并不立即开始编译代码。首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。</p><p>在机器上，执行java -version命令就可以看到自己安装的JDK中JIT是哪种模式:<br><img src="/category/HelloJava/javaversion.png" alt="-version"></p><h4 id="热点检测"><a href="#热点检测" class="headerlink" title="热点检测"></a>热点检测</h4><p>上面我们说过，要想触发JIT，首先需要识别出热点代码。目前主要的热点代码识别方式是热点探测（Hot Spot Detection），有以下两种：</p><ol><li>基于采样的方式探测（Sample Based Hot Spot Detection) ：周期性检测各个线程的栈顶，发现某个方法经常出险在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因干扰热点探测。</li><li>基于计数器的热点探测（Counter Based Hot Spot Detection)。采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。<br>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。<br>方法计数器。顾名思义，就是记录一个方法被调用次数的计数器。<br>回边计数器。是记录方法中的for或者while的运行次数的计数器。</li></ol><h4 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h4><p>前面提到过，JIT除了具有缓存的功能外，还会对代码做各种优化。说到这里，不得不佩服HotSpot的开发者，他们在JIT中对于代码优化真的算是面面俱到了。</p><p><strong>经过前端编译与后端编译，最终我们的java文件被机器所执行。</strong></p><h2 id="JDK、JRE与JVM："><a href="#JDK、JRE与JVM：" class="headerlink" title="JDK、JRE与JVM："></a>JDK、JRE与JVM：</h2><p><img src="/category/HelloJava/jdk.png" alt="JDK"></p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>Java Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。<br>最主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了属于自己的JDK。<br>JDK有以下三种版本：<br>J2SE， standard edition，标准版，是我们通常用的一个版本<br>J2EE， enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序<br>J2ME，micro edtion，主要用于移动设备、嵌入式设备上的java应用程序</p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>Java Runtime Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>我们刚生成的.class文件就是通过jvm来编译执行<br>Java Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的组成包括 JVM 指令集，符号表以及一些补助信息。</p><h2 id="至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。"><a href="#至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。" class="headerlink" title="至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。"></a>至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Java入门
    
    </summary>
    
      <category term="Java入门" scheme="https://www.ysmjjsy.com/categories/Java%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
