<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余生梦见皆是缘</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ysmjjsy.com/"/>
  <updated>2019-09-12T06:42:15.877Z</updated>
  <id>https://www.ysmjjsy.com/</id>
  
  <author>
    <name>Goya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSE-网络编程</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-网络编程/</id>
    <published>2017-08-29T10:35:42.000Z</published>
    <updated>2019-09-12T06:42:15.877Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 12 2019 15:07:33 GMT+0800 (GMT+08:00) --><h1 id="网络编程概述"><a href="#网络编程概述" class="headerlink" title="网络编程概述"></a>网络编程概述</h1><p><strong>计算机网络</strong></p><p>是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议和协调下，实现资源共享和信息传递的计算机系统</p><p>计算机网络的主要功能：</p><p>资源共享</p><p>信息传输与集中处理</p><p>均衡负荷与分布处理</p><p>综合信息服务(www/综合业务数字网络 ISDN)</p><p><strong>网络编程</strong></p><p>就是用来实现网络互连的不同计算机上运行的程序间可以进行数据交换。Java语言对网络编程提供了良好的支持，通过其提供的接口我们可以很方便地进行网络编程</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="什么是网络"><a href="#什么是网络" class="headerlink" title="什么是网络"></a>什么是网络</h3><p><strong>网络是几乎可以实时相互发送和接收数据的计算机和其他设备的集合。</strong>网络通常用线缆连接，数据为转换为电磁波，通过线缆移动。不过，无线网络会通过无线电波传输数据，许多长距离的传输现在会用通过玻璃纤维发送可见光的光纤电缆来完成。</p><p>网络中的每台机器为一个节点（node）。大多数节点是计算机，但是打印机、路由器、网桥、网关、ATM机也都是节点。每个网络节点都有地址 (address)，这是用于唯一标识节点的一个字节序列。每个地址中的字节越多，可用的地址就越多，就可以有更多的设备同时连入网络。</p><p>不同的网络会以不同的方式分配地址。以太网（Ethernet）地址与物理以太网硬件关联。以太网硬件的生产厂家使用预分配的厂商编码确保他们的硬件地址或与其他厂家的硬件地址不冲突。每家厂商都要负责保证不会生产出两块地址相同的以太网卡。</p><p>所有现代计算机网络都是包交换（分组交换）网络：<strong>流经网络的数据分割成小块，称为包（packet,也称分组），每个包都单独加以处理。每个包都包含了由谁发送和将发往何处的信息。</strong></p><p>计算机来回传递数据时还有另一个重要的一个点，那就是协议，<strong>协议（protocol）是定义计算机如何通信的一组明确的规则：包括地址格式、数据如何分包等</strong>。针对网络通信的不同方面，定义有很多不同的协议。例如：Hypertext Transfer Protocol(HTTP)。</p><h3 id="网络通信协议及接口"><a href="#网络通信协议及接口" class="headerlink" title="网络通信协议及接口"></a>网络通信协议及接口</h3><p><strong>网络模型</strong></p><p>计算机网络之间以何种规则进行通信，就是网络模型研究问题</p><p>网络模型一般是指：</p><p>OSI(Open System Interconnection开放系统互连)参考模型</p><p>TCP/IP参考模型</p><p><strong>网络通信协议</strong></p><p>计算机网络中实现通信必须有一些约定，即通信协议；包括对速率，传输代码，代码结构，传输控制步骤，出错控制等制定的标准。</p><p>网络通信接口：</p><p>为了使两个节点之间能进行对话，必须在他们之间建立通信工具（即接口），使彼此之间，能进行信息交换。接口包括两部分：</p><ul><li>硬件装置：实现结点之间的信息传送</li><li>软件装置：规定双方进行通信的约定协议</li></ul><h3 id="通信协议分层思想"><a href="#通信协议分层思想" class="headerlink" title="通信协议分层思想"></a>通信协议分层思想</h3><p>通过网络发送数据是一项复杂的操作，必须仔细地协调网络的物理特性以及所发送数据的路基特征。为了对应用程序开发人员和最终用户隐藏这种复杂性，网络通信的不同方面被分解为多个层。每一层表示为物理硬件（即线缆和电流）与所传输信息之间的不同抽象层次。在理论上，每一层只与紧挨其上和其下的层对话。将网络分层，这样就可以修改甚至替换某一层的软件，只要层与层之间的接口保持不变，就不会影响到其他层。</p><p><strong>为什么要分层：</strong></p><p>由于结点之间联系很复杂，在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式就是层次方式，及同层间可以通信，上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。</p><p><strong>通信协议的分层规定：</strong></p><p>把用户应用程序作为最高层，把物理通信线路作为最底层，将其间的协议处理分为若干层，规定每层处理的任务，也规定每层的接口标准。</p><p><img src="/category/JavaSE-网络编程/w1.png" alt="wang"></p><p>上面的图显示了网络中可能存在的协议栈。</p><h4 id="四层分层"><a href="#四层分层" class="headerlink" title="四层分层"></a>四层分层</h4><p>有几种不同的分层模型，分别适合特定类型网络的需要。我这边主要介绍适用于Internet的标准TCP/IP四层模型，如下图所示：</p><p><img src="/category/JavaSE-网络编程/w2.png" alt="wang"></p><p><strong>主机网络层</strong></p><p>主机网络层定义了一个特定的网络接口（如以太网或WiFi天线）如何通过物理连接向本地网络或世界其他地方发送IP数据报。主机网络层中，由连接不同计算机的硬件（线缆、光纤电缆、无线电波或烟信号）组成的部分有时称为网络的物理层。Java程序员不需要担心这一层，除非出现了问题，比如插头从计算机后面掉了下来，或者有人挖断了你与外部世界之间的T-1线。换句话说，Java从来都看不到物理层。</p><p><strong>网际层</strong></p><p>网际层主机网络层的下一层，这也是作为Java程序员需要考虑的第一层，网际层协议定义了数据位和字节如何组织为更大的分组，称为包，还定义了寻址机制，不同计算机要按这个寻址机制查找对方。网际协议（IP）是世界上使用最广泛的网际层协议，也是Java唯一理解的网际层协议。</p><p>网际协议主要是两个协议：IPV4和IPV6，IPV4使用32位地址，IPV6使用128位地址，另外还增加了一些技术特性来帮助完成路由。这是两个完全不同的网络协议，如果没有特殊的网关/或隧道协议，即使在相同的网络上它们也无法做到互操作，不过Java几乎对你隐藏了所有这些区别。</p><p>除了路由和寻址，网际层的第二个作用是支持不同类型的主机网络层相互对话。Internet路由器会完成WiFi和Ethernet、Ethernet和DSL、DSL和光纤往返等协议之间的转换。如果没有网际层或类似的分层，则每个计算机只能与同一类网络上的其他计算机对话。网际层负责使用同够协议将异构网络相互连接。</p><p><strong>传输层</strong></p><p>原始数据报有一些缺点。最显著的缺点是不能保证可靠传送，即使能传送也可能在传输中遭到破坏。首部校验只能检测首部中的破坏情况，而不能检测数据报中的数据部分。最后即使数据报能到底目的地而未被破坏，也不一定会以发送时的顺序到达。</p><p>传输层（transport layer）负责确保各包以发送的顺序接收，并保证没有数据丢失或破坏。如果丢包，传输层会请求发送方重传这个包。为实现这个目标，IP网络会给每个数据报添加一个附加首部，其中包含有更多信息。</p><p>这一层上主要有两个协议。第一个是传输控制协议（Transmission Control Protocol，TCP），这是一个开销很高的协议，支持对丢失或破坏的数据进行重传，并按照发送时的顺序进行传送。第二个协议是用户数据报协议（User Datagram Protocol ，UDP），它允许接收方检测被破坏的包，但不保证这些包以正确的顺序传送（或者包有可能根本未传送）。但是，UDP通常比TCP快。TCP称为可靠（reliable）协议；UDP是不可靠（unreliable）协议。</p><p><strong>应用层</strong></p><p>向用户传送数据的层称为应用层（application layer）。它下面的三层共同定义了数据如何从一台计算机传输到另一台计算机。应用层确定了数据传输后的操作。有用户Web的HTTP，还有用户电子邮件的SMTP、POP、IMAP、；用于文件传输的FTP、FSP、TFTP，用于文件访问的NFS；用于文件共享的Gnutella和BitTorrent；用于语音通信的会话启动协议（Session Initiation Protocol，SIP）和Skype等。此外你的程序可以在必要时定义自己的应用层协议。</p><p><strong>IP、TCP、UDP</strong></p><p>IP设计为允许任意两点之间有多个路由，可以绕过被破坏的路由器实现数据包的路由。由于两点间存在多个路由，并且两点间的最短路径可能由于网络业务流量或其他因素而随时间改变，所以构成某个特定数据流的包可能不会采用相同的路由。另外，即使它们全部到达，也可能不会以发送的顺序到达。为了改进这种基本机制，将TCP置于IP之上，使连接的两端能够确认接收IP包，以及请求重传丢失或被破坏的包。此外，TCP允许接收端的包按发送时的顺序重新组合在一起。</p><p>不过，TCP会有很大的开销。因此，如果有些情况丢失个别包不会完全破坏数据的话，也可以使用UDP发送数据包，而不需要TCP提供保证。UDP是不可靠协议，它不能保证包一定会到达目的地，也不保证包会以发送时的相同顺序到达。但是它开销小，速度快，也可以在应用层的UDP数据流中建立纠错码，来解决数据丢失问题。</p><p>可以在IP之上运行很多其他协议。但是Java支持的协议只有TCP和UDP，以及建立在TCP和UDP之上的应用层协议。所有其他传输层、网际层和更底层的协议，如ICMP、IGMP、ARP、RARP、RSVP和其他洗衣在Java程序中都只能通过连接到原生代码来实现。</p><p><strong>IP地址和域名</strong></p><p>IPv4网络中的每台计算机都有一个4字节的数字标识。一般写为点分四段格式，如192.1.32.90，这4个数中，每个数都是一个无符号字节，范围从0到255。IPv4网络中的每台计算机都有一个唯一的4节地址。当数据通过网络传输时，包的首部会包括要发往的机器地址（目的地址）和发送这个包的机器地址（源地址）。沿路的路由器通过检查目的地址来选择发送数据包的最佳路由。包括源地址是为了让接收方知道要向谁回复。</p><p>虽然计算机可以轻松地处理数字，但人类对于记忆数字却不在行。因此开发了域名系统（Domain Name System，DNS）用来将人类易于记忆的主机名（如www.12345.com）转换为数字Internet地址（如208.201.243.99）。当Java程序访问网络时，他们需要同时处理数字地址和相应的主机名。这些方法由java.net.InetAddress类提供。</p><p><strong>端口</strong></p><p>如果每台计算机一次只做一件事情，那么地址可能就足够了。但是，现代计算机同时要做很多不同的事情。电子邮件需要与FTP请求分开，而FTP又要与Web业务流分开。这是通过端口（port）实现的。每台有IP地址的计算机都有几千个逻辑端口（确切地讲，每个传输层协议有65535个端口）。这些只是计算机内存中的抽象，不表示任何物理实物，与USB端口不同。每个端口由1到65535之间的一个数字标识。每个端口可以分配给一个特定的服务。</p><p><strong>防火墙</strong></p><p>Internet上有些顽皮的人。为了把他们关在门外，在本地网络建立一个访问点，检查所有进出该访问点的业务流通常很有用。位于Internet和本地网络之间的一些硬件和软件会检查所有进出的数据，以保证其合法性，这就称为防火墙（firewall）。防火墙通常是将本地网络连接到更大的Internet的路由器的一部分，还可以完成其他任务，如网络地址转换。此外，防火墙也可以是单独的机器。防火墙主要还是负责检查传入或传出其网络接口的各个包，根据一组规则接收或拒绝这些包。</p><p>过滤通常是基于网络地址和端口的。Java与防火墙没有太大关系，除非防火墙总是碍你事。</p><h4 id="七层模型"><a href="#七层模型" class="headerlink" title="七层模型"></a>七层模型</h4><p><img src="/category/JavaSE-网络编程/w4.png" alt="wang"></p><p><img src="/category/JavaSE-网络编程/w5.png" alt="wang"></p><p><img src="/category/JavaSE-网络编程/w6.png" alt="wang"></p><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP协议是网络层的主要协议，支持网间互连的数据报通信，它提供主要功能由：</p><ul><li>无连接数据报传送</li><li>数据报路由选择和差错控制</li></ul><p><img src="/category/JavaSE-网络编程/i1.png" alt="ip"></p><p><strong>IP地址</strong></p><p>每个人的电脑都有一个独一无二的IP地址，这样互相通信时就不会传错信息了。</p><p>IP地址是用一个点来分成四段的，在计算机内部IP地址是用四个字节来表示的，一个字节代表一段，每一个字节代表的数最大只能到达255。</p><p>要想让落网中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接受数据的计算机和识别发送的计算机，在TCP/IP协议中，这个标识号就是IP地址</p><p><img src="/category/JavaSE-网络编程/i2.png" alt="ip"></p><p><strong>IP地址的组成：网络号段+主机号段</strong></p><p>A类：第一号段为网络号段+后三段的主机号段</p><p>一个网络号：256<em>256</em>256=16777216</p><p>B类：前二号段为网络号段+后二段的主机号段</p><p>一个网络号：256*256=65536</p><p>C类：前三号段为网络号段+后一段的主机号段</p><p>一个网络号：256</p><p>IP地址的分类：</p><p>A类：1.0.0.1—-127.255.255.254—&gt;(1)10.x.x.x是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)</p><p>B类：128.0.0.1—-191.255.255.254 172.16.0.0—-172.31.255.255是私有地址。169.254.x.x是保留地址</p><p>C类：192.0.0.1—-223.255.255.254 192.168.x.x是私有地址</p><p>D类：224.0.0.1—-239.255.255.254</p><p>E类：240.0.0.1—-247.255.255.254</p><p><img src="/category/JavaSE-网络编程/i4.png" alt="ip"></p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p><strong>端口号</strong></p><p>物理端口：网卡口</p><p>逻辑端口：</p><ul><li>每个网络都会至少有一个逻辑端口</li><li>用于标识进程的逻辑地址，不同进程的标识</li><li>有效端口：0-65535，其中0-1024系统使用或保留端口</li></ul><p><strong>查看端口</strong></p><ul><li>用命令提示符cmd查看所有端口：netstat -ano</li><li>查看具体程序：使用任务管理器查看PID</li></ul><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p><strong>URI=URL+URN</strong></p><p>URI：Uniform Resource Identifier ，统一资源标志符。<br>URL：Uniform Resource Locator，统一资源定位符。<br>URN：Uniform Resource Name，统一资源命名。</p><p>网络三大基石：HTML，HTTP，URL</p><ul><li>在www上，每一信息资源都有统一且唯一的地址，即统一资源定位符。Uniform Resource Locator。<br>如：<a href="https://localhost:8080/index.html" target="_blank" rel="noopener">https://localhost:8080/index.html</a> ，有4部分组成。（协议，主机域名或IP，端口号，资源文件名）</li></ul><h4 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h4><p><strong>构造方法摘要</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">URL(String spec)</span><br><span class="line"><span class="comment">//根据 String 表示形式创建 URL 对象。</span></span><br><span class="line"></span><br><span class="line">URL(String protocol, String host, <span class="keyword">int</span> port, String file)</span><br><span class="line"><span class="comment">//根据指定 protocol、host、port 号和 file 创建 URL 对象。</span></span><br><span class="line"></span><br><span class="line">URL(String protocol, String host, String file)</span><br><span class="line"><span class="comment">//根据指定的 protocol 名称、host 名称和 file 名称创建 URL。</span></span><br></pre></td></tr></table></figure><p><strong>常用方法摘要</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getAuthority</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取此 URL 的授权部分。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取与此 URL 关联协议的默认端口号。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">getFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取此 URL 的文件名。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">getHost</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取此 URL 的主机名（如果适用）。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">getPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取此 URL 的路径部分。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取此 URL 的端口号。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">getUserInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取此 URL 的 userInfo 部分。</span></span></span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestURL</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        URL url2 = <span class="keyword">new</span> URL(<span class="string">"https://www.bilibili.com/"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取此的授权部分 URL 。</span></span><br><span class="line">        System.out.println(url2.getAuthority());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取此 URL的文件名。</span></span><br><span class="line">        System.out.println(url2.getFile());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取端口</span></span><br><span class="line">        System.out.println(url2.getPort());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取主机</span></span><br><span class="line">        System.out.println(url2.getHost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得默认端口</span></span><br><span class="line">        System.out.println(url2.getDefaultPort());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得路径</span></span><br><span class="line">        System.out.println(url2.getPath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取该 URL的userInfo部分。</span></span><br><span class="line">        System.out.println(url2.getUserInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP，超文本传输协议，英文全称是Hypertext Transfer Protocol，它是互联网上应用最为广泛的一种网络协议。HTTP是一种应用层协议，它是基于TCP协议之上的请求/响应式的协议，即一个客户端与服务器建立连接后，向服务器发送一个请求；服务器接到请求后，给予相应的响应信息。HTTP协议默认的端口号为80.</p><p>现在使用的HTTP协议是HTTP/1.1版本，1997年之前采用的是HTTP1.0版本。HTTP连接在1.0版本中采用非持续连接工作方式，1.1版本采用的是持续连接工作方式，持续连接是指服务器在发送响应后仍然在一段时间内保持这条由TCP运输层协议建立起来的连接，使客户机和服务器可以继续在这条连接上传输HTTP报文。</p><p>是否采用持续连接工作方式，1.0中默认是关闭的，需要在HTTP头加入”Connection:Keep-Alive”，才能启用Keep-Alive。HTTP1.1中默认启用Keep-Alive，如果加入”Connection:close”，才关闭。目前大部分浏览器都是用HTTP1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。</p><h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><p>HTTP协议是基于TCP协议之上的请求/响应式协议，下面主要介绍HTTP报文的格式，HTTP报文主要有请求报文和响应报文两种。首先看请求报文的格式：</p><p><img src="/category/JavaSE-网络编程/h1.png" alt="http"></p><p>HTTP请求报文由请求行、首部行和实体主体组成，由浏览器发送给服务器。上面这张图中SP表示空格，cr lf表示回车和换行。</p><p><img src="/category/JavaSE-网络编程/h2.png" alt="http"></p><p>上面这张图是HTTP响应报文，它由状态行、首部行和实体主体组成。下面两张图是在谷歌浏览器内访问服务器查看的HTTP请求和响应。</p><p><img src="/category/JavaSE-网络编程/h3.png" alt="http"></p><p><img src="/category/JavaSE-网络编程/h4.png" alt="http"></p><h4 id="HTTP请求方法和响应状态码"><a href="#HTTP请求方法和响应状态码" class="headerlink" title="HTTP请求方法和响应状态码"></a>HTTP请求方法和响应状态码</h4><p>在上面的HTTP请求报文例子中，我们可以看到请求方法是GET，这表示请求读取由URL所标志的信息，除了GET，还有其它几种常用的方法。</p><p><img src="/category/JavaSE-网络编程/h5.png" alt="http"></p><p>在HTTP响应报文的例子中，我们可以看到状态码是200，表示响应成功。下表是其它状态码，总共5大类，33种。</p><p><img src="/category/JavaSE-网络编程/h6.png" alt="http"></p><h4 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h4><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。</p><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。</p><p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><p>HTTPS和HTTP的区别主要为以下四点：1、https协议需要到ca申请证书，一般免费证书很少，需要交费。2、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="TCP协议与UDP协议"><a href="#TCP协议与UDP协议" class="headerlink" title="TCP协议与UDP协议"></a>TCP协议与UDP协议</h3><h4 id="UDP："><a href="#UDP：" class="headerlink" title="UDP："></a>UDP：</h4><p>UDP，用户数据报协议，英文全称是User Datagram Protocol，它是TCP/IP协议簇中无连接的运输层协议。</p><p>将数据源和目的封装成数据包中，不需要建立连接，每个数据报的大小在限制在64K，因无连接，是不可靠协议；不需要建立连接，速度快</p><h5 id="UDP协议格式"><a href="#UDP协议格式" class="headerlink" title="UDP协议格式"></a>UDP协议格式</h5><p><img src="/category/JavaSE-网络编程/u1.png" alt="udp"></p><p>UDP格式</p><p>从图中可以看到，UDP协议十分简单，它由两部分组成：首部和数据。其中，首部仅有8个字节，包括源端口和目的端口，长度（UDP用于数据报的长度）、校验和。</p><h4 id="TCP："><a href="#TCP：" class="headerlink" title="TCP："></a>TCP：</h4><p>TCP（Transmission Control Protocol ，传输控制协议）是面向连接的传输层协议。TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。TCP协议采用字节流传输数据。</p><p>TCP建立连接，形成传输数据的通道，在连接中进行大数据量传输，通过三次握手完成连接，是可靠协议；必须建立连接，效率会低</p><h5 id="TCP报文段格式"><a href="#TCP报文段格式" class="headerlink" title="TCP报文段格式"></a>TCP报文段格式</h5><p>TCP报文段包括协议首部和数据两部分，协议首部的固定部分有20个字节，首部的固定部分后面是选项部分。</p><p><img src="/category/JavaSE-网络编程/t1.png" alt="tcp"></p><p><strong>下面是报文段首部各个字段的含义。</strong></p><ol><li>源端口号以及目的端口号，各占2个字节，端口是传输层和应用层的服务接口，用于寻找发送端和接收端的进程，一般来讲，通过端口号和IP地址，可以唯一确定一个TCP连接，在网络编程中，通常被称为一个socket接口。</li><li>序号，占4字节，用来标识从TCP发送端向TCP接收端发送的数据字节流。</li><li>确认序号，占4字节，包含发送确认的一端所期望收到的下一个序号，因此，确认序号应该是上次已经成功收到数据字节序号加1.</li><li>数据偏移，占4位，用于指出TCP首部长度，若不存在选项，则这个值为20字节，数据偏移的最大值为60字节。</li><li>保留字段占6位，暂时可忽略，值全为0</li><li>标志位<br>URG（紧急） : 为1时表明紧急指针字段有效<br>ACK（确认）：为1时表明确认号字段有效<br>PSH（推送）：为1时接收方应尽快将这个报文段交给应用层<br>RST（复位）：为1时表明TCP连接出现故障必须重建连接<br>SYN（同步）：在连接建立时用来同步序号<br>FIN （终止）： 为1时表明发送端数据发送完毕要求释放连接</li><li>接收窗口占2个字节，用于流量控制和拥塞控制，表示当前接收缓冲区的大小。在计算机网络中，通常是用接收方的接收能力的大小来控制发送方的数据发送量。TCP连接的一端根据缓冲区大小确定自己的接收窗口值，告诉对方，使对方可以确定发送数据的字节数。</li><li>校验和占2个字节，范围包括首部和数据两部分。</li><li>选项是可选的，默认情况是不选。</li></ol><h5 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h5><p>TCP是面向连接的协议，因此每个TCP连接都有3个阶段：连接建立、数据传送和连接释放。连接建立经历三个步骤，通常称为“三次握手”。</p><p>TCP三次握手过程如下：</p><p><img src="/category/JavaSE-网络编程/t2.png" alt="tcp"></p><ol><li>第一次握手<br>客户机发送连接请求报文段到服务器，并进入SYN_SENT状态，等待服务器确认。（SYN = 1,seq=x）</li><li>第二次握手<br>服务器收到连接请求报文，如果同意建立连接，向客户机发回确认报文段，并为该TCP连接分配TCP缓存和变量。(SYN=1,ACK=1,seq=y,ack=x+1)。</li><li>第三次握手<br>客户机收到服务器的确认报文段后，向服务器给出确认报文段，并且也要给该连接分配缓存和变量。此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。(ACK=1,seq=x+1,ack=y+1)。</li></ol><p><strong>TCP四次挥手过程如下：</strong></p><p><img src="/category/JavaSE-网络编程/e.png" alt="tcp"></p><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><ol><li>TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。</li><li>服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li><li>服务器关闭客户端的连接，发送一个FIN给客户端。</li><li>客户端发回ACK报文确认，并将确认序号设置为收到序号加1。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>TCP和UDP位于同一层，都是建立在IP层的基础之上。由于两台电脑之间有不同的IP地址，因此两台电脑就可以区分开来，也就可以互相通话了。通话一般有两种通话方式：第一种是TCP，第二种是UDP。TCP是可靠的连接，<strong>TCP就像打电话，需要先打通对方电话，等待对方有回应后才会跟对方继续说话，也就是一定要确认可以发信息以后才会把信息发出去。TCP上传任何东西都是可靠的，只要两台机器上建立起了连接，在本机上发送的数据就一定能传到对方的机器上，UDP就好比发电报，发出去就完事了，对方有没有接收到它都不管，所以UDP是不可靠的。</strong> TCP传送数据虽然可靠，但传送得比较慢，UDP传送数据不可靠，但是传送得快。</p><h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h3><p>此类表示互联网协议 (IP) 地址。</p><p>常用方法摘要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getAddress();</span><br><span class="line"><span class="comment">//返回此 InetAddress 对象的原始 IP 地址。</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> InetAddress <span class="title">getByName</span><span class="params">(String host)</span></span>;</span><br><span class="line"><span class="comment">//在给定主机名的情况下确定主机的 IP 地址。</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getHostAddress</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回 IP 地址字符串（以文本表现形式）。</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getHostName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取此 IP 地址的主机名。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> InetAddress <span class="title">getLocalHost</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回本地主机。</span></span><br></pre></td></tr></table></figure><p>127.0.0.1：本机地址，主要用于测试。别名：Localhost<br><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="comment">//InetAdress类表示IP地址</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取本机IP</span></span><br><span class="line">        InetAddress ip = InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(ip);</span><br><span class="line">        <span class="comment">//获得主机名</span></span><br><span class="line">        System.out.println(ip.getHostName());</span><br><span class="line">        <span class="comment">//获得IP地址</span></span><br><span class="line">        System.out.println(ip.getHostAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIP2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        InetAddress inetAddress = InetAddress.getByName(<span class="string">"www.baidu.com"</span>);</span><br><span class="line">        <span class="comment">// 获取此 IP 地址的主机名。</span></span><br><span class="line">        System.out.println(inetAddress.getHostName());</span><br><span class="line">        <span class="comment">//返回 IP 地址字符串（以文本表现形式）。</span></span><br><span class="line">        System.out.println(inetAddress.getHostAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>OSI参考模型的分为哪几层，每层的功能？<br>OSI，开放系统互连参考模型，它的7个层次自顶到下依次为应用层，表示层，会话层，传输层，网络层，数据链路层和物理层。各层的功能见文章开始。</li><li>TCP协议和UDP协议的区别？<br>TCP协议是传输控制协议，UDP协议是用户数据报协议，两者都是传输层的协议，主要区别在于前者是可靠的，面向连接的协议，后者是不可靠的，无连接的协议。其它的区别还有，TCP协议传输速度慢，UDP常用于一次性传输比较少量数据的网络应用。</li><li>TCP三次握手为什么不能是两次?<br>主要是防止两次握手情况下已经失效的连接请求报文段突然又传送到服务端而产生错误。例如，客户机A向服务器B发送TCP连接请求，第一个连接请求报文在网络的某个节点长时间滞留，A超时后认为报文丢失，于是再重传一次连接请求，B收到后建立连接。数据传输完毕后双方断开连接，而这时之前滞留的连接请求到达了服务端B，而B认为A又发来连接请求。如果两次握手建立连接，A并无连接请求，造成B的资源浪费。</li><li>HTTP请求的GET方法和POST方法的区别？<br>GET和POST是HTTP请求的两种方法，主要区别在于GET方法是请求读取由URL所标志的信息，POST是给服务器添加信息。<a href="http://kb.cnblogs.com/page/188928/" target="_blank" rel="noopener">点击查看更多</a></li><li>在浏览器中输入网址到显示出页面的整个过程？<br>(1) 输出包含域名的网址 (2) 浏览器向DNS请求解析域名对应的IP地址 (3) 域名系统DNS解析出域名对应的IP地址 (4) 浏览器与该服务器建立TCP连接 (5) 浏览器发送HTTP请求 (6) 服务器通过HTTP响应把页面文件发送给浏览器 (7) TCP连接释放 (8) 浏览器解释文件，并显示</li></ol><h3 id="InetSocketAddress类"><a href="#InetSocketAddress类" class="headerlink" title="InetSocketAddress类"></a>InetSocketAddress类</h3><p>此类实现 IP 套接字地址（IP 地址 + 端口号）</p><p><strong>构造方法摘要</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InetSocketAddress(InetAddress addr, <span class="keyword">int</span> port);</span><br><span class="line"><span class="comment">//根据 IP 地址和端口号创建套接字地址。</span></span><br><span class="line"></span><br><span class="line">InetSocketAddress(<span class="keyword">int</span> port);</span><br><span class="line"><span class="comment">//创建套接字地址，其中 IP 地址为通配符地址，端口号为指定值。</span></span><br><span class="line"></span><br><span class="line">InetSocketAddress(String hostname, <span class="keyword">int</span> port);</span><br><span class="line"><span class="comment">//根据主机名和端口号创建套接字地址。</span></span><br></pre></td></tr></table></figure><p><strong>常用方法摘要</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InetAddress <span class="title">getAddress</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取 InetAddress。</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getHostName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取 hostname。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取端口号。</span></span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8082</span>);</span><br><span class="line">        System.out.println(inetSocketAddress.getHostName());</span><br><span class="line">        <span class="comment">//获得InetSocketAddress的端口</span></span><br><span class="line">        System.out.println(inetSocketAddress.getPort());</span><br><span class="line">        System.out.println(inetSocketAddress.getHostString());</span><br><span class="line">        <span class="comment">//返回一个InetAddress对象（IP对象）</span></span><br><span class="line">        InetAddress address = inetSocketAddress.getAddress();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Socker编程"><a href="#Socker编程" class="headerlink" title="Socker编程"></a>Socker编程</h2><p>一般的网络编程都称为Socket编程，Socket的英文意思是“插座”。那么什么是Socket呢？简单地说，Socket，套接字，就是两台主机之间逻辑连接的端点。TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。Socket，本质上就是一组接口，是对TCP/IP协议的封装和应用(程序员层面上)。</p><p>Socket编程主要涉及到客户端和服务器端两个方面，首先是在服务器端创建一个服务器套接字(ServerSocket)，并把它附加到一个端口上，服务器从这个端口监听连接。端口号的范围是0到65536，但是0到1024是为特权服务保留的端口号，我们可以选择任意一个当前没有被其他进程使用的端口。</p><p>客户端请求与服务器进行连接的时候，根据服务器的域名或者IP地址，加上端口号，打开一个套接字。当服务器接受连接后，服务器和客户端之间的通信就像输入输出流一样进行操作。</p><p><img src="/category/JavaSE-网络编程/s.png" alt="socket"></p><h3 id="Socket使用范例"><a href="#Socket使用范例" class="headerlink" title="Socket使用范例"></a>Socket使用范例</h3><p><strong>服务器端ServerSocket</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerSocket</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">                ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">                <span class="comment">/*创建一个ServerSocket对象时往往会给它指定一个端口号</span></span><br><span class="line"><span class="comment">                指定端口号的意思是这个new出来的ServerSocket对象要使用的</span></span><br><span class="line"><span class="comment">                是哪一个端口号，通过哪一个端口号来监听客户端的连接</span></span><br><span class="line"><span class="comment">                因此指定一个端口号的意义就是为了告诉计算机ServerSocket对象</span></span><br><span class="line"><span class="comment">                在哪个地方监听客户端的连接*/</span></span><br><span class="line">                <span class="comment">/*服务器端接收客户端连接的请求是不间断地接收的，所以服务器端的</span></span><br><span class="line"><span class="comment">                编程一般都是死循环，永不休止地运行着。*/</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                            Socket s = ss.accept();</span><br><span class="line">                            <span class="comment">/*在服务器端调用accept()方法接受客户端的连接对象,accept()方法是</span></span><br><span class="line"><span class="comment">                            一个阻塞式方法，一直在傻傻地等待着是否有客户端申请连接上来</span></span><br><span class="line"><span class="comment">                            然后服务器端的Socket插座就和客户端的Socket插座建立了连接了*/</span></span><br><span class="line">                            <span class="comment">/*客户端能否连接上服务器端，取决于服务器端是否接受客户端的连接请求</span></span><br><span class="line"><span class="comment">                            如果接受了客户端的连接请求，那么在服务器端就安装上一个Socket插座</span></span><br><span class="line"><span class="comment">                            通过这个插座与连接上的客户端就可以建立连接，互相通信了*/</span></span><br><span class="line">                            System.out.println(<span class="string">"A Client Connected!"</span>);</span><br><span class="line">                            <span class="comment">/*使用InputStream流接收从客户端发送过来的信息，使用DataInputStream数据流处理接收到的信息*/</span></span><br><span class="line">                DataInputStream dis = <span class="keyword">new</span> DataInputStream(s.getInputStream());</span><br><span class="line">                            <span class="comment">/*使用readUTF(方法将接收到的信息全部读取出来，存储到变量str里面</span></span><br><span class="line"><span class="comment">                            readUTF()方法也是一个阻塞式方法，会傻傻地等待客户端发送信息过来，然后将接收到的信息读取出来</span></span><br><span class="line"><span class="comment">                            如果客户端不写东西过来，它就一直在服务器端傻傻地等待着，直到客户端写东西过来为止</span></span><br><span class="line"><span class="comment">                            堵塞式的方法效率往往是不高的,比如说一个客户端连接上来了，但是它迟迟不发送信息，</span></span><br><span class="line"><span class="comment">                            那么服务器端的程序就阻塞住了，这样另外一个客户端就连接不上来了，因为另外一个客户端要想连接</span></span><br><span class="line"><span class="comment">                            上服务器端，就必须得在服务器端调用accept()方法，可accept()方法必须得在下一次循环时才能够被</span></span><br><span class="line"><span class="comment">                            调用，现在服务器端的程序运行到调用readUTF()这个方法时就阻塞住了，它要等待着已经连接上来的</span></span><br><span class="line"><span class="comment">                            那个客户端发送信息过来后将信息读取出来，如果客户端一直不发信息到服务器端，那么readUTF()方法</span></span><br><span class="line"><span class="comment">                            就一直无法读取到信息，那么服务器端的程序会阻塞在这里，无法进行下次循环，这样其他的客户端就</span></span><br><span class="line"><span class="comment">                            无法连接到服务器端了*/</span></span><br><span class="line">                            String str = dis.readUTF();</span><br><span class="line">                            System.out.println(str);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>客户端Socket</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClientSocket</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">/*Client申请连接到Server端上*/</span></span><br><span class="line">        <span class="comment">/*连接上服务器端以后，就可以向服务器端输出信息和接收从服务器端返回的信息</span></span><br><span class="line"><span class="comment">        输出信息和接收返回信息都要使用流式的输入输出原理进行信息的处理*/</span></span><br><span class="line">        <span class="comment">/*这里是使用输出流OutputStream向服务器端输出信息*/</span></span><br><span class="line">        OutputStream os = s.getOutputStream();</span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(os);</span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);<span class="comment">/*客户端睡眠30秒后再向服务器端发送信息*/</span></span><br><span class="line">        dos.writeUTF(<span class="string">"Hello Server!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-网络编程/s2.png" alt="socket"></p><p>客户端通过端口6666向服务器端请求连接，服务器端接受客户端的连接请求以后，就在服务器端上安装一个Socket，然后让这个Socket与客户端的Socket连接，这样服务器端就可以与客户端互相通信了，当有另外一个客户端申请连接时，服务器端接受了以后，又会安装另外一个Socket与这个客户端的Socket进行连接。</p><h2 id="UDP与TCP协议编程"><a href="#UDP与TCP协议编程" class="headerlink" title="UDP与TCP协议编程"></a>UDP与TCP协议编程</h2><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p><strong>需求：</strong>完成在线咨询功能，学生和老师在线一对一交流</p><p><strong>分析：</strong></p><p>使用基于UDP协议的Socket网络编程实现<br>不需要利用IO流实现数据的传输<br>每个数据发送单元被统一封装成数据包的方式，发送方将数据包发送到网络中，数据包在网络中去寻找他的目的地，一切以包为中心。</p><p><strong>UDP基本概念：</strong></p><p>DatagramSocket：用于发送或接收数据包的套接字<br>DatagramPacket：数据包</p><ol><li>​</li></ol><p><strong>实现</strong></p><p>接收方</p><p><strong>流程：</strong></p><ol><li>创建发送端Socket对象</li><li>创建数据，并把数据打包</li><li>调用Socket对象的发送方法发送数据包</li><li>释放资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleOne</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.开放一个端口</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">5051</span>);</span><br><span class="line">        <span class="comment">//2.准备容器接收</span></span><br><span class="line">        <span class="keyword">byte</span>[] receiveBuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="comment">//3.等待包裹容器封包</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(receiveBuf,receiveBuf.length);</span><br><span class="line">        System.out.println(<span class="string">"等你包裹来。。。。"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//4.接收包裹</span></span><br><span class="line">            socket.receive(packet);</span><br><span class="line">            <span class="comment">//5.解析包裹</span></span><br><span class="line">            String receStr = <span class="keyword">new</span> String(packet.getData(),<span class="number">0</span>,packet.getLength());</span><br><span class="line">            System.out.println(<span class="string">"我收到了："</span>+receStr);</span><br><span class="line">            <span class="keyword">if</span> (receStr.equals(<span class="string">"exit"</span>))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送方</p><p><strong>流程：</strong></p><ol><li>创建发送端Socket对象</li><li>创建数据(接收容器)</li><li>调用Socket对象的接收方法接收数据</li><li>解析数据包，并显示在控制台</li><li>释放资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleTwo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.指定一个端口进行发送</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        <span class="comment">//2.指定一个IP</span></span><br><span class="line">        InetAddress addr = InetAddress.getByName(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">5051</span>;</span><br><span class="line">        <span class="comment">//3.准备一个小容器</span></span><br><span class="line">        <span class="keyword">byte</span>[] sendBuf;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.println(<span class="string">"你要发什么东西："</span>);</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            <span class="comment">//4.加入要放的数据</span></span><br><span class="line">            sendBuf = s.getBytes();</span><br><span class="line">            <span class="comment">//5.数据打包</span></span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(sendBuf,sendBuf.length,addr,port);</span><br><span class="line">            <span class="comment">//6.发送包</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">"exit"</span>))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//7.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UDP发送接收图解</p><p><img src="/category/JavaSE-网络编程/t.png" alt="udp"></p><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p><strong>需求：</strong>完成网络登录功能</p><p>用户输入用户名密码，服务器给出登录成功或失败的提示<br><strong>分析：</strong></p><p>使用基于TCP协议的Socket网络编程实现<br>TCP协议基于请求响应模式<br>在网络通讯中，第一次主动发起通讯的程序被作为客户端程序<br>第一次通讯中等待连接的程序被称作服务器程序<br>利用IO流实现数据的传输</p><p><strong>实现</strong></p><p>服务器<br><strong>流程</strong></p><ol><li>创建发送端的Socket对象</li><li>获取输出流，写数据</li><li>释放资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//服务器开启了一个监听端口</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">"开启了服务器"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//等待客户端连接</span></span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"有一个人连接过来了"</span>);</span><br><span class="line">            <span class="comment">//获得客户端输入的东西</span></span><br><span class="line">            InputStream inputStream = accept.getInputStream();</span><br><span class="line">            <span class="comment">//包装成DataInputStream流</span></span><br><span class="line">            DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(inputStream);</span><br><span class="line">            <span class="comment">//通过流流读取消息</span></span><br><span class="line">            String s = dataInputStream.readUTF();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><p><strong>流程</strong></p><ol><li>创建接收端的Socket对象</li><li>监听客户端连接，返回一个Socket对象</li><li>获取输入流，读取数据显示在控制台</li><li>释放资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建同一连接</span></span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">6666</span>);</span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(s.getOutputStream());</span><br><span class="line">        dos.writeUTF(<span class="string">"hello,world！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本博文参考于</p><p><a href="https://www.cnblogs.com/midiyu/p/7875574.html" target="_blank" rel="noopener">Java - 网络编程完全总结</a></p><p><a href="https://blog.csdn.net/allenfoxxxxx/article/details/90707505" target="_blank" rel="noopener">Java网络编程</a></p><p><a href="https://www.cnblogs.com/jimoer/p/9485668.html" target="_blank" rel="noopener">Java网络编程的基本网络概念</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE网络编程，UDP/TCP协议，Socket等
    
    </summary>
    
      <category term="JavaSE网络编程" scheme="https://www.ysmjjsy.com/categories/JavaSE%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-多线程</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-多线程/</id>
    <published>2017-08-27T16:00:00.000Z</published>
    <updated>2019-09-12T01:55:45.547Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 12 2019 09:57:18 GMT+0800 (GMT+08:00) --><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="多线程引入"><a href="#多线程引入" class="headerlink" title="多线程引入"></a>多线程引入</h2><p><img src="/category/JavaSE-多线程/duo.png" alt="多线程"></p><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p><strong>进程</strong></p><p>正在运行的程序，是系统进行资源分配和调用的独立单位</p><p>每一个进程都有它自己的内存空间和系统资源</p><p>通过任务管理器我们就看到了进程的存在</p><p>所有运行中的任务通常对应一个进程,当一个程序进入内存运行时,即变成一个进程.进程是处于运行过程中的程序,并且具有一定独立的功能,进程是系统进行资源分配和调度的一个独立单位.</p><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，即进程空间或（虚空间）。进程不依赖于线程而独立存在，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。</p><p>进程的特性: <strong>独立性</strong> 、<strong>动态性</strong></p><p><strong>并发性</strong>:多个进程可以在单个处理器上并发执行,多个进程之间不会相互影响.</p><p><strong>并发</strong>和<strong>并行</strong>的区别</p><p><strong>并行(parellel)</strong>指的是在同一时刻,有多条指令在多个处理器上同时被执行;</p><p><strong>并发</strong>指的是在同一时刻只能有一条指令执行,但多个进程指令被快速轮换执行,使得宏观上具有多个进程同时执行的结果.</p><p><strong>线程</strong></p><p>线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</p><p>是进程中的单个顺序控制流，是一条执行路径</p><p>一个进程如果只有一条执行路径，则称为单线程程序</p><p>一个进程如果由多条执行路径，则称为多线程程序</p><p><strong>总结</strong></p><p>进程在执行过程中拥有独立的内存单元，进程有独立的地址空间，而多个线程共享内存，从而极大地提高了程序的运行效率。</p><p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。</p><p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器,一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><p>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程包含以下内容：</p><ul><li>一个指向当前被执行指令的指令指针；</li><li>一个栈；</li><li>一个寄存器值的集合，定义了一部分描述正在执行线程的处理器状态的值</li><li>一个私有的数据区。</li></ul><p>我们使用Join()方法挂起当前线程，直到调用Join()方法的线程执行完毕。该方法还存在包含参数的重载版本，其中的参数用于指定等待线程结束的最长时间（即超时）所花费的毫秒数。如果线程中的工作在规定的超时时段内结束，该版本的Join()方法将返回一个布尔量True。</p><p>简而言之：</p><p>一个程序至少有一个进程，一个进程至少有一个线程。<br>线程的划分尺度小于进程，使得多进程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><p>在Java中，每次程序运行至少启动2个线程：一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个进程。</p><h2 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h2><p>多线程扩展了多进程的概念,使得同一进程可以同时并发处理多个任务.线程也被称为轻量级进程,线程时进程的执行单元.线程在程序中是独立的并发的执行流.当进程被初始化之后,主线程就被创建了.</p><p>线程是进程的组成部分,一个进程可以有多个线程,但一个线程必须有一个父进程.线程可以拥有自己的栈,自己的程序计数器和自己的局部变量,但不拥有系统资源,它与父进程的其他线程共享该进程所拥有的全部资源.因为多个线程共享父进程的所有资源,因此编程比较方便,但必须更加小心,需要<strong>确保线程不会妨碍到同一进程里的其他线程</strong>.</p><p><strong>线程是独立运行的,它并不知道进程中是否还有其他的线程存在</strong>.线程的执行是抢占式的:当前运行的线程在任何时候都可能被挂起,以便另一个线程可以运行.</p><p>一个线程可以创建和撤销另一个线程,同一个进程中的多个线程之间可以并发执行.</p><p>从逻辑角度来看,多线程存在于一个应用程序中,让一个应用程序可以有多个执行部分同时进行,但操作系统无须将多个线程看做多个独立的应用,对多线程实现调度和管理以及资源分配.线程的调度和管理由进程本身负责完成.</p><p>总结:</p><ol><li><strong>操作系统可以同时执行多个任务,每个任务就是进程</strong>;</li><li><strong>进程可以同时执行多个任务,每个任务就是线程</strong>.</li></ol><p>多线程的优势</p><ol><li><strong>进程</strong>之间不能共享内存,但<strong>线程之间共享内存很容易</strong></li><li>系统创建进程需要为该进程重新分配系统资源,但创建线程则代价小得多,因此使用多线程来实现多任务并发比多进程的效率高.</li><li>Java语言内置了多线程功能支持,而不是单纯地作为底层操作系统的调度方式,从而简化了Java的多线程编程.</li></ol><p>多线程的应用是很广泛的,比如一个浏览器必须能同时下载多个图片,一个web服务器必须能同时响应多个用户请求;Java虚拟机本身就在后台提供了一个超级线程来进行垃圾回收…..</p><h2 id="Java程序运行原理"><a href="#Java程序运行原理" class="headerlink" title="Java程序运行原理"></a>Java程序运行原理</h2><p>Java命令会启动Java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程，该进程会自动启动一个“主线程”，然后主线程去调用某个类的main方法，所以main方法运行在主线程中，在此之前的所有程序都是单线程的。</p><p><strong>JVM虚拟机的启动是单线程的还是多线程的？</strong></p><p>多线程的，原因是垃圾回收线程也要先启动，否则很容易出现内存溢出。现在的垃圾回收线程加上前面的主线程，最低启动了两个线程，所以jvm的启动是多线程的</p><p><strong>实现多线程的程序</strong></p><p>由于线程是依赖进程而存在的，所以我们应该先创建一个进程出来，而进程是由系统创建的，所以我们应该去调用系统功能创建一个进程。</p><p>Java是不能直接调用系统功能的，所以我们没有办法直接实现多线程程序，但是，Java可以去调用C/C++写好的程序来实现多线程程序，由C/C++去调用系统功能创建进程，然后由Java去调用这样的东西，然后提供一些类供我们使用，我们就可以实现多线程程序了。</p><h2 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h2><p>在Java中，“线程”指两件不同的事情：</p><ol><li>java.lang.Thread类的一个实例；</li><li>线程的执行。</li></ol><p>在 Java程序中，有两种方法创建线程：</p><p>一是对 Thread 类进行派生并覆盖 run方法；</p><p>二是通过实现Runnable接口创建。</p><p>使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义、实例化和启动新线程。</p><p>一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。</p><p>Java中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。</p><p>一个Java应用总是从main()方法开始运行，main()方法运行在一个线程内，他被称为主线程。</p><p>一旦创建一个新的线程，就产生一个新的调用栈。</p><p>线程总体分两类：用户线程和守候线程。</p><p>当所有用户线程执行完毕的时候，JVM自动关闭。但是守候线程却不独立于JVM，守候线程一般是由操作系统或者用户自己创建的。</p><h2 id="Java线程：创建与启动"><a href="#Java线程：创建与启动" class="headerlink" title="Java线程：创建与启动"></a>Java线程：创建与启动</h2><h3 id="定义线程"><a href="#定义线程" class="headerlink" title="定义线程"></a>定义线程</h3><ol><li>扩展java.lang.Thread类。</li></ol><p>通过继承Thread类创建线程类的具体步骤和具体代码如下：</p><p>• 定义一个继承Thread类的子类，并重写该类的run()方法；</p><p>• 创建Thread子类的实例，即创建了线程对象；</p><p>• 调用该线程对象的start()方法启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeThead</span> <span class="keyword">extends</span> <span class="title">Thraad</span>   </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>   </span>&#123; </span><br><span class="line">     <span class="comment">//do something here  </span></span><br><span class="line">    &#125;  </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"> SomeThread oneThread = <span class="keyword">new</span> SomeThread();   </span><br><span class="line">  步骤<span class="number">3</span>：启动线程：   </span><br><span class="line"> oneThread.start(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实现java.lang.Runnable接口。</li></ol><p>通过实现Runnable接口创建线程类的具体步骤和具体代码如下：</p><p>• 定义Runnable接口的实现类，并重写该接口的run()方法；</p><p>• 创建Runnable实现类的实例，并以此实例作为Thread的target对象，即该Thread对象才是真正的线程对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span>   </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>   </span>&#123; </span><br><span class="line">  <span class="comment">//do something here  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br><span class="line">Runnable oneRunnable = <span class="keyword">new</span> SomeRunnable();   </span><br><span class="line">Thread oneThread = <span class="keyword">new</span> Thread(oneRunnable);   </span><br><span class="line">oneThread.start();</span><br></pre></td></tr></table></figure><p>通过实现Runnable接口创建多线程时,Thread类的作用就是把run()方法包装成线程执行体.</p><p>可以看到<strong>两个子线程的i变量是连续的</strong>这是因为采用Runnable接口的方式创建的多个线程可以共享线程类的实例变量.是因为:程序创建的Runnable对象只是线程的target,而多个线程可以共享一个target,所以多个线程可以共享一个线程类(实际上应该是线程的target类)的实例变量.</p><ol><li>通过Callable和Future创建线程</li></ol><p>通过Callable和Future创建线程的具体步骤和具体代码如下：</p><p>• 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。<br>• 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>• 使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>• 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值其中，Callable接口(也只有一个方法)定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>   </span>&#123; </span><br><span class="line">  <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  步骤1：创建实现Callable接口的类SomeCallable(略);   </span></span><br><span class="line"><span class="comment">  步骤2：创建一个类对象： </span></span><br><span class="line"><span class="comment">      Callable oneCallable = new SomeCallable(); </span></span><br><span class="line"><span class="comment">  步骤3：由Callable创建一个FutureTask对象：   </span></span><br><span class="line"><span class="comment">    FutureTask oneTask = new FutureTask(oneCallable); </span></span><br><span class="line"><span class="comment">  注释： FutureTask是一个包装器，它通过接受Callable来创建，它同时实现了 Future和Runnable接口。 </span></span><br><span class="line"><span class="comment">  步骤4：由FutureTask创建一个Thread对象：   </span></span><br><span class="line"><span class="comment">    Thread oneThread = new Thread(oneTask);   </span></span><br><span class="line"><span class="comment">  步骤5：启动线程：  </span></span><br><span class="line"><span class="comment">    oneThread.start(); </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从Java5开始,Java提供了Callable接口,该接口可以理解为是Runnable接口的增强版,Callable接口提供了一个call()方法可以作为线程执行体,但call()方法比run()方法功能更强大,call()方法可以有返回值.call()方法可以声明抛出的异常.</p><p>但是Callable接口并不是Runnable接口的子接口,所以Callable对象不能直接作为Thread的target.而且call()方法还有一个返回值,call()方法并不是直接调用的,它是作为线程执行体被调用的.好在Java提供了Future接口来代表Callable接口里的Call()方法的返回值,并为Future接口提供了一个FutureTask实现类,该实现类既实现了Future接口,并实现了Runnable接口——可以作为Thread类的target.</p><p>在Future接口里定义了几个公共方法来控制它关联的Callable任务.</p><p>Callable接口有泛型限制,并且Callable接口里的泛型形参类型与call()方法返回值类型相同.而且Callable接口是函数式接口,可以用Lambda表达式创建Callable对象</p><p>创建并启动具有返回值的线程的步骤如下:</p><ol><li>创建Callable接口的实现类,并实现call()方法,该call()方法将作为线程执行体,且该call()方法有返回值,再创建Callable实现类的实例.</li><li>使用FutureTask类来包装Callable对象,该FutureTask对象封装了该Callable对象的call()方法的返回值</li><li>使用FutureTask对象作为Thread对象的target创建并启动新线程</li><li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值.</li></ol><h3 id="获取和设置线程名称"><a href="#获取和设置线程名称" class="headerlink" title="获取和设置线程名称"></a>获取和设置线程名称</h3><p><strong>获取线程对象的名称</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span>;<span class="comment">//获取线程的名称</span></span><br></pre></td></tr></table></figure><p>注：当实现Runnable接口时，获取线程应该是<strong>Thread.currentThread()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;<span class="comment">//返回当前正在执行的线程对象</span></span><br></pre></td></tr></table></figure><p><strong>设置线程对象的名称</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;<span class="comment">//设置线程名称</span></span><br></pre></td></tr></table></figure><p><strong>常见问题</strong></p><ol><li>线程的名字，一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是mian，非主线程的名字不确定。</li><li>线程都可以设置名字，也可以获取线程的名字，连主线程也不例外。</li><li>获取当前线程的对象的方法是：Thread.currentThread()；</li><li>在上面的代码中，只能保证：每个线程都将启动，每个线程都将运行直到完成。一系列线程以某种顺序启动并不意味着将按该顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。</li><li>当线程目标run()方法结束时该线程完成。</li><li>一旦线程启动，它就永远不能再重新启动。只有一个新的线程可以被启动，并且只能一次。一个可运行的线程或死线程可以被重新启动。</li><li>线程的调度是JVM的一部分，在一个CPU的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。</li><li>众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的。</li><li>尽管通常采用队列形式，但这是没有保障的。队列形式是指当一个线程完成“一轮”时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，它才能被再次选中。事实上，我们把它称为可运行池而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列而成一个一个队列的事实。</li><li>尽管我们没有无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。</li></ol><h3 id="创建线程的三种方式对比"><a href="#创建线程的三种方式对比" class="headerlink" title="创建线程的三种方式对比"></a>创建线程的三种方式对比</h3><p>采用实现Runnable,Callable接口的方式创建多线程的优缺点:</p><ol><li>线程类只是实现了Runnable接口或Callable接口,还可以继承其他类</li><li>多个线程可以共享同一个target对象,非常适合多个相同线程来处理同一份资源的情况,较好的体现了面向对象的思想</li><li>需要访问当前线程,则必须使用Thread.currentThread()方法</li></ol><p>采用继承Thread类的方式创建多线程的优缺点:</p><ol><li>因为该线程已经继承了Thread类,所以不能在继承其他父类</li><li>编写简单,如果需要访问当前线程,则无需使用Thread.currentThread()方法,直接使用this即可获得当前线程.</li></ol><h3 id="run-和start"><a href="#run-和start" class="headerlink" title="run()和start()"></a>run()和start()</h3><p>run()：仅仅是封装被线程执行的代码，直接调用时普通方法</p><p>start()：首先启动了线程，然后再由jvm去调用该线程的run()方法</p><p>注意:<strong>启动线程使用的是start()方法,而不是run()方法!永远都不要调用线程对象的run()方法!!!</strong>调用start()方法来启动线程,系统会把该run()方法当成线程来处理;如果直接调用线程对象的run()方法,系统会把线程对象当做普通对象来处理,而run()方法也是一个普通方法,而不是线程执行体.</p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="/category/JavaSE-多线程/duo2.png" alt="duo"></p><h3 id="1-新建状态"><a href="#1-新建状态" class="headerlink" title="1. 新建状态"></a>1. 新建状态</h3><p>​ 用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）。</p><p>注意：不能对已经启动的线程再次调用start()方法，否则会出现<a href="http://lib.csdn.net/base/17" target="_blank" rel="noopener">Java</a>.lang.IllegalThreadStateException异常。</p><h3 id="2-就绪状态"><a href="#2-就绪状态" class="headerlink" title="2. 就绪状态"></a>2. 就绪状态</h3><p>​ 处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。</p><p>提示：如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠一伙儿，转去执行子线程。</p><h3 id="3-运行状态"><a href="#3-运行状态" class="headerlink" title="3. 运行状态"></a>3. 运行状态</h3><p>​ 处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。<em>**</em></p><p>处于就绪状态的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。如果该线程失去了cpu资源，就会又从运行状态变为就绪状态。重新等待系统分配资源。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。</p><p>注： 当发生如下情况是，线程会从运行状态变为阻塞状态：</p><ol><li>线程调用sleep方法主动放弃所占用的系统资源</li><li>线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞</li><li>线程试图获得一个同步监视器，但更改同步监视器正被其他线程所持有</li><li>线程在等待某个通知（notify）</li><li>程序调用了线程的suspend方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。</li></ol><p>当线程的run()方法执行完，或者被强制性地终止，例如出现异常，或者调用了stop()、desyory()方法等等，就会从运行状态转变为死亡状态。</p><h3 id="4-阻塞状态"><a href="#4-阻塞状态" class="headerlink" title="4. 阻塞状态"></a>4. 阻塞状态</h3><ol><li>线程调用sleep()方法主动放弃所占用的处理器资源</li><li>线程调用了一个堵塞式IO方法,在该方法返回之前,该线程被堵塞</li><li>线程试图获得一个同步监视器,但该同步监视器正被其他线程所持有</li><li>线程在等待某个通知(notify)</li><li>线程调用了线程的suspend()方法将该线程挂起,这个方法容易引起死锁(要尽量避免!!!)<strong>已过时。*</strong>该方法已经遭到反对，因为它具有固有的死锁倾向。如果目标线程挂起时在保护关键系统资源的监视器上保持有锁，则在目标线程重新开始以前任何线程都不能访问该资源。如果重新开始目标线程的线程想在调用resume之前锁定该监视器，则会发生死锁。这类死锁通常会证明自己是“冻结”的进程。*</li></ol><p>如果当前线程被堵塞之后,其他线程就可以获得执行的机会,被堵塞的线程会在合适的时候重新进入<strong>就绪状态</strong>,注意是<strong>就绪状态而不是运行状态</strong>.被堵塞线程的堵塞解除后,必须重新等待线程调度器再次调用它.</p><p><strong>解除上面的堵塞</strong></p><ol><li>调用sleep()方法的线程经过了指定的时间</li><li>线程调用的堵塞式IO方法已经返回</li><li>线程成功地获得了试图取得的同步监视器</li><li>线程正在等待某个通知时,其他线程发出了一条通知</li><li>处于挂起状态的线程被调用了resume()恢复方法</li></ol><p><img src="/category/JavaSE-多线程/duo3.png" alt="duo"></p><p>线程状态转换图</p><p>不难看出,<strong>线程从堵塞状态进入就绪状态,无法直接进入运行状态</strong>.而就绪和运行状态之间的转换通常不受程序控制,而是由系统线程调度所决定,当处于就绪状态的线程获取到CPU的资源时,该线程进入运行状态;当处于运行状态的线程失去处理器资源时,该线程进入就绪状态. 有一个方法例外:可以<strong>调用yield()方法可以让运行状态的线程转入就绪状态</strong>.</p><h3 id="5-死亡状态"><a href="#5-死亡状态" class="headerlink" title="5. 死亡状态"></a>5. 死亡状态</h3><p>线程会以下列三种方式结束,结束后就处于死亡状态</p><ol><li>run()或call()方法执行完成,线程正常结束</li><li>线程抛出一个未捕获的Exception或Error</li><li>直接调用该线程的stop()方法来结束该线程——-该方法容易引起死锁(不推荐!!!)</li></ol><p>当主线程结束时,其他线程不受任何影响,并不会随之结束.一旦子线程启动起来,它就拥有和主线程相同的地位,它不会受主线程的影响</p><p>为了测试某个线程是否已经死亡,可以调用该对象的isAlive()方法,当线程处于<strong>就绪</strong>,<strong>运行</strong>,<strong>堵塞</strong>三种状态时,该方法返回true,当线程处于<strong>新建</strong>和<strong>死亡</strong>两种状态时,该方法将返回false</p><p><strong>不要对一个已经死亡的线程再调用start()方法来让它重新启动</strong>,死亡就是死亡,该线程将不可再次作为线程执行.<strong>如果依然对一个已经死亡的线程再次调用start()方法来启动该线程,将会引发IllegalThreadStateException异常</strong>,这表明处于死亡状态的线程已经无法再次运行了.</p><h2 id="线程管理-控制线程"><a href="#线程管理-控制线程" class="headerlink" title="线程管理/控制线程"></a>线程管理/控制线程</h2><h3 id="线程的调度及获取和设置线程优先级"><a href="#线程的调度及获取和设置线程优先级" class="headerlink" title="线程的调度及获取和设置线程优先级"></a>线程的调度及获取和设置线程优先级</h3><p>假如我们计算机只有一个cpu，那么cpu在某一个时刻只能执行一条指令，线程只有得到cpu时间片，也就是使用权，才可以执行指令，那么java是如何对线程进行调用的呢？</p><p>线程有两种调度模型：</p><p>时间调度模型和抢占式调度模型</p><p>时间调度模型：所有线程轮流使用cpu使用权，平均分配每个线程占用cpu的时间片</p><p><strong>抢占式调度和协作式调度策略</strong></p><p><strong>抢占式调度</strong>:线代桌面和服务器操作系统一般采取抢占式调度策略,系统会给每个可执行的线程一个小时间段来处理任务;当该时间段用完后,系统就会剥夺该线程所占用的资源,让其他线程获得执行的机会.在选择下一个进程的时候,系统会考虑线程的优先级</p><p><strong>协作式调度</strong>:小型设备如手机则采取协作式调度策略,只有当一个线程调用了它的sleep()或yeid()方法后才会放弃所占用的资源——-即必须由该线程主动放弃所占用的资源</p><p>Java使用的是抢占式调度模型</p><h4 id="设置和获取线程优先级"><a href="#设置和获取线程优先级" class="headerlink" title="设置和获取线程优先级"></a>设置和获取线程优先级</h4><p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级。</p><p>Thread类提供了setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级，其中setPriority方法的参数是一个整数，范围是1~·0之间，也可以使用Thread类提供的三个静态常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAX_PRIORITY   =<span class="number">10</span></span><br><span class="line">MIN_PRIORITY   =<span class="number">1</span></span><br><span class="line">NORM_PRIORITY   =<span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span></span>;<span class="comment">//返回线程对象的优先级</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span></span>;<span class="comment">//更改线程的优先级</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>线程默认的优先级是5</p><p>线程优先级范围是：1-10</p><p>线程优先级高仅仅表示线程获取的CPU时间片几率高，但是在次数比较多，或者多次运行的时候才能看到比较好的效果</p><p>虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p><h3 id="线程睡眠—sleep"><a href="#线程睡眠—sleep" class="headerlink" title="线程睡眠—sleep"></a>线程睡眠—sleep</h3><p>如果需要<strong>让当前正在执行的线程暂停一段时间,并进入堵塞状态,则可以通过调用Thread类的静态sleep()方法来实现</strong>.</p><p>sleep()方法有两种重载形式:</p><p>1.static void sleep(long millis):让当前正在执行的线程暂停millis毫秒,并进入堵塞状态</p><p>2.static void sleep(long millis,intnanos):让当前正在执行的线程暂停millis毫秒加nanos毫微秒,并进入堵塞状态(很少用)</p><p>当<strong>当前线程</strong>调用sleep()方法进入堵塞状态后,在其睡眠时间段内,该线程不会获得执行的机会,即使系统中没有其他可执行的线程,处于sleep()中的线程也不会执行,因此sleep()方法常用来<strong>暂停程序的执行</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName());  </span><br><span class="line">        MyThread myThread=<span class="keyword">new</span> MyThread();  </span><br><span class="line">        myThread.start();  </span><br><span class="line">        myThread.sleep(<span class="number">1000</span>);<span class="comment">//这里sleep的就是main线程，而非myThread线程  </span></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;  </span><br><span class="line">            System.out.println(<span class="string">"main"</span>+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程让步—yield"><a href="#线程让步—yield" class="headerlink" title="线程让步—yield"></a>线程让步—yield</h3><p>yeid()方法也是Thread类提供的一个静态方法,<strong>它也可以让当前正在执行的线程暂停,但它不会阻塞该线程,它只是让该线程转入就绪状态</strong>.<strong>yield()只是让当前线程暂停一下,让系统的线程调度器重新调度一次</strong>.完全可能的情况是:当某个线程调用了yield()方法暂停之后,线程调度器又将其调度出来重新执行.</p><p>当某个线程调用了yield()方法暂停之后,只有优先级与当前线程相同,或者<strong>优先级比当前线程更高</strong>的<strong>处于就绪状态</strong>的线程才会获得执行的机会.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"低级"</span>, <span class="number">1</span>).start();  </span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"中级"</span>, <span class="number">5</span>).start();  </span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"高级"</span>, <span class="number">10</span>).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, <span class="keyword">int</span> pro)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(name);<span class="comment">// 设置线程的名称  </span></span><br><span class="line">        <span class="keyword">this</span>.setPriority(pro);<span class="comment">// 设置优先级  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;  </span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"线程第"</span> + i + <span class="string">"次执行！"</span>);  </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>)  </span><br><span class="line">                Thread.yield();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sleep()和yield()方法的区别</strong></p><p>1.sleep()方法暂停当前线程后,会给其他线程机会,不会理会其他线程的优先级:但yield()方法只会给优先级相同,或优先级更高的线程执行机会</p><p>2.sleep()方法会使线程进入堵塞状态,知道经过堵塞时间才会转入就绪状态;而yield()不会将线程转入堵塞状态,它只是强调当前线程进入就绪状态.因此完全有可能某个线程调用yield()方法暂停之后,立即重新获得处理器资源而被执行</p><p>3.sleep()方法声明抛出了InterruptedException异常,所以调用sleep()方法时要么捕捉该异常,要么显式声明抛出该异常;而yield()方法则没有声明抛出任何异常</p><p>4.sleep()方法比yield()方法有更好的移植性,通常不建议用yield()方法来控制并发线程的执行.</p><h3 id="线程加入—join"><a href="#线程加入—join" class="headerlink" title="线程加入—join"></a>线程加入—join</h3><p>Thread提供了让一个线程等待另一个线程完成的方法———-join()方法.当某个执行流中调用其他线程的join()方法时,调用线程将被堵塞,<strong>直到被join()方法加入的join线程执行完为止</strong>.</p><p>比如下面程序中的mian线程即主线程,主线程中调用了其他线程(jt线程)的join()方法,此时调用线程(main线程)将被堵塞,直到被join()方法加入的join线程执行完毕为止.</p><p>join()方法通常由<strong>使用线程的程序调用</strong>,<strong>目的</strong>是:将大问题划分为许多小问题,每个小问题分配一个线程.当所有的小问题都得到解决处理后,再调用主线程来进一步操作.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="comment">// 提供一个有参数的构造器，用于设置该线程的名字</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JoinThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// 重写run()方法，定义线程执行体</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(inti =<span class="number">0</span>; i &lt;<span class="number">100</span>; i++ )&#123;</span><br><span class="line">      System.out.println(getName() +<span class="string">"  "</span>+ i);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="comment">// 启动子线程</span></span><br><span class="line">  newJoinThread(<span class="string">"新线程"</span>).start();</span><br><span class="line">  <span class="keyword">for</span>(inti =<span class="number">0</span>; i &lt;<span class="number">100</span>; i++ )&#123;</span><br><span class="line">    <span class="keyword">if</span>(i ==<span class="number">20</span>) &#123;      </span><br><span class="line">      JoinThread jt =<span class="keyword">new</span> JoinThread(<span class="string">"被Join的线程"</span>);</span><br><span class="line">      jt.start();</span><br><span class="line">      <span class="comment">// main线程调用了jt线程的join()方法，main线程</span></span><br><span class="line">      <span class="comment">// 必须等jt执行结束才会向下执行</span></span><br><span class="line">      jt.join();   </span><br><span class="line">    &#125;   </span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"  "</span>+ i);        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-多线程/cmd.png" alt="cmd"></p><p>上述代码中main线程中调用了jt线程的join()方法,main线程必须要等jt线程执行完毕之后才会向下执行</p><p>join()方法有如下三种重载的方法:</p><ol><li>join():等待被join的线程执行完成.</li><li>join(long millis):等待被join的线程的时间最长为millis毫秒.</li><li>join(long millis,int nanos):等待被join的线程的事件最长为millis毫秒加nanos毫微秒(这个方法很少用!!!)</li></ol><h3 id="后台-守护-线程"><a href="#后台-守护-线程" class="headerlink" title="后台(守护)线程"></a>后台(守护)线程</h3><p>有一种线程,它是在后台运行的,它的任务是为其他的线程提供服务的,这种线程称为后台线程(Daemon Thread).JVM的垃圾回收线程就是典型的后台线程.</p><p>后台线程的特征:<strong>如果所有的前台线程都死亡,后台线程自动死亡</strong>.</p><p>调用Thread对象的setDaemon(true)方法可将指定线程设置成后台线程.</p><p>守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。</p><p>守护线程的用途为：</p><p>​ • 守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。</p><p>​ • Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。</p><p>setDaemon方法的详细说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span></span>;</span><br><span class="line"><span class="comment">//将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。    </span></span><br><span class="line"><span class="comment">//该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。   </span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">// on - 如果为 true，则将该线程标记为守护线程。    </span></span><br><span class="line"><span class="comment">// 抛出：    </span></span><br><span class="line"><span class="comment">//IllegalThreadStateException - 如果该线程处于活动状态。    </span></span><br><span class="line"><span class="comment">//SecurityException - 如果当前线程无法修改该线程。</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong>JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台线程时候一定要注意这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="comment">// 定义后台线程的线程执行体与普通线程没有任何区别</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt;<span class="number">1000</span>; i++ )&#123;</span><br><span class="line">            System.out.println(getName() +<span class="string">"  "</span>+ i);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    DaemonThread t =<span class="keyword">new</span> DaemonThread();</span><br><span class="line">    <span class="comment">// 将此线程设置成后台线程</span></span><br><span class="line">    t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 启动后台线程</span></span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt;<span class="number">10</span>; i++ )&#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()  +<span class="string">"  "</span>+ i); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// -----程序执行到此处，前台线程（main线程）结束------</span></span><br><span class="line"><span class="comment">// 后台线程也应该随之结束</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-多线程/cmd2.png" alt="cmd"></p><p>本来该线程应该执行到i=999才会结束,但运行程序时不难发现该后台线程无法运行到999,因为当主线程也就是程序中唯一的前台线程运行结束后,JVM会主动退出,因而后台线程也就被结束了.</p><p>Thread类还提供了一个isDaemon()方法来判断当前线程是否为后台线程.</p><p>上面程序中:主线程默认是前台线程,t线程默认是后台线程.并不是所有的线程默认都是前台线程,有些线程默认就是后台线程—————-<strong>前台线程创建的子线程默认是前台线程,后台线程创建的子线程默认是后台线程</strong>.</p><p>前台线程死亡之后,JVM会通知后台线程死亡,<strong>但从它接收到指令到做出相应,需要一定时间</strong>(这也是为什么上图中:在main线程死亡之后Thread-0还进行了一会才死亡的原因).而且将某个线程设置为后台线程,必须要在该线程启动之前设置,即setDaemon(true)必须在start()方法之前调用,否则会引发IllegalThreadStateException异常</p><h3 id="正确结束线程"><a href="#正确结束线程" class="headerlink" title="正确结束线程"></a>正确结束线程</h3><p>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法：</p><p>​ • 正常执行完run方法，然后结束掉；</p><p>​ • 控制循环条件和判断条件的标识符来结束掉线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">boolean</span> next=<span class="keyword">true</span>;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">while</span> (next) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">10</span>)  </span><br><span class="line">                next=<span class="keyword">false</span>;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>由系统的线程调度具有一定的随机性造成的,不过即使程序偶然出现问题,那也是由于编程不当引起的.当多个线程来访问同一个数据时,很容易”偶然”出现安全性问题.</p><p>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>因为run()方法的方法体不具有同步安全性———程序中有两个并发线程在同一个对象;而且系统恰好在一个方法内执行线程切换,切换给另一个修改对象的线程,所以就出现了问题.就跟以前讲的文件并发访问,当有两个进程并发修改同一个文件时就有可能造成异常.</p><p>为了解决上述问题,Java引入了同步监视器来解决这个问题,使用同步监视器的通用方法就是同步代码块</p><p><strong>synchronized</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;<span class="comment">//括号里的obj就是同步监视器</span></span><br><span class="line">  ......<span class="comment">//此处的代码就是同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的含义是:在线程开始执行同步代码块之前,必须先获得对同步监视器的锁定.</p><p><strong>任何时刻只能有一个线程可以获得同步监视器的锁定,当同步代码块执行完成之后,该线程会释放该同步监视器的锁定</strong>.</p><p>同步监视器的目的:<strong>阻止两个线程对同一个共享资源进行并发访问</strong>,推介使用<strong>可能被并发访问的共享资源充当同步监视器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">// 模拟用户账户privateAccount account;</span></span><br><span class="line">  <span class="comment">// 当前取钱线程所希望取的钱数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> drawAmount;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrawThread</span><span class="params">(String name , Account account,<span class="keyword">double</span> drawAmount&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">super</span>(name)</span></span>;</span><br><span class="line">    <span class="keyword">this</span>.account = account;</span><br><span class="line">    <span class="keyword">this</span>.drawAmount = drawAmount;    </span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 当多条线程修改同一个共享数据时，将涉及数据安全问题。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 使用account作为同步监视器，任何线程进入下面同步代码块之前，</span></span><br><span class="line"><span class="comment">// 必须先获得对account账户的锁定——其他线程无法获得锁，也就无法修改它</span></span><br><span class="line"><span class="comment">// 这种做法符合：“加锁 → 修改 → 释放锁”的逻辑</span></span><br><span class="line">    <span class="keyword">synchronized</span>(account)&#123;</span><br><span class="line">      <span class="comment">// 账户余额大于取钱数目</span></span><br><span class="line">      <span class="keyword">if</span>(account.getBalance() &gt;= drawAmount)&#123;</span><br><span class="line">        <span class="comment">// 吐出钞票System.out.println(getName() +"取钱成功！吐出钞票:"+drawAmount);</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException ex)&#123;</span><br><span class="line">          ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 修改余额</span></span><br><span class="line">        account.setBalance(account.getBalance() - drawAmount);               </span><br><span class="line">        System.out.println(<span class="string">"\t余额为: "</span>+ account.getBalance());</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(getName() +<span class="string">"取钱失败！余额不足！"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同步代码块结束，该线程释放同步锁</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法符合”加锁—-修改—-释放锁”的逻辑,任何线程在修改指定资源之前,首先对该资源加锁,在加锁期间其他线程无法修改该资源,当线程修改完成后,该线程释放对该资源的锁定.</p><p>通过这种方式可以<strong>保证并发线程在同一时刻只有一个线程可以进入修改共享资源的代码区</strong>(也被称为临界区),所以<strong>同一时刻最多只有一个线程处于临界区内,从而保证了线程的安全性</strong>.</p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>Java多线程还提供了同步方法来和同步代码块相对应,使用synchronized字来修饰某个方法,该方法称为同步方法.对于synchronized关键字修饰的实例方法,无须显式指定同步监视器,同步方法的同步监视器是this,也就是调用该方法的对象.</p><p>通过同步方法可以非常方便的实现线程安全的类,线程安全的类具有如下特征:</p><p>1.该类的对象可以被多个线程安全地访问</p><p>2.每个线程调用该对象的任意方法之后都能得到正确结果</p><p>3.每个线程调用该对象的任意方法之后,该对象状态依然保持合理的状态</p><p>不可变类总是线程安全的,因为它的对象时不可变的;但<strong>可变对象需要额外的方法来保证其线程安全</strong>.</p><p>由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">  <span class="comment">// 封装账户编号、账户余额两个成员变量</span></span><br><span class="line">  <span class="keyword">private</span> String accountNo;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span></span>&#123;&#125;<span class="comment">// 构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo ,doublebalance)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">    <span class="keyword">this</span>.balance = balance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// accountNo的setter和getter方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountNo</span><span class="params">(String accountNo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getAccountNo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    returnthis.accountNo;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 因此账户余额不允许随便修改，所以只为balance提供getter方法，</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    returnthis.balance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 提供一个线程安全draw()方法来完成取钱操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> voidd <span class="title">raw</span><span class="params">(<span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 账户余额大于取钱数目</span></span><br><span class="line">    <span class="keyword">if</span>(balance &gt;= drawAmount)&#123;</span><br><span class="line">    <span class="comment">// 吐出钞票</span></span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">"取钱成功！吐出钞票:"</span>+ drawAmount);</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(InterruptedException ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 修改余额</span></span><br><span class="line">      balance -= drawAmount;</span><br><span class="line">      System.out.println(<span class="string">"\t余额为: "</span>+ balance);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() +<span class="string">"取钱失败！余额不足！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 下面两个方法根据accountNo来重写hashCode()和equals()方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accountNo.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>== obj)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(obj !=<span class="keyword">null</span>&amp;&amp; obj.getClass() == Account.class)&#123;</span><br><span class="line">      Account target =(Account)obj;</span><br><span class="line">      <span class="keyword">return</span> target.getAccountNo().equals(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了一个代表取钱的draw()方法,并使用synchronized关键字来修饰该方法,把该方法编程同步方法,该同步方法的同步监视器是this,对于同一个Account账户而言,任意时刻只能有一个线程获得对Account对象的锁定,然后进入draw()方法执行取钱操作——-这样也可以保证多个线程并发取钱的线程安全.</p><p>注意:<strong>synvhronized关键字可以修饰方法,可以修饰代码块,但不能修饰构造器,成员变量等等</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="comment">// 模拟用户账户</span></span><br><span class="line">  <span class="keyword">private</span> Account account;</span><br><span class="line">  <span class="comment">// 当前取钱线程所希望取的钱数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> drawAmount;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrawThread</span><span class="params">(String name,Account account,doubledrawAmount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.account = account;</span><br><span class="line">    <span class="keyword">this</span>.drawAmount = drawAmount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当多条线程修改同一个共享数据时，将涉及数据安全问题。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用account对象的draw方法来执行取钱</span></span><br><span class="line">    <span class="comment">// 同步方法的同步监视器是this，this代表调用draw()方法的对象。</span></span><br><span class="line">    <span class="comment">// 也就是说：线程进入draw()方法之前，必须先对account对象的加锁</span></span><br><span class="line">    account.draw(drawAmount);    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中,调用draw()方法的对象是account,多个线程并发修改同一份account之前,必须先对account对象加锁,这也符合”加锁—-修改—-释放锁”的逻辑</p><p>在上面的示例中,调用draw()方法的对象是account,多个线程并发修改同一份account之前,必须先对account对象加锁,这也符合”加锁—-修改—-释放锁”的逻辑</p><p><strong>面向对象中的一种流行的设计模式:</strong></p><p>DDD(领域驱动设计):这种方式认为每个类都应该是完备的领域对象,比如:Account代表用户账户,应该提供用户账户的相关方法;通过draw()方法来执行取钱操作(实际上还应该提供transfer()等方法来完成转账等操作),而不是直接将setBalance()方法暴露出来任人操作,这样才能保证Account对象的完整性和一致性.</p><p><strong>可变类的线程安全是以降低程序的运行效率作为代价的</strong>.</p><ol><li>不要堆线程安全类的所有方法进行同步,只对那些会改变竞争资源(竞争资源也就是共享资源)的方法进行同步.</li><li>可变类有两种运行环境:单线程环境和多线程环境,则应该为该可变类提供两种版本,即线程不安全版本和线程安全版本.在单线程环境中使用线程不安全版本以保证性能(StringBuilder);在多线程中使用线程安全的版本(StringBuffer)</li></ol><p><strong>释放同步监视器的锁定</strong></p><p>程序无须显式释放对同步监视器的锁定,线程会在如下几种情况下释放对同步监视器的锁定</p><ol><li>当前线程的同步方法,同步代码块执行结束</li><li>当前线程在同步代码块,同步方法中遇到break,return终止了代码块导致其异常结束</li><li>当前线程在同步代码块,同步方法中出现了未处理的Error和Exception</li><li>当前线程执行同步代码块和同步方法时,程序执行了同步监视器对象的wait()方法,当前线程暂停,并释放同步监视器</li></ol><p><strong>下面出现的情况,线程不会释放同步监视器</strong></p><ol><li>当前线程在执行同步代码块,同步方法时,程序调用了Thread.sleep(),Thread.yield()方法来暂停当前线程的执行,当前线程并不会释放同步监视器</li><li>线程在执行同步代码块时,其他线程调用了该线程的suspend()方法将该线程挂起,该线程不会释放同步监视器.程序应该尽量避免使用suspend()和resume()方法来控制线程.</li></ol><h3 id="使用特殊域变量-volatile-实现线程同步"><a href="#使用特殊域变量-volatile-实现线程同步" class="headerlink" title="使用特殊域变量(volatile)实现线程同步"></a>使用特殊域变量(volatile)实现线程同步</h3><p>• volatile关键字为域变量的访问提供了一种免锁机制；</p><p>• 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新；</p><p>• 因此每次使用该域就要重新计算，而不是使用寄存器中的值；</p><p>• volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。</p><blockquote><p>volatile关键字表示直接操内存池里的数据</p><p>不操作副本，直接操作原始空间</p><p>主要定义在属性上</p><p>无法描述同步处理，只是一种直接内存的处理，避免了副本的操作，而synchronize是实现同步的</p></blockquote><pre><code>public class SynchronizedThread {  class Bank {private volatile int account = 100;public int getAccount() {  return account;}/*** 用同步方法实现* * @param money*/public synchronized void save(int money) {  account += money;}/*** 用同步代码块实现* * @param money*/public void save1(int money) {  synchronized (this) {    account += money;  }}</code></pre><p>}<br>class NewThread implements Runnable {<br>private Bank bank;<br>public NewThread(Bank bank) {<br>this.bank = bank;<br>}<br>@Override<br>public void run() {<br>for (int i = 0; i &lt; 10; i++) {<br>// bank.save1(10);<br>bank.save(10);<br>System.out.println(i + “账户余额为：” +bank.getAccount());<br>}<br>}<br>}<br>/**</p><ul><li><p>建立线程，调用内部类<br>*/</p><pre><code>public void useThread() {</code></pre><p>Bank bank = new Bank();<br>NewThread new_thread = new NewThread(bank);<br>System.out.println(“线程1”);<br>Thread thread1 = new Thread(new_thread);<br>thread1.start();<br>System.out.println(“线程2”);<br>Thread thread2 = new Thread(new_thread);<br>thread2.start();<br>}</p><p>public static void main(String[] args) {<br>SynchronizedThread st = new SynchronizedThread();<br>st.useThread();<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**注：**多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用final域，有锁保护的域和volatile域可以避免非同步的问题。</span><br><span class="line"></span><br><span class="line">### 同步锁</span><br><span class="line"></span><br><span class="line">通过显式定义同步锁对象来实现同步-----同步锁对象由Lock对象充当.(这是一种更为强大的线程同步机制)</span><br><span class="line"></span><br><span class="line">Lock是控制多个线程对共享资源进行访问的工具,每次只能有一个线程对Lock对象加锁,程序开始访问共享资源之前首先要先获得Lock对象</span><br><span class="line"></span><br><span class="line">某些锁可能允许对共享资源并发访问,如ReadWriteLock(读写锁);</span><br><span class="line"></span><br><span class="line">Lock,ReadWriteLock是Java5提供的两个根接口,并为Lock提供了ReentrantLock(可重入锁)实现类,为ReadWriteLock提供了ReentrantReadWriteLock实现类</span><br><span class="line"></span><br><span class="line">ReentrantReadWriteLock为读写提供了三种锁模式:Writing,ReadingOptimistic,Reading</span><br><span class="line"></span><br><span class="line">在实现线程安全的控制中比较常用的是ReentrantLock(可重入锁).使用该Lock对象可以显式地释放锁,加锁.</span><br><span class="line"></span><br><span class="line">在[Java](http://www.2cto.com/kf/ware/Java/)SE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。ReenreantLock类的常用方法有：    </span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line"> ReentrantLock();// 创建一个ReentrantLock实例         </span><br><span class="line"> lock();//获得锁        </span><br><span class="line"> unlock();//释放锁</span><br></pre></td></tr></table></figure></li></ul><p><strong>注：</strong>ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只给出要修改的代码，其余代码与上同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> account = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">//需要声明这个锁</span></span><br><span class="line">  <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> account;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这里不再需要synchronized </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      account += money;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">  <span class="comment">// 定义锁对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">//.......</span></span><br><span class="line">  <span class="comment">// 提供一个线程安全draw()方法来完成取钱操作(定义一个保证线程安全的方法)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(doubledrawAmount)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">// 账户余额大于取钱数目</span></span><br><span class="line">      <span class="keyword">if</span>(balance &gt;= drawAmount)&#123;</span><br><span class="line">        <span class="comment">// 吐出钞票</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">"取钱成功！吐出钞票:"</span>+ drawAmount);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException ex)&#123;             </span><br><span class="line">          ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改余额balance -= drawAmount;</span></span><br><span class="line">        System.out.println(<span class="string">"\t余额为: "</span>+ balance);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()  +<span class="string">"取钱失败！余额不足！"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      <span class="comment">// 修改完成，释放锁</span></span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 下面两个方法根据accountNo来重写hashCode()和equals()方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accountNo.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>== obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(obj !=<span class="keyword">null</span>&amp;&amp; obj.getClass() == Account.class)&#123;</span><br><span class="line">      Account target = (Account)obj;</span><br><span class="line">      returntarget.getAccountNo().equals(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用ReentrantLock对象来进行同步,加锁和释放锁出现在不同的作用范围内时,通常建议使用finally块来确保在必要时释放锁.</p><p>程序中实现draw()方法时,进入方法开始执行后立即请求对ReentrantLock对象进行加锁,当执行完draw()方法的取钱逻辑后,程序使用finally块确保释放锁.</p><p>使用Lock时是显式调用Lock对象作为同步锁,而使用同步方法时系统隐式地使用当前对象作为同步监视器,同样都符合”加锁—-修改—-释放锁”的操作模式,而且Lock对象时每个Lock对象都对应一个Account对象,一样可以保证对于同一个Account对象,同一时刻只能有一个线程能进入临界区</p><p>ReentrantLock锁具有可重入性,一个线程可以对已加锁的ReentrantLock锁再次加锁,ReentrantLock对象会维持一个计数器来追踪lock()方法的嵌套使用,线程在每次调用lock()方法加锁后,必须显式调用unlock()方法来释放锁,所以一段被锁保护的代码可以调用另一个被相同锁保护的方法.</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p><strong>当两个线程互相等待对方释放同步监视器时就会发生死锁</strong>.</p><p>产生死锁的四个必要条件如下。当下边的四个条件都满足时即产生死锁，即任意一个条件不满足既不会产生死锁。</p><ul><li>互斥条件：资源不能被共享，只能被同一个进程使用</li><li>请求与保持条件：已经得到资源的进程可以申请新的资源</li><li>非剥夺条件：已经分配的资源不能从相应的进程中被强制剥夺</li><li>循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程占用的资源</li></ul><p>举个常见的死锁例子：进程A中包含资源A,进程B中包含资源B，A的下一步需要资源B，B的下一步需要资源A，所以它们就互相等待对方占有的资源释放，所以也就产生了一个循环等待死锁。</p><p>Java没有提供任何检测措施来处理死锁的情况,所以多线程编程时应该尽量采取措施来避免死锁的出现.一旦出现死锁,整个程序既不会发生任何异常,也不会给出任何提示,只是所有线程处于堵塞状态,无法继续.</p><p><strong>处理死锁的方法</strong></p><ul><li>忽略该问题，也即鸵鸟算法。当发生了什么问题时，不管他，直接跳过，无视它；</li><li>检测死锁并恢复；</li><li>资源进行动态分配；</li><li>破除上面的四种死锁条件之一。</li></ul><p>死锁很容易发生,尤其是在系统中出现多个同步监视器的情况下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">classA &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">( B b )</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程名: "</span>+ Thread.currentThread().getName()+<span class="string">" 进入了A实例的foo()方法"</span>);</span><br><span class="line"><span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">try</span>&#123;  </span><br><span class="line">      Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException ex)&#123;</span><br><span class="line">      ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"当前线程名: "</span>+ Thread.currentThread().getName()+<span class="string">" 企图调用B实例的last()方法"</span>);</span><br><span class="line"><span class="comment">// ③</span></span><br><span class="line">    b.last();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"进入了A类的last()方法内部"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">classB &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">voidbar</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程名: "</span>+ Thread.currentThread().getName()+<span class="string">" 进入了B实例的bar()方法"</span>);</span><br><span class="line"><span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException ex)&#123;</span><br><span class="line">      ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"当前线程名: "</span>+ Thread.currentThread().getName()            +<span class="string">" 企图调用A实例的last()方法"</span>);</span><br><span class="line">    <span class="comment">// ④a.last();    </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"进入了B类的last()方法内部"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  A a =newA();</span><br><span class="line">  B b =newB();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread.currentThread().setName(<span class="string">"主线程"</span>);</span><br><span class="line">    <span class="comment">// 调用a对象的foo方法a.foo(b);</span></span><br><span class="line">    System.out.println(<span class="string">"进入了主线程之后"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread.currentThread().setName(<span class="string">"副线程"</span>);</span><br><span class="line">    <span class="comment">// 调用b对象的bar方法b.bar(a);</span></span><br><span class="line">    System.out.println(<span class="string">"进入了副线程之后"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    DeadLock dl =newDeadLock();</span><br><span class="line">    <span class="comment">// 以dl为target启动新线程</span></span><br><span class="line">    newThread(dl).start();</span><br><span class="line">    <span class="comment">// 调用init()方法</span></span><br><span class="line">    dl.init();   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread类的suspend()方法也容易导致死锁,Java不推介使用该方法来暂停线程的执行.</p><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>程序通常无法准确控制线程的轮换执行,但Java也提供了一些机制来保证线程协调运行.</p><p>传统的线程通信</p><p>Object类提供的三个方法(这三个方法必须由<strong>同步监视器对象</strong>来调用):</p><p><strong>同步监视器对象可以分为下列两种情况:</strong></p><p>1.使用synchronized修饰的同步方法,该类的默认实例(this)就是同步监视器.</p><p>2.使用synchronized修饰的同步代码块,同步监视器是synchronized后括号里的<strong>对象</strong></p><p><strong>这三个方法解释如下:</strong></p><p>wait():导致当前线程等待,直到其它线程调用该同步监视器的notify()方法或notifyAll()方法来唤醒该线程.调用wait()方法的当前线程会释放对该同步监视器的锁定.</p><p>notify():唤醒此同步监视器上等待的单个线程.只有当前线程放弃对该同步监视器的锁定后(使用wait()方法),才可以执行被唤醒的线程.</p><p>notifyAll():唤醒在此同步监视器上等待的所有线程.只有当前线程放弃对该同步监视器的锁定后,才可以执行被唤醒的线程.</p><p><strong>单个消费者生产者例子如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;  <span class="comment">//生产者和消费者都要操作的资源  </span></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(flag)  </span><br><span class="line">            <span class="keyword">try</span>&#123;wait();&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;  </span><br><span class="line">        <span class="keyword">this</span>.name=name+<span class="string">"---"</span>+count++;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者..."</span>+<span class="keyword">this</span>.name);  </span><br><span class="line">        flag=<span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">this</span>.notify();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(!flag)  </span><br><span class="line">            <span class="keyword">try</span>&#123;wait();&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者..."</span>+<span class="keyword">this</span>.name);  </span><br><span class="line">        flag=<span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">this</span>.notify();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Resource res;  </span><br><span class="line">    Producer(Resource res)&#123;  </span><br><span class="line">        <span class="keyword">this</span>.res=res;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </span><br><span class="line">            res.set(<span class="string">"商品"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Resource res;  </span><br><span class="line">    Consumer(Resource res)&#123;  </span><br><span class="line">        <span class="keyword">this</span>.res=res;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </span><br><span class="line">            res.out();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerDemo</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Resource r=<span class="keyword">new</span> Resource();  </span><br><span class="line">        Producer pro=<span class="keyword">new</span> Producer(r);  </span><br><span class="line">        Consumer con=<span class="keyword">new</span> Consumer(r);  </span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(pro);  </span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(con);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;<span class="comment">//运行结果正常，生产者生产一个商品，紧接着消费者消费一个商品。</span></span><br></pre></td></tr></table></figure><p>但是如果有多个生产者和多个消费者，上面的代码是有问题，比如2个生产者，2个消费者，运行结果就可能出现生产的1个商品生产了一次而被消费了2次，或者连续生产2个商品而只有1个被消费，这是因为此时共有4个线程在操作Resource对象r, 而notify()唤醒的是线程池中第1个wait()的线程，所以生产者执行notify()时，唤醒的线程有可能是另1个生产者线程，这个生产者线程从wait()中醒来后不会再判断flag，而是直接向下运行打印出一个新的商品，这样就出现了连续生产2个商品。<br><strong>为了避免这种情况，修改代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> String name;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name)</span></span>&#123;  </span><br><span class="line">            <span class="keyword">while</span>(flag) <span class="comment">/*原先是if,现在改成while，这样生产者线程从冻结状态醒来时，还会再判断flag.*/</span>  </span><br><span class="line">                <span class="keyword">try</span>&#123;wait();&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;  </span><br><span class="line">            <span class="keyword">this</span>.name=name+<span class="string">"---"</span>+count++;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者..."</span>+<span class="keyword">this</span>.name);  </span><br><span class="line">            flag=<span class="keyword">true</span>;  </span><br><span class="line">            <span class="keyword">this</span>.notifyAll();<span class="comment">/*原先是notity(), 现在改成notifyAll(),这样生产者线程生产完一个商品后可以将等待中的消费者线程唤醒，否则只将上面改成while后，可能出现所有生产者和消费者都在wait()的情况。*/</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;  </span><br><span class="line">            <span class="keyword">while</span>(!flag) <span class="comment">/*原先是if,现在改成while，这样消费者线程从冻结状态醒来时，还会再判断flag.*/</span>  </span><br><span class="line">                <span class="keyword">try</span>&#123;wait();&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者..."</span>+<span class="keyword">this</span>.name);  </span><br><span class="line">            flag=<span class="keyword">false</span>;  </span><br><span class="line">            <span class="keyword">this</span>.notifyAll(); <span class="comment">/*原先是notity(), 现在改成notifyAll(),这样消费者线程消费完一个商品后可以将等待中的生产者线程唤醒，否则只将上面改成while后，可能出现所有生产者和消费者都在wait()的情况。*/</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerDemo</span></span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">            Resource r=<span class="keyword">new</span> Resource();  </span><br><span class="line">            Producer pro=<span class="keyword">new</span> Producer(r);  </span><br><span class="line">            Consumer con=<span class="keyword">new</span> Consumer(r);  </span><br><span class="line">            Thread t1=<span class="keyword">new</span> Thread(pro);  </span><br><span class="line">            Thread t2=<span class="keyword">new</span> Thread(con);  </span><br><span class="line">            Thread t3=<span class="keyword">new</span> Thread(pro);  </span><br><span class="line">            Thread t4=<span class="keyword">new</span> Thread(con);  </span><br><span class="line">            t1.start();  </span><br><span class="line">            t2.start();  </span><br><span class="line">            t3.start();  </span><br><span class="line">            t4.start();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="使用Condition控制线程通信"><a href="#使用Condition控制线程通信" class="headerlink" title="使用Condition控制线程通信"></a>使用Condition控制线程通信</h3><p>如果程序使用Lock对象保证同步,则系统中不存在隐式地同步监视器,也就不能用wait(),notify(),notifyAll()方法进行线程通信了.</p><p>当使用Lock对象来保证同步时,Java提供了一个Condition类来保持协调,使用Conditon可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象,Conditon对象也可以唤醒其它处于等待的线程.</p><p>Conditon将同步监视器方法(wait(),notify(),notifyAll())分解成不同的对象,以便通过将这些对象和Lock对象组合使用,为每个对象提供多个等待集(wait-set).Lock替代了同步方法或同步代码块,Conditon替代了同步监视器的功能.</p><p>Conditon实例绑定在一个Lock对象上,要获得特定Lock实例的Conditon实例,调用Lock对象的newConditon()方法即可.</p><p><strong>Conditon类提供了如下三个方法:</strong></p><p>await():类似于隐式同步器上的wait()方法,导致当前线程等待,直到其它线程调用该Conditon的signal()方法或signalAll()方法来唤醒线程.</p><p>signal():唤醒在此Lock对象上等待的单个线程.只有当前线程放弃对该Lock对象的锁定后(使用await()方法),才可以执行被唤醒线程</p><p>signalAll():唤醒在此Lock对象上等待的所有线程.只有当前线程放弃对该Lock对象的锁定后(使用await()方法),才可以执行被唤醒线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> String name;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">/*Lock是一个接口，ReentrantLock是该接口的一个直接子类。*/</span>  </span><br><span class="line">        <span class="keyword">private</span> Condition condition_pro=lock.newCondition(); <span class="comment">/*创建代表生产者方面的Condition对象*/</span>  </span><br><span class="line">        <span class="keyword">private</span> Condition condition_con=lock.newCondition(); <span class="comment">/*使用同一个锁，创建代表消费者方面的Condition对象*/</span>  </span><br><span class="line">          </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name)</span></span>&#123;  </span><br><span class="line">            lock.lock();<span class="comment">//锁住此语句与lock.unlock()之间的代码  </span></span><br><span class="line">            <span class="keyword">try</span>&#123;  </span><br><span class="line">                <span class="keyword">while</span>(flag)  </span><br><span class="line">                    condition_pro.await(); <span class="comment">//生产者线程在conndition_pro对象上等待  </span></span><br><span class="line">                <span class="keyword">this</span>.name=name+<span class="string">"---"</span>+count++;  </span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者..."</span>+<span class="keyword">this</span>.name);  </span><br><span class="line">                flag=<span class="keyword">true</span>;  </span><br><span class="line">                 condition_con.signalAll();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">finally</span>&#123;  </span><br><span class="line">                lock.unlock(); <span class="comment">//unlock()要放在finally块中。  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;  </span><br><span class="line">            lock.lock(); <span class="comment">//锁住此语句与lock.unlock()之间的代码  </span></span><br><span class="line">            <span class="keyword">try</span>&#123;  </span><br><span class="line">                <span class="keyword">while</span>(!flag)  </span><br><span class="line">                    condition_con.await(); <span class="comment">//消费者线程在conndition_con对象上等待  </span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者..."</span>+<span class="keyword">this</span>.name);  </span><br><span class="line">            flag=<span class="keyword">false</span>;  </span><br><span class="line">            condition_pro.signqlAll(); <span class="comment">/*唤醒所有在condition_pro对象下等待的线程，也就是唤醒所有生产者线程*/</span>  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">finally</span>&#123;  </span><br><span class="line">                lock.unlock();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="使用堵塞队列-BlockingQueue-控制线程通信"><a href="#使用堵塞队列-BlockingQueue-控制线程通信" class="headerlink" title="使用堵塞队列(BlockingQueue)控制线程通信"></a>使用堵塞队列(BlockingQueue)控制线程通信</h3><p>Java5提供了一个BlockingQueue接口,虽然BlockingQueue也是Queue的子接口,但它的主要作用<strong>不是作为容器,而是作为线程同步的工具</strong>.</p><p>BlockingQueue具有一个特征:当生产者线程试图向BlockingQueue中放入元素时,如果该队列已满,则线程堵塞;当消费者线程试图从BlockingQueue中取出元素时,如果该队列已经已空,则该线程堵塞.</p><p>程序中两个线程通过交替向BlockingQueue中放入元素取出元素,即可实现控制线程通信.</p><p>BlockingQueue提供下面两个支持堵塞的方法:</p><ul><li>put(E e):尝试把e元素放入BlockingQueue中,如果该队列的元素已满,则堵塞线程</li><li>take():尝试从BlockingQueue的头部取出元素,如果该队列的元素已空,则堵塞该线程.</li></ul><p>BlockingQueue继承了Queue接口,当然也可以使用Queue接口中的方法</p><ul><li>在队列尾部插入元素:add(E e),offer(E e)和put(E e)方法,当该队列已满时,这三个方法分别抛出异常,返回false,堵塞队列.</li><li>在队列头部删除并返回删除的元素:remove(),poll(),和take()方法.当该队列已空时,这三个方法分别会抛出异常,返回false,堵塞队列.</li><li>在队列头部取出但不删除元素:包括element()和peek()方法,当队列已空时,这两个方法分别抛出异常,返回false.</li></ul><p>BlockingQueue包含如下5个实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue ：基于数组实现的BlockingQueue队列。</span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue：基于链表实现的BlockingQueue队列。</span><br><span class="line"></span><br><span class="line">PriorityBlockingQueue：它并不是保准的阻塞队列，该队列调用remove（）、poll（）、take（）等方法提取出元素时，并不是取出队列中存在时间最长的元素，而是队列中最小的元素。</span><br><span class="line">                       它判断元素的大小即可根据元素（实现Comparable接口）的本身大小来自然排序，也可使用Comparator进行定制排序。</span><br><span class="line"></span><br><span class="line">SynchronousQueue：同步队列。对该队列的存、取操作必须交替进行。</span><br><span class="line"></span><br><span class="line">DelayQueue：它是一个特殊的BlockingQueue，底层基于PriorityBlockingQueue实现，不过，DelayQueue要求集合元素都实现Delay接口（该接口里只有一个<span class="keyword">long</span> getDelay（）方法），</span><br><span class="line">            DelayQueue根据集合元素的getDalay（）方法的返回值进行排序。</span><br></pre></td></tr></table></figure><p>下面使用ArrayBlockingQueue为例来介绍堵塞队列的功能和用法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个长度为2的阻塞队列</span></span><br><span class="line">    BlockingQueue bq =newArrayBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">    bq.put(<span class="string">"Java"</span>);</span><br><span class="line">    <span class="comment">// 与bq.add("Java"、bq.offer("Java")相同</span></span><br><span class="line">    bq.put(<span class="string">"Java"</span>);</span><br><span class="line">    <span class="comment">// 与bq.add("Java"、bq.offer("Java")相同</span></span><br><span class="line">    bq.put(<span class="string">"Java"</span>);</span><br><span class="line">    <span class="comment">// ① 阻塞线程。</span></span><br><span class="line">    <span class="comment">//bq.add("Java");</span></span><br><span class="line">    <span class="comment">//抛出异常//bq.offer("Java");</span></span><br><span class="line">    <span class="comment">//返回false,元素不会被放入</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此类似的是:BlockingQueue已空的情况下:</p><p>使用take()方法取出元素会堵塞线程;</p><p>使用remove()方法尝试取出元素将引发异常;</p><p>使用poll()方法取出元素将会返回false,元素不会被删除.</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个容量为1的BlockingQueue</span></span><br><span class="line">        </span><br><span class="line">        BlockingQueue&lt;String&gt; b=<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//启动3个生产者线程</span></span><br><span class="line">        <span class="keyword">new</span> Producer(b).start();</span><br><span class="line">        <span class="keyword">new</span> Producer(b).start();</span><br><span class="line">        <span class="keyword">new</span> Producer(b).start();</span><br><span class="line">        <span class="comment">//启动一个消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> Consumer(b).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; b;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;String&gt; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b=b;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String [] str=<span class="keyword">new</span> String[]&#123;</span><br><span class="line">            <span class="string">"java"</span>,</span><br><span class="line">            <span class="string">"struts"</span>,</span><br><span class="line">            <span class="string">"Spring"</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9999999</span>;i++)&#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">"生产者准备生产集合元素！"</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">            </span><br><span class="line">                b.put(str[i%<span class="number">3</span>]);</span><br><span class="line">                sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">//尝试放入元素，如果队列已满，则线程被阻塞</span></span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;System.out.println(e);&#125;</span><br><span class="line">            System.out.println(getName()+<span class="string">"生产完成："</span>+b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">"消费者准备消费集合元素！"</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">//尝试取出元素，如果队列已空，则线程被阻塞</span></span><br><span class="line">                b.take();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;System.out.println(e);&#125;</span><br><span class="line">            System.out.println(getName()+<span class="string">"消费完："</span>+b);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程组和未处理异常"><a href="#线程组和未处理异常" class="headerlink" title="线程组和未处理异常"></a>线程组和未处理异常</h2><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>Java使用ThreadGroup来表示线程组,它可以对一批线程进行分类管理.Java允许程序直接对线程组进行控制.对线程组的控制相当于同时控制这批线程.</p><p><strong>用户创建的所有线程都属于指定线程组</strong>,<strong>如果程序没有显示指定线程属于哪个线程组,那么该线程属于默认线程组</strong>.在默认情况下,<strong>子线程和创建它的父线程都处于同一线程组内</strong>,比如:A线程创建了B线程,并且没有指定B线程属于哪一个线程组,那么B线程属于A线程所在的那个线程组.</p><p><strong>一旦某个线程加入了指定的线程组之后,该线程将一直属于该线程组,直到该线程死亡</strong>.线程运行中途不能改变它所属的线程组.</p><p>Thread类提供了几个构造器来设置新创建的线程属于哪个线程组</p><ul><li>Thread(ThreadGroup group, Runnable target):以target的run()方法作为线程执行体创建新线程,属于group线程组.</li><li>Thread(ThreadGroup group, Runnable target,String name):以target的run()方法作为线程执行体创建新线程,该线程属于group线程组,且线程名为name</li><li>Thread(ThreadGroup group, String name):创建新线程,新线程名字为name,属于group线程组.</li></ul><p>Thread类提供了一个<code>getThreadGroup()</code>方法来返回线程所属的线程组,getThreadGroup()方法的返回值是ThreadGroup对象,表示一个线程组.</p><p>ThreadGroup类提供了下面两个简单的构造器来创建实例:</p><ul><li>ThreadGroup(String name):以指定的线程组名字来创建新的线程组</li><li>ThreadGroup(ThreadGroup parent,String name):以指定的名字,指定的父线程组创建一个新线程组.</li></ul><p>线程组总会有一个名字字符串类型的名字,该名字可以通过ThreadGroup的getName()方法来获取,但是不允许改变线程组名字.</p><p>ThreadGroup类提供了如下几个常用的方法来操作整个线程组里的所有线程:</p><ul><li>int activeCount():返回此线程组中活动线程总数</li><li>interrupt():中断此线程组中所有线程</li><li>isDaemon():判断该线程组是否是后台线程组</li><li>setDaemon(boolean daemon):把该线程组设置成后台线程组.</li><li>setMaxPriority(int pri):设置线程组的最高优先级</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="comment">// 提供指定线程名的构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 提供指定线程名、线程组的构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(ThreadGroup group , String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(group, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(inti =<span class="number">0</span>; i &lt;<span class="number">20</span>; i++ )&#123; </span><br><span class="line">      System.out.println(getName() +<span class="string">" 线程的i变量"</span>+ i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取主线程所在的线程组，这是所有线程默认的线程组</span></span><br><span class="line">    ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();      </span><br><span class="line">    System.out.println(<span class="string">"主线程组的名字："</span>+ mainGroup.getName());</span><br><span class="line">    System.out.println(<span class="string">"主线程组是否是后台线程组："</span>+ mainGroup.isDaemon());</span><br><span class="line">    newMyThread(<span class="string">"主线程组的线程"</span>).start();</span><br><span class="line">    ThreadGroup tg =newThreadGroup(<span class="string">"新线程组"</span>);</span><br><span class="line">    tg.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(<span class="string">"tg线程组是否是后台线程组："</span>+ tg.isDaemon());</span><br><span class="line">    MyThread tt =newMyThread(tg ,<span class="string">"tg组的线程甲"</span>);</span><br><span class="line">    tt.start();newMyThread(tg ,<span class="string">"tg组的线程乙"</span>).start();   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>ThreadGroup内还定义了一个<code>void uncaughtException(Thread t,Throwable e):</code>该方法可以处理该线程组内的任意线程所抛出的未处理异常.该方法中的t代表出现异常的线程,e代表该线程抛出的异常.void uncaughtException(Thread t,Throwable e)该方法属于Thread.UncaughtExceptionHandler接口里唯一的一个方法,该接口是Thread类的一个静态内部接口</p><p><strong>Thread类提供如下两个方法来设置异常处理器:</strong></p><ul><li>static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh):为该线程类的<strong>所有线程实例</strong>设置默认的异常处理器.</li><li>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh):为<strong>指定的线程实例</strong>设置异常处理器</li></ul><p>ThreadGroup类实现了Thread.UncaughtExceptionHandler接口,所以每个线程所属的线程组都会作为默认的异常处理器.</p><p>当一个线程抛出未处理的异常时,JVM会首先查找该异常所对应的异常处理器(setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)方法设置的异常处理器),如果找到该异常处理器,则将调用该异常处理器处理该异常;否则JVM将会调用该线程所属的线程组对象的uncaughtExceptio()方法来处理该异常.</p><p><strong>线程组处理异常的默认流程如下:</strong></p><ol><li>如果该线程组有父线程组,则调用父线程组的uncaughtException()方法来处理该异常</li><li>如果该线程实例所属的线程类有默认的异常处理器(由setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)方法设置的异常处理器),那么就调用该异常处理器来处理该异常.</li><li>如果该异常对象是ThreadDeath的对象,则不做任何处理;否则,将异常跟踪栈的信息打印到System.err错误输出流,并结束该线程</li></ol><p>下面程序为主线程设置了异常处理器,当主线程运行抛出未处理的异常时,该异常处理器会起作用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyExHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span>&#123;</span><br><span class="line">  <span class="comment">// 实现uncaughtException方法，该方法将处理线程的未处理异常</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>&#123;</span><br><span class="line">    System.out.println(t +<span class="string">" 线程出现了异常："</span>+ e);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置主线程的异常处理器</span></span><br><span class="line">    Thread.currentThread().setUncaughtExceptionHandler(newMyExHandler());</span><br><span class="line">    inta =<span class="number">5</span>/<span class="number">0</span>;<span class="comment">// ①System.out.println("程序正常结束！");</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为:</span></span><br><span class="line"><span class="comment">//Thread[main,5,main] 线程出现了异常：java.lang.ArithmeticException: / by zero</span></span><br></pre></td></tr></table></figure><p><strong>说明异常处理器与通过catch捕捉异常是不同的,当使用catch捕捉异常时,通常不会向上传播给上一级调用者;但使用异常处理器对异常进行处理之后,异常依然会传播给上一级调用者</strong>.</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>系统启动一个新线程的成本是比价高的,因为涉及到与操作系统交互,在这种情况下,使用线程池可以很好的提高性能,尤其是当程序中需要创建大量生存期很短的线程时,更应该考虑使用线程池</p><p>线程池在系统启动时即创建大量空闲的线程,程序将一个Runnable对象或Callable对象传给线程池,线程池就会启动一个线程来执行它们的run()或call()方法,当run()或call()方法执行结束后,该线程并不会死亡,而是再次返回线程池中称为空闲状态,等待执行下一个Runnable对象的run()或call()方法.</p><p>使用线程池可以有效控制系统中并发线程的数量,当系统中包含大量并发线程时,会导致系统性能剧烈下降,甚至JVM崩溃,而线程池的最大线程数参数可以控制系统中并发线程数不超过此数.</p><p>合理利用线程池能够带来三个好处：</p><ol><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><p>Java5新增了一个Executors工厂类来产生线程池,该工厂类提供了如下几个静态工厂方法来创建线程池</p><p>使用线程池来执行线程任务的步骤如下:</p><ol><li>调用Executor类的静态工厂方法创建一个ExecutorService对象,该对象代表一个线程池.</li><li>创建Runnable实现类或Callable实现类的实例,作为线程执行任务.</li><li>调用ExecutorService对象的submit()方法提交Runnable实例或Callable实例</li><li>当不想提交任何任务时,调用ExecutorService对象的shutdown()方法来关闭线程池.</li></ol><h3 id="使用Executors工厂类产生线程池"><a href="#使用Executors工厂类产生线程池" class="headerlink" title="使用Executors工厂类产生线程池"></a>使用Executors工厂类产生线程池</h3><p>Executor线程池框架的最大优点是把任务的提交和执行解耦。客户端将要执行的任务封装成Task，然后提交即可。而Task如何执行客户端则是透明的。具体点讲，提交一个Callable对象给ExecutorService（如最常用的线程池ThreadPoolExecutor），将得到一个Future对象，调用Future对象的get方法等待执行结果。线程池实现原理类结构图如下：</p><p><img src="/category/JavaSE-多线程/pool.png" alt="pool"></p><p>ExecutorService<strong>是<a href="http://lib.csdn.net/base/17" target="_blank" rel="noopener">Java</a>中对线程池定义的一个接口，它<code>java.util.concurrent</code>包中。</strong></p><p>Java API对ExecutorService接口的实现有两个，所以这两个即是Java线程池具体实现类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除此之外，ExecutorService还继承了<code>Executor</code>接口（注意区分Executor接口和Executors工厂类），这个接口只有一个<code>execute()</code>方法，最后我们看一下整个继承树：</p><p>​ 使用Executors执行多线程任务的步骤如下：</p><p>• 调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池；</p><p>• 创建Runnable实现类或Callable实现类的实例，作为线程执行任务；</p><p>• 调用ExecutorService对象的submit()方法来提交Runnable实例或Callable实例；</p><p>• 当不想提交任务时，调用ExecutorService对象的shutdown()方法来关闭线程池。</p><p><strong>使用Executors的静态工厂类创建线程池的方法如下：</strong></p><ol><li>newFixedThreadPool() ：</li></ol><p>​ 作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。<br>栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按FIFO方式处理任务队列中的任务。</p><ol><li>newCachedThreadPool() ：</li></ol><p>​ 作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。<br>栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。</p><ol><li>newSingleThreadExecutor() ：</li></ol><p>​ 作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。</p><ol><li>newScheduledThreadPool() ：</li></ol><p>​ 作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。</p><ol><li>newSingleThreadScheduledExecutor() ：</li></ol><p>​ 作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。</p><p><strong>注：</strong>Executors只是一个工厂类，它所有的方法返回的都是<code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>这两个类的实例。</p><p><strong>ExecutorService有如下几个执行方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//execute(Runnable);</span></span><br><span class="line"><span class="comment">//这个方法接收一个Runnable实例，并且异步的执行，请看下面的实例：</span></span><br><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Asynchronous task"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.shutdown();</span><br><span class="line"><span class="comment">//--------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//submit(Runnable);</span></span><br><span class="line"><span class="comment">//submit(Runnable)和execute(Runnable)区别是前者可以返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完毕，请看下面执行的例子：</span></span><br><span class="line">Future future = executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Asynchronous task"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">future.get();  <span class="comment">//returns null if the task has finished correctly.</span></span><br><span class="line"><span class="comment">//如果任务执行完成，future.get()方法会返回一个null。注意，future.get()方法会产生阻塞。</span></span><br><span class="line"><span class="comment">//--------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//submit(Callable);</span></span><br><span class="line"><span class="comment">//submit(Callable)和submit(Runnable)类似，也会返回一个Future对象，但是除此之外，submit(Callable)接收的是一个Callable的实现，Callable接口中的call()方法有一个返回值，可以返回任务的执行结果，而Runnable接口中的run()方法是void的，没有返回值。请看下面实例：</span></span><br><span class="line">Future future = executorService.submit(<span class="keyword">new</span> Callable()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Asynchronous Callable"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Callable Result"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"future.get() = "</span> + future.get());</span><br><span class="line"><span class="comment">//如果任务执行完成，future.get()方法会返回Callable任务的执行结果。另外，future.get()方法会产生阻塞。</span></span><br><span class="line"><span class="comment">//--------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//invokeAny(...)</span></span><br><span class="line"><span class="comment">//invokeAny(...)方法接收的是一个Callable的集合，执行这个方法不会返回Future，但是会返回所有Callable任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果，反正是其中的某一个。请看下面实例：</span></span><br><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">Set&lt;Callable&lt;String&gt;&gt; callables = <span class="keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Task 1"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Task 2"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Task 3"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">String result = executorService.invokeAny(callables);</span><br><span class="line">System.out.println(<span class="string">"result = "</span> + result);</span><br><span class="line">executorService.shutdown();</span><br><span class="line"><span class="comment">//每次执行都会返回一个结果，并且返回的结果是变化的，可能会返回“Task2”也可是“Task1”或者其它。</span></span><br><span class="line"><span class="comment">//--------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//invokeAll(...)</span></span><br><span class="line"><span class="comment">// invokeAll(...)与 invokeAny(...)类似也是接收一个Callable集合，但是前者执行之后会返回一个Future的List，其中对应着每个Callable任务执行后的Future对象。情况下面这个实例：</span></span><br><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">Set&lt;Callable&lt;String&gt;&gt; callables = <span class="keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Task 1"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Task 2"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Task 3"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callables);</span><br><span class="line"><span class="keyword">for</span>(Future&lt;String&gt; future : futures)&#123;</span><br><span class="line">    System.out.println(<span class="string">"future.get = "</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><p><strong>ExecutorService关闭方法</strong></p><p>当我们使用完成ExecutorService之后应该关闭它，否则它里面的线程会一直处于运行状态。举个例子，如果的应用程序是通过main()方法启动的，在这个main()退出之后，如果应用程序中的ExecutorService没有关闭，这个应用将一直运行。之所以会出现这种情况，是因为ExecutorService中运行的线程会阻止JVM关闭。</p><p>要关闭ExecutorService中执行的线程，我们可以调用<strong>ExecutorService.shutdown()</strong>方法。在调用shutdown()方法之后，ExecutorService不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在shutdown()执行之前提交的任务都会被执行。</p><p>如果想立即关闭ExecutorService，我们可以调用<strong>ExecutorService.shutdownNow()</strong>方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。</p><h3 id="使用Java8增强的ForkJoinPool产生线程池"><a href="#使用Java8增强的ForkJoinPool产生线程池" class="headerlink" title="使用Java8增强的ForkJoinPool产生线程池"></a>使用Java8增强的ForkJoinPool产生线程池</h3><p>Java8增强的ForkJoinPool</p><p>Java7提供了ForkJoinPool来支持将一个任务分解为多个”小任务”并行计算,再把多个”小任务”的结果合并成总的计算结果.ForkJoinPool是ExecutorService的实现类,因此是一种特殊的线程池.</p><p>ForkJoinPool提供如下两个常用的构造器:</p><ul><li>ForkJoinPool(int parallelism):创建一个包含parallelism个并行线程的ForkJoinPool.</li><li>ForkJoinPool():以Runtime.availableProcessors()方法的返回值作为parallelism参数来创建ForkJoinPool</li></ul><p>Java8为ForkJoinPool增加了通用池功能.ForkJoinPool类通过如下两个静态方法提供通用池功能:</p><p>ForkJoinPool commonPool():该方法返回一个通用池,通用池的运行状态不会受shutdown()或shutdownNow()方法的影响.如果程序直接执行System.exit(0)来终止虚拟机,通用池以及通用池中正在执行的任务都会被自动终止.</p><p>int getCommonPoolParallelism():该方法返回通用池的并行级别.</p><p>创建了ForkJoinPool实例之后,就可以调用ForkJoinPool的submit(ForkJoinTask task)或invoke(ForkJoinTask task)方法来执行指定的任务了.其中ForkJoinTask代表一个可以并行,合并的任务.ForkJoinTask是一个抽象类,它有两个抽象子类:RecursiveAction和RecursiveTask.其中RecursiveAction代表有返回值的任务,RecursiveTask代表没有返回值的任务.</p><p><img src="/category/JavaSE-多线程/fu.png" alt="fu"></p><p>在Java 8中，引入了自动并行化的概念。它能够让一部分Java代码自动地以并行的方式执行，前提是使用了ForkJoinPool。</p><p>ForkJoinPool同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。</p><p>ForkJoinPool主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题。典型的应用比如快速排序算法。这里的要点在于，ForkJoinPool需要使用相对少的线程来处理大量的任务。比如要对1000万个数据进行排序，那么会将这个任务分割成两个500万的排序任务和一个针对这两组500万数据的合并任务。以此类推，对于500万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于10时，会停止分割，转而使用插入排序对它们进行排序。那么到最后，所有的任务加起来会有大概2000000+个。问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。所以当使用ThreadPoolExecutor时，使用分治法会存在问题，因为ThreadPoolExecutor中的线程无法像任务队列中再添加一个任务并且在等待该任务完成之后再继续执行。而使用ForkJoinPool时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。比如，我们需要统计一个double数组中小于0.5的元素的个数，那么可以使用ForkJoinPool进行实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] d;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinTask</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.first = first;</span><br><span class="line">            <span class="keyword">this</span>.last = last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> subCount;</span><br><span class="line">            <span class="keyword">if</span> (last - first &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                subCount = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (d[i] &lt; <span class="number">0.5</span>)&#123;</span><br><span class="line">                        subCount++;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (first + last) /<span class="number">2</span>;</span><br><span class="line">                ForkJoinTask left = <span class="keyword">new</span> ForkJoinTask(first, mid);</span><br><span class="line">                left.fork();</span><br><span class="line">                ForkJoinTask right = <span class="keyword">new</span> ForkJoinTask(mid + <span class="number">1</span>, last);</span><br><span class="line">                right.fork();</span><br><span class="line">                subCount = left.join();</span><br><span class="line">                subCount += right.join();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> subCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool pool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        pool.submit(<span class="keyword">new</span> ForkJoinTask(<span class="number">0</span>, <span class="number">9999999</span>));</span><br><span class="line">        pool.awaitTermination(<span class="number">2</span>,TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(<span class="string">"Found "</span> + n + <span class="string">" values"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的关键是fork()和join()方法。在ForkJoinPool使用的线程中，会使用一个内部队列来对需要执行的任务以及子任务进行操作来保证它们的执行顺序。</p><p><strong>注：</strong>使用ThreadPoolExecutor和ForkJoinPool的性能差异：</p><ol><li>首先，使用ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用4个线程来完成超过200万个任务。但是，使用ThreadPoolExecutor时，是不可能完成的，因为ThreadPoolExecutor中的Thread无法选择优先执行子任务，需要完成200万个具有父子关系的任务时，也需要200万个线程，显然这是不可行的。</li><li>ForkJoinPool能够实现工作窃取(Work Stealing)，在该线程池的每个线程中会维护一个队列来存放需要被执行的任务。当线程自身队列中的任务都执行完毕后，它会从别的线程中拿到未被执行的任务并帮助它执行。因此，提高了线程的利用率，从而提高了整体性能。</li><li>对于ForkJoinPool，还有一个因素会影响它的性能，就是停止进行任务分割的那个阈值。比如在之前的快速排序中，当剩下的元素数量小于10的时候，就会停止子任务的创建。</li></ol><p><strong>结论：</strong></p><ol><li>当需要处理递归分治算法时，考虑使用ForkJoinPool；</li><li>仔细设置不再进行任务划分的阈值，这个阈值对性能有影响；</li><li>Java 8中的一些特性会使用到ForkJoinPool中的通用线程池。在某些场合下，需要调整该线程池的默认的线程数量。</li></ol><h2 id="线程相关类"><a href="#线程相关类" class="headerlink" title="线程相关类"></a>线程相关类</h2><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal它并不是一个线程，而是一个可以在每个线程中存储数据的数据存储类，通过它可以在指定的线程中存储数据，数据存储之后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到该线程的数据。 即多个线程通过同一个ThreadLocal获取到的东西是不一样的，就算有的时候出现的结果是一样的（偶然性，两个线程里分别存了两份相同的东西），但他们获取的本质是不同的。使用这个工具类可以简化多线程编程时的并发访问，很简洁的隔离多线程程序的竞争资源。</p><p>它代表一个线程局部变量,通过把数据放在ThreadLocal中就可以让每个线程创建一个该变量的副本,从而避免并发访问的线程安全问题.</p><p>ThreadLocal类支持泛型支持.通过使用ThreadLocal类可以<strong>简化多线程编程中的并发访问</strong>,使用这个工具类可以<strong>简捷地隔离多线程程序的竞争资源</strong>.</p><p>线程局部变量(ThreadLocal)的功用非常简单,就是为每一个使用该变量的线程都提供一个变量值的副本,使每一个使用该变量的线程都提供一个变量值的副本,<strong>使每一个线程都可以独立地改变自己的副本,而不会和其他线程的副本冲突</strong>.</p><p>对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。ThreadLocal类提供了如下的三个public方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal();<span class="comment">//创建一个线程本地变量。</span></span><br><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span></span>;<span class="comment">//返回此线程局部变量的当前线程副本中的值，如果这是线程第一次调用该方法，则创建并初始化此副本。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  T <span class="title">initialValue</span><span class="params">()</span></span>;<span class="comment">//返回此线程局部变量的当前线程的初始值。</span></span><br></pre></td></tr></table></figure><p>下面通过系统源码来分析出现这个结果的原因。 在ThreadLocal中存在着两个很重要的方法，get()和set()方法，一个读取一个设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the value of this variable for the current thread. If an entry</span></span><br><span class="line"><span class="comment">    * doesn't yet exist for this variable on this thread, this method will</span></span><br><span class="line"><span class="comment">    * create an entry, populating the value with the result of</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #initialValue()&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the current value of the variable for the calling thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Optimized for the fast path.</span></span><br><span class="line">       Thread currentThread = Thread.currentThread();</span><br><span class="line">       Values values = values(currentThread);</span><br><span class="line">       <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object[] table = values.table;</span><br><span class="line">            <span class="keyword">int</span> index = hash &amp; values.mask;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.reference == table[index]) &#123;</span><br><span class="line">   　　　　　      <span class="keyword">return</span> (T) table[index + <span class="number">1</span>];</span><br><span class="line">             &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    　　　　values = initializeValues(currentThread);</span><br><span class="line">    　　&#125;</span><br><span class="line">    　　<span class="keyword">return</span> (T) values.getAfterMiss(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sets the value of this variable for the current thread. If set to</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125;, the value will be set to null and the underlying entry will</span></span><br><span class="line"><span class="comment">    * still be present.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value the new value of the variable for the caller thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">         Thread currentThread = Thread.currentThread();</span><br><span class="line">    　　 Values values = values(currentThread);</span><br><span class="line">    　　 <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">    　　　　  values = initializeValues(currentThread);</span><br><span class="line">    　　　&#125;</span><br><span class="line">       values.put(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从注释上可以看出，get方法会返回一个当前线程的变量值，如果数组不存在就会创建一个新的。另外，对于“当前线程”和“数组”，数组对于每个线程来说都是不同的 values.table。而values是通过当前线程获取到的一个Values对象，因此这个数组是每个线程唯一的，不能共用，而下面的几句话也更直接了，获取一个索引，再返回通过这个索引找到数组中对应的值。这也就解释了为什么多个线程通过同一个ThreadLocal返回的是不同的东西。</p><p>​ Java中为什么要这么设置呢？</p><ul><li>ThreadLocal在日常开发中使用到的地方较少，但是在某些特殊的场景下，通过ThreadLocal可以轻松实现一些看起来很复杂的功能。一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑使用ThreadLocal。例如在Handler和Looper中。对于Handler来说，它需要获取当前线程的Looper，很显然Looper的作用域就是线程并且不同的线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松的实现Looper在线程中的存取。如果不采用ThreadLocal，那么系统就必须提供一个全局的哈希表供Handler查找指定的Looper，这样就比较麻烦了，还需要一个管理类。</li><li><p>ThreadLocal的另一个使用场景是复杂逻辑下的对象传递，比如监听器的传递，有些时候一个线程中的任务过于复杂，就可能表现为函数调用栈比较深以及代码入口的多样性，这种情况下，我们又需要监听器能够贯穿整个线程的执行过程。这个时候就可以使用到ThreadLocal，通过ThreadLocal可以让监听器作为线程内的全局对象存在，在线程内通过get方法就可以获取到监听器。如果不采用的话，可以使用参数传递，但是这种方式在设计上不是特别好，当调用栈很深的时候，通过参数来传递监听器这个设计太糟糕。而另外一种方式就是使用static静态变量的方式，但是这种方式存在一定的局限性，拓展性并不是特别的强。比如有10个线程在执行，就需要提供10个监听器对象。</p><p><strong>注：</strong>ThreadLocal和其他所有的同步机制一样，都是为了解决多线程中对于同一变量的访问冲突。值普通的同步机制中，通过对象加锁来实现多线程对同一变量的安全访问，且该变量是多线程共享的，所有需要使用这种同步机制来明确分开是在什么时候对变量进行读写，在什么时候需要锁定该对象。此种情况下，系统并没有将这个资源复制多份，而是采取安全机制来控制访问而已。ThreadLocal只是从另一个角度解决多线程的并发访问，即将需要并发访问的资源复制多份，每个线程拥有一份资源，每个线程都有自己的资源副本。</p></li></ul><p>ThreadLocal并不能代替同步机制,同步机制是为了同步多个线程对相同资源的并发访问,是多个线程之间进行通信的有效方式,而ThreadLocal是为了隔离多个线程的数据共享,从根本上上避免多个线程之间对共享资源(变量)的竞争,也就不需要对多个线程进行同步了.</p><p><strong>总结：</strong>若多个线程之间需要共享资源，以达到线程间的通信时，就使用同步机制；若仅仅需要隔离多线程之间的关系资源，则可以使用ThreadLocal。</p><h3 id="包装线程不安全的集合"><a href="#包装线程不安全的集合" class="headerlink" title="包装线程不安全的集合"></a>包装线程不安全的集合</h3><p>前面提到了ArrayList,LinkedList,HashSet,TreeSet,HashMap,TreeMap都是线程不安全的集合,当<strong>多个并发线程</strong>访问这些集合存取元素时,就可能会破坏这些集合的数据完整性.</p><p>可以使用Collections提供的类方法把这些集合编程线性安全的集合.</p><p>如果需要把某个集合包装成线性安全的集合,应该在创建之后立即包装</p><p>//使用Collections的synchronizedMap方法将一个普通的HashMap包装成一个线程安全的类</p><p><code>HashMap m=Collections.synchronizedMap(newHashMap());</code></p><p><strong>线程安全的集合类</strong></p><p><img src="/category/JavaSE-多线程/duo4.png" alt="duo"></p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>定时器是一个应用十分广泛的线程工具，可用于调度多个定时任务以后台线程的方式执行，在Java中，可以通过Timer和TimerTask类来实现定义调度的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Timer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task,<span class="keyword">long</span> delay)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task,<span class="keyword">long</span> delay,<span class="keyword">long</span> period)</span></span>;</span><br><span class="line"><span class="comment">//TimerTask</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>开发中：Quartz是一个完全由Java编写的开源调度框架</p><p>本文转载编辑于</p><p><a href="https://www.jianshu.com/p/b33ff24b411e" target="_blank" rel="noopener">Java多线程</a></p><p><a href="https://www.cnblogs.com/snow-flower/p/6114765.html" target="_blank" rel="noopener">Java多线程详解</a></p><p>推荐博文：</p><p><a href="https://www.cnblogs.com/wxd0108/p/5479442.html" target="_blank" rel="noopener">Java中的多线程你只要看这一篇就够了</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE多线程详解
    
    </summary>
    
      <category term="JavaSE多线程" scheme="https://www.ysmjjsy.com/categories/JavaSE%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-API</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-API/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-API/</id>
    <published>2017-08-25T08:15:23.000Z</published>
    <updated>2019-08-30T08:19:19.669Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:20:24 GMT+0800 (GMT+08:00) --><h1 id="JavaSE-常用API"><a href="#JavaSE-常用API" class="headerlink" title="JavaSE-常用API"></a>JavaSE-常用API</h1><h2 id="GregorianCalendar类"><a href="#GregorianCalendar类" class="headerlink" title="GregorianCalendar类"></a>GregorianCalendar类</h2><p>Date类用来表示时间点，并且官方目前推荐用GregorianCalendar类</p><p>GregorianCalendar类用来表示更为通用的日历表示法</p><p>GregorianCalendar类扩展一个更通用的Calendar类，这个类描述了日历的一般属性</p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>new GregorianCalendar():构造一个新对象，用于表示对象构造时的日期和时间。</p><p>new GregorianCalendar(1999，11，31):用给定日期和时间构造一个Gregorian日历对象</p><p>要想查询某个时间点的年月日等信息，应该使用GregorianCalendar类的get方法，为了表达希望得到的项，需要借助于Calendar类中定义的一些常量，比如Calendar.Month或Calendar.DAY_OF_WEEK;</p><p>还有设置年月日的set方法。</p><p>get方法和set、add方法在概念上有区别，get方法仅仅查看并返回对象的状态，而set和add方法却对对象的状态进行修改。对实例域做出修改的方法称为更改器方法，仅访问实例域而不进行修改的方法称为访问其方法。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>void add(int field, int amount):对给定的时间域增加指定数量的时间</p><p>int getFirstDayOfWeek():获得当前用户所在地区，一个星期中的第一天。</p><p>void setTime(Date time):将日历设置为指定的时间点.</p><p>Date getTime():获得这个日历对象当前值所表达的时间点</p><p>String[]getShortWeekdays()</p><p>String[]getShortMonths ()</p><p>String[]getWeekdays()</p><p>String[]getMonths ()</p><p>获得当前地区的星期几或几月份的名称，利用Calendar的星期和月份常量作为数组索引值.</p><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>它为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span> <span class="params">(<span class="keyword">int</span> field)</span>:<span class="comment">//返回给定日历字段的值，日历类中的每个日历字段都是静态的成员变量，并且时int类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> field,<span class="keyword">int</span> amount)</span>:<span class="comment">//根据给定的日历字段和对应的时间，来对当前的日历进行操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date)</span>:<span class="comment">//设置当前日历的年月日</span></span></span><br></pre></td></tr></table></figure><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>可以使用Object类型的变量引用任何类型的对象，Object类型的变量只能用于作为各种值得通用持有者。要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的类型转换。</p><p>在Java中，只有基本类型不是对象。所有的数组类型都属于Object类。</p><p>构造方法：public Object()</p><h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a>hashCode()方法</h3><p>散列码(hash code)是由对象导出的一个整数值,散列码是没有规律的。hashCode方法定义在Object类中，每个对象都有一个默认的散列码,其值为对象的存储地址.</p><p>int hash(Object…objects):返回一个散列码，由提供的所有对象的散列码组合而得到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">    System.out.println(p.hashCode());<span class="comment">//11299397</span></span><br><span class="line">    Phone p2 = <span class="keyword">new</span> Phone();</span><br><span class="line">    System.out.println(p2.hashCode());<span class="comment">//24446859</span></span><br><span class="line">    Phone p3 = p1;</span><br><span class="line">    System.out.println(p3.hashCode());<span class="comment">//11299397</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass()方法"></a>getClass()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final  Class &lt;？&gt; getClass（）</span><br></pre></td></tr></table></figure><p>返回此运行时类Object返回的 Class对象是由static synchronized所表示的类的方法锁定的对象。</p><p><strong>实际结果的类型是Class&lt;? extends |X|&gt; 其中|X|是静态类型上其表达的擦除getClass被调用。</strong>例如，此代码片段中不需要强制转换：</p><p><code>Number n = 0;</code><br><code>Class&lt;? extends Number&gt; c = n.getClass();</code></p><p>返回：</p><p>在<code>Class</code>表示运行时类此对象的对象。在<code>Class</code>表示运行时类此对象的对象。</p><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><p>返回对象的字符串表示，默认是由类的全路径+’@’+哈希值的十六进制表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public  String  toString()</span><br></pre></td></tr></table></figure><p>返回对象的字符串表示形式。通常，该 toString方法返回一个“文本表示”此对象的字符串。结果应该是一个简洁但信息丰富的表示，便于人们阅读。建议所有子类都重写此方法。</p><p>toString类 的方法Object返回一个字符串，该字符串由对象为实例的类的名称，符号字符“ @`”和对象的哈希码的无符号十六进制表示组成。换句话说，此方法返回一个等于值的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName()+<span class="string">'@'</span>+ Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure><ul><li><p>返回：</p><p>对象的字符串表示形式。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer类下的一个静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toHexString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//把一个整数转成一个十六进制表示的字符串</span></span><br></pre></td></tr></table></figure><p>一般toString()方法返回的值是没有意义的，所以我们需要对其重写，一般在子类重写该方法</p><p>建议把该类的所有成员变量值组成返回即可，也可以根据自己需求</p><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals（Object  obj）</span><br></pre></td></tr></table></figure><p>指示某个其他对象是否“等于”此对象。</p><p>该equals方法在非null对象引用上实现等价关系：</p><ul><li>它是<em>自反的</em>：对于任何非空引用值 x，x.equals(x)应该返回 true。</li><li>它是<em>对称的</em>：对于任何非空引用值 x和y，x.equals(y)应该返回true当且仅当 y.equals(x)回报true。</li><li>它是<em>传递</em>性：对于任何非空的参考值 x，y以及z，如果 x.equals(y)回报率true和 y.equals(z)回报率true，那么 x.equals(z)应该返回true。</li><li>它是<em>一致的</em>：对于任何非空引用值 x以及一致返回 或一致返回的y多次调用 ，前提是不修改在对象比较中使用的信息。 x.equals(y) true false equals</li><li>对于任何非空引用值x， x.equals(null)应返回false。</li></ul><p>equals类 的方法Object实现了对象上最具辨别力的等价关系; 即，对于任何非空的参考值x和 y，该方法返回true当且仅当x和y指代相同的对象（x == y具有值true）。</p><p>请注意，通常需要在重写此hashCode方法时覆盖该方法，以便维护该hashCode方法的常规协定，该协定声明相等的对象必须具有相等的哈希代码。</p><h4 id="equals方法的常用格式："><a href="#equals方法的常用格式：" class="headerlink" title="equals方法的常用格式："></a>equals方法的常用格式：</h4><ol><li><p>显示参数命名为otherObject，稍后需要将他转换成另一个叫做other的变量。</p></li><li><p>检测this与otherObject是否引用同一个对象:</p><p><code>if(otherObject== null) return false;</code></p></li><li><p>比较this与otherObject是否属于同一个类，如果equals的语义在每个子类中有所改变，就是用getClass检测:</p><p><code>if(getClass()!=otherObject.getClass())return false;</code></p><p>如果所有子类都拥有统一的语义，就使用instanceof检测:</p><p><code>if(!otherObjectinstanceof ClassName)) return false;</code></p></li><li><p>将otherObject转换为相应的类型变量:</p><p><code>ClassNameother = (ClassName)otherObject</code></p></li><li><p>使用==比较基本类型域，使用equals比较对象域，如果都匹配，返回true，否则返回false</p><p><code>returnfield1 == other.field1&amp;&amp;Object.equals(field2,other.field2)&amp;&amp;.. .;</code></p></li><li><p>如果在子类中重新定义equals，就要在其中包含调用super.equals(other)</p></li></ol><p><strong>equals方法指示其他某个对象是否与此对象”相等”.这个方法默认情况下比较的是地址值，比较地址值一般来说意义不大，所以需要重写该方法，一般用来比较对象的成员变量值是否相同</strong></p><blockquote><p>==：</p><p>基本类型：比较的就是值是否相同</p><p>引用类型：比较的就是地址值是否相同</p></blockquote><p>demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">  <span class="comment">//return true</span></span><br><span class="line">  <span class="comment">//这里改进phone的equals方法，根据这里比较的成员变量决定返回true或false</span></span><br><span class="line">  <span class="comment">//因为name是String类型，所以不能用==比较，应该用equals</span></span><br><span class="line">  <span class="comment">//String类的equals方法是重写Object类的，比较的是字符串内容是否相同</span></span><br><span class="line">  <span class="comment">//我们比较的是手机类的成员变量，所以要向下转型</span></span><br><span class="line">  Phone p = (Phone)obj;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="keyword">this</span>.size == p.size)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><p>确定不存在对该对象的更多引用时，由于对象的垃圾回收器调用此方法。用于垃圾回收，但是什么时候回收不知道</p><p>当垃圾回收器</p><p>protected void finalize（）throw Throwable</p><blockquote><p>当垃圾收集确定没有对该对象的更多引用时，由对象上的垃圾收集器调用。子类重写finalize处置系统资源或执行其他清理的方法。</p><p>一般合同finalize是，如果Java TM虚拟机确定不再有任何方法可以通过任何尚未死亡的线程访问此对象，则会调用它，除非采取了一些操作通过最终确定一些其他准备完成的对象或类。该finalize方法可以采取任何动作，包括使该对象再次可用于其他线程; finalize然而，通常的目的是在对象被不可撤销地丢弃之前执行清理操作。例如，表示输入/输出连接的对象的finalize方法可能会执行显式I / O事务，以在永久丢弃对象之前断开连接。</p><p>finalize类 的方法不Object执行特殊操作; 它只是正常返回。子类 Object可以覆盖此定义。</p><p>Java编程语言不保证哪个线程将为finalize任何给定对象调用该方法。但是，可以保证，调用finalize时，调用finalize的线程不会持有任何用户可见的同步锁。如果finalize方法抛出未捕获的异常，则忽略该异常并终止该对象的终止。</p><p>在finalize为一个对象调用该方法之后，在Java虚拟机再次确定不再有任何方法可以通过任何尚未死亡的线程访问该对象之前不再采取任何操作，包括可能的操作准备好最终确定的其他对象或类，此时可以丢弃该对象。</p><p>finalize对于任何给定对象，Java虚拟机永远不会多次调用该方法。</p><p>该finalize方法抛出的任何异常都会导致暂停此对象的终结，但会被忽略。</p><p>抛出：</p><p>Throwable- Exception通过这种方法提出的</p></blockquote><h3 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone()方法"></a>clone()方法</h3><p>protected Object clone（）throw CloneNotSupportedException</p><p>Cloneable:此类实现了Cloneable接口，以指示Object.clone()方法可以合法的对该类实例进行按字段赋值，这个接口是个标记接口，告诉我们实现该接口就可以实现对象的复制了</p><p>创建并返回此对象的副本。“复制”的确切含义可能取决于对象的类别。一般意图是，对于任何对象x，表达式：<br>x.clone（）！= x<br>将是真的，那表达式：<br>x.clone（）。getClass（）== x.getClass（）<br>会true，但这些不是绝对的要求。通常情况是：<br>x.clone（）。等于（x）的<br>将是true，这不是一个绝对的要求。<br>按照惯例，返回的对象应该通过调用获得 super.clone。如果一个类及其所有超类（除了 Object）遵守这个约定，那将是这种情况 x.clone().getClass() == x.getClass()。</p><p>按照惯例，此方法返回的对象应独立于此对象（正在克隆）。要实现此独立性，可能需要在返回super.clone之前修改返回的对象的一个​​或多个字段。通常，这意味着复制包含被克隆对象的内部“深层结构”的任何可变对象，并使用对副本的引用替换对这些对象的引用。如果一个类只包含原始字段或对不可变对象的引用，那么通常情况下super.clone 不需要修改返回的对象中的任何字段。</p><p>clone类 的方法Object执行特定的克隆操作。首先，如果此对象的类未实现接口Cloneable，则 CloneNotSupportedException抛出a。请注意，所有数组都被认为是实现接口，Cloneable并且clone数组类型方法的返回类型T[] 是T[]T是任何引用或基本类型。否则，此方法创建此对象的类的新实例，并使用该对象的相应字段的内容初始化其所有字段，就像通过赋值一样; 这些字段的内容本身不会被克隆。因此，该方法执行该对象的“浅拷贝”，而不是“深拷贝”操作。</p><p>该类Object本身并不实现接口 Cloneable，因此clone在类的对象上调用该方法Object将导致在运行时抛出异常。</p><p>返回：<br>这个实例的克隆。<br>抛出：<br>CloneNotSupportedException- 如果对象的类不支持该Cloneable接口。覆盖该clone方法的子类也可以抛出此异常以指示无法克隆实例。</p><p>要想实现对象克隆，那么对象所在的类需要实现一个Cloneable接口</p><h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><p>System类下有一个静态的字段</p><p><code>public static final InputStream in;</code>标准的输入流，对应着键盘输入</p><p><code>InputStream is = System.in</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class Demo&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> y = Demo.x;</span><br><span class="line">Phone p = Demo.p;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">Scanner(InputStream source);</span><br><span class="line"><span class="comment">//基本用法</span></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> x = sc.nexInt();</span><br></pre></td></tr></table></figure><h4 id="Scanner类的成员方法"><a href="#Scanner类的成员方法" class="headerlink" title="Scanner类的成员方法"></a>Scanner类的成员方法</h4><p>基本格式:</p><p>hasNextXxx()：判断是否还有下一个输入项，其中Xxx可以是Int，Double等，如果需要判断是否包含下一个字符串则可以省略Xxx</p><p>nextXxx()：获取下一个输入想，Xxx和上面的方法中Xxx相同</p><p>默认情况下，Scanner使用空格，回车等作为分隔符</p><p>常用方法</p><p>public int nextInt()</p><p>public String nextLine()</p><h2 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h2><p>字符串是由多个字符组成的一串数据，也可以看成是一个字符数组。</p><ul><li>字符串字面值“abc“也可以看成是一个字符串对象</li><li>字符串是常量，一旦被赋值，就不能被改变<ul><li>字符串的内容不能改变，而不是引用不能改变</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String  a = <span class="string">"123"</span>;</span><br><span class="line"></span><br><span class="line">String b = <span class="string">"123"</span>;</span><br><span class="line"></span><br><span class="line">a  == b ;<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为引用的是同一个123</span></span><br></pre></td></tr></table></figure><h4 id="堆内存里有个字符串常量池-gt-本质是一个数组"><a href="#堆内存里有个字符串常量池-gt-本质是一个数组" class="headerlink" title="堆内存里有个字符串常量池-&gt;本质是一个数组"></a>堆内存里有个字符串常量池-&gt;本质是一个数组</h4><p><code>String s = &quot;123&quot;;</code><br>池中没有新的数据则添加数据，如果有，则指向<br>在采用直接赋值过程中，对于字符串而言可以实现池数据的自动保存，这样如果再有相同数据定义时，减少想通过对象产生，提升操作性能</p><p><code>String s = new String(&quot;123&quot;);</code><br>开辟两块堆内存空间，而只会使用一块，而另外一个由于字符串常量所定义的匿名对象会成为垃圾空间<br>实际上是属于一种自己专用的内存空间，但是在String类里面也提供有帮助开发者实现手工入池</p><h4 id="两种方法的区别"><a href="#两种方法的区别" class="headerlink" title="两种方法的区别:"></a>两种方法的区别:</h4><p>1-&gt;只会产生一个实例化对象，并且可以自动保存到对象池中，以实现该字符串实例的重用</p><p>2-&gt;会产生两个实例化对象，并且不会自动入池，无法对对象重用，但是可以利用intern()方法手工入池</p><h4 id="String对象-常量-池"><a href="#String对象-常量-池" class="headerlink" title="String对象(常量)池"></a>String对象(常量)池</h4><p>对象池的主要目的是实现数据的共享处理，以Spring对象池为例，里面的内容主要就是为了重用，重用就是为了共享设计，但是在在Java之中对象（常量）池实际上可分为两种</p><p><strong>静态常量池：</strong></p><p>指的是程序(.*class)在加载时候会自动将此程序之中保存的字符串、普通的常量、类和方法的信息等等，全部进行分配;</p><p><strong>运行时常量池：</strong></p><p>指的是程序(.*class)加载之后，里面可能有一些变量，这个时候提供的常量池。</p><h4 id="空串和Null串"><a href="#空串和Null串" class="headerlink" title="空串和Null串:"></a>空串和Null串:</h4><p>空串有自己的串长度和内容，String变量可以存放一个特殊的值，名为null，有时候要检查一个字符串既不是null也不为空串，需要使用</p><p>if(str !=null &amp;&amp;str.length()!= 0)</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span>:<span class="comment">//空构造</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span>:<span class="comment">//把字节数组转成在字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes,<span class="keyword">int</span> index,<span class="keyword">int</span> length)</span>:<span class="comment">//把字节数组的一部分转成字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value)</span>:<span class="comment">//把字符数组转成字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value,<span class="keyword">int</span> index,<span class="keyword">int</span> count)</span>:<span class="comment">//把字符数组的一部分转成字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span>:<span class="comment">//把字符串常量值转成字符串</span></span></span><br></pre></td></tr></table></figure><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看程序写结果</span></span><br><span class="line"><span class="comment">//字符串如果是变量相加，先开空间，再拼接</span></span><br><span class="line"><span class="comment">//字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则就创建</span></span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = <span class="string">"helloworld"</span>;</span><br><span class="line">System.out.println(s3 == s1+s2);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3.equals(s1+s2));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//通过反编译可知，这里已经做了处理</span></span><br><span class="line">System.out.println(s3 ==<span class="string">"hello"</span>+<span class="string">"world"</span>);<span class="comment">//true--&gt;s3=="helloworld"</span></span><br><span class="line">System.out.println(s3.equals(<span class="string">"hello"</span>+<span class="string">"world"</span>));<span class="comment">//true--&gt;s3.equals("helloworld")</span></span><br></pre></td></tr></table></figure><h4 id="String类的判断功能"><a href="#String类的判断功能" class="headerlink" title="String类的判断功能"></a>String类的判断功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>:<span class="comment">//比较字符串的内容是否相同，区分大小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String str)</span>:<span class="comment">//比较字符串的内容是否相同，忽略大小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span>:<span class="comment">//判断大字符串中是否包含小字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startWith</span><span class="params">(String str)</span>:<span class="comment">//判断字符串是否以某个指定的字符串开头</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String str)</span>:<span class="comment">//判断字符串是否以某个指定的字符串结尾</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>:<span class="comment">//判断字符串是否为空</span></span></span><br><span class="line"><span class="function"><span class="comment">//注意：字符串内容为空和字符串对象为空</span></span></span><br><span class="line"><span class="function">String s </span>= <span class="string">""</span>;</span><br><span class="line">String s = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h4 id="String类的获取功能"><a href="#String类的获取功能" class="headerlink" title="String类的获取功能"></a>String类的获取功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>:<span class="comment">//获取字符串的长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>:<span class="comment">//获取指定索引位置的字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span>:<span class="comment">//返回指定字符在此字符串中第一次出现处的索引</span></span></span><br><span class="line"><span class="function"><span class="comment">//在这里是int类型而不是char类型，是因为'a'和97都可以代表'a'</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Stirng str)</span>:<span class="comment">//返回指定字符出中第一次出现处的索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch,<span class="keyword">int</span> fromIndex)</span>:<span class="comment">//返回指定字符串在此字符串中从指定位置后第一次出现处的索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str,<span class="keyword">int</span> fromIndex)</span>:<span class="comment">//返回指定字符串在此字符串中从中指定位置后第一次出现处的索引</span></span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span>:<span class="comment">//从指定位置开始截取字符串，默认到末尾</span></span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>:<span class="comment">//从指定位置开始到指定位置结束截取字符串</span></span></span><br></pre></td></tr></table></figure><h4 id="字符串的遍历"><a href="#字符串的遍历" class="headerlink" title="字符串的遍历"></a>字符串的遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;s.length();x++)&#123;</span><br><span class="line">  System.out.println(s.charAt(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="统计大小写个数案例"><a href="#统计大小写个数案例" class="headerlink" title="统计大小写个数案例"></a>统计大小写个数案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个字符串</span></span><br><span class="line">String s = <span class="string">"Hello123World"</span>;</span><br><span class="line"><span class="comment">//定义三个统计变量</span></span><br><span class="line"><span class="keyword">int</span> bigCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> smallCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> numberCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历字符串，得到每一个字符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;s.length();x++)&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = s.charAt(x);</span><br><span class="line">  <span class="comment">//判断该字符到底属于那种类型</span></span><br><span class="line">  <span class="keyword">if</span>(ch&gt;=<span class="string">'a'</span> &amp;&amp; ch&lt;=<span class="string">'z'</span>)&#123;</span><br><span class="line">    smallCount++;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">'A'</span> &amp;&amp; ch&lt;=<span class="string">'Z'</span>)&#123;</span><br><span class="line">    bigCount++;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">'0'</span> &amp;&amp; ch&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    numberCount++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">System.out.println(<span class="string">"大写字母"</span>+bigCount+<span class="string">"个"</span>);</span><br><span class="line">System.out.println(<span class="string">"小写字母"</span>+smallCount+<span class="string">"个"</span>);</span><br><span class="line">System.out.println(<span class="string">"数字"</span>+numberCount+<span class="string">"个"</span>);</span><br></pre></td></tr></table></figure><h4 id="String类的转换功能"><a href="#String类的转换功能" class="headerlink" title="String类的转换功能"></a>String类的转换功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getBytes():<span class="comment">//把字符串转换为字节数组</span></span><br><span class="line"><span class="keyword">char</span>[] toCharArray():<span class="comment">//把字符串转换为字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span>[] chs)</span>:<span class="comment">//把字符数组转成字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span>:<span class="comment">//把int类型的数组转成字符串,注意：String类的valueOf()方法可以把任意类型的数据转成字符串</span></span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span>:<span class="comment">//把字符串转成小写</span></span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span>:<span class="comment">//把字符串转成大写</span></span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span>:<span class="comment">//把字符串拼接</span></span></span><br></pre></td></tr></table></figure><h5 id="字符串首字母大写，其他转小写"><a href="#字符串首字母大写，其他转小写" class="headerlink" title="字符串首字母大写，其他转小写"></a>字符串首字母大写，其他转小写</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = s.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase().concat(s.substring(<span class="number">1</span>).toLowerCase());</span><br></pre></td></tr></table></figure><h4 id="String类的其他功能"><a href="#String类的其他功能" class="headerlink" title="String类的其他功能"></a>String类的其他功能</h4><h5 id="String类的替换功能"><a href="#String类的替换功能" class="headerlink" title="String类的替换功能"></a>String类的替换功能</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> old,<span class="keyword">char</span> new)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(String old,String new)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="去除字符串两空格"><a href="#去除字符串两空格" class="headerlink" title="去除字符串两空格"></a>去除字符串两空格</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h5 id="按字典顺序比较两个字符串"><a href="#按字典顺序比较两个字符串" class="headerlink" title="按字典顺序比较两个字符串"></a>按字典顺序比较两个字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span></span>;</span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br><span class="line">String s3 = <span class="string">"abc"</span>;</span><br><span class="line">String s4 = <span class="string">"xyz"</span>;</span><br><span class="line">System.out.println(s1.compareTo(s2));<span class="comment">//0</span></span><br><span class="line">System.out.println(s1.compareTo(s3));<span class="comment">//7</span></span><br><span class="line">System.out.println(s1.compareTo(s4));<span class="comment">//-16至于这里为什么是-16，可以想想</span></span><br></pre></td></tr></table></figure><h5 id="int数组拼接成字符串案例"><a href="#int数组拼接成字符串案例" class="headerlink" title="int数组拼接成字符串案例"></a>int数组拼接成字符串案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个明确：返回值类型：String 参数列表：int[] arr</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">arrayToString</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义一个字符串</span></span><br><span class="line">  String s = <span class="string">""</span>;</span><br><span class="line">  <span class="comment">//先把字符串拼接一个"["</span></span><br><span class="line">  s += <span class="string">"["</span>;</span><br><span class="line">  <span class="comment">//遍历int数组，得到每一个元素</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length;x++)&#123;</span><br><span class="line">    <span class="comment">//先判断该元素是否是最后一个</span></span><br><span class="line">    <span class="keyword">if</span>(x==arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">//是就直接拼接元素和"]"</span></span><br><span class="line">      s +=arr[x];</span><br><span class="line">      s += <span class="string">"]"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//拼接元素和逗号以及空格</span></span><br><span class="line">      s += arr[x];</span><br><span class="line">      s += <span class="string">", "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字符反转"><a href="#字符反转" class="headerlink" title="字符反转"></a>字符反转</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个明确，返回值类型：String 参数列表：String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverse</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义一个新字符串</span></span><br><span class="line">  String result = <span class="string">""</span>;</span><br><span class="line">  <span class="comment">//把字符串转成字符数组</span></span><br><span class="line">  <span class="keyword">char</span>[] chs = line.toCharArray();</span><br><span class="line">  <span class="comment">//倒着遍历字符串，得到每一个字符</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x = chs.length-<span class="number">1</span>;x&gt;=<span class="number">0</span>;x--)&#123;</span><br><span class="line">    <span class="comment">//用新字符串把每一个字符拼接起来</span></span><br><span class="line">    result += chs[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在大串中查找小串出现的次数案例"><a href="#在大串中查找小串出现的次数案例" class="headerlink" title="在大串中查找小串出现的次数案例"></a>在大串中查找小串出现的次数案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义大串</span></span><br><span class="line">  String maxString=<span class="string">"woaijavazhenaijavawoaizhavazhenaijava"</span>;</span><br><span class="line">  <span class="comment">//定义小串</span></span><br><span class="line">  String minString=<span class="string">"java"</span>;</span><br><span class="line">  <span class="comment">//功能实现</span></span><br><span class="line">  <span class="keyword">int</span> count = getCount(maxString,minString);</span><br><span class="line">  System.out.println(<span class="string">"java在大串中出现了"</span>+count+<span class="string">"次"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">(String maxString,String minString)</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义一个统计变量，初始值是0</span></span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> index;</span><br><span class="line">  <span class="comment">//先查，赋值，判断</span></span><br><span class="line">  <span class="keyword">while</span>((index = maxString.indexOf(minStirng))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    count++;</span><br><span class="line">    maxString = maxString.subString(index+minString.length());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h5><p>字符串 -&gt; %s<br>字 符 -&gt; %c<br>整 数 -&gt; %d<br>小 数 -&gt; %f</p><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p>线程安全的可变字符串</p><p>StringBuffer和String的区别</p><p>StringBuffer长度和内容可变，String不可变</p><p>如果使用StringBuffer做字符串的拼接，不会浪费太多的资源</p><h3 id="StringBuffer类的构造方法"><a href="#StringBuffer类的构造方法" class="headerlink" title="StringBuffer类的构造方法"></a>StringBuffer类的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span>:<span class="comment">//无参构造方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span>:<span class="comment">//指定容量的字符串缓冲区对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span>:<span class="comment">//指定字符串内容的字符串缓冲区对象</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//StringBuffer的方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span>:<span class="comment">//返回当前容量，理论值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>:<span class="comment">//返回长度(字符数)，实际值</span></span></span><br></pre></td></tr></table></figure><h3 id="StringBuffer的添加功能"><a href="#StringBuffer的添加功能" class="headerlink" title="StringBuffer的添加功能"></a>StringBuffer的添加功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span>:<span class="comment">//可以把任意类型数据添加到字符串缓冲区里面，并返回字符串缓冲区本身</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset,String str)</span>:<span class="comment">//在指定位置把任意类型的数据插入到字符串缓冲区里面，并返回字符串缓冲区本身</span></span></span><br></pre></td></tr></table></figure><h3 id="StringBuffer的删除功能"><a href="#StringBuffer的删除功能" class="headerlink" title="StringBuffer的删除功能"></a>StringBuffer的删除功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span>:<span class="comment">//删除指定位置的字符，并返回本身</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>:<span class="comment">//删除从指定位置开始指定位置结束的内容，并返回本身</span></span></span><br></pre></td></tr></table></figure><h3 id="StringBuffer的替换功能"><a href="#StringBuffer的替换功能" class="headerlink" title="StringBuffer的替换功能"></a>StringBuffer的替换功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,String str)</span>:<span class="comment">//从start开始到end用str替换</span></span></span><br></pre></td></tr></table></figure><h3 id="StringBuffer的反转功能"><a href="#StringBuffer的反转功能" class="headerlink" title="StringBuffer的反转功能"></a>StringBuffer的反转功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">reverse</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="StringBuffer的截取功能"><a href="#StringBuffer的截取功能" class="headerlink" title="StringBuffer的截取功能"></a>StringBuffer的截取功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这里返回值类型是String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="String和StringBuffer的相互转换"><a href="#String和StringBuffer的相互转换" class="headerlink" title="String和StringBuffer的相互转换"></a>String和StringBuffer的相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String --&gt; StringBuffer</span></span><br><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">//方法1，通过构造方法</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(s);</span><br><span class="line"><span class="comment">//方法2，通过append方法</span></span><br><span class="line">String Buffer sb2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb2.append(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuffer --&gt; String</span></span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">"java"</span>);</span><br><span class="line"><span class="comment">//方法1，通过构造方法</span></span><br><span class="line">String str = <span class="keyword">new</span> String(buffer);</span><br><span class="line"><span class="comment">//方法2，通过toString()方法</span></span><br><span class="line">String str2 = buffer.toString();</span><br></pre></td></tr></table></figure><h3 id="用StringBuffer做数组拼接指定格式字符串"><a href="#用StringBuffer做数组拼接指定格式字符串" class="headerlink" title="用StringBuffer做数组拼接指定格式字符串"></a>用StringBuffer做数组拼接指定格式字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">arrToString2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">  sb.append(<span class="string">"["</span>)；</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;arr.length;x++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(x == arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">        sb.apend(arr[x]);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sb.append(arr[x]).append(<span class="string">", "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  sb.append(<span class="string">"]"</span>);</span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串反转功能"><a href="#字符串反转功能" class="headerlink" title="字符串反转功能"></a>字符串反转功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverse2</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断一个字符串是否对称"><a href="#判断一个字符串是否对称" class="headerlink" title="判断一个字符串是否对称"></a>判断一个字符串是否对称</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//把字符串转成字符数组</span></span><br><span class="line">  <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>,end = chs.length-<span class="number">1</span>;start&lt;=end;start++,end--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(chas[start]!=chs[end])&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-StringBuffer-StringBuilder的区别"><a href="#String-StringBuffer-StringBuilder的区别" class="headerlink" title="String,StringBuffer,StringBuilder的区别"></a>String,StringBuffer,StringBuilder的区别</h3><p>String是内容不可变的，StringBuffer，StringBuilder是内容可变的</p><p>StringBuffer是同步的，数据安全，效率低，StringBuilder是不同步的，数据不安全，效率高</p><p>String作为参数传递，效果和基本类型作为参数传递是一样的，形式参数的改变不影响实际参数</p><p><strong>StringBuffer和数组的区别？</strong></p><p>二者都可以看出是一个容器，装其他的数据</p><p>但是，StringBuffer的数据最终是一个字符串数据</p><p>而数组可以放置多种数据，但必须是同一种数据类型</p><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>Arrays：针对数组进行操作的工具类，比如说排序和查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span>:<span class="comment">//把数组转成字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span>:<span class="comment">//对数组进行排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> key)</span>:<span class="comment">//二分查找</span></span></span><br></pre></td></tr></table></figure><h2 id="基本包装类"><a href="#基本包装类" class="headerlink" title="基本包装类"></a>基本包装类</h2><p>所有的基本类型都有一个与之对应的类，这些类称为包装器:Integer、Long、Double、Short、Byte、Character、Void、Boolean。前六个类派生于公共的超类Number。对象包装器类是不可变的，一旦构造了包装器，就不允许更改包装在其中的值，同时，包装器类还是final，因此不能定义它们的子类。</p><p>自动装箱: list.add(3);</p><p>list.add(Integer.valueOf(3));</p><p>自动拆箱: int n = list.gei(i);</p><p>Int n = list.gei(i).intValue();</p><p>参数数量可变的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span>… values)</span></span>&#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了对基本数据类型进行更多的操作，更方便的操作，Java就针对每一种基本数据类型提供了对应的类类型，包装类类型</p><p>byte —&gt;Byte</p><p>short —&gt; Short</p><p>int —&gt; Integer</p><p>long —&gt; Long</p><p>float —&gt; Float</p><p>double —&gt; Double</p><p>char —&gt; Character</p><p>boolean —&gt; Boolean</p><h3 id="Integer的构造方法"><a href="#Integer的构造方法" class="headerlink" title="Integer的构造方法"></a>Integer的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span> <span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"><span class="comment">//这里这个字符出啊必须是由数字字符组成</span></span></span><br></pre></td></tr></table></figure><h3 id="String和int类型的相互转换"><a href="#String和int类型的相互转换" class="headerlink" title="String和int类型的相互转换"></a>String和int类型的相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> --&gt; String</span><br><span class="line">String.valueOf(number)</span><br><span class="line">String --&gt; <span class="keyword">int</span></span><br><span class="line">Integer.parseInt(s)</span><br></pre></td></tr></table></figure><h3 id="Integer中进制转换的操作"><a href="#Integer中进制转换的操作" class="headerlink" title="Integer中进制转换的操作"></a>Integer中进制转换的操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用的基本进制转换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toBinaryString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toOctalString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toHexString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//十进制到其他进制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> radix)</span></span>;</span><br><span class="line"><span class="comment">//其他进制到十进制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s,<span class="keyword">int</span> radix)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="JDK5自动装箱和拆箱"><a href="#JDK5自动装箱和拆箱" class="headerlink" title="JDK5自动装箱和拆箱"></a>JDK5自动装箱和拆箱</h3><p>自动装箱：把基本类型转换为包装类类型</p><p>自动拆箱：把包装类类型转换为基本类型</p><p><strong>注意：</strong></p><p>在使用Integer x = null;代码机会出现NullPointerException，建议先判断是否为null，然后再使用</p><p>Integer的数据直接赋值，如果在-128到127之间，会直接从缓冲池里获取数据</p><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>Character类在对象中包装一个基本类型char的值</p><p>该类提供了几种方法，以确定字符的类型（小写字母，数字，等等），并将字符从大写转换成小写，反之亦然</p><p>构造方法：<code>Character(char value)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUpperCase</span><span class="params">(<span class="keyword">char</span> ch)</span>:<span class="comment">//判断给定的字符是否是大写字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLowerCase</span><span class="params">(<span class="keyword">char</span> ch)</span>:<span class="comment">//判断给定的字符是否是小写字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> ch)</span>:<span class="comment">//判断给定的字符是否是数字字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">toUpperCase</span><span class="params">(<span class="keyword">char</span> ch)</span>:<span class="comment">//把给定的字符转换为大写字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">toLowerCase</span><span class="params">(<span class="keyword">char</span> ch)</span>:<span class="comment">//把给定的字符转换为小写字符</span></span></span><br></pre></td></tr></table></figure><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>用于数学运算的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> E</span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span>:<span class="comment">//绝对值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> a)</span>:<span class="comment">//向上取整</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> a)</span>:<span class="comment">//向下取整</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>:<span class="comment">//最大值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span>:<span class="comment">//a的b次幂</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">()</span>:<span class="comment">//随机数[0.0,1.0)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">round</span><span class="params">(<span class="keyword">float</span> a)</span>:<span class="comment">//四舍五入</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> a)</span>:<span class="comment">//正平方根</span></span></span><br></pre></td></tr></table></figure><h3 id="获取任意范围内的随机数"><a href="#获取任意范围内的随机数" class="headerlink" title="获取任意范围内的随机数"></a>获取任意范围内的随机数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入开始数:"</span>);</span><br><span class="line">    <span class="keyword">int</span> start = sc.nextInt();</span><br><span class="line">    System.out.println(<span class="string">"请输入结束数:"</span>);</span><br><span class="line">    <span class="keyword">int</span> end = sc.nextInt();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;<span class="number">100</span>;x++)&#123;</span><br><span class="line">      <span class="comment">//调用功能</span></span><br><span class="line">      <span class="keyword">int</span> num = getRandom(start,end);</span><br><span class="line">      <span class="comment">//输出结果</span></span><br><span class="line">      System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回值类型：int 参数列表int start，int end</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = (<span class="keyword">int</span>)(Math.random()*end)+start;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><p>产生随机数的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span>:<span class="comment">//没有给种子，用的是默认种子，是当前时间的毫秒值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">(<span class="keyword">long</span> seed)</span>:<span class="comment">//给出指定的种子</span></span></span><br><span class="line"><span class="function"><span class="comment">//给定种子后，每次得到的随机数是相同的</span></span></span><br><span class="line"><span class="function"><span class="comment">//成员方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span>:<span class="comment">//返回的是int范围内的随机数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> n)</span>:<span class="comment">//返回的是[0,n)范围内的随机数</span></span></span><br></pre></td></tr></table></figure><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p>System类包含一些有用的类字段和方法，它不能被实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span>:<span class="comment">//运行垃圾回收器，等同于调用了Runtime里的gc()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span>:<span class="comment">//终止当前正在运行的Java虚拟机，参数用作状态码；根据惯例，非0的状态码表示异常终止</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span>:<span class="comment">//返回以毫秒为单位的当前时间</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">arraycopy</span><span class="params">(Object src,<span class="keyword">int</span> srcPos,Object dest,<span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span>:<span class="comment">//从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束</span></span></span><br></pre></td></tr></table></figure><h2 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h2><p>可以让超过Integer范围内的数据进行运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">BigInteger(String val);</span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">add</span><span class="params">(BigInteger val)</span>:<span class="comment">//加</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">subtract</span><span class="params">(BigInteger val)</span>:<span class="comment">//减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">multiply</span><span class="params">(BigInteger val)</span>:<span class="comment">//乘</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">divide</span><span class="params">(BigInteger val)</span>:<span class="comment">//除</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger[] <span class="title">divideAndRemainder</span><span class="params">(BigInteger val)</span>:<span class="comment">//返回商和余数的数组</span></span></span><br></pre></td></tr></table></figure><h2 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h2><p>不可变的、任意精度的有符号十进制数，可以解决数据丢失问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BigDecimal</span><span class="params">(String val)</span></span>;</span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">add</span><span class="params">(BigDecimal val)</span>:<span class="comment">//加</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">subtract</span><span class="params">(BigDecimal augend)</span>:<span class="comment">//减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">multiply</span><span class="params">(BigDecimal subtrahend)</span>:<span class="comment">//乘</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">divide</span><span class="params">(BigDecimal multipicand)</span>:<span class="comment">//除</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal[] <span class="title">divide</span><span class="params">(BigDecimal divisor,<span class="keyword">int</span> scale,<span class="keyword">int</span> roundingMode)</span>:<span class="comment">//返回商和余数的数组</span></span></span><br></pre></td></tr></table></figure><h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><p>表示特定的瞬间，精确到毫秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">Date():<span class="comment">//根据当前的默认毫秒值创建日期对象</span></span><br><span class="line">Date(<span class="keyword">long</span> date):<span class="comment">//根据给定的毫秒值创建日期对象</span></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span>:<span class="comment">//获取时间，以毫秒为单位</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">long</span> time)</span>:<span class="comment">//设置时间</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//从Date得到一个毫秒值</span></span></span><br><span class="line"><span class="function">  <span class="comment">//getTime()</span></span></span><br><span class="line"><span class="function"><span class="comment">//把一个毫秒值转换为Date</span></span></span><br><span class="line"><span class="function">  <span class="comment">//构造方法</span></span></span><br><span class="line"><span class="function">  <span class="comment">//setTime(long time)</span></span></span><br></pre></td></tr></table></figure><h3 id="DateFormat类实现日期和字符串的相互转换"><a href="#DateFormat类实现日期和字符串的相互转换" class="headerlink" title="DateFormat类实现日期和字符串的相互转换"></a>DateFormat类实现日期和字符串的相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Date --&gt; String(格式化)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">format</span><span class="params">(Date date)</span></span>;</span><br><span class="line"><span class="comment">//String --&gt;Date(解析)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String source)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DateFormat:可以进行日期和字符串的格式化和解析，但是由于是抽象类，所以使用具体子类SimpleDateFormat</span></span><br><span class="line"><span class="comment">//SimpleDateFormat的构造方法</span></span><br><span class="line">SimpleDateFormat():<span class="comment">//默认模式</span></span><br><span class="line">SimpleDateFormat(String pattern):<span class="comment">//给定的模式</span></span><br><span class="line"><span class="comment">//这个模式的字符串(年-y，月-M，日-d，时-H，分-m，秒-s)</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date date = new Date();</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);</span><br><span class="line">String str = sdf.format(date);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p><code>parse()</code>:解析字符串</p><h2 id="UUID类"><a href="#UUID类" class="headerlink" title="UUID类"></a>UUID类</h2><p>是一种生成无重复字符串的一种程序类，这种程序类的主要功能是根据时间戳实现一个自动的无重复的字符串定义</p><p><code>UUID.randomUUID();</code></p><h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><p>进行null的相关处理，在以前进行程序开发的时候，如果为了防止程序中出现空指向的异常，可以以追加有null的验证。</p><p>在引用接受的一方往往都是被动的进行判断，在Java中提供Optional这个类，可以实现null的处理操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt;empty(); <span class="comment">//返回空数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;<span class="comment">//获取数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span></span>; <span class="comment">//保存数据，但是不允许出现null.如果在保存数据时候存在null，则会抛出NullPointerException异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span></span>; <span class="comment">//保存数据，允许为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span></span>; <span class="comment">//空的时候返回其它数据</span></span><br></pre></td></tr></table></figure><h2 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h2><p>解决线程同步问题<br>在ThreadLocal类里面存放两个对象，一个线程对象，一个数据对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作数据对象：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span></span>;<span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span>;<span class="comment">//设置数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;<span class="comment">//取出数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;<span class="comment">//删除数据</span></span><br></pre></td></tr></table></figure><p>每一个线程通过ThreadLocal只允许保存一个数据</p><h2 id="Base64加密与解密"><a href="#Base64加密与解密" class="headerlink" title="Base64加密与解密"></a>Base64加密与解密</h2><p>Base64类里面有两个内部类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Base64.Encoder:进行加密处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] encode(<span class="keyword">byte</span>[] src);</span><br><span class="line"><span class="comment">//Base64.Decoder:进行解密处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] decode(String src);</span><br></pre></td></tr></table></figure><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><p>比较器</p><p><code>public int ComparTo();</code></p><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p>挽救型比较器</p><h2 id="CharSequence接口"><a href="#CharSequence接口" class="headerlink" title="CharSequence接口"></a>CharSequence接口</h2><p>三个常用子类<br>String StringBuffer StringBuilder</p><p>描述的是一个字符串</p><h2 id="AutoCloseable接口"><a href="#AutoCloseable接口" class="headerlink" title="AutoCloseable接口"></a>AutoCloseable接口</h2><p>日资源开发的处理，以实现资源的自动关闭（释放资源)<br>jdk1.7后，该接口只有一个方法:</p><p><code>public void close() throws Exception</code></p><p>除了实现这个接口，还得实现异常处理，要跟异常捆绑在一起</p><h2 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h2><p>描述运行时状态，是唯一一个与JVM运行状态有关的类，并且都会默认提供有一个该类的实例化对象<br>构造方法私有，单类设计模式，<br><code>getRuntime()</code> 获取实例化对象<br><code>availableProcessors()</code> 方法可以获取本机的CPU内核数<br><code>maxMermory()</code> 获取最大内存空间，默认配置本机系统内存的四分之一<br><code>totalMemory()</code> 获取可用内存空间，默认配置本机系统内存六十四分之一<br><code>freeMemory()</code> 获取空闲内存空间<br><code>gc()</code> 手工进行GC处理</p><p>垃圾收集器，是可以由系统自动调用垃圾释放功能，也可以自己手工调用</p><h2 id="Cleanner类"><a href="#Cleanner类" class="headerlink" title="Cleanner类"></a>Cleanner类</h2><p>进行finialize()方法替代<br>在新一代的清除回收处理的过程之中，更多情况下考虑的是多线程的使用，即，为了防止有可能造成的延迟处理，许多对象回收前的处理都是单独通过一个线程完成的</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE常用API
    
    </summary>
    
      <category term="JavaSE常用API" scheme="https://www.ysmjjsy.com/categories/JavaSE%E5%B8%B8%E7%94%A8API/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-IO流</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-IO/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-IO/</id>
    <published>2017-08-24T16:00:00.000Z</published>
    <updated>2019-09-11T03:57:38.379Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 11:58:46 GMT+0800 (GMT+08:00) --><h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>我们要想实现IO的操作，就必须知道硬盘上文件的表现形式</p><p>而Java提供了一个类File供我们使用</p><p>File：文件和目录（文件夹）路径名的抽象表示形式</p><h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File(String pathname);<span class="comment">//根据一个路径得到File对象</span></span><br><span class="line">File(String parent,String child);<span class="comment">//根据一个目录和一个子文件/目录得到File对象</span></span><br><span class="line">File(File parent,String child);<span class="comment">//根据一个父File对象和一个子文件/目录得到File对象</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"E:\\demo\\a.txt"</span>);</span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">"E:\\demo"</span>,<span class="string">"a.txt"</span>);</span><br><span class="line">    File file3 = <span class="keyword">new</span> File(<span class="string">"E:\\demo"</span>);</span><br><span class="line">    File file4 = <span class="keyword">new</span> File(file3,<span class="string">"a.txt"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="File类的方法"><a href="#File类的方法" class="headerlink" title="File类的方法"></a>File类的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span></span>;<span class="comment">//创建文件，如果存在这样的文件，就不创建了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span></span>;<span class="comment">//创建文件夹，如果存在这样的文件，就不创建了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span></span>;<span class="comment">//创建文件夹，如果父文件夹不存在，会帮你创建出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//如果创建文件或则文件夹忘了写盘符路径，默认在项目路径下</span></span><br><span class="line"><span class="comment">//Java中的删除不走回收站</span></span><br><span class="line"><span class="comment">//要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重命名功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File dest)</span></span>;</span><br><span class="line"><span class="comment">//如果路径名相同，就是改名</span></span><br><span class="line"><span class="comment">//如果路径名不同，就是改名并剪切</span></span><br><span class="line"><span class="comment">//路径以盘符开始：绝对路径 C:\\a.txt</span></span><br><span class="line"><span class="comment">//路径不以盘符开始：相对路径 a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span></span>;<span class="comment">//判断是否是目录</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span></span>;<span class="comment">//判断是否是文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;<span class="comment">//判断是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span></span>;<span class="comment">//判断是否可读</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span></span>;<span class="comment">//判断是否可写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">()</span></span>;<span class="comment">//判断是否隐藏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAbsolutePath</span><span class="params">()</span></span>;<span class="comment">//获取绝对路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span></span>;<span class="comment">//获取相对路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;<span class="comment">//获取名称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span></span>;<span class="comment">//获取长度，字节数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span></span>;<span class="comment">//获取最后一次的修改时间，毫秒值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] list();<span class="comment">//获取指定目录下的所有文件或者文件夹的名称数组</span></span><br><span class="line"><span class="keyword">public</span> File[] listFiles();<span class="comment">//获取指定目录下的所有文件或者文件夹的File数组</span></span><br><span class="line"><span class="comment">//要想实现这个效果，就必须学习一个接口：文件过滤器</span></span><br><span class="line"><span class="keyword">public</span> String[] list(FilenameFilter filter);</span><br><span class="line"><span class="keyword">public</span> File[] listFiles(FilenameFilter filter);</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>方法定义中调用方法本身的现象</p><p>程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调；</p><p>用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过；</p><p>程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。递归是一种应用非常广泛的算法（或者编程技巧）。递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。</p><p>递归需要满足的三个条件：1. 一个问题的解可以分解为几个子问题的解；2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样；3. 存在递归终止条件。</p><h3 id="递归的三个条件："><a href="#递归的三个条件：" class="headerlink" title="递归的三个条件："></a><strong>递归的三个条件：</strong></h3><ol><li>边界条件</li><li>递归前进段</li><li>递归返回段</li></ol><p><strong>当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</strong></p><h3 id="递归注意实现"><a href="#递归注意实现" class="headerlink" title="递归注意实现"></a>递归注意实现</h3><p>要有出口，否则就是死递归</p><p>次数不能太多，否则就内存溢出</p><p>构造方法不能递归使用</p><h3 id="递归5的阶乘"><a href="#递归5的阶乘" class="headerlink" title="递归5的阶乘"></a>递归5的阶乘</h3><p><img src="/category/JavaSE-IO/dig.png" alt="递归5的阶乘"></p><p><img src="/category/JavaSE-IO/dig2.png" alt="递归5的阶乘"></p><h3 id="递归问题"><a href="#递归问题" class="headerlink" title="递归问题"></a>递归问题</h3><p><strong>问题：N级台阶（比如100级），每次可走1步或者2步，求总共有多少种走法？</strong></p><p>分析：如果有大于2级的n级台阶，那么假如第一次跳一级台阶，剩下还有n-1级台阶，有f(n-1)种跳法，假如第一次条2级台阶，剩下n-2级台阶，有f(n-2)种跳法。这就表示f(n)=f(n-1)+f(n-2)，即斐波那契数列。假设只有一个台阶，那么只有一种跳法，那就是一次跳一级，f(1)=1；如果有两个台阶，那么有两种跳法，第一种跳法是一次跳一级，第二种跳法是一次跳两级，f(2)=2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//费波纳契数列变形，求n个台阶的走法，递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>)+f(n+<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</p><p><strong>递归代码要警惕重复计算</strong></p><p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//费波纳契数列变形，求n个台阶的走法，递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="comment">//新建一个HashMap，用来保存已经求过的f(n)，避免重复计算</span></span><br><span class="line">  HashMap&lt;Integer,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//求f(n)时，先判断map中是否已经存在，如果存在直接取值</span></span><br><span class="line">  <span class="keyword">if</span>(hashMap.containsKey(n))&#123;</span><br><span class="line">    <span class="keyword">return</span> hashMap.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ret = f(n-<span class="number">1</span>)+f(n+<span class="number">2</span>);</span><br><span class="line">  hashMap.put(n,ret);<span class="comment">//将f(n)存进map中</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归代码要警惕堆栈溢出</strong></p><p>我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题，递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;<span class="comment">//全局变量，表示递归的深度</span></span><br><span class="line"><span class="comment">//费波纳契数列变形，求n个台阶的走法，递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  ++depth;</span><br><span class="line">  <span class="keyword">if</span>(depth&gt;<span class="number">1000</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"超过设定深度了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//新建一个HashMap，用来保存已经求过的f(n)，避免重复计算</span></span><br><span class="line">  HashMap&lt;Integer,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//求f(n)时，先判断map中是否已经存在，如果存在直接取值</span></span><br><span class="line">  <span class="keyword">if</span>(hashMap.containsKey(n))&#123;</span><br><span class="line">    <span class="keyword">return</span> hashMap.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ret = f(n-<span class="number">1</span>)+f(n+<span class="number">2</span>);</span><br><span class="line">  hashMap.put(n,ret);<span class="comment">//将f(n)存进map中</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>怎么将递归代码改写为非递归代码？</strong></p><p>递归本身就是借助栈来实现的，如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，便可以将递归改成非递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//费波纳契数列变形，求n个台阶的走法，非递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="comment">//n = 1或n = 2,直接返回f(1) = 1,f(2) = 2</span></span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;<span class="comment">//ret中存储的结果f(n)</span></span><br><span class="line">  <span class="keyword">int</span> prepre = <span class="number">1</span>;<span class="comment">//prepre存储的值是f(n-2),初始值是f(1)=1</span></span><br><span class="line">  <span class="keyword">int</span> pre = <span class="number">2</span>;<span class="comment">//pre存储的值是f(n-1),f(2)=2</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="comment">//手动模拟栈的过程</span></span><br><span class="line">    ret = prepre + pre;</span><br><span class="line">    prepre = pre;</span><br><span class="line">    pre = pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归:文件目录</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务：计算一个文件夹大小：累加文件的大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gyf</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归:文件目录</span></span><br><span class="line">        <span class="comment">/**打印出a目录所有文件名称，包括子文件夹的文件*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.创建目录对象</span></span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">"C:/Users/10301/Desktop/a"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.打印目录的子文件</span></span><br><span class="line">        printSubFile(dir);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSubFile</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印目录的子文件</span></span><br><span class="line">        File[] subfiles = dir.listFiles();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(File f : subfiles)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f.isDirectory())&#123;<span class="comment">//文件夹</span></span><br><span class="line">                printSubFile(f);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//文件</span></span><br><span class="line">                System.out.println(f.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习:从键盘输入接收一个文件夹路径,打印出该文件夹下所有的.jpg文件名</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//练习:从键盘输入接收一个文件夹路径,打印出该文件夹下所有的.jpg文件名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取文件路径</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入一个文件夹路径..."</span>);</span><br><span class="line">        String path = scanner.nextLine();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.把路径封装成File对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">            System.out.println(<span class="string">"此路径对应的文件不存在"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!file.isDirectory())&#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入文件夹路径，而不文件路径"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.遍历文件夹下的子文件</span></span><br><span class="line">        printSubFile(file);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSubFile</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印目录的子文件</span></span><br><span class="line">        File[] subfiles = dir.listFiles();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(File f : subfiles)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f.isDirectory())&#123;<span class="comment">//文件夹</span></span><br><span class="line">                printSubFile(f);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//文件</span></span><br><span class="line">                <span class="keyword">if</span>(f.getName().endsWith(<span class="string">".jpg"</span>))&#123;</span><br><span class="line">                    System.out.println(f.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p><img src="/category/JavaSE-IO/io.png" alt="IO流"></p><p>IO流用来处理设备之间的数据传输,Java对数据的操作是通过流的方式<br>Java用于操作流的类都在IO包中，上传文件和下载文件</p><p>Java对数据的操作是通过流的方式</p><p>Java用于操作流的对象都在IO包中</p><p>Stream是java的一个类，专门用于处理程序个外部设备的输入输出（简称IO），这里的外部设备可以是文件、键盘或者网络。基本所有的流都在这个包中。实际上流就是数据在程序和外部设备之间的管道，而类的方法则是管道上的各种按钮。</p><p><strong>所以为什么需要流呢？</strong></p><p>在数据量很大的情况下，节省时间<br>内存有限，需要“分时分步”进行传输<br>带宽有限<br>而stream可以分次传输数据，一点一点传，这就是Stream存在的意义。这里可以参照腾X的下载软件，每次下载一个文件都是在本地建一个cache文件，然后把文件分成很多个部分缓存到本地，等缓存完毕再以.qlv形式的文件保存在硬盘中。</p><p><strong>流的重要性：</strong></p><p>流是java的一个类，但类并不是流<br>流是单向的，要么input，要么output。<br>流不会改变原数据，也不能存储数据<br>Java的Stream有很多个子类，可以划分为若干类</p><p><strong>按流向分为两种：</strong></p><p>输入流（读取数据）<br>输出流（写数据）</p><p>Java流的传输只有一个方向，所以我们把从外部设备流向程序的数据流称为输入流。</p><p>反之，把程序数据流向外部设备的流称为输出流。</p><p><strong>流按操作类型分为两种</strong>:</p><p>字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的<br>字符流 : 字符流只能操作纯字符数据，比较方便。</p><h2 id="四大基本Stream"><a href="#四大基本Stream" class="headerlink" title="四大基本Stream"></a>四大基本Stream</h2><p>Java流有很多种，但是基本都是继承自四个基本流（<em>这四个类是抽象类，不能直接实例化new</em>）：</p><ul><li>InputStream：输入字节流</li><li>OutputStream：输出字节流</li><li>Reader：输入字符流</li><li>Writer：输出字符流</li></ul><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>字节流以字节（8bit）为单位，字节流能处理所有类型的数据（如图片、avi等）</p><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p><img src="/category/JavaSE-IO/in1.png" alt="InputStream"></p><p>字节输入流</p><ol><li>InputStream 是所有的输入字节流的父类，它是一个抽象类。用来读取数据。</li><li>ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。</li><li>ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）</li></ol><p><strong>字节输入流操作步骤:</strong></p><p>创建字节输出流对象</p><p>调用read()方法读取数据，并把数据显示在控制台</p><p>释放资源</p><p><strong>计算机如何识别什么时候把两个字节转换为一个中文？</strong></p><p>第一个字节肯定是负数</p><p>第二个字节常见的是负数，可能有正数</p><p>当看到负数就把两个字节拼在一起</p><h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><p><strong>文件输入流</strong></p><p>FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream 用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用 FileReader</p><p><strong>构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream(File file)</span><br><span class="line">FileInputStream(String name)</span><br></pre></td></tr></table></figure><p><strong>成员方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> 从此输入流中读取一个数据字节。</span></span><br></pre></td></tr></table></figure><p><strong>案例:读取一个txt文件数据(方法一)</strong></p><ul><li>1.FileInputStream用于读取文件数据，在构造方法中传入文件对象</li></ul><ul><li>2.构造方法，有可能抛出文件找不到的异常</li></ul><ul><li>3.read方法是每次读取一个字节的数据,把字节转成int返回<ul><li>读取数据也会抛出异常，比如突然文件某部份数据损坏了</li><li>读取的数据是文件编码的表值(ascii,GBK,unicode)</li><li>ascii是包含在GBK或者unicode中的</li><li>如果读取数据到最后，会返回一个-1（代表读完数据了）</li></ul></li></ul><ul><li>4.文件不用后，要关闭输入流，避免占用资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取txt文件内容</span></span><br><span class="line"><span class="comment"> * 1.通过FileInputStream来读取txt文件内容</span></span><br><span class="line"><span class="comment"> * 2.读取内容通过read方法，</span></span><br><span class="line"><span class="comment"> *   》read方法每次读文件1个字节(byte),把byte转成int返回</span></span><br><span class="line"><span class="comment">      》当读到后的时候，返回-1，-1表示读取文件结束</span></span><br><span class="line"><span class="comment">   3.当读完文件后，这个输入流要关闭，释放资源</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//FileNotFoundException fnfe;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//案例：读取txt文件内容</span></span><br><span class="line">        <span class="comment">//1.创建一个文件对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.创建一个文件输入流【读取文件数据】对象</span></span><br><span class="line">        FileInputStream fis1 = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//再创建一个文件输入 流对象 </span></span><br><span class="line">        FileInputStream fis2 = <span class="keyword">new</span> FileInputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.读取a.txt的数据</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.read方法每次读文件1个字节(byte),把byte转成int返回</span></span><br><span class="line"><span class="comment">         * 2.当读到后的时候，返回-1，-1读取文件结束</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(fis1.read());</span><br><span class="line">        System.out.println(fis1.read());</span><br><span class="line">        System.out.println(fis1.read());</span><br><span class="line">        System.out.println(fis1.read());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        fis1.close();</span><br><span class="line">        fis2.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例:读取一个txt文件数据(方法二)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个文件对象</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"abc.txt"</span>);</span><br><span class="line">System.out.println(file.getAbsolutePath());</span><br><span class="line">                </span><br><span class="line"><span class="comment">//2.创建一个文件输入流</span></span><br><span class="line">FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="comment">//while循环里，每次读取字节赋值给b</span></span><br><span class="line"><span class="keyword">while</span>((b = inputStream.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试题:read()方法读取的是一个字节,为什么返回是int,而不是byte ？</strong></p><blockquote><p>因为字节输入流可以操作任意类型的文件,比如图片音频等,这些文件底层都是以二进制形式的存储的,如果每次读取都返回byte,有可能在读到中间的时候遇到111111111 那么这11111111是byte类型的-1,我们的程序是遇到-1就会停止不读了,后面的数据就读不到了,所以在读取的时候用int类型接收,如果11111111会在其前面补上 24个0凑足4个字节,那么byte类型的-1就变成int类型的255了这样可以保证整个数据读完,而结束标记的-1就是int类型</p></blockquote><p><img src="/category/JavaSE-IO/f.png" alt="F"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//面试题:read()方法读取的是一个字节,为什么返回是int,而不是byte ？</span></span><br><span class="line">        <span class="comment">//如果使用FileInputStream读取图片数据</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 00010111 00010111 00010111 00010111</span></span><br><span class="line"><span class="comment">         * 00010111 11111111 00010111 00010111</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * byte:11111111 表示的-1</span></span><br><span class="line"><span class="comment">         * int:00000000 00000000 00000000 11111111  byte转成int 补0 了不是-1   因此往后读数据</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 为什么11111111是表示-1？</span></span><br><span class="line"><span class="comment">         * 因为计算机是以补码的方式计算</span></span><br><span class="line"><span class="comment">         * 补码： 11111111 （-1）</span></span><br><span class="line"><span class="comment">         * 反码： 11111110</span></span><br><span class="line"><span class="comment">         * 原码:  10000001</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 假如使用FileInputStream读取图片的时候，</span></span><br><span class="line"><span class="comment">         * 图片中间有一段数据刚好是 11111111，这八个一表示的-1，用byte接收</span></span><br><span class="line"><span class="comment">         * java程序如果读取的是-1，后面的数据就不读取</span></span><br><span class="line"><span class="comment">         * 如果把8个1转成int,那就是00000000 00000000 00000000 11111111,这个表示255，</span></span><br><span class="line"><span class="comment">         * 就不是-1，归避后面数据没有读取问题</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="DataInputSteam"><a href="#DataInputSteam" class="headerlink" title="DataInputSteam"></a>DataInputSteam</h5><p>数据输入流</p><p>操作基本数据类型</p><h5 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h5><p>内存输入流</p><p>操作字节数组</p><h5 id="SequenceInputStream-序列流"><a href="#SequenceInputStream-序列流" class="headerlink" title="SequenceInputStream 序列流"></a>SequenceInputStream 序列流</h5><p><strong>什么是序列流</strong></p><blockquote><p>序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推.</p></blockquote><p>案例：使用字节流把两个件数据写到另一个文件</p><p>案例：使用序列流把两个件数据写到另一个文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.SequenceInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//SequenceInputStream 序列流</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * InputStream:输入流</span></span><br><span class="line"><span class="comment">         * Sequence:序列 连续</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, </span></span><br><span class="line"><span class="comment">         * 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        test2();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//需求：a.txt,b.txt 依次写c.txt</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建序列流</span></span><br><span class="line">        FileInputStream fis1 = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileInputStream fis2 = <span class="keyword">new</span> FileInputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">        SequenceInputStream sis = <span class="keyword">new</span> SequenceInputStream(fis1, fis2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建输出流</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"c.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//读写 </span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((b = sis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fis2.close();</span><br><span class="line">        sis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//需求：a.txt,b.txt 依次写c.txt</span></span><br><span class="line">        <span class="comment">//1.创建两个输入流</span></span><br><span class="line">        FileInputStream fis1 = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileInputStream fis2 = <span class="keyword">new</span> FileInputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.创建一个输出流</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"c.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.先把a文件的内容写到c.txt</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((b=fis1.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fos.write(<span class="string">"\r\n"</span>.getBytes());<span class="comment">//换行</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.再把b文件内容写到c.txt</span></span><br><span class="line">        <span class="keyword">while</span>((b=fis2.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.关流</span></span><br><span class="line">        fis1.close();</span><br><span class="line">        fis2.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>序列流整合多个字节流（了解）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.SequenceInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//SequenceInputStream序列流使用二</span></span><br><span class="line">        <span class="comment">//需求，把a.txt b.txt c.txt 的内容拷贝到d.txt</span></span><br><span class="line">        <span class="comment">//1.Vector是集合</span></span><br><span class="line">        Vector&lt;InputStream&gt; vector = <span class="keyword">new</span> Vector&lt;InputStream&gt;();</span><br><span class="line">        vector.add(<span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>));</span><br><span class="line">        vector.add(<span class="keyword">new</span> FileInputStream(<span class="string">"b.txt"</span>));</span><br><span class="line">        vector.add(<span class="keyword">new</span> FileInputStream(<span class="string">"c.txt"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.Enumeration枚举</span></span><br><span class="line">        Enumeration&lt;InputStream&gt; e = vector.elements();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.序列流</span></span><br><span class="line">        SequenceInputStream sis = <span class="keyword">new</span> SequenceInputStream(e);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.创建输出流</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//读写 </span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((b = sis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><ol><li>OutputStream 是所有的输出字节流的父类，它是一个抽象类。</li><li>ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。PipedOutputStream 是向与其它线程共用的管道中写入数据，</li><li>ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。</li></ol><p><strong>字节输出流操作步骤:</strong></p><p>创建字节输出流对象</p><p>写数据</p><p>释放资源</p><p>write(int b):写一个字节</p><p>write(byte[] b):写一个字节数组</p><p>write(byte[] b,int off,int len):写一个字节数组的一部分</p><p><strong>如何实现数据的换行？</strong></p><p>实现换行不同操作系统换行符号识别不一样</p><p>Windows:\r\n</p><p>Linux:\n</p><p>Mac:\r</p><h5 id="FileInputStream-1"><a href="#FileInputStream-1" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><ul><li>文件输出流是用于将数据写入 File 的输出流。</li><li>FileOutputStream 用于写入诸如图像数据之类的原始字节的流。</li><li>查看文档的构造方法和成员方法</li></ul><p><strong>创建字节输出流做了几件事情：</strong></p><p>调用系统功能去创建文件</p><p>创建fos对象</p><p>把fos对象指向这个文件</p><p>//关闭此文件输出流并释放与此流有关的系统资源</p><p>//让流对象变成垃圾，这样就可以被垃圾回收器回收</p><p>//通知系统去释放跟该文件相关的资源</p><p>fos.close();</p><p><strong>如何实现数据的追加写入？</strong></p><p>FileOutPutStream构造方法的第二个参数:true</p><p>写在末尾处可以实现追加</p><p><strong>案例:往一个abc.txt文件写数据（知识点）</strong></p><ul><li>new FileOutputStream(file)这种构造方法，会把以前的内容都删除</li><li>new FileOutputStream(file,true);这种构造方法能追加内容</li><li>FileNotFoundException是IOException的子类</li><li>write(int b)，写数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*      FileOutputStream:表示文件输出流，用于往文件写内容</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      构造方法</span></span><br><span class="line"><span class="comment"> *      FileOutputStream(String name)</span></span><br><span class="line"><span class="comment"> *      FileOutputStream(File file) </span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      方法</span></span><br><span class="line"><span class="comment"> *      write(int b);//每次写一个字节</span></span><br><span class="line"><span class="comment"> *      write(byte[] b) ;//一次写多个字节</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//案例：往b.txt 写个内容</span></span><br><span class="line">        <span class="comment">//1.创建文件输出流对象</span></span><br><span class="line">        <span class="comment">//FileOutputStream fos = new FileOutputStream("b.txt");</span></span><br><span class="line">        OutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);<span class="comment">//多态写法</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.写数据 </span></span><br><span class="line"><span class="comment">//      fos.write(97);//a</span></span><br><span class="line"><span class="comment">//      fos.write(98);//b</span></span><br><span class="line"><span class="comment">//      fos.write(99);//c</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一次性写多个字节</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        fos.write(bytes);</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例:拷贝图片和音频</strong></p><ul><li>原理，使用输入流读取数据，使用输出流写数据</li><li>画图讲原理和性能<br>每次都读一次字节，太慢，效率太低</li></ul><p><img src="/category/JavaSE-IO/o1.png" alt="o"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//案例:拷贝图片</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 目的：结合输入流和输出流使用</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 图片路径：C:\Users\10301\Desktop\a\cm.jpg</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.先创建输入流对象和输出流对象</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/Users/10301/Desktop/a/cm.jpg"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"C:/Users/10301/Desktop/a/cm2.jpg"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.通过输入流读取图片的数据</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( (b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//3.通过输出流写入图片数据</span></span><br><span class="line">            fos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">        System.out.println(<span class="string">"图片拷贝成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字节数组拷贝之available()方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//案例:拷贝图片【优化一、这种方式在大文件下不建议使用】</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 前面拷贝图片问题：每次只读一个字节，写入的时候也是一个字节一个字节写</span></span><br><span class="line"><span class="comment">         *                  如果有10W个字节，就要读10W次，写10W次</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 字节数组拷贝之available()方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1.文件输入流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/Users/10301/Desktop/a/cm.jpg"</span>);</span><br><span class="line">        <span class="keyword">int</span> size = fis.available();<span class="comment">//是返回文件的长度【字节为单位】</span></span><br><span class="line">        System.out.println(<span class="string">"文件的大小:"</span> + size);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.现在一次读文件大小的字节</span></span><br><span class="line">        <span class="comment">//2.1定义一个字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[size];<span class="comment">//相当于现在是一个空杯子</span></span><br><span class="line">        <span class="comment">//2.2 把数据读到字节数组中</span></span><br><span class="line">        <span class="keyword">int</span> r = fis.read(bytes);<span class="comment">//这个方法的返回值读取到的实际长度</span></span><br><span class="line">        System.out.println(<span class="string">"r:"</span> + r);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.把字节数组一次性写入到文件</span></span><br><span class="line">        <span class="comment">//3.1 输出流</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"C:/Users/10301/Desktop/a/cm-副本.jpg"</span>);</span><br><span class="line">        <span class="comment">//3.2 写数据</span></span><br><span class="line">        fos.write(bytes);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例:正确的拷贝文件的方法（杯子思想、缓冲思想）</strong></p><ol><li><p>输入流读取数据的方法:</p><p>read(byte[] b) 读取指定字节数的数据</p></li></ol><ol><li><p>输出流写数据的方法:</p><p>write(byte[] b)</p><p>write(byte[] b, int off, int len)写出有效的字节个数</p></li></ol><p><img src="/category/JavaSE-IO/o2.png" alt="o"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 杯子思想,缓冲思想</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gyf</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//案例:拷贝图片【优化二、这种方式开发中建议经常使用】</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.每次只读一个字节，又觉得太慢</span></span><br><span class="line"><span class="comment">         * 2.一次性读一个文件的所有数据，又怕内存装不下</span></span><br><span class="line"><span class="comment">         *   内存只有2G,视频3G,这样就会内存溢出</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 3.最终解决方法：折中，定义每次读8KB</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.输入流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/Users/10301/Desktop/a/cm.jpg"</span>);</span><br><span class="line">        <span class="comment">//2.输出流</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"C:/Users/10301/Desktop/a/cm-副本2.jpg"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.定义个8kb字节数组，也叫缓冲区流</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes =  <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( (len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//4.写入文件</span></span><br><span class="line">            fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"读取的次数:"</span> + i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.关闭流</span></span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="DataOutputSteam"><a href="#DataOutputSteam" class="headerlink" title="DataOutputSteam"></a>DataOutputSteam</h5><p>数据输出流</p><p>操作基本数据类型</p><p><strong>什么是数据输入输出流</strong></p><p>DataInputStream, DataOutputStream可以按照基本数据类型大小读写数据<br>例如:<br>按Long大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//DataOutputStream&amp;DataInputStream 数据输入输出流</span></span><br><span class="line"><span class="comment">/*      DataInputStream, DataOutputStream可以按照基本数据类型大小读写数据 </span></span><br><span class="line"><span class="comment">        例如按Long大小写出一个数字, 写出时该数据占8字节. </span></span><br><span class="line"><span class="comment">        读取的时候也可以按照Long类型读取, 一次读取8个字节.*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读3个long数据</span></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>));</span><br><span class="line">        System.out.println(dis.readLong());<span class="comment">//读8个字节</span></span><br><span class="line">        System.out.println(dis.readLong());<span class="comment">//读8个字节</span></span><br><span class="line">        System.out.println(dis.readLong());<span class="comment">//读8个字节</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> a = <span class="number">997</span>;</span><br><span class="line">        <span class="keyword">long</span> b = <span class="number">998</span>;</span><br><span class="line">        <span class="keyword">long</span> c = <span class="number">999</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用FileOutputStream没法写入long类型数据</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        <span class="comment">//byte -128~127 0~255</span></span><br><span class="line"><span class="comment">/*      fos.write(997);只会写一个字节，不会写4个字节</span></span><br><span class="line"><span class="comment">        fos.write(998);</span></span><br><span class="line"><span class="comment">        fos.write(999);*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//fos.wr</span></span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(fos);</span><br><span class="line">        dos.writeLong(a);<span class="comment">//写4个字节</span></span><br><span class="line">        dos.writeLong(b);</span><br><span class="line">        dos.writeLong(c);</span><br><span class="line">        </span><br><span class="line">        dos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h5><p>内存输出流</p><p>操作字节数组</p><p>此类实现了一个输出流，其中的数据被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。</p><p><img src="/category/JavaSE-IO/byte.png" alt="byte"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//ByteArrayOutputStream 字节数组输出流</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.前面学习的流-必需关于一个文件</span></span><br><span class="line"><span class="comment">         * FileOutputStream fos = new FileOutputStream("a.txt")</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 2.ByteArrayOutputStream 不需要关联文件</span></span><br><span class="line"><span class="comment">         *  </span></span><br><span class="line"><span class="comment">         * 3.此类实现了一个输出流，其中的数据被写入一个 byte 数组。</span></span><br><span class="line"><span class="comment">         *    缓冲区会随着数据的不断写入而自动增长。</span></span><br><span class="line"><span class="comment">         *   可使用 toByteArray() 和 toString() 获取数据。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment">//1.创建字节数组输出流对象</span></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//2.输入流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.写入输出流</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自动把字节数组 转成 字符串</span></span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line">        System.out.println(baos.toString(<span class="string">"UTF-8"</span>));<span class="comment">//指定编码格式的字符串</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取文件数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes, <span class="string">"UTF-8"</span>));<span class="comment">//指定编码格式的字符串</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.关流</span></span><br><span class="line">        fis.close();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试题：找bug</strong></p><blockquote><p>定义一个文件输入流,调用read(byte[] b)方法,将a.txt文件中的内容打印出来(byte数组大小限制为5)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">/*      面试题：找bug</span></span><br><span class="line"><span class="comment">        定义一个文件输入流,调用read(byte[] b)方法,</span></span><br><span class="line"><span class="comment">        将a.txt文件中的内容打印出来(byte数组大小限制为5)*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.文件输入流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.字节数组输出流</span></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.字节数组【缓冲区思想，杯子思想】</span></span><br><span class="line">        <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//通过字节缓冲数组写入</span></span><br><span class="line">            baos.write(arr, <span class="number">0</span>, len);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//把字节转成字符串</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 中文乱码问题</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(arr,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//内部会调用toString方法,把字节数组转成字符串</span></span><br><span class="line">        System.out.println(baos);</span><br><span class="line">        </span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对象操作流ObjecOutputStream-amp-ObjecInputStream-（了解）"><a href="#对象操作流ObjecOutputStream-amp-ObjecInputStream-（了解）" class="headerlink" title="对象操作流ObjecOutputStream&amp; ObjecInputStream （了解）"></a>对象操作流ObjecOutputStream&amp; ObjecInputStream （了解）</h5><p><strong>什么是对象操作流</strong></p><p>该流可以将一个对象写出, 或者读取一个对象到程序中. 也就是执行了序列化和反序列化的操作.</p><p><strong>归档（序列化） ：将对象存在一个文件解归档=反序列化：把一个文件解析出对象</strong></p><p>ObjecOutputStream对象输出流，把一个对象存储起来，存储的对象必须实现Serializable接口<br>ObjecInputStream对象输入流，把存的数据还原成一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.EOFException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInput;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//对象操作流ObjectOutputStream&amp; ObjectInputStream</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一、ObjectOutputStream：将一个对象写入文件</span></span><br><span class="line"><span class="comment">         *    1.如果使用这个类写入对象，这个对象需要序列化</span></span><br><span class="line"><span class="comment">         *    2.序列化就是让这个对象实现一个Serializable接口</span></span><br><span class="line"><span class="comment">         *    3.如果没实现Serializable接口，会抛异常NotSerializableException</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * 二、ObjectInputStream：从文件中读一个对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//案例：从文件中取出女朋友对象</span></span><br><span class="line">        <span class="comment">//1.创建一个对象输入流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"gf.data"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.读数据</span></span><br><span class="line">        GirlFriend gf1 = (GirlFriend) ois.readObject();</span><br><span class="line">        System.out.println(gf1);</span><br><span class="line">        GirlFriend gf2 = (GirlFriend) ois.readObject();</span><br><span class="line">        System.out.println(gf2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果没有数据可读了，强制读的时候报错了EOFException，</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(ois.readObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//案例：将对象直接存入文件</span></span><br><span class="line">        <span class="comment">//1.创建女朋友对象</span></span><br><span class="line">        GirlFriend gf1 = <span class="keyword">new</span> GirlFriend(<span class="string">"林志玲"</span>, <span class="number">1.78</span>);</span><br><span class="line">        GirlFriend gf2 = <span class="keyword">new</span> GirlFriend(<span class="string">"林心如"</span>, <span class="number">1.68</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.创建对象输出流</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"gf.data"</span>);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.往文件存入对象</span></span><br><span class="line">        oos.writeObject(gf1);</span><br><span class="line">        oos.writeObject(gf2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.关流</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlFriend</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GirlFriend</span><span class="params">(String name, <span class="keyword">double</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"GirlFriend [name="</span> + name + <span class="string">", height="</span> + height + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对象操作流优化</strong></p><p>为了方便读取多个对象<br>建立把将对象存储在集合中，然后将集合对象存入取出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//对象操作流优化-思路，存多个对象时，把对象存在list里面</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把女朋友对象存在List中，再把List写入文件【序列化/归档】</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.创建集合</span></span><br><span class="line">        List&lt;GirlFriend&gt; list = <span class="keyword">new</span> ArrayList&lt;GirlFriend&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.添加女朋友</span></span><br><span class="line">        list.add(<span class="keyword">new</span> GirlFriend(<span class="string">"林志玲"</span>, <span class="number">1.78</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> GirlFriend(<span class="string">"林心如"</span>, <span class="number">1.68</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> GirlFriend(<span class="string">"林嘉欣"</span>, <span class="number">1.58</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.把list存入文件</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"list.data"</span>));</span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.关流</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlFriend</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GirlFriend</span><span class="params">(String name, <span class="keyword">double</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"GirlFriend [name="</span> + name + <span class="string">", height="</span> + height + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInput;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//案例：从list.data 读取所有的女朋友对象【反序列化、解归档】</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.创建对象输入流</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"list.data"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.读取List对象</span></span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把obj转list</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        List&lt;GirlFriend&gt; list = (List&lt;GirlFriend&gt;)obj;</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(GirlFriend gf : list)&#123;</span><br><span class="line">            System.out.println(gf);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h5><p>序列化流：ObjectOutputStream</p><p>反序列化流：ObjectInputStream</p><p><strong>序列化数据后，再次修改类文件，读取数据会出现问题，如何解决？</strong></p><p>使用transient关键字声明不需要序列化的成员变量</p><p><strong>NotSerializableException：未序列化异常</strong></p><p>类通过实现java.io.Serializable接口以启用其序列化功能，未实现此接口的类将无法使其任何状态序列化或反序列化，该接口没有任何方法，类似这种没有方法的接口被称为标记接口</p><p><strong>Serializable接口的ID</strong></p><p>要归档或者序列化的对象必须实现Serializable接口才能被序列化<br>Serializable 中有个id，但ID不是一定有加的<br>SerialVersionUid，简言之，其目的是序列化对象版本控制，有关各版本反序列化时是否兼容。<br>如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常。<br>如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；<br>如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  Serializable接口的ID</span></span><br><span class="line"><span class="comment">        1.要归档或者序列化的对象必须实现Serializable接口才能被序列化 </span></span><br><span class="line"><span class="comment">        2.Serializable 中有个id，但ID不是一定要加的</span></span><br><span class="line"><span class="comment">        3.SerialVersionUid，简言之，其目的是以序列化对象进行版本控制，有关各版本</span></span><br><span class="line"><span class="comment">        反序列化时是否兼容。</span></span><br><span class="line"><span class="comment">        4.如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常。</span></span><br><span class="line"><span class="comment">        5.如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本</span></span><br><span class="line"><span class="comment">            的数据都能保留，那就不用修改；</span></span><br><span class="line"><span class="comment">        6.如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，</span></span><br><span class="line"><span class="comment">                这时就应该手动更新版本号，即SerialVersionUid。</span></span><br><span class="line"><span class="comment">        7.一般不会添加ID,就算添加了ID,版本号最好不要修改</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//save();</span></span><br><span class="line">        <span class="comment">//取学生</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"stu.data"</span>));</span><br><span class="line">        Student stu = (Student) ois.readObject();</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException, FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建学生对象</span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">"霍建华"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.把学生存入文件</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"stu.data"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 存的学生的版本号是1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        oos.writeObject(stu);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.关流</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化版本ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String hometown;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IO-编码表"><a href="#IO-编码表" class="headerlink" title="IO-编码表"></a>IO-编码表</h4><p><img src="/category/JavaSE-IO/bm.png" alt="b"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String (<span class="keyword">byte</span>[] bytes,String charsetName);<span class="comment">//通过指定的字符集编码字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] getBytes(String charsetName);<span class="comment">//使用指定的字符集合把字符串编码为字节数组</span></span><br></pre></td></tr></table></figure><h4 id="BufferedInputStream和BufferOutputStream"><a href="#BufferedInputStream和BufferOutputStream" class="headerlink" title="BufferedInputStream和BufferOutputStream"></a>BufferedInputStream和BufferOutputStream</h4><ul><li>这两个流是内置了缓冲区流,也就是说内部有一个 字节数组</li><li>缓冲思想<br>字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，<br>java本身在设计的时候,加入了数组这样的缓冲区效果，<br>也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流</li><li>BufferedInputStream<br>BufferedInputStream内置了一个缓冲区(数组)<br>从BufferedInputStream中读取一个字节时<br>BufferedInputStream会一次性从文件中读取8192个(8Kb), 存在缓冲区中, 返回给程序<br>程序再次读取时, 就不用找文件了, 直接从缓冲区中获取<br>直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个</li><li>BufferedOutputStream<br>BufferedOutputStream也内置了一个缓冲区(数组)<br>程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中<br>直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里</li></ul><p><strong>案例:使用缓冲输入输出流拷贝文件</strong></p><p><img src="/category/JavaSE-IO/b.png" alt="b"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//1.创建文件输入流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/Users/10301/Desktop/a/ghsy.mp3"</span>);</span><br><span class="line">        <span class="comment">//2.创建文件输出流</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"C:/Users/10301/Desktop/a/ghsy-副本.mp3"</span>);</span><br><span class="line">        <span class="comment">//3.输入流读数据、输出流写数据</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( (b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.关流</span></span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">        System.out.println(<span class="string">"音频拷贝完成..."</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*  BufferedInputStream和BufferedOutputStream</span></span><br><span class="line"><span class="comment">            &gt;这两个流是内置了缓冲区流,也就是说内部有一个字节数组</span></span><br><span class="line"><span class="comment">            &gt;这个两个类没有前面我们写的好用，因为它内部每次读8kb字节，如果想读80kb,没办法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">            <span class="comment">//案例：拷贝音频文件</span></span><br><span class="line">            <span class="comment">//1.创建缓冲输入流</span></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/Users/10301/Desktop/a/ghsy.mp3"</span>);</span><br><span class="line">            BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">            <span class="comment">//2.创建缓冲输出流</span></span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"C:/Users/10301/Desktop/a/ghsy-副本.mp3"</span>);</span><br><span class="line">            BufferedOutputStream bos =<span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">            <span class="comment">//3.输入流读数据、输出流写数据</span></span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// bis.read()方法，内部会读8kb数据</span></span><br><span class="line">            <span class="keyword">while</span>( (b = bis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(b);<span class="comment">//内部会写8kb数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//4.关流,只需要关缓冲流，文件流不用关</span></span><br><span class="line">            bis.close();<span class="comment">//【内部会关文件流输入流】</span></span><br><span class="line">            bos.close();<span class="comment">//【内部会关文件流输出流】</span></span><br><span class="line">            System.out.println(<span class="string">"音频拷贝完成..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="带Buffered的流和自己写的数组缓冲对比"><a href="#带Buffered的流和自己写的数组缓冲对比" class="headerlink" title="带Buffered的流和自己写的数组缓冲对比"></a>带Buffered的流和自己写的数组缓冲对比</h5><p>自己写的数组的读写和带Buffered的读取哪个更快?<br>自己写数组会略胜一筹,因为读和写操作的是同一个数组<br>而Buffered操作的是两个数组</p><h5 id="BufferOutputStream的flush和close方法的区别"><a href="#BufferOutputStream的flush和close方法的区别" class="headerlink" title="BufferOutputStream的flush和close方法的区别"></a>BufferOutputStream的flush和close方法的区别</h5><ul><li>flush()方法<br>用来刷新缓冲区的,刷新后可以再次写出</li><li>close()方法<br>用来关闭流释放资源的的,如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line">    <span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line">    <span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line">    <span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line">    <span class="keyword">import</span> java.io.IOException;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">//BufferedOutputStream的flush和close方法的区别</span></span><br><span class="line">        <span class="comment">/*  flush()方法</span></span><br><span class="line"><span class="comment">                1.用来刷新缓冲区的,刷新后可以再次写出 </span></span><br><span class="line"><span class="comment">            close()方法</span></span><br><span class="line"><span class="comment">                2.用来关闭流释放资源的</span></span><br><span class="line"><span class="comment">                3.如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">            <span class="comment">//案例：把a文件的内容拷贝到b文件</span></span><br><span class="line">            <span class="comment">//1.输入流</span></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">            BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">            <span class="comment">//2.输出流</span></span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">            BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">            <span class="comment">//3.读写操作</span></span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>( (b = bis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(b);</span><br><span class="line">            &#125; </span><br><span class="line">            bos.flush();</span><br><span class="line">            bos.write(<span class="number">97</span>);</span><br><span class="line">            <span class="comment">//bos.flush();</span></span><br><span class="line">            <span class="comment">//4.关闭流</span></span><br><span class="line">            bis.close();</span><br><span class="line">            bos.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="字节流读写中文乱码问题"><a href="#字节流读写中文乱码问题" class="headerlink" title="字节流读写中文乱码问题"></a>字节流读写中文乱码问题</h5><p>字节流读取中文:<br>字节流读取中文的问题<br>字节流在读中文的时候有可能会读到半个中文,造成乱码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//字节流读写中文乱码问题</span></span><br><span class="line">        <span class="comment">//1.读数据</span></span><br><span class="line">        <span class="comment">//创建文件输入流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        <span class="comment">//读</span></span><br><span class="line">        <span class="comment">//定义字节数组[杯子思想，缓冲区思想]</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在UTF-8编码表中，一个中文占3个字节,一个英文占1个字节</span></span><br><span class="line"><span class="comment">         * 在GBK编译中，一个中文占2个字节</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( (len = fis.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"len:"</span> + len );</span><br><span class="line">            <span class="comment">//把字节转成字符串</span></span><br><span class="line">            String s = <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br><span class="line">            System.out.println(<span class="string">"s:"</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节流写入中文的问题<br>字节流直接操作的字节,所以写出中文必须将字符串转换成字节数组<br>写出回车换行 write(“\r\n”.getBytes());</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">        <span class="comment">//案例：往a.txt文件写中文</span></span><br><span class="line">        <span class="comment">//1.输出流</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        <span class="comment">//2.写中文</span></span><br><span class="line">        String s = <span class="string">"你好，Gosling最近好吗？"</span>;</span><br><span class="line">        <span class="comment">//把字符转成字节数组</span></span><br><span class="line">        <span class="comment">//byte[] bytes = s.getBytes();</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * charsetName 字符编码 UTF-8(Unicode),GBK,ASCII</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = s.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        fos.write(bytes);</span><br><span class="line">        <span class="comment">//3.关流</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="流的标准处理代码"><a href="#流的标准处理代码" class="headerlink" title="流的标准处理代码"></a>流的标准处理代码</h5><p><strong>流的标准处理异常代码1.6版本及其以前</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//流的标准处理异常代码-jdk1.6版本及其以前</span></span><br><span class="line">        <span class="comment">//案例：a.txt的内容拷贝到b.txt</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//读写数据会抛出</span></span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//读写数据会抛出</span></span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流的标准处理异常代码1.7以上版本</strong></p><p>原理：在try()中创建的流对象必须实现了AutoCloseable这个接口,如果实现了,在try后面的{}(读写代码)执行后就会自动调用,流对象的close方法将流关掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//流的标准处理异常代码1.7版本</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.把流对象的声明放在try() 括号里面</span></span><br><span class="line"><span class="comment">         * 2.操作流【读写数据】的代码放在花括号里面</span></span><br><span class="line"><span class="comment">         * 3.这样写不用关闭流，java自动关闭流</span></span><br><span class="line"><span class="comment">         * 4.在try的括号里的对象，必须是实现AutoCloseable的接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">            <span class="comment">//Person p = new Person();</span></span><br><span class="line">            <span class="comment">//声明一个自己输入流</span></span><br><span class="line">            MyInputStream myis = <span class="keyword">new</span> MyInputStream();</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInputStream</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我的输入流关闭了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><p><strong>练习:图片加密</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//练习:图片加密</span></span><br><span class="line">        <span class="comment">//1.输入输出流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/Users/10301/Desktop/a/cm2.jpg"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"C:/Users/10301/Desktop/a/cm.jpg"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.读写数据</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 加密操作</span></span><br><span class="line"><span class="comment">         * 解密操作</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 一个数异或2次，数据不变</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(b ^ <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.关流</span></span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"图片加密完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习:根据用户输入的文件拷贝文件到当前项目目录</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//练习:根据用户输入的文件[图片]拷贝文件到当前项目目录</span></span><br><span class="line">        <span class="comment">//C:/Users/10301/Desktop/a/cm2.jpg</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.获取用户输入的文件路径</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入一个文件的路径[请不要输入文件夹路径]:"</span>);</span><br><span class="line">        String path = scanner.nextLine();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.判断这个路径是否为文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">            System.out.println(<span class="string">"您输入的路径不是一个文件"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.如果是文件就拷贝</span></span><br><span class="line">        <span class="comment">//3.1 输入流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.2输出流</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file.getName());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.3读写【性能】</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span> * <span class="number">1024</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.4关流</span></span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"文件拷贝完成..."</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习:录入数据拷贝到文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//练习:录入数据拷贝到文件</span></span><br><span class="line">        <span class="comment">//1.创建一个文件输出流</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"new.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.创建一个Scanner对象</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入需要录入内容...输入quit代表退出"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.通过死循环来获取用户输入【当输入quit，代表不录入】</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//获取用户的输入</span></span><br><span class="line">            String line = scanner.nextLine();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//退出循环</span></span><br><span class="line">            <span class="keyword">if</span>(line.equals(<span class="string">"quit"</span>))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//写入文件</span></span><br><span class="line">            fos.write(line.getBytes());</span><br><span class="line">            <span class="comment">//换行</span></span><br><span class="line">            fos.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.关流</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>字符流以字符为单位，根据码表映射字符，一次可能读多个字节，字符流只能处理字符类型的数据</p><ol><li>字符流是可以直接读写字符的IO流</li><li>字符流读取字符, 就要先读取到字节数据, 然后转为字符.</li><li>写入字符, 需要把字符转为字节再写出</li><li>字符流=字节流+编码表</li></ol><p><img src="/category/JavaSE-IO/inout.png" alt="rw"></p><p><strong>InputStreamReader</strong></p><p>InputStreamReader(InputStream is);//用默认的编码读取数据</p><p>InputStreamReader(InputStream is,String charsetName);//用指定的编码读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InputStreamReader的方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>;<span class="comment">//一次读取一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] chs)</span></span>;<span class="comment">//一次读取一个字符数组</span></span><br></pre></td></tr></table></figure><p><strong>OutputStreamWriter</strong></p><p>OutputStreamWriter(OutputStream out);//根据默认编码把字节流的数据转换为字符流</p><p>OutputStreamWriter(OutputStream out,String charsetName);//根据指定编码把字节流数据转换为字符流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OutputStreamWriter的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span></span>;<span class="comment">//写一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span></span>;<span class="comment">//写一个字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span>;<span class="comment">//写一个字符数组的一部分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span></span>;<span class="comment">//写一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span>;<span class="comment">//写一个字符串的一部分</span></span><br></pre></td></tr></table></figure><p>由于我们常见的操作都是使用本地默认编码，所以不用指定编码</p><p>而转换流的名称有点长，所以Java就提供了其子类供我们使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter = FileOutputStream + 编码表(GBK);</span><br><span class="line">FileWriter = FileOutputStream + 编码表(GBK);</span><br><span class="line"></span><br><span class="line">InputStreamReader = FileInputStream + 编码表(GBK);</span><br><span class="line">FileReader = FileInputStream + 编码表(GBK)</span><br></pre></td></tr></table></figure><p><strong>close()和flush()的区别？</strong></p><p>close()：关闭流对象，但是先刷新一次缓冲区，关闭之后，流对象不可与再继续使用</p><p>flush()：仅仅刷新缓冲区，刷新之后，流对象还可以继续使用</p><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><ol><li>Reader 是所有的输入字符流的父类，它是一个抽象类。</li><li>CharReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。</li><li>BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。</li><li>FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。</li><li>InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。</li></ol><p><img src="/category/JavaSE-IO/reader.png" alt="reader"></p><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><ol><li><p>Writer 是所有的输出字符流的父类，它是一个抽象类。</p></li><li><p>CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据，</p></li><li><p>BufferedWriter 是一个装饰器为Writer 提供缓冲功能。</p></li><li><p>PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。</p></li><li><p>OutputStreamWriter 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。</p><p><img src="/category/JavaSE-IO/writer.png" alt="writer"></p><p>​</p></li></ol><h5 id="FileReader读取字符流"><a href="#FileReader读取字符流" class="headerlink" title="FileReader读取字符流"></a>FileReader读取字符流</h5><p>查看API的方法<br>案例:使用FileReader 读取一个文本数据（知识点):</p><blockquote><p>1、read方法是读取字符char</p><p>2、一个字符可能占用1个字节，2个字节，或者3个字节</p><p>3、占用字节个的数根据码表决定(ASCII:1字节，GBK:2字节 unicode:3个字节)</p><p>4、用int表示字节，假如读取到2个字节，int有4个字节，前个两个字节可以补0</p><p>5、GBK,unicode中，中文的字符的第一个字节都是负数，所以知道怎么去读取</p><p>6、读取的方式与FileInputStream字节流差不多，会用FileInputStream，就会用 FileReader</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以后读纯文本文件，使用FileReader这个类，为什么？因为我们不用考虑乱码问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//读字节</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        <span class="comment">//int 00000000 00000000 00000000 11111111</span></span><br><span class="line">        System.out.println((<span class="keyword">byte</span>)fis.read());</span><br><span class="line">        System.out.println((<span class="keyword">byte</span>)fis.read());</span><br><span class="line">        System.out.println((<span class="keyword">byte</span>)fis.read());</span><br><span class="line">        </span><br><span class="line">        System.out.println((<span class="keyword">byte</span>)fis.read());</span><br><span class="line">    </span><br><span class="line">        System.out.println((<span class="keyword">byte</span>)fis.read());</span><br><span class="line">        System.out.println((<span class="keyword">byte</span>)fis.read());</span><br><span class="line">        System.out.println((<span class="keyword">byte</span>)fis.read());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//FileReader </span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * FileReader 用于读取字符</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        FileReader reader = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.读取数据</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * reader.read() : 先读取到字节数据, 然后转为字符</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>)reader.read());</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)reader.read());</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)reader.read());</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)reader.read());</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)reader.read());</span><br><span class="line">        System.out.println(reader.read());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c = reader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="FileWiter-写入字符流"><a href="#FileWiter-写入字符流" class="headerlink" title="FileWiter 写入字符流"></a>FileWiter 写入字符流</h5><p><strong>查看API中FileWriter的方法</strong></p><p><strong>案例:使用FileWrite写入数据（知识点）</strong></p><blockquote><p>1.其实内部是通过一个字符数组缓冲区写入文件<br>2.内部方法，创建一个字符串长度的字符数组缓存区</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FileWiter:</span></span><br><span class="line"><span class="comment"> * 掌握：</span></span><br><span class="line"><span class="comment"> * 1.write方法使用</span></span><br><span class="line"><span class="comment"> * 2.write方法内部实现，内部是通过一个字符数组缓冲区写入文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//FileWiter 文件写入流、文件写入字符流</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//案例：使用FileWiter往一个文件a.txt写内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.创建writer对象</span></span><br><span class="line">        FileWriter writer = <span class="keyword">new</span> FileWriter(<span class="string">"a.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.写内容</span></span><br><span class="line">        writer.write(<span class="string">"你好!"</span>);</span><br><span class="line">        writer.write(<span class="string">"\r\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"你好!"</span>);</span><br><span class="line">        writer.write(<span class="string">"\r\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"你好!"</span>);</span><br><span class="line">        writer.write(<span class="string">"\r\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"你好!"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.关闭</span></span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="案例-字符流的拷贝"><a href="#案例-字符流的拷贝" class="headerlink" title="案例:字符流的拷贝"></a>案例:字符流的拷贝</h5><blockquote><p>//案例:字符流的拷贝<br>//思路：用FileReader读字符,用FileWriter写字符</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//案例:字符流的拷贝</span></span><br><span class="line">        <span class="comment">//思路：用FileReader读字符,用FileWriter写字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.创建 “读取流” 对象</span></span><br><span class="line">        FileReader reader = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.创建 "写入流" 对象</span></span><br><span class="line">        FileWriter writer = <span class="keyword">new</span> FileWriter(<span class="string">"b.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.读取和写入【缓冲思想】</span></span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( (len = reader.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            writer.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建 “读取流” 对象</span></span><br><span class="line">        FileReader reader = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.创建 "写入流" 对象</span></span><br><span class="line">        FileWriter writer = <span class="keyword">new</span> FileWriter(<span class="string">"b.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.读取和写入</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((c = reader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            writer.write(c);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用字符流的场景"><a href="#使用字符流的场景" class="headerlink" title="使用字符流的场景"></a>使用字符流的场景</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用字符流的场景</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.使用FileReader读取字符</span></span><br><span class="line"><span class="comment">         *      原理：先读字节，把字节转成字符（byte -&gt; char）</span></span><br><span class="line"><span class="comment">         * 2.使用FileWriter写入字符</span></span><br><span class="line"><span class="comment">         *      原理：writer(String str),str 转成 字符数组 再转成 字节写入文件</span></span><br><span class="line"><span class="comment">         *      (string -&gt; char[] -&gt; char -&gt; byte)</span></span><br><span class="line"><span class="comment">         * 如果是读取文本文件，使用FileReader比较好,不考虑乱码问题</span></span><br><span class="line"><span class="comment">         * 如果是写入文本文件，不建议使用FileWriter,直接使用FileOutputStream好一点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="带缓冲的字符流-BufferedReader-BufferedWriter"><a href="#带缓冲的字符流-BufferedReader-BufferedWriter" class="headerlink" title="带缓冲的字符流 BufferedReader/BufferedWriter"></a>带缓冲的字符流 BufferedReader/BufferedWriter</h5><ol><li><strong>BufferedReader</strong><ol><li>read()方法读取字符时会一次读取若干字符到缓冲区,然后逐个返回给程序, 降低读取文件的次数, 提高效率</li></ol></li><li><strong>BufferedWriter</strong><ol><li>write()方法写出字符时会先写到缓冲区缓冲区写满时才会写到文件, 降低写文件的次数, 提高效率</li><li>查看源码:字符缓冲区的大小是8192</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 带缓冲的字符流 BufferedReader/BufferedWriter</span></span><br><span class="line"><span class="comment">         * 1.这两个类，内部都一个缓冲区，字符数组</span></span><br><span class="line"><span class="comment">         * 2.br.read()方法，内部会读8192（8*1024）个字符</span></span><br><span class="line"><span class="comment">         * 3.bw.write(),内部会写8192（8*1024）个字符</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 回顾：带缓冲的字节流,BufferedInputStream/BufferedOutputStream</span></span><br><span class="line"><span class="comment">         * 1.这两个类，内部都一个缓冲区，字节数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//需求：拷贝文件,a.txt -&gt; b.txt</span></span><br><span class="line">        <span class="comment">//1.创建Reader</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.创建Writer</span></span><br><span class="line">        FileWriter fw =<span class="keyword">new</span> FileWriter(<span class="string">"b.txt"</span>);</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.读写</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( (c = br.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bw.write(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.关流</span></span><br><span class="line">        br.close();<span class="comment">//内部关闭FileReader</span></span><br><span class="line">        bw.close();<span class="comment">//内部关闭FileWriter</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BufferedReader的readLine()&amp;BufferedWriter的newLine()方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//BufferedReader的readLine()&amp;BufferedWriter的newLine()方法</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.readLine()，每次读取一行数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.创建Reader</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.读一行数据</span></span><br><span class="line"><span class="comment">/*      System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">        System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">        System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">        System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">        System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">        System.out.println(br.readLine());*/</span></span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.关流</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BufferedWriter的newLine()方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//BufferedWriter的newLine()方法</span></span><br><span class="line">        <span class="comment">// newLine()换行</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//往b.txt写a.txt文件的内容【一行一行拷贝,读一行写一行】</span></span><br><span class="line">        <span class="comment">//1.创建Reader</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.创建writer</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"b.txt"</span>);</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.读一行写一行</span></span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当使用readline读取一行数据时，不会读回车换行"\r\n"字符</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//bw.write("\r\n");</span></span><br><span class="line">            bw.newLine();<span class="comment">//换行</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.关流</span></span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例:使用带缓冲的字符流拷贝文件</strong></p><p><strong>BufferedReader的readLine()&amp;BufferedWriter的newLine()方法</strong></p><ol><li>BufferedReader的readLine()方法可以读取一行字符(不包含换行符号)</li><li>BufferedWriter的newLine()可以输出一个跨平台的换行符号”\r\n”</li></ol><p><strong>案例:将文本反转</strong></p><blockquote><p>一个文本文档上的文本反转,第一行和倒数第一行交换,第二行和倒数第二行交换</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 掌握思想：</span></span><br><span class="line"><span class="comment"> * 1.for循环的倒序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//案例:将文本反转写入另一个文件</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.把文本每一行内容读取出来存在List&lt;String&gt; 集合</span></span><br><span class="line">        <span class="comment">//1.1 集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.2一行行读取文件</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(line);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.当我们要写入文件时，倒序保存List集合中的内容到文件中</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"b.txt"</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = list.size() - <span class="number">1</span> ; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            bw.write(list.get(i));</span><br><span class="line">            bw.newLine();<span class="comment">//换行 </span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">        System.out.println(<span class="string">"finish...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="装饰-Decorator-设计模式"><a href="#装饰-Decorator-设计模式" class="headerlink" title="装饰(Decorator)设计模式"></a>装饰(Decorator)设计模式</h4><p><strong>装饰模式的概念:</strong><br>动态的给一个对象添加一些额外的功能，就增加功能来说，装饰模式比生成子类更为灵活。<br>在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。<br>它是创建一个包装对象，也就是使用装饰来包裹真实的对象。</p><p><strong>适用性</strong></p><ol><li>需要扩展一个类的功能，或给一个类添加附加职责。</li><li>当不能采用生成子类来实现，比如final类</li></ol><p><strong>装饰模式的实现方式</strong></p><ol><li>装饰对象和真实对象有相同的接口。</li><li>装饰对象包含一个真实对象的引用（reference）</li><li>装饰对象的所有方法，内部实现都是通过真实对象的引用来调用，然后实现自己的功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一、设计模式【一种固定代码风格】</span></span><br><span class="line"><span class="comment">         *     面试题：Java中有哪些设计模式</span></span><br><span class="line"><span class="comment">         *     常用设计模式：装饰模式、单例模式、模版模式、适配器模式、代理模式、工厂模式...</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 二、装饰(Decorator)设计模式</span></span><br><span class="line"><span class="comment">         *  1.装饰模式的概念:</span></span><br><span class="line"><span class="comment">            装饰模式是动态的给一个对象添加一些额外的功能，就增加功能来说，装饰模式比生成子类更为灵活。</span></span><br><span class="line"><span class="comment">            装饰模式是在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。</span></span><br><span class="line"><span class="comment">            装饰模式是创建一个包装对象，也就是使用装饰来包裹真实的对象。  </span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            2.装饰模式的实现方式</span></span><br><span class="line"><span class="comment">                1. 装饰对象和真实对象有相同的接口/抽象类。</span></span><br><span class="line"><span class="comment">                2. 装饰对象包含一个真实对象的引用（reference）</span></span><br><span class="line"><span class="comment">                3. 装饰对象的所有方法，内部实现都是通过真实对象的引用来调用，然后实现自己的功能</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            3.适用性</span></span><br><span class="line"><span class="comment">                1. 需要扩展一个类的功能，或给一个类添加附加职责。</span></span><br><span class="line"><span class="comment">                2. 当不能采用生成子类来实现，比如final类    </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*  BufferedInputStream bis = new BufferedInputStream(new FileInputStream("a.txt"));</span></span><br><span class="line"><span class="comment">        BufferedOutputStream bos;</span></span><br><span class="line"><span class="comment">        BufferedReader br;</span></span><br><span class="line"><span class="comment">        BufferedWriter bw;*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*GYFStudent stu = new GYFStudent();</span></span><br><span class="line"><span class="comment">        stu.code();*/</span></span><br><span class="line">        </span><br><span class="line">        GYFStudent stu = <span class="keyword">new</span> GYFStudent(<span class="keyword">new</span> UniversityStudent());</span><br><span class="line">        stu.code();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.接口实现类</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UniversityStudent</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"在大学期间学了一点点C语言..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*class GYFStudent extends UniversityStudent&#123;</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void code() &#123;</span></span><br><span class="line"><span class="comment">        // TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">        super.code();</span></span><br><span class="line"><span class="comment">        System.out.println("在GYF IT EDU 学习Java语言...");</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GYFStudent</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UniversityStudent us;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GYFStudent</span><span class="params">(UniversityStudent us)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.us = us;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//装饰对象的所有方法，内部实现都是通过真实对象的引用来调用，然后实现自己的功能</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        us.code();</span><br><span class="line">        System.out.println(<span class="string">"在GYF IT EDU 学习Java语言..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        GYFStudent stu = <span class="keyword">new</span> GYFStudent();</span><br><span class="line">        </span><br><span class="line">        stu.coding();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//人可以具备编码的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//大学生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniversityStudent</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我会一点c基础编程..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">piano</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我会钢琴..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种继承类的写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GYFStudent</span> <span class="keyword">extends</span> <span class="title">UniversityStudent</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">super</span>.coding();</span><br><span class="line">        System.out.println(<span class="string">"我会java基础编程了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class GYFStudent implements Person&#123;</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  private UniversityStudent uStu;</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  public GYFStudent(UniversityStudent uStu) &#123;</span></span><br><span class="line"><span class="comment">//      super();</span></span><br><span class="line"><span class="comment">//      this.uStu = uStu;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  @Override</span></span><br><span class="line"><span class="comment">//  public void coding() &#123;</span></span><br><span class="line"><span class="comment">//      // TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//      uStu.coding();</span></span><br><span class="line"><span class="comment">//      System.out.println("我会java基础编程了...");</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h5 id="InputStreamReader-amp-OutputStreamWriter"><a href="#InputStreamReader-amp-OutputStreamWriter" class="headerlink" title="InputStreamReader&amp;OutputStreamWriter"></a>InputStreamReader&amp;OutputStreamWriter</h5><ul><li>这两个类用于使用指定的码表读写字符</li><li>FileReader是使用默认码表读取文件, 如果需要使用指定码表读取请使用InputStreamReader(字符流,编码表)</li><li>FileWriter是使用默认码表写出文件, 如果需要使用指定码表写入请使用OutputStreamWriter(字符流,编码表)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">/*      InputStreamReader&amp;OutputStreamWriter</span></span><br><span class="line"><span class="comment">        1&gt;这两个类用于使用指定的码表读写字符*/</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//案例1：使用指定 “码表UTF-8&amp;GBK” 读取字符</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * charsetName：字符编码的名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">"UTF-8"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//读一个字符</span></span><br><span class="line">    <span class="comment">/*  System.out.println((char)isr.read());</span></span><br><span class="line"><span class="comment">        System.out.println((char)isr.read());*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//读一行</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">        System.out.println(br.readLine());</span><br><span class="line">        </span><br><span class="line">        br.close();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例2</span></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 掌握：</span></span><br><span class="line"><span class="comment"> * 1.当读取文件内容，还有写入文件，可以指定编码格式</span></span><br><span class="line"><span class="comment"> * 2.使用InputStreamReader&amp;OutputStreamWriter这个类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gyf</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="comment">/*  OutputStreamWriter</span></span><br><span class="line"><span class="comment">        1&gt;使用指定的编码 写入文件</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.创建Writer</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"c.txt"</span>);</span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">"GBK"</span>);</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.写</span></span><br><span class="line">        bw.write(<span class="string">"你好，IO流...搞的我有点晕..."</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">"你好，IO流...搞的我有点晕..."</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.关流</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习:获取文本上字符出现的次数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 掌握:当键盘敲 enter键，两个字符\r\n : 回车换行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//练习:获取文本上字符出现的次数,把数据写入文件</span></span><br><span class="line"><span class="comment">/*      思路：</span></span><br><span class="line"><span class="comment">        1.遍历文本每一个字符</span></span><br><span class="line"><span class="comment">        2.字符出现的次数存在Map中</span></span><br><span class="line"><span class="comment">        */</span><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;();</span></span><br><span class="line"><span class="comment">         * map.put('a',18);</span></span><br><span class="line"><span class="comment">         * map.put('你',2);</span></span><br><span class="line"><span class="comment">         */</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">        3.把map中的数据写入文件*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//==================================</span></span><br><span class="line">        <span class="comment">//1.创建Map集合</span></span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="comment">//System.out.println(map.get('a'));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.遍历每一个字符,每一个字符出现的次数放到map中</span></span><br><span class="line">        FileReader reader = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((c = reader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//int 还原 char</span></span><br><span class="line">            <span class="keyword">char</span> ch = (<span class="keyword">char</span>)c;</span><br><span class="line">            <span class="comment">// 判断char是否在map中第一次出现</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(ch) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(ch, <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(ch, map.get(ch) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.把map中数据存在文件count.txt</span></span><br><span class="line">        <span class="comment">//3.1 创建Writer</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"count.txt"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.2 遍历map,再写入数据</span></span><br><span class="line">        <span class="keyword">for</span>(Entry&lt;Character, Integer&gt; entry :map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">switch</span> (entry.getKey()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                bw.write(<span class="string">"空格="</span> + entry.getValue());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\t'</span>:<span class="comment">//\t表示tab 键字符</span></span><br><span class="line">                bw.write(<span class="string">"tab键="</span> + entry.getValue());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\r'</span>:<span class="comment">//</span></span><br><span class="line">                bw.write(<span class="string">"回车="</span> + entry.getValue());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\n'</span>:<span class="comment">//</span></span><br><span class="line">                bw.write(<span class="string">"换行="</span> + entry.getValue());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                bw.write(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.关流</span></span><br><span class="line">        reader.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打印流的概述和特点-掌握"><a href="#打印流的概述和特点-掌握" class="headerlink" title="打印流的概述和特点 (掌握)"></a>打印流的概述和特点 (掌握)</h4><p><strong>什么是打印流</strong></p><p>该流可以很方便的将对象的toString()结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式<br>System.out就是一个PrintStream, 其默认向控制台输出信息<br>PrintStream和PrintWriter分别是打印的字节流和字符流</p><p><strong>打印流的特点</strong></p><p>只有写数据的，没有读数据，只能操作目的地，不能操作数据源</p><p>可以操作任意类型的数据</p><p>如果启动了自动刷新，能够自动刷新</p><p>该流是可以直接操作文本文件的</p><p><strong>启动自动刷新</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">"pw2.txt"</span>), <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印流的概述和特点 (掌握)</span></span><br><span class="line">    <span class="comment">/*  什么是打印流 </span></span><br><span class="line"><span class="comment">        1.该流可以很方便的将对象的toString()结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式</span></span><br><span class="line"><span class="comment">        2.System.out就是一个PrintStream, 其默认向控制台输出信息</span></span><br><span class="line"><span class="comment">        3.PrintStream和PrintWriter分别是打印的字节流和字符流*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.打印的字节流【打印到控制台】</span></span><br><span class="line">        PrintStream ps = System.out;</span><br><span class="line">        ps.println(<span class="string">"你好，元宵节快乐"</span>);<span class="comment">//打印字符串</span></span><br><span class="line">        ps.println(<span class="number">19.6</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.打印的字符流</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.PrintWriter调用打印方法，控制台是没有内容，它是把内容写到文件中</span></span><br><span class="line"><span class="comment">         * 2.如果打印了内容，没有调用flush或者close，内容在文件中也不存在</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="string">"test.txt"</span>);</span><br><span class="line">        pw.println(<span class="string">"吃汤圆了..."</span>);</span><br><span class="line">        pw.print(<span class="string">"超市一包汤圆10几块钱"</span>);</span><br><span class="line">        pw.print(<span class="number">13.01</span>);</span><br><span class="line">        <span class="comment">//pw.flush();</span></span><br><span class="line">        pw.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准输入输出流概述和输出语句-了解"><a href="#标准输入输出流概述和输出语句-了解" class="headerlink" title="标准输入输出流概述和输出语句(了解)"></a>标准输入输出流概述和输出语句(了解)</h4><p>System.in是InputStream, 标准输入流, 默认可以从键盘输入读取字节数据</p><p>System.out是PrintStream, 标准输出流, 默认可以向Console中输出字符和字节数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//标准输入输出流概述和输出语句(了解)</span></span><br><span class="line"><span class="comment">/*      System.in是InputStream, 标准输入流, 默认可以从键盘输入读取字节数据</span></span><br><span class="line"><span class="comment">        System.out是PrintStream, 标准输出流, 默认可以向Console中输出字符和字节数据*/</span></span><br><span class="line">        </span><br><span class="line">        InputStream is = System.in;<span class="comment">//标准输入流</span></span><br><span class="line">        PrintStream ps = System.out;<span class="comment">//标准输出流</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="随机访问流概述和读写数据"><a href="#随机访问流概述和读写数据" class="headerlink" title="随机访问流概述和读写数据"></a>随机访问流概述和读写数据</h4><p><strong>随机访问流概述</strong></p><p>RandomAccessFile概述<br>RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。<br>支持对随机访问文件的读取和写入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RandomAccessFile这个类用于文件断点下载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gyf</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//随机访问流概述和读写数据</span></span><br><span class="line"><span class="comment">/*      随机访问流概述</span></span><br><span class="line"><span class="comment">        RandomAccessFile概述</span></span><br><span class="line"><span class="comment">        RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。</span></span><br><span class="line"><span class="comment">        支持对随机访问文件的读取和写入。*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法两个参数：</span></span><br><span class="line"><span class="comment">         * name:文件名称、路径</span></span><br><span class="line"><span class="comment">         * mode:模式 ，r=read 只读、 w=write</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1.创建一个随机访问流对象，以读写的方式打开文件</span></span><br><span class="line">        RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"a.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.读字符</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用RandomAccessFile的readChar/readLine方法读文件有乱码问题</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">/*      System.out.println(raf.readChar());</span></span><br><span class="line"><span class="comment">        System.out.println(raf.readChar());</span></span><br><span class="line"><span class="comment">        System.out.println(raf.readChar());</span></span><br><span class="line"><span class="comment">        System.out.println(raf.readLine());*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用字节数组来读比较好</span></span><br><span class="line"><span class="comment">/*      byte[] buf = new byte[1024];</span></span><br><span class="line"><span class="comment">        int len;</span></span><br><span class="line"><span class="comment">        while((len = raf.read(buf)) != -1)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(new String(buf,0,len));</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.写数据</span></span><br><span class="line">        <span class="comment">//raf.writeChars("abc");</span></span><br><span class="line">        <span class="comment">//raf.writeBytes("abc");</span></span><br><span class="line">        raf.seek(<span class="number">4</span>);<span class="comment">//指定位置</span></span><br><span class="line">        raf.write(<span class="number">97</span>);</span><br><span class="line">        raf.write(<span class="number">98</span>);</span><br><span class="line">        raf.write(<span class="number">99</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Properties的概述和作为Map集合的使用"><a href="#Properties的概述和作为Map集合的使用" class="headerlink" title="Properties的概述和作为Map集合的使用"></a>Properties的概述和作为Map集合的使用</h4><p><strong>Properties的概述</strong></p><p>Properties 类表示了一个持久的属性集。</p><p>Properties 可保存在流中或从流中加载。</p><p>属性列表中每个键及其对应值都是一个字符串。</p><p>是Hashtable的子类，说明是一个map集合</p><p><strong>方法</strong></p><p>Properties的load()和store()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(Reader reader)</span></span>;<span class="comment">//把文件中的数据读取到集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(Writer writer,String comments)</span></span>;<span class="comment">//把集合中的数据存储到文件</span></span><br></pre></td></tr></table></figure><p>public Object setProperty(String key,String value)</p><p>public String getProperty(String key)</p><p>public Enumeration<string>stringPropertyNames()</string></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.time.Period;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//Properties的概述和作为Map集合的使用【掌握-经常用】</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Properties:属性</span></span><br><span class="line"><span class="comment">            1.Properties 类表示了一个持久的属性集。</span></span><br><span class="line"><span class="comment">            2.Properties 可保存在流中或从流中加载。</span></span><br><span class="line"><span class="comment">            3.属性列表中每个键及其对应值都是一个字符串。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历properties所有属性key和值value</span></span><br><span class="line">        <span class="comment">//1.创建属性对象</span></span><br><span class="line">        Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.关联文件</span></span><br><span class="line">        p.load(<span class="keyword">new</span> FileInputStream(<span class="string">"info.properties"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.遍历一</span></span><br><span class="line">        Set&lt;Object&gt; keys = p.keySet();</span><br><span class="line">        <span class="keyword">for</span>(Object key : keys)&#123;</span><br><span class="line">            System.out.println(key + <span class="string">"="</span> + p.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(keys);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.遍历二</span></span><br><span class="line">        System.out.println(<span class="string">"====================="</span>);</span><br><span class="line">        <span class="comment">//p.entrySet();</span></span><br><span class="line">        <span class="keyword">for</span>(Entry&lt;Object, Object&gt; entry :p.entrySet())&#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException, FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//使用Properties读取数据</span></span><br><span class="line">        <span class="comment">//1.创建属性对象</span></span><br><span class="line">        Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.关联文件</span></span><br><span class="line">        p.load(<span class="keyword">new</span> FileInputStream(<span class="string">"info.properties"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.通过key读数据</span></span><br><span class="line">        String name = p.getProperty(<span class="string">"name"</span>);</span><br><span class="line">        String city = p.getProperty(<span class="string">"city"</span>);</span><br><span class="line">        String hometown = p.getProperty(<span class="string">"hometown"</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(city);</span><br><span class="line">        System.out.println(hometown);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Properties来存储数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException, FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建属性对象</span></span><br><span class="line">        Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.存数据</span></span><br><span class="line">        p.setProperty(<span class="string">"name"</span>, <span class="string">"gyf"</span>);</span><br><span class="line">        p.setProperty(<span class="string">"city"</span>, <span class="string">"广州"</span>);</span><br><span class="line">        p.setProperty(<span class="string">"hometown"</span>, <span class="string">"梅州"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.关联文件</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当Properties把key和value存入文件，把中文转成unicode编码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        p.store(<span class="keyword">new</span> FileOutputStream(<span class="string">"info.properties"</span>), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//捋一捋IO流</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一、IO流-输入输出流</span></span><br><span class="line"><span class="comment">         * I:input</span></span><br><span class="line"><span class="comment">         * O:out</span></span><br><span class="line"><span class="comment">         * IO流 操作文件，读取文件内容，往文件写内容</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 二、字节流</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * &gt;InputStream</span></span><br><span class="line"><span class="comment">         *  -FileInputStream 文件输入流，读的单位是字节</span></span><br><span class="line"><span class="comment">         *  -BufferedInputStream 缓冲输入流，内部有个byte[]字节数组</span></span><br><span class="line"><span class="comment">         *  -SequenceInputStream 序列流，把多个字节流整合成一个流</span></span><br><span class="line"><span class="comment">         *  -ObjectInputStream 对象输入流，直接从文件中读取一个对象,这个对象要实现serilazable接口</span></span><br><span class="line"><span class="comment">         *  -Sytem.in 标准输入流-指键盘</span></span><br><span class="line"><span class="comment">         *  -DataInputStream 数据输入流，按基本数据类型的大小(long) 读取文件</span></span><br><span class="line"><span class="comment">         *  </span></span><br><span class="line"><span class="comment">         * &gt;OutputStream</span></span><br><span class="line"><span class="comment">         *  -FileOutputStream 文件输出流，写的单位是字节</span></span><br><span class="line"><span class="comment">         *  -BufferedOutputStream 缓冲输出流，内部有个byte[]字节数组</span></span><br><span class="line"><span class="comment">         *  -ByteArrayOutputStream 字节数组输出流，把数据读取到内存中，这个类不需要关联文件</span></span><br><span class="line"><span class="comment">         *  -ObjectOutputStream 对象输出流，直接把一个对象存入文件，</span></span><br><span class="line"><span class="comment">         *  -PrintStream 打印流，把内容打印到控制台</span></span><br><span class="line"><span class="comment">         *  -System.out 标准输出流-指控制台</span></span><br><span class="line"><span class="comment">         *  -DataOutputStream 数据输出流，按基本数据类型的大小(long) 写入文件</span></span><br><span class="line"><span class="comment">         *  </span></span><br><span class="line"><span class="comment">         * 三、字符流</span></span><br><span class="line"><span class="comment">         * &gt;Reader</span></span><br><span class="line"><span class="comment">         *  -FileReader 文件读取流，读取的单位是字符</span></span><br><span class="line"><span class="comment">         *  -BufferedReader 缓冲读取流，内部有个char[] 字符数组</span></span><br><span class="line"><span class="comment">         *  -InputStreamReader 指定字符编码读取文件</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * &gt;Writer</span></span><br><span class="line"><span class="comment">         *  -FileWriter 文件写入流,写入的单位是字符</span></span><br><span class="line"><span class="comment">         *  -BufferedWriter,缓冲写入流，内部有个char[] 字符数组</span></span><br><span class="line"><span class="comment">         *  -OutputStreamWriter 指定字符编码写入文件</span></span><br><span class="line"><span class="comment">         *  -PrintWriter 打印流，把内容打印一个文件</span></span><br><span class="line"><span class="comment">         *  </span></span><br><span class="line"><span class="comment">         *  </span></span><br><span class="line"><span class="comment">         * RandomAccessFile 随机访问流，特点：读和写都在一个类中</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * Properties 相当于Map一样使用，这个类把数据存在一个后缀名为.properties文件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE-IO流详解
    
    </summary>
    
      <category term="JavaSE流" scheme="https://www.ysmjjsy.com/categories/JavaSE%E6%B5%81/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-Map容器</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E9%9B%86%E5%90%882/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-集合2/</id>
    <published>2017-08-23T10:35:42.000Z</published>
    <updated>2019-09-10T02:38:36.081Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 10 2019 10:41:17 GMT+0800 (GMT+08:00) --><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>Map，图，是一种存储键值对映射的容器类，在Map中键可以是任意类型的对象，但不能有重复的键，每个键都对应一个值，真正存储在图中的是键值构成的条目。</p><p><strong>Map和Collection集合的区别：</strong></p><p>Map容器存储元素是成对出现的，Map集合的键是唯一的，值是可重复的</p><p>Collection集合存储元素是单独出现的，Set是唯一的，List是可重复的</p><p>Map容器的数据结构值针对键有效，跟值无关</p><p>Collection集合的数据结构是针对元素有效</p><p>下面是接口Map的类结构。</p><p><img src="/category/JavaSE-集合2/map.png" alt="map"></p><p><img src="/category/JavaSE-集合2/map1.png" alt="map"></p><p>从上面这张图中我们可以看到接口Map提供了很多查询、更新和获取存储的键值对的方法，更新包括方法clear()、put()、putAll()、remove()等等，查询方法包括containsKey、containsValue等等。Map接口常用的有三个具体实现类，分别是HashMap、LinkedHashMap、TreeMap。</p><h2 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h2><ul><li><p>键找值</p></li><li><ul><li>获取所有的键的集合</li><li>遍历键的集合，得到每一个键</li><li>根据键到集合中去找值</li></ul></li><li><p>键值对对象找键和值</p></li><li><ul><li>获取所有键值对对象的集合</li><li>遍历键值对对象的集合，获取每一个键值对对象</li><li>根据键值对对象去获取键和值。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"><span class="comment">//创建元素并添加集合</span></span><br><span class="line">map.put(<span class="string">"a"</span>,<span class="string">"A"</span>);</span><br><span class="line">map.put(<span class="string">"b"</span>,<span class="string">"B"</span>);</span><br><span class="line">map.put(<span class="string">"c"</span>,<span class="string">"C"</span>);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">Set&lt;String&gt; set = map.keySet();</span><br><span class="line"><span class="comment">//遍历键的集合，获取得到每一个键</span></span><br><span class="line"><span class="keyword">for</span>(String key:set)&#123;</span><br><span class="line">  <span class="comment">//根据键去找值</span></span><br><span class="line">  String value = map.get(key);</span><br><span class="line">  System.out.println(key+<span class="string">"---"</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set&lt;map.Entry&lt;K,V&gt;&gt; entrySet():返回的是键值对对象的集合</span></span><br><span class="line"><span class="comment">//创建集合对象</span></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">"a"</span>,<span class="string">"A"</span>);</span><br><span class="line">map.put(<span class="string">"b"</span>,<span class="string">"B"</span>);</span><br><span class="line">map.put(<span class="string">"c"</span>,<span class="string">"C"</span>);</span><br><span class="line"><span class="comment">//获取所有键值对对象的集合</span></span><br><span class="line">Set&lt;Map.Entry&lt;String,String&gt;&gt; set = map.entrySet();</span><br><span class="line"><span class="comment">//遍历键值对对象的集合，得到每一个键值对对象</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Stirng,String&gt; me :set)&#123;</span><br><span class="line">  <span class="comment">//根据键值对对象获取键和值</span></span><br><span class="line">  String key = me.getKey();</span><br><span class="line">  String value = me.getValue();</span><br><span class="line">  System.out.println(key+<span class="string">"---"</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap是基于哈希表的Map接口的非同步实现，继承自AbstractMap，AbstractMap是部分实现Map接口的抽象类。在平时的开发中，HashMap的使用还是比较多的。</p><p><em>HashSet</em>和<em>HashMap</em>,二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong>HashSet里面有一个HashMap（适配器模式）</strong>。</p><p><em>HashMap</em>实现了<em>Map</em>接口，允许放入null元素，除该类未实现同步外，其余跟Hashtable大致相同，跟<em>TreeMap</em>不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个<em>HashMap</em>的顺序可能会不同。<br>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。<strong>Java HashMap采用的是冲突链表方式</strong>。</p><p><img src="/category/JavaSE-集合2/hm1.jpg" alt="HashMap"></p><p>从上图容易看出，如果选择合适的哈希函数，put()和get()方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</p><p>有两个参数可以影响<em>HashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>在之前的版本中，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当链表中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>哈希表内部使用Entry[]数组存放数据(Entry是封装键值对的对象)</p><p>数组默认的初始容量是16(可以通过构造方法参数指定)</p><p>数组容量会翻倍增长—StringBuilder翻倍+2</p><p>将对向放入到<em>HashMap</em>或<em>HashSet</em>中时，有两个方法需要特别关心：hashCode()和equals()。<strong>hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要@Override hashCode()和equals()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造函数 ( Hash值键值下一个节点 )</span></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-集合2/hm2.png" alt="HashMap"></p><p>Key.hashCode() 获得键的哈希值</p><p>使用哈希值和数组长度，来计算下标</p><p>把键值对封装成Entry实例</p><p>把Entry实例放入i 位置</p><p>空位置，直接放入</p><p>有数据，依次使用equals()进行比较是否相等</p><p>如果有相等的，覆盖值</p><p>如果没有相等的，链表连接在一起，放在链表头部，后进先出（碰撞）</p><p>负载率，加载因子到0.75(数据数量/容量)</p><p>新建翻倍容量的新数组</p><p>所有数据重新执行哈希运算，放入新数组</p><p>问题：</p><p>如果碰撞过多会造成效率低，所以尽可能要去避免。所以hashcode方法和equals重写的时候尽量严谨一些，并且尽量保持一致（对象一样，生成的hashcode值一样）</p><p>Jdk1.8之后</p><p>链表长度到8，会转成红黑树（平衡的二叉树）</p><p>树上的数据减少到6，会转回成链表</p><p>hashCode()</p><p>Object()方法</p><p>默认实现，使用内存地址作为哈希值，可以重写hashCode()方法，使用属性数据来计算产生哈希值</p><p>HashSet底层如何优化：</p><p>尽可能让对象的哈希值不通过</p><p>方法：</p><p>基本类型可以加值</p><p>引用类型就加哈希值</p><p>//哈希值尽量的分散</p><p>int p = 31; //固定</p><p>int r =1; //可以改变</p><p>r= r * p + x;</p><p>r= r * p + y;</p><p>returnr;</p><h3 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h3><ul><li><strong>get()</strong></li></ul><p>get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.getValue()。因此getEntry()是算法的核心。<br>算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过key.equals(k)方法来判断是否是要找的那个entry。</p><p><img src="/category/JavaSE-集合2/hm3.png" alt="HashMap"></p><p>上图中hash(k)&amp;(table.length-1)等价于hash(k)%table.length，原因是<em>HashMap</em>要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getEntry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-<span class="number">1</span>)];<span class="comment">//得到冲突链表</span></span><br><span class="line">         e != <span class="keyword">null</span>; e = e.next) &#123;<span class="comment">//依次遍历冲突链表中的每个entry</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//依据equals()方法判断是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>put()</strong></li></ul><p>put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry，插入方式为<strong>头插法</strong>。</p><p><img src="/category/JavaSE-集合2/hm4.png" alt="HashMap"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//自动扩容，并重新哈希</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">//hash%table.length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在冲突链表头部插入新的entry</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>remove()</strong></li></ul><p>remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry（修改链表的相应指针）。查找过程跟getEntry()过程类似。</p><p><img src="/category/JavaSE-集合2/hm5.png" alt="HashMap"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//removeEntryForKey()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//hash&amp;(table.length-1)</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">//得到冲突链表</span></span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">//遍历冲突链表</span></span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">//找到要删除的entry</span></span><br><span class="line">            modCount++; size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;<span class="comment">//删除的是冲突链表的第一个entry</span></span><br><span class="line">            <span class="keyword">else</span> prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e; e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>前面已经说过<em>HashSet</em>是对<em>HashMap</em>的简单包装，对<em>HashSet</em>的函数调用都会转换成合适的<em>HashMap</em>方法，因此<em>HashSet</em>的实现非常简单，只有不到300行代码。这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet是对HashMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="comment">//HashSet里面有一个HashMap</span></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用hash(int h)方法所计算得到的hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中，<strong>(n - 1) &amp; hash</strong>用于计算对象应该保存在table数组的哪个索引处。HashMap底层数组的长度总是2的n次方，当数组长度为2的n次幂的时候，<strong>(n - 1) &amp; hash</strong> 算得的index相同的几率较小，数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p></blockquote><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap继承自HashMap，它主要是用链表实现来扩展HashMap类，HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们插入图的顺序排序，也可以按它们最后一次被访问的顺序排序。</p><p><em>LinkedHashSet</em>和<em>LinkedHashMap</em>在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong>LinkedHashSet里面有一个LinkedHashMap（适配器模式）</strong>。</p><p><em>LinkedHashMap</em>实现了<em>Map</em>接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是<em>linked list</em>和<em>HashMap</em>的混合体，也就是说它同时满足<em>HashMap</em>和<em>linked list</em>的某些特性。<strong>可将LinkedHashMap看作采用linked list增强的HashMap。</strong></p><p><img src="/category/JavaSE-集合2/ls1.png" alt="LinkedHashMap"></p><p>事实上<em>LinkedHashMap</em>是<em>HashMap</em>的直接子类，<strong>二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表（doubly-linked list）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同</strong>。上图给出了<em>LinkedHashMap</em>的结构图，主体部分跟<em>HashMap</em>完全一样，多了header指向双向链表的头部（是一个哑元），<strong>该双向链表的迭代顺序就是entry的插入顺序</strong>。</p><p>除了可以保迭代历顺序，这种结构还有一个好处：<strong>迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可</strong>，也就是说<em>LinkedHashMap</em>的迭代时间就只跟entry的个数相关，而跟table的大小无关。</p><p>有两个参数可以影响<em>LinkedHashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到<em>LinkedHashMap</em>或<em>LinkedHashSet</em>中时，有两个方法需要特别关心：hashCode()和equals()。<strong>hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要@Override hashCode()和equals()方法。</p><p>通过如下方式可以得到一个跟源<em>Map<strong>迭代顺序</strong>一样的LinkedHashMap</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Map m)</span> </span>&#123;</span><br><span class="line">    Map copy = <span class="keyword">new</span> LinkedHashMap(m);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出于性能原因，<em>LinkedHashMap</em>是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>LinkedHashMap</em>包装成（wrapped）同步的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> LinkedHashMap(...));</span><br></pre></td></tr></table></figure><ul><li><strong>get()</strong></li></ul><p>get(Object key)方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样</p><ul><li><strong>put()</strong></li></ul><p>put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于get()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry。</p><p>注意，这里的<strong>插入有两重含义</strong>：</p><ol><li>从table的角度看，新的entry需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的entry插入到冲突链表的头部。</li><li>从header的角度看，新的entry需要插入到双向链表的尾部。</li></ol><p><img src="/category/JavaSE-集合2/ls2.png" alt="LinkedHashMap"></p><p>addEntry()代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.addEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">// 自动扩容，并重新哈希</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">// hash%table.length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.在冲突链表头部插入新的entry</span></span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</span><br><span class="line">    table[bucketIndex] = e;</span><br><span class="line">    <span class="comment">// 2.在双向链表的尾部插入新的entry</span></span><br><span class="line">    e.addBefore(header);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中用到了addBefore()方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。addBefore()的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</span><br><span class="line">    after  = existingEntry;</span><br><span class="line">    before = existingEntry.before;</span><br><span class="line">    before.after = <span class="keyword">this</span>;</span><br><span class="line">    after.before = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码只是简单修改相关entry的引用而已。</p><ul><li><strong>remove()</strong></li></ul><p>remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry（修改链表的相应引用）。查找过程跟get()方法类似。</p><p>注意，这里的<strong>删除也有两重含义</strong>：</p><blockquote><ol><li>从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li><li>从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li></ol></blockquote><p><img src="/category/JavaSE-集合2/ls3.png" alt="LinkedHashMap"></p><p>removeEntryForKey()对应的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.removeEntryForKey()，删除key值对应的entry</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">// hash&amp;(table.length-1)</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">// 得到冲突链表</span></span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">// 遍历冲突链表</span></span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">// 找到要删除的entry</span></span><br><span class="line">            modCount++; size--;</span><br><span class="line">            <span class="comment">// 1. 将e从对应bucket的冲突链表中删除</span></span><br><span class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;</span><br><span class="line">            <span class="keyword">else</span> prev.next = next;</span><br><span class="line">            <span class="comment">// 2. 将e从双向链表中删除</span></span><br><span class="line">            e.before.after = e.after;</span><br><span class="line">            e.after.before = e.before;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e; e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>前面已经说过<em>LinkedHashSet</em>是对<em>LinkedHashMap</em>的简单包装，对<em>LinkedHashSet</em>的函数调用都会转换成合适的<em>LinkedHashMap</em>方法，因此<em>LinkedHashSet</em>的实现非常简单，这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// LinkedHashSet里面有一个LinkedHashMap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的。</p><p>在实际使用中，如果更新图时不需要保持图中元素的顺序，就使用HashMap，如果需要保持图中元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap。</p><h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p><em>WeakHashMap</em>，从名字可以看出它是某种 <em>Map</em>。它的特殊之处在于 <em>WeakHashMap</em> 里的entry可能会被GC自动删除，即使程序员没有调用remove()或者clear()方法。</p><p>更直观的说，当使用 <em>WeakHashMap</em> 时，即使没有显示的添加或删除任何元素，也可能发生如下情况：</p><blockquote><ul><li>调用两次size()方法返回不同的值；</li><li>两次调用isEmpty()方法，第一次返回false，第二次返回true；</li><li>两次调用containsKey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；</li><li>两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。</li></ul></blockquote><p>遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉？其实不然，<em>WeekHashMap</em> 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。</p><p>要明白 <em>WeekHashMap</em> 的工作原理，还需要引入一个概念：弱引用（WeakReference）。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象（基本意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的“有效引用”并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。</p><p><em>WeakHashMap</em> 内部是通过弱引用来管理entry的，弱引用的特性对应到 <em>WeakHashMap</em> 上意味着什么呢？将一对key, value放入到 <em>WeakHashMap</em> 里并不能避免该key值被GC回收，除非在 <em>WeakHashMap</em> 之外还有对该key的强引用。</p><p>关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。</p><p><strong>具体实现</strong></p><p>WeakHashMap的存储结构类似于HashMap</p><p><strong>Weak HashSet?</strong></p><p>既然有 <em>WeekHashMap</em>，是否有 <em>WeekHashSet</em> 呢？答案是没有:( 。不过Java <em>Collections</em>工具类给出了解决方案，Collections.newSetFromMap(Map<e ,boolean>map)方法可以将任何 <em>Map</em>包装成一个<em>Set</em>。通过如下方式可以快速得到一个 <em>Weak HashSet</em>：</e></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将WeakHashMap包装成一个Set</span></span><br><span class="line">Set&lt;Object&gt; weakHashSet = Collections.newSetFromMap(</span><br><span class="line">        <span class="keyword">new</span> WeakHashMap&lt;Object, Boolean&gt;());</span><br></pre></td></tr></table></figure><p>不出你所料，newSetFromMap()方法只是对传入的 <em>Map</em>做了简单包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collections.newSetFromMap()用于将任何Map包装成一个Set</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">newSetFromMap</span><span class="params">(Map&lt;E, Boolean&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SetFromMap&lt;&gt;(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SetFromMap</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;E, Boolean&gt; m;  <span class="comment">// The backing map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;E&gt; s;       <span class="comment">// Its keySet</span></span><br><span class="line">    SetFromMap(Map&lt;E, Boolean&gt; map) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Map is non-empty"</span>);</span><br><span class="line">        m = map;</span><br><span class="line">        s = map.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123;        m.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> m.size(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> m.isEmpty(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> m.containsKey(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span>   </span>&#123; <span class="keyword">return</span> m.remove(o) != <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; <span class="keyword">return</span> m.put(e, Boolean.TRUE) == <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> s.iterator(); &#125;</span><br><span class="line">    <span class="keyword">public</span> Object[] toArray()         &#123; <span class="keyword">return</span> s.toArray(); &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)     &#123; <span class="keyword">return</span> s.toArray(a); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> s.toString(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>             </span>&#123; <span class="keyword">return</span> s.hashCode(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span>   </span>&#123; <span class="keyword">return</span> o == <span class="keyword">this</span> || s.equals(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;<span class="keyword">return</span> s.containsAll(c);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>   </span>&#123;<span class="keyword">return</span> s.removeAll(c);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>   </span>&#123;<span class="keyword">return</span> s.retainAll(c);&#125;</span><br><span class="line">    <span class="comment">// addAll is the only inherited implementation</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>Hashtable和前面介绍的HashMap很类似，它也是一个散列表，存储的内容是键值对映射，不同之处在于，Hashtable是继承自Dictionary的，Hashtable中的函数都是同步的，这意味着它也是线程安全的，另外，Hashtable中key和value都不可以为null。</p><p>上面的三个集合类都是在Java2之前推出的容器类，可以看到，尽管在使用中效率比较低，但是它们都是线程安全的。下面介绍两个特殊的集合类。</p><h2 id="Map总结"><a href="#Map总结" class="headerlink" title="Map总结"></a>Map总结</h2><ul><li><p>Map</p></li><li><ul><li>Map集合的数据结构仅仅针对键有效，与值无关。</li><li>存储的键值对形式的元素，键唯一，值可重复。</li></ul></li></ul><ul><li><p>HashMap</p></li><li><ul><li><p>底层数据结构是哈希表</p></li><li><p>哈希表依赖两个方法：hashCode()和equals()</p></li><li><p>执行顺序：</p></li><li><ul><li><p>首先判断hashCode()值是否相同</p></li><li><ul><li><p>是：继续执行equals(),看其返回值</p></li><li><ul><li>是true：说明元素重复，不添加</li><li>是false：就直接添加到集合</li></ul></li><li><p>否：就直接添加到集合</p></li></ul></li><li><p>最终：自动生成hashCode()和equals()即可</p></li></ul></li><li><p>LinkedHashSet</p></li><li><ul><li>底层数据结构由链表和哈希表组成</li><li>由链表保证元素有序</li><li>由哈希表保证元素唯一</li></ul></li></ul></li><li><p>Hashtable</p></li><li><ul><li><p>底层数据结构是哈希表.线程安全，效率低</p></li><li><p>哈希表依赖两个方法：hashCode()和equals()</p></li><li><p>执行顺序：</p></li><li><ul><li><p>首先判断hashCode()值是否相同</p></li><li><ul><li><p>是：继续执行equals(),看其返回值</p></li><li><ul><li>是true：说明元素重复，不添加</li><li>是false：就直接添加到集合</li></ul></li><li><p>否：就直接添加到集合</p></li></ul></li><li><p>最终：自动生成hashCode()和equals()即可</p></li></ul></li></ul></li><li><p>TreeMap</p></li><li><ul><li><p>底层数据结构是红黑树（是一种平衡的二叉树）</p></li><li><p>如何保证元素唯一性呢？</p></li><li><ul><li>根据比较的返回值是否是0来确定</li></ul></li><li><p>如何保证元素的排序呢？</p></li><li><ul><li><p>两种方式</p></li><li><ul><li><p>自然排序（元素具备比较性）</p></li><li><ul><li>让元素所属的类实现Comparable接口</li></ul></li><li><p>比较器排序（集合具备比较性）</p></li><li><ul><li>让集合接受一个Comparator的实现类对象</li></ul></li></ul></li></ul></li></ul></li></ul><p>集合的常见方法及遍历方式</p><p>Collection：</p><p>add()</p><p>remove()</p><p>contains()</p><p>iterator()</p><p>size()</p><p>遍历：</p><p>增强for</p><p>迭代器</p><ul><li>List</li></ul><p>get（）</p><p>遍历：</p><p>普通for</p><ul><li>Set</li></ul><p>Map：</p><p>put()</p><p>remove()</p><p>containskey(),containsValue()</p><p>keySet()</p><p>get()</p><p>value()</p><p>entrySet()</p><p>size()</p><p>遍历：</p><p>根据键找值</p><p>根据键值对对象分别找键和值</p><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>针对集合操作的工具类，有对集合进行排序和二分查找的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span>;<span class="comment">//排序，默认情况下是自然排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">binarySearch</span><span class="params">(List&lt;?&gt; list,T key)</span></span>;<span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;T&gt; list)</span></span>;<span class="comment">//反转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list)</span></span>;<span class="comment">//随机置换</span></span><br></pre></td></tr></table></figure><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="体介绍"><a href="#体介绍" class="headerlink" title="体介绍"></a>体介绍</h2><p>Java <em>TreeMap</em>实现了<em>SortedMap</em>接口，也就是说会按照key的大小顺序对<em>Map</em>中的元素进行排序，key大小的评判可以通过其本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator）。</p><p><strong>TreeMap底层通过红黑树（Red-Black tree）实现</strong>，也就意味着containsKey(), get(), put(), remove()都有着log(n)的时间复杂度。其具体算法实现参照了《算法导论》。</p><p><img src="/category/JavaSE-集合2/hh1.png" alt="红黑树"></p><p>出于性能原因，<em>TreeMap</em>是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>TreeMap</em>包装成（wrapped）同步的：</p><p>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(…));</p><p><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一陪</strong>。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。</li><li>对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。</li></ol><p>在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的条件。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>前文说到当查找树的结构发生改变时，红黑树的条件可能被破坏，需要通过调整使得查找树重新满足红黑树的条件。调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：<strong>左旋（Rotate Left），右旋（RotateRight）</strong>。</p><h2 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h2><p>左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/category/JavaSE-集合2/hh2.png" alt="红黑树"></p><p><em>TreeMap</em>中左旋代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rotate Left</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a><strong>右旋</strong></h2><p>右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/category/JavaSE-集合2/hh3.png" alt="红黑树"></p><p><em>TreeMap</em>中右旋代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rotate Right</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法剖析-1"><a href="#方法剖析-1" class="headerlink" title="方法剖析"></a>方法剖析</h2><ul><li><strong>get()</strong></li></ul><p>get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.value。因此getEntry()是算法的核心。算法思想是根据key的自然顺序（或者比较器顺序）对二叉查找树进行查找，直到找到满足k.compareTo(p.key) == 0的entry。</p><p><img src="/category/JavaSE-集合2/hh4.png" alt="红黑树"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getEntry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)<span class="comment">//不允许key值为null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)<span class="comment">//向左找</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">//向右找</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>put()</strong></li></ul><p>put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束，还需要进行调整（旋转，改变某些节点的颜色）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) t = t.left;<span class="comment">//向左找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) t = t.right;<span class="comment">//向右找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);<span class="comment">//创建并插入新的entry</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) parent.left = e;</span><br><span class="line">    <span class="keyword">else</span> parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);<span class="comment">//调整</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的插入部分并不难理解：首先在红黑树上找到合适的位置，然后创建新的entry并插入（当然，新插入的节点一定是树的叶子）。难点是调整函数fixAfterInsertion()，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。</p><p><img src="/category/JavaSE-集合2/hh5.png" alt="红黑树"></p><p>调整函数fixAfterInsertion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树调整函数fixAfterInsertion()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;<span class="comment">//如果y为null，则视为BLACK</span></span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况1</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">// 情况1</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况1</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       <span class="comment">// 情况2</span></span><br><span class="line">                    rotateLeft(x);                         <span class="comment">// 情况2</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况3</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况3</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));        <span class="comment">// 情况3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况4</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">// 情况4</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况4</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况4</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       <span class="comment">// 情况5</span></span><br><span class="line">                    rotateRight(x);                        <span class="comment">// 情况5</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况6</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况6</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));         <span class="comment">// 情况6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>remove()</strong></li></ul><p>remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry<k ,v>entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束，因此有可能要进行调整。</k></p><h2 id="寻找节点后继"><a href="#寻找节点后继" class="headerlink" title="寻找节点后继"></a>寻找节点后继</h2><p>对于一棵二叉查找树，给定节点t，其后继（树种比大于t的最小的那个元素）可以通过如下方式找到：</p><blockquote><ol><li>t的右子树不空，则t的后继是其右子树中最小的那个元素。</li><li>t的右孩子为空，则t的后继是其第一个向左走的祖先。</li></ol></blockquote><p>后继节点在红黑树的删除操作中将会用到。</p><p><img src="/category/JavaSE-集合2/hm6.png" alt="红黑树"></p><p>TreeMap</p><p>中寻找节点后继的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 寻找节点后继函数successor()</span><br><span class="line">static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123;</span><br><span class="line">    if (t == null)</span><br><span class="line">        return null;</span><br><span class="line">    else if (t.right != null) &#123;// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素</span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        while (p.left != null)</span><br><span class="line">            p = p.left;</span><br><span class="line">        return p;</span><br><span class="line">    &#125; else &#123;// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先</span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        while (p != null &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>remove()</strong></p><p>remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry<k ,v>entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。</k></p><p>getEntry()函数前面已经讲解过，这里重点放deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixAfterDeletion(Entry<k ,v>x)进行调整。</k></p><p><strong>由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整</strong>。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况：</p><blockquote><ol><li>删除点p的左右子树都为空，或者只有一棵子树非空。</li><li>删除点p的左右子树都非空。</li></ol></blockquote><p>对于上述情况1，处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）；对于情况2，可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1，可以画画看）。</p><p>基于以上逻辑，红黑树的节点删除函数deleteEntry()代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红黑树entry删除函数deleteEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;<span class="comment">// 2. 删除点p的左右子树都非空。</span></span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);<span class="comment">// 后继</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;<span class="comment">// 1. 删除点p只有一棵子树非空。</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);<span class="comment">// 调整</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 1. 删除点p的左右子树都为空</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);<span class="comment">// 调整</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数fixAfterDeletion()。首先请思考一下，删除了哪些点才会导致调整？<strong>只有删除点是BLACK的时候，才会触发调整函数</strong>，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。</p><p>跟上文中讲过的fixAfterInsertion()函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种：1.改变某些节点的颜色，2.对某些节点进行旋转。</p><p><img src="/category/JavaSE-集合2/hh7.png" alt="红黑树"></p><p>上述图解的总体思想是：将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则：a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环（因为x为红色）；b).一旦进入情况3和情况4，一定会退出循环（因为x为root）。</p><p>删除后调整函数fixAfterDeletion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况1</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况1</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况1</span></span><br><span class="line">                sib = rightOf(parentOf(x));             <span class="comment">// 情况1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 情况2</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 情况2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);       <span class="comment">// 情况3</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 情况3</span></span><br><span class="line">                    rotateRight(sib);                   <span class="comment">// 情况3</span></span><br><span class="line">                    sib = rightOf(parentOf(x));         <span class="comment">// 情况3</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况4</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况4</span></span><br><span class="line">                setColor(rightOf(sib), BLACK);          <span class="comment">// 情况4</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况4</span></span><br><span class="line">                x = root;                               <span class="comment">// 情况4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 跟前四种情况对称</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况5</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况5</span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况5</span></span><br><span class="line">                sib = leftOf(parentOf(x));              <span class="comment">// 情况5</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 情况6</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 情况6</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);      <span class="comment">// 情况7</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 情况7</span></span><br><span class="line">                    rotateLeft(sib);                    <span class="comment">// 情况7</span></span><br><span class="line">                    sib = leftOf(parentOf(x));          <span class="comment">// 情况7</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况8</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况8</span></span><br><span class="line">                setColor(leftOf(sib), BLACK);           <span class="comment">// 情况8</span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况8</span></span><br><span class="line">                x = root;                               <span class="comment">// 情况8</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>前面已经说过TreeSet是对TeeMap的简单包装，对TreeSet的函数调用都会转换成合适的TeeMap方法，因此TreeSet的实现非常简单。这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet是对TreeMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = <span class="keyword">new</span> TreeMap&lt;E,Object&gt;();<span class="comment">// TreeSet里面有一个TreeMap</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE面向对象,集合,HashMap,红黑树
    
    </summary>
    
      <category term="JavaSE集合框架" scheme="https://www.ysmjjsy.com/categories/JavaSE%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-异常</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E5%BC%82%E5%B8%B8/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-异常/</id>
    <published>2017-08-23T10:35:42.000Z</published>
    <updated>2019-09-10T07:12:54.258Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 10 2019 15:13:45 GMT+0800 (GMT+08:00) --><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。</p><ul><li><strong>Throwable 类</strong>是 Java 语言中所有错误或异常的超类。</li><li>只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。类似地，只有此类或其子类之一才可以是 catch 子句中的参数类型。</li><li>Throwable 包含了其线程创建时线程执行堆栈的快照。它还包含了给出有关错误更多信息的消息字符串。</li><li>最后，它还可以包含 cause（原因）：另一个导致此 throwable 抛出的 throwable。此 cause 设施在 1.4 版本中首次出现。它也称为异常链 设施，因为 cause 自身也会有 cause，依此类推，就形成了异常链，每个异常都是由另一个异常引起的。</li></ul><p><img src="/category/JavaSE-异常/th1.png" alt="异常"></p><p>上图可以看到Java异常体系层次结构图</p><p>在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。异常对象都是派生于Throwable类的一个实例，如果Java中内置的异常类不能满足需求，可以创建者自己的异常类。</p><p>在 Java 中一个异常的产生，主要有如下三种原因：</p><ol><li>Java 内部错误发生异常，Java 虚拟机产生的异常。</li><li>编写的程序代码中的错误所产生的异常，例如空指针异常、数组越界异常等。这种异常称为未检査的异常，一般需要在某些类中集中处理这些异常。</li><li>通过 throw 语句手动生成的异常，这种异常称为检査的异常，一般用来告知该方法的调用者一些必要的信息。</li></ol><p>Java 通过面向对象的方法来处理异常。在一个方法的运行过程中，如果发生了异常，则这个方法会产生代表该异常的一个对象，并把它交给运行时的系统，运行时系统寻找相应的代码来处理这一异常。</p><p>我们把生成异常对象，并把它提交给运行时系统的过程称为拋出（throw）异常。运行时系统在方法的调用栈中查找，直到找到能够处理该类型异常的对象，这一个过程称为捕获（catch）异常。</p><p><strong>Throwable：</strong> 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><h2 id="检查与非检查"><a href="#检查与非检查" class="headerlink" title="检查与非检查"></a>检查与非检查</h2><p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。通常，Java的异常(包括Exception和Error)分为<strong>可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。</strong>派生于Error类或RuntimeException类的所有异常称为未检查异常，所有其他的异常称为已检查异常。编译器将核查是否为所有的已检查异常提供类了异常处理器。<br>可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p><pre><code>  除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。 不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。### 常见的非检查性异常：</code></pre><p><img src="/category/JavaSE-异常/yc01.png" alt="非检查性异常"></p><h3 id="常见的检查性异常："><a href="#常见的检查性异常：" class="headerlink" title="常见的检查性异常："></a>常见的检查性异常：</h3><p><img src="/category/JavaSE-异常/yc02.png" alt="检查性异常"></p><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><ul><li><p><strong>Error（错误）：</strong>Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p><p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p><ul><li>Error 是 Throwable 的子类，用于指示合理的应用程序<strong>不应该试图捕获的严重问题</strong>。</li><li>大多数这样的错误都是异常条件。虽然 ThreadDeath 错误是一个“正规”的条件，但它也是 Error 的子类，因为大多数应用程序都不应该试图捕获它。</li><li>在执行该方法期间，无需在其 throws 子句中声明可能抛出但是未能捕获的 Error 的任何子类，因为这些错误可能是再也不会发生的异常条件。</li><li>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。</li></ul></li></ul><h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><ul><li><strong>Exception（异常）：</strong> 是程序本身可以处理的异常。</li></ul><p>Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。</p><p>Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。</p><ul><li>Exception 常用异常主要分为两类<ul><li><strong>非运行时异常 （编译异常）：</strong>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。IOException（I/O 输入输出异常），其中 IOException 及其子类异常又被称作「受查异常」，程序本身没有问题，由于向I/O错误这类问题属于其他异常、试图在文件尾部后面读取数据、试图打开一个不存在的文件、试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在。</li><li>另一类是 <strong>RuntimeException（运行时异常）</strong>，RuntimeException 被称作「非受查异常」。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。错误的类型转换、数组访问越界、访问空指针、如果出现RuntimeException异常，那就一定是你的问题。</li></ul></li><li>受查异常就是指，编译器在编译期间要求必须得到处理的那些异常，你必须在编译期处理了。</li></ul><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p>在 Java 应用程序中，异常处理机制为：<strong>抛出异常</strong>，<strong>捕捉异常</strong>。</p><p>对于运行时异常、错误或可查异常，Java技术所要求的异常处理方式有所不同。</p><p>由于运行时异常的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。</p><p>对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数Error异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。</p><p>对于所有的可查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常。</p><p>能够捕捉异常的方法，需要提供相符类型的异常处理器。所捕捉的异常，可能是由于自身语句所引发并抛出的异常，也可能是由某个调用的方法或者Java运行时 系统等抛出的异常。也就是说，一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。</p><p>任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常。</p><p>从方法中抛出的任何异常都必须使用throws子句。</p><p>捕捉异常通过try-catch语句或者try-catch-finally语句实现。</p><p>总体来说，Java规定：对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。</p><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</p><p>什么时候使用throws子句声明异常，什么异常必须使用throws子句声明:</p><p>调用一个抛出已检查异常的方法</p><p>程序运行过程中发现错误，并且利用throw语句抛出一个已检查异常</p><p>程序出现错误</p><p>Java虚拟机和运行时库出现的内部错误</p><p>对于那些可能被他人使用的Java方法，应该根据异常规范，在方法的首部声明</p><p>这个方法可能抛出异常，如果一个方法有可能抛出多个已检查异常，那么就必须在方法的首部列出所有的异常类，每个异常类之间用逗号隔开。但是不需要声明Java内部错误，即从Error继承的错误。</p><p>任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常。从方法中抛出的任何异常都必须使用throws子句。</p><h4 id="throws抛出异常"><a href="#throws抛出异常" class="headerlink" title="throws抛出异常"></a>throws抛出异常</h4><p>如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用throws子句来声明抛出异常。例如汽车在运行时可能会出现故障，汽车本身没办法处理这个故障，那就让开车的人来处理。</p><p>throws语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是Exception异常类型，则该方法被声明为抛出所有的异常。多个异常可使用逗号分割。throws语句的语法格式为：throws 异常类名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methodname <span class="keyword">throws</span> Exception1,Exception2,..,ExceptionN</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法名后的throws Exception1,Exception2,…,ExceptionN 为声明要抛出的异常列表。当方法抛出异常列表的异常时，方法将不对这些类型及其子类类型的异常作处理，而抛向调用该方法的方法，由他去处理。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Exception;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> NegativeArraySizeException </span>&#123;</span><br><span class="line"><span class="comment">// 定义方法并抛出NegativeArraySizeException异常</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[-<span class="number">3</span>]; <span class="comment">// 创建数组</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// 主方法</span></span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// try语句处理异常信息</span></span><br><span class="line">pop(); <span class="comment">// 调用pop()方法</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NegativeArraySizeException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"pop()方法抛出的异常"</span>);<span class="comment">// 输出异常信息</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用throws关键字将异常抛给调用者后，如果调用者不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的调用者。</p><p>pop方法没有处理异常NegativeArraySizeException，而是由main函数来处理。</p><h5 id="Throws抛出异常的规则："><a href="#Throws抛出异常的规则：" class="headerlink" title="Throws抛出异常的规则："></a>Throws抛出异常的规则：</h5><pre><code>1) 如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。2）必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误3)仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。4）调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;&#125;  <span class="comment">//合法  </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//编译错误，必须捕获或声明抛出IOException  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  method1();  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//合法，声明抛出IOException  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span><span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">  method1();  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//合法，声明抛出Exception，IOException是Exception的子类  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">  method1();  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//合法，捕获IOException  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> <span class="keyword">try</span>&#123;  </span><br><span class="line">    method1();  </span><br><span class="line"> &#125;<span class="keyword">catch</span>(IOException e)&#123;…&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//编译错误，必须捕获或声明抛出Exception  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method6</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  <span class="keyword">try</span>&#123;  </span><br><span class="line">    method1();  </span><br><span class="line">  &#125;<span class="keyword">catch</span>(IOException e)&#123;<span class="keyword">throw</span> <span class="keyword">new</span> Exception();&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//合法，声明抛出Exception  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method7</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;  </span><br><span class="line"> <span class="keyword">try</span>&#123;  </span><br><span class="line">  method1();  </span><br><span class="line"> &#125;<span class="keyword">catch</span>(IOException e)&#123;<span class="keyword">throw</span> <span class="keyword">new</span> Exception();&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一个方法可能会出现异常的依据如下：</p><pre><code> 1. 方法中有throw语句。例如，以上method7()方法的catch代码块有throw语句。      2. 调用了其他方法，其他方法用throws子句声明抛出某种异常。例如，method3()方法调用了method1()方法，method1()方法声明抛出IOException，因此，在method3()方法中可能会出现IOException。</code></pre><h4 id="使用throw抛出异常"><a href="#使用throw抛出异常" class="headerlink" title="使用throw抛出异常"></a>使用throw抛出异常</h4><p>throw总是出现在函数体中，用来抛出一个Throwable类型的异常。程序会在throw语句后立即终止，它后面的语句执行不到，然后在包含它的所有try块中（可能在上层调用函数中）从里向外寻找含有与其匹配的catch子句的try块。<br>我们知道，异常是异常类的实例对象，我们可以创建异常类的实例对象通过throw语句抛出。如果出现了异常情况，我们可以把该异常抛出，这个时候抛出的应该是异常的对象。该语句的语法格式为：<br>throw new exceptionname;<br>例如抛出一个IOException类的异常对象：<br>throw new IOException;<br>要注意的是，throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象。下面的操作是错误的：<br>throw new String(“exception”);<br>这是因为String 不是Throwable 类的子类。</p><p>如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。</p><p>如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"><span class="keyword">import</span> java.lang.Exception;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quotient</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">throws</span> MyException </span>&#123; <span class="comment">// 定义方法抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (y &lt; <span class="number">0</span>) &#123; <span class="comment">// 判断参数是否小于0</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"除数不能是负数"</span>); <span class="comment">// 异常信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x/y; <span class="comment">// 返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; <span class="comment">// 主方法</span></span><br><span class="line"><span class="keyword">int</span>  a =<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>  b =<span class="number">0</span>; </span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// try语句包含可能发生异常的语句</span></span><br><span class="line"><span class="keyword">int</span> result = quotient(a, b); <span class="comment">// 调用方法quotient()</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (MyException e) &#123; <span class="comment">// 处理自定义异常</span></span><br><span class="line">System.out.println(e.getMessage()); <span class="comment">// 输出异常信息</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123; <span class="comment">// 处理ArithmeticException异常</span></span><br><span class="line">System.out.println(<span class="string">"除数不能为0"</span>); <span class="comment">// 输出提示信息</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">// 处理其他异常</span></span><br><span class="line">System.out.println(<span class="string">"程序发生了其他的异常"</span>); <span class="comment">// 输出提示信息</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; <span class="comment">// 创建自定义异常类</span></span><br><span class="line">String message; <span class="comment">// 定义String类型变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String ErrorMessagr)</span> </span>&#123; <span class="comment">// 父类方法</span></span><br><span class="line">message = ErrorMessagr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123; <span class="comment">// 覆盖getMessage()方法</span></span><br><span class="line"><span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="throws和throw的区别"><a href="#throws和throw的区别" class="headerlink" title="throws和throw的区别"></a>throws和throw的区别</h4><p><strong>throws：</strong></p><p>用在方法声明后面，跟的是异常类名</p><p>可以跟多个异常类名，用逗号隔开</p><p>表示抛出异常，由该方法的调用者来处理</p><p>throws表示出现异常的一种可能性，并不一定会发生这些异常</p><p><strong>throw：</strong></p><p>用在方法体内，跟的是异常对象名</p><p>只能抛出一个异常对象名</p><p>表示抛出异常，由方法体内的语句处理</p><p>throw则是抛出了异常，执行throw则一定抛出了某种异常</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p><h4 id="try…catch语句"><a href="#try…catch语句" class="headerlink" title="try…catch语句"></a>try…catch语句</h4><p>其基本格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//可能出现问题的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常名 变量)&#123;</span><br><span class="line">  <span class="comment">//针对问题的处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">try&#123;</span></span><br><span class="line"><span class="comment">   // 程序代码</span></span><br><span class="line"><span class="comment">&#125;catch(异常类型1 异常的变量名1)&#123;</span></span><br><span class="line"><span class="comment">  // 程序代码</span></span><br><span class="line"><span class="comment">&#125;catch(异常类型2 异常的变量名2)&#123;</span></span><br><span class="line"><span class="comment">  // 程序代码</span></span><br><span class="line"><span class="comment">&#125;catch(异常类型2 异常的变量名2)&#123;</span></span><br><span class="line"><span class="comment">  // 程序代码</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>关键词try后的一对大括号将一块可能发生异常的代码包起来，称为监控区域。Java方法在运行过程中出现异常，则创建异常对象。将异常抛出监控区域之 外，由Java运行时系统试图寻找匹配的catch子句以捕获异常。若有匹配的catch子句，则运行其异常处理代码，try-catch语句结束。</p><p>try后可以有多个catch</p><p>匹配的原则是：如果抛出的异常对象属于catch子句的异常类，或者属于该异常类的子类，则认为生成的异常对象与catch块捕获的异常类型相匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//捕捉throw语句抛出的“除数为0”异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// try监控区域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(); <span class="comment">// 通过throw语句抛出异常</span></span><br><span class="line">System.out.println(<span class="string">"a/b的值是："</span> + a / b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArithmeticException e) &#123; <span class="comment">// catch捕捉异常</span></span><br><span class="line">System.out.println(<span class="string">"程序出现异常，变量b不能为0。"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"程序正常结束。"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：程序出现异常，变量b不能为0。</span></span><br><span class="line"><span class="comment">//程序正常结束。</span></span><br><span class="line"><span class="comment">//在try监控区域通过if语句进行判断，当“除数为0”的错误条件成立时引发ArithmeticException异常，创建 ArithmeticException异常对象，并由throw语句将异常抛给Java运行时系统，由系统寻找匹配的异常处理器catch并运行相应异 常处理代码，打印输出“程序出现异常，变量b不能为0。”try-catch语句结束，继续程序流程。</span></span><br><span class="line"><span class="comment">//事实上，“除数为0”等ArithmeticException，是RuntimException的子类。而运行时异常将由运行时系统自动抛出，不需要使用throw语句。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//捕捉运行时系统自动抛出“除数为0”引发的ArithmeticException异常。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"a/b的值是："</span> + a / b);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"程序出现异常，变量b不能为0。"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"程序正常结束。"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：程序出现异常，变量b不能为0。</span></span><br><span class="line"><span class="comment">//程序正常结束。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">System.out.println("a/b的值是：" + a/b);</span></span><br><span class="line"><span class="comment">在运行中出现“除数为0”错误，引发ArithmeticException异常。运行时系统创建异常对象并抛出监控区域，转而匹配合适的异常处理器catch，并执行相应的异常处理代码。</span></span><br><span class="line"><span class="comment">由于检查运行时异常的代价远大于捕捉异常所带来的益处，运行时异常不可查。Java编译器允许忽略运行时异常，一个方法可以既不捕捉，也不声明抛出运行时异常。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不捕捉、也不声明抛出运行时异常。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line">b = <span class="number">0</span>; <span class="comment">// 除数b 的值为0</span></span><br><span class="line">System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">at Test.TestException.main(TestException.java:8)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序可能存在除数为0异常和数组下标越界异常。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= intArray.length; i++) &#123;</span><br><span class="line">intArray[i] = i;</span><br><span class="line">System.out.println(<span class="string">"intArray["</span> + i + <span class="string">"] = "</span> + intArray[i]);</span><br><span class="line">System.out.println(<span class="string">"intArray["</span> + i + <span class="string">"]模 "</span> + (i - <span class="number">2</span>) + <span class="string">"的值:  "</span></span><br><span class="line">+ intArray[i] % (i - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"intArray数组下标越界异常。"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"除数为0异常。"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"程序正常结束。"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">intArray[0] = 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">intArray[0]模 -2的值:  0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">intArray[1] = 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">intArray[1]模 -1的值:  0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">intArray[2] = 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">除数为0异常。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序正常结束。</span></span><br><span class="line"><span class="comment">程序可能会出现除数为0异常，还可能会出现数组下标越界异常。程序运行过程中ArithmeticException异常类型是先行匹配的，因此执行相匹配的catch语句：</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>需要注意的是，一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。</p><p>Java通过异常类描述异常类型，异常类的层次结构如图1所示。对于有多个catch子句的异常程序而言，应该尽量将捕获底层异常类的catch子 句放在前面，同时尽量将捕获相对高层的异常类的catch子句放在后面。否则，捕获底层异常类的catch子句将可能会被屏蔽。</p><p>RuntimeException异常类包括运行时各种常见的异常，ArithmeticException类和ArrayIndexOutOfBoundsException类都是它的子类。因此，RuntimeException异常类的catch子句应该放在 最后面，否则可能会屏蔽其后的特定异常处理或引起编译错误。</p><h4 id="try…catch…finall语句"><a href="#try…catch…finall语句" class="headerlink" title="try…catch…finall语句"></a>try…catch…finall语句</h4><p>try-catch语句还可以包括第三部分，就是finally子句。它表示无论是否出现异常，都应当执行的内容。</p><ul><li>finally 关键字用来创建在 try 代码块后面执行的代码块。</li><li><strong>无论是否发生异常，finally 代码块中的代码总会被执行</strong>。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</li></ul><p>try-catch-finally语句的一般语法形式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 可能会发生异常的程序代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Type1 id1) &#123;</span><br><span class="line">  <span class="comment">// 捕获并处理try抛出的异常类型Type1</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Type2 id2) &#123;</span><br><span class="line">  <span class="comment">// 捕获并处理try抛出的异常类型Type2</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 无论是否发生异常，都将执行的语句块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">String greetings[] = &#123; <span class="string">" Hello world !"</span>, <span class="string">" Hello World !! "</span>,</span><br><span class="line"><span class="string">" HELLO WORLD !!!"</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 特别注意循环控制变量i的设计，避免造成无限循环</span></span><br><span class="line">System.out.println(greetings[i++]);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"数组下标越界异常"</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"--------------------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">Hello world !</span></span><br><span class="line"><span class="comment">--------------------------</span></span><br><span class="line"><span class="comment">Hello World !!</span></span><br><span class="line"><span class="comment">--------------------------</span></span><br><span class="line"><span class="comment">HELLO WORLD !!!</span></span><br><span class="line"><span class="comment">--------------------------</span></span><br><span class="line"><span class="comment">数组下标越界异常</span></span><br><span class="line"><span class="comment">--------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。<br>catch 块：用于处理try捕获到的异常。<br>finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。</p><p>在以下4种特殊情况下，finally块不会被执行：</p><ol><li>在finally语句块中发生了异常。</li><li>在前面的代码中用了System.exit()退出程序。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7出现了新的异常处理方案</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常名<span class="number">1</span>|异常名<span class="number">2</span>|... 变量)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个方法虽然简洁，但是也不够好</span></span><br><span class="line"><span class="comment">//处理方式是一致的(实际开发中，好多时候可能就是针对同类型的问题，给出同一个处理)</span></span><br><span class="line"><span class="comment">//多个异常之间必须是平级关系</span></span><br></pre></td></tr></table></figure><p>try里面发现问题后，jvm会帮我们生成一个异常对象，然后把这个对象抛出，和catch里面的类进行匹配，如果该对象是某个类型的，就会执行该catch里面的处理信息</p><p>异常中要了解的几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span></span>;<span class="comment">//异常的消息字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;<span class="comment">//返回异常的简单信息描述</span></span><br><span class="line"><span class="comment">//此对象的类的name(全路径名)</span></span><br><span class="line"><span class="comment">//":"(冒号和一个空格)</span></span><br><span class="line"><span class="comment">//调用此对象getLocalizeMessage()方法的结果(默认返回的是getMessage()的内容)</span></span><br><span class="line">printStackTrace();<span class="comment">//获取异常类名和异常的信息，以及异常出现在程序中的位置，返回值void，把信息输出在控制台</span></span><br></pre></td></tr></table></figure><h5 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h5><p>被finally控制的语句体一定会执行(特殊情况：在执行到finally之前jvm退出了(比如System.exit(0))</p><p><strong>finally的作用：</strong></p><p>用于释放资源，在IO流操作和数据库操作中会见到</p><p><strong>面试题：</strong></p><p>final,finally,和finalize的区别？</p><p>final：最终的意思，可以修饰类，成员变量，成员方法</p><p>finally：是异常处理的一部分，用于释放资源</p><p>finalize：是Object类的一个方法，用于垃圾回收</p><p>如果catch里面有return语句，请问finally里面的代码还会执行吗？如果会，请问是在return前还是return后？</p><p>会，前。准确的说应该是中间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(getInt());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      System.out.println(a/<span class="number">0</span>);</span><br><span class="line">      a = <span class="number">20</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">      a = <span class="number">30</span>;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      return a 在程序执行到这一步的时候，这里不是return a而是return 30;这个返回路径就形成了，但是呢，他发现后面还有finally，所以继续执行finally的内容，a=40.再次回到以前的返回路径，继续走return 30;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      a = <span class="number">40</span>;</span><br><span class="line">      <span class="keyword">return</span> a;<span class="comment">//如果这样结果就是40了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return a;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="try-carch…finally语句的执行顺序"><a href="#try-carch…finally语句的执行顺序" class="headerlink" title="try..carch…finally语句的执行顺序"></a>try..carch…finally语句的执行顺序</h4><ol><li>当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；</li><li>当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；</li><li>当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；</li></ol><p><img src="/category/JavaSE-异常/try.png" alt="try"></p><h3 id="我们应该如何处理异常以及异常注意事项"><a href="#我们应该如何处理异常以及异常注意事项" class="headerlink" title="我们应该如何处理异常以及异常注意事项"></a>我们应该如何处理异常以及异常注意事项</h3><p>原则：如果该功能内部可以将问题处理，用try，如果处理不了，交由调用者处理，用throws</p><p>区别：后续程需要继续运行就try，后续程序不需要继续运行就throws</p><p>举例：感冒了就自己吃点药 try</p><p>吃了好几天药没得结果得了H7N9，那就得throws</p><p>如果医院没有特效药就变成Error</p><h3 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h3><p>子类覆盖父类的方法时，子类的方法必须抛出相同的异常或父类。</p><p>如果父类抛出了多个异常，子类覆盖父类时，只能抛出相同的异常或者时他的子集，子类不能抛出父类没有的异常</p><p>如果被覆盖的方法没有异常抛出，那么子类的方法绝对不可以抛出异常，如果子类方法内由异常发生，那么子类只能try，不能throws</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>java不可能所有的情况都考虑到，所以在实际的开发中，我们可能需要自己定义异常</p><p>而我们自己随意的写一个类，是不能作为异常类来看的，要想你的类是一个异常类就必须继承自Exception或者RuntimeException：</p><p>两种方式：</p><ul><li>继承Exception</li><li>继承RuntimeException</li></ul><h2 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h2><pre><code>  1. 如果调用quotient(3,-1)，将发生MyException异常，程序调转到catch (MyException e)代码块中执行；  2.  如果调用quotient(5,0)，将会因“除数为0”错误引发ArithmeticException异常，属于运行时异常类，由Java运行时系统自动抛出。quotient（）方法没有捕捉ArithmeticException异常，Java运行时系统将沿方法调用栈查到main方法，将抛出的异常上传至quotient（）方法的调用者：     int result = quotient(a, b); // 调用方法quotient()    由于该语句在try监控区域内，因此传回的“除数为0”的ArithmeticException异常由Java运行时系统抛出，并匹配catch子句：   catch (ArithmeticException e) { // 处理ArithmeticException异常</code></pre><p>System.out.println(“除数不能为0”); // 输出提示信息<br>}</p><pre><code>    处理结果是输出“除数不能为0”。Java这种向上传递异常信息的处理机制，形成异常链。   Java方法抛出的可查异常将依据调用栈、沿着方法调用的层次结构一直传递到具备处理能力的调用方法，最高层次到main方法为止。如果异常传递到main方法，而main不具备处理能力，也没有通过throws声明抛出该异常，将可能出现编译错误。        3. 如还有其他异常发生，将使用catch (Exception e)捕捉异常。由于Exception是所有异常类的父类，如果将catch (Exception e)代码块放在其他两个代码块的前面，后面的代码块将永远得不到执行，就没有什么意义了，所以catch语句的顺序不可掉换。</code></pre><h2 id="Throwable类中的常用方法"><a href="#Throwable类中的常用方法" class="headerlink" title="Throwable类中的常用方法"></a>Throwable类中的常用方法</h2><p>注意：catch关键字后面括号中的Exception类型的参数e。Exception就是try代码块传递给catch代码块的变量类型，e就是变量名。catch代码块中语句”e.getMessage();”用于输出错误性质。通常异常处理常用3个函数来获取异常的有关信息:</p><pre><code> getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。</code></pre><p>getMeage()：返回异常的消息信息。<br>printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。</p><pre><code> 有时为了简单会忽略掉catch语句后的代码，这样try-catch语句就成了一种摆设，一旦程序在运行过程中出现了异常，就会忽略处理异常，而错误发生的原因很难查找。</code></pre><h2 id="Java常见异常"><a href="#Java常见异常" class="headerlink" title="Java常见异常"></a>Java常见异常</h2><p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p><ol><li><p>runtimeException子类:</p><ol><li><p>java.lang.ArrayIndexOutOfBoundsException</p><p>数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p><ol><li>java.lang.ArithmeticException<br>算术条件异常。譬如：整数除零等。</li><li>java.lang.NullPointerException<br>空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li><li><p>java.lang.ClassNotFoundException<br>找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</p><ol><li>java.lang.NegativeArraySizeException 数组长度为负异常</li></ol></li><li>java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>java.lang.SecurityException 安全性异常</li><li>java.lang.IllegalArgumentException 非法参数异常</li></ol></li></ol></li><li><p>IOException</p><ol><li>IOException：操作输入流和输出流时可能出现的异常。</li><li>EOFException 文件已结束异常</li><li>FileNotFoundException 文件未找到异常</li></ol></li></ol><ol><li>其他<ol><li>ClassCastException 类型转换异常类</li><li>ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>SQLException 操作数据库异常类</li><li>NoSuchFieldException 字段未找到异常</li><li>NoSuchMethodException 方法未找到抛出的异常</li><li>NumberFormatException 字符串转换为数字抛出的异常</li><li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li><li>IllegalAccessException 不允许访问某类异常</li><li>InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li></ol></li></ol><h2 id="分析堆栈跟踪元素："><a href="#分析堆栈跟踪元素：" class="headerlink" title="分析堆栈跟踪元素："></a>分析堆栈跟踪元素：</h2><p>堆栈跟踪是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。</p><p>可以调用Throwable类的printStackTrace方法访问堆栈跟踪的文本描述信息。</p><p>还可以使用getStackTrace方法，它会得到StackTraceElement对象的一个数组。StackTraceElement类含有能够获得文件名和当前执行的代码号的方法，还含有能够获得类名和方法名的方法。toString方法将产生一个格式化字符串，其中包含所获得的信息。静态的Thread.getAllStackTrace方法，它可以产生所有线程的堆栈跟踪。</p><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言机制允许在测试期间向代码插入一些检查语句，当代码发布时，这些插入的检测语句将会被自动的移走</p><p>Java语言引入关键字assert。这个关键字有两种形式:</p><p>assert 条件;</p><p>assert 条件:表达式;</p><p>要想断言x是一个非负数值:assert &gt;= 0;</p><p>或者将x的实际值传递给AssertionError对象</p><p>Assert x &gt;= 0 : x;</p><p>在默认情况下，断言被禁用。可以在运行程序时用 –enableassertions或-ea选项启用它: java –enableassertions Myapp。</p><p>在启动或禁用断言时不必重新编译程序。启用或禁用断言是类加载器的功能。当断言被禁用时，类加载器将跳过断言代码，因此不会降低程序运行速度。</p><p>也可以在某个类或某个包中使用断言:</p><p>Java –ea:MyClass –ea:com.mycompany.mylib… MyApp</p><p>这条命令将开启MyClass类在com.mycompany.mylib包和它的子包中的所有类的断言。</p><h2 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h2><p>日志系统管理着一个名为Logger.global的默认日志记录器，可以用System.out替换它，并通过调用info方法记录日志信息:Logger.getGlobal().info</p><p>日志记录器级别:SEVERE,WARNING,INFO,CONFIG,FINE,FINER,FINERST.</p><p>logger.setlevel(level.FINE);</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE异常，断言，记录日志，自定义异常
    
    </summary>
    
      <category term="JavaSE异常" scheme="https://www.ysmjjsy.com/categories/JavaSE%E5%BC%82%E5%B8%B8/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-Collection集合</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E9%9B%86%E5%90%88/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-集合/</id>
    <published>2017-08-23T08:15:37.000Z</published>
    <updated>2019-09-09T09:33:38.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 09 2019 17:35:24 GMT+0800 (GMT+08:00) --><h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p>数据既可以存储基本数据类型，也可以存储引用类型，它存储引用类型的时候的数组就叫对象数组</p><p>假如有一个学生类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> vodi <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建学生数组(对象数组)</span></span><br><span class="line">    Student[] students = <span class="keyword">new</span> Student(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//创建5个学生对象并赋值</span></span><br><span class="line">    Student s1 = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">18</span>);</span><br><span class="line">    Student s2 = <span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="number">19</span>);</span><br><span class="line">    Student s3 = <span class="keyword">new</span> Student(<span class="string">"王五"</span>,<span class="number">20</span>);</span><br><span class="line">    Student s4 = <span class="keyword">new</span> Student(<span class="string">"赵六"</span>,<span class="number">21</span>);</span><br><span class="line">    Student s5 = <span class="keyword">new</span> Student(<span class="string">"陈七"</span>,<span class="number">22</span>);</span><br><span class="line">    <span class="comment">//把学生对象放到数组中</span></span><br><span class="line">    student[<span class="number">0</span>] = s1;</span><br><span class="line">    student[<span class="number">1</span>] = s2;</span><br><span class="line">    student[<span class="number">2</span>] = s3;</span><br><span class="line">    student[<span class="number">3</span>] = s4;</span><br><span class="line">    student[<span class="number">4</span>] = s5;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x&lt;student.length;x++)&#123;</span><br><span class="line">      Student s = student[x];</span><br><span class="line">      System.out.println(s.getName()+<span class="string">"---"</span>+s.getAge);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>定义方法时候不知道定义多少个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line">修饰符 返回值类型 方法名(数据类型... 变量名)&#123;&#125;</span><br><span class="line"><span class="comment">//这里的变量其实是一个数组，如果一个方法有可变参数，并且有多个参数，那么可变参数肯定是最后一个</span></span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>在面向对象的语言中，对事务的描述都是通过对象体现的，为了方便多个对象进行操作，我们就必须把这多个对象进行存储，而不能是一个基本的变量，应该是一个容器类型的变量。而学过的容器类型的有数组和StringBuffer，StringBuffer的结果是一个字符串，不能满足要求。当选择数组作为容器，这就是对象数组，然而对象数组长度是固定的，不能满足变化的需求，这就产生了集合容器。</p><p>数据结构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。Java提供了几个能有效地组织和操作数据的数据结构，这些数据结构通常称为Java集合框架。</p><p>Java容器里只能放对象，对于基本类型（int, long, float, double等），需要将其包装成对象类型后（Integer, Long, Float, Double等）才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</p><p>由于Java里对象都在堆上，且对象只能通过引用访问，容器里放的其实是对象的引用而不是对象本身</p><p><strong>数组和集合的区别？</strong></p><ul><li><p>长度区别</p><ul><li>数组的长度固定</li><li>集合长度可变</li></ul></li><li><p>内容不同</p><ul><li>数组存储的是同一种类型的元素</li><li>集合可以存储不同类型的元素</li></ul></li><li><p>元素的数据类型问题</p><ul><li>数组可以存储基本数据类型，也可以存储引用数据类型</li><li>集合只能存储引用类型</li></ul><h3 id="集合继承体系"><a href="#集合继承体系" class="headerlink" title="集合继承体系"></a>集合继承体系</h3><p><img src="/category/JavaSE-集合/集合继承体系.png" alt="集合继承体系"></p></li></ul><p><em>Map</em>接口没有继承自<em>Collection</em>接口，因为<em>Map</em>表示的是关联式容器而不是集合。但Java为我们提供了从<em>Map</em>转换到<em>Collection</em>的方法，可以方便的将<em>Map</em>切换到集合视图。</p><p>上图中提供了<em>Queue</em>接口，却没有<em>Stack</em>，这是因为<em>Stack</em>的功能已被JDK 1.6引入的<em>Deque</em>取代</p><h3 id="Collection集合功能概述"><a href="#Collection集合功能概述" class="headerlink" title="Collection集合功能概述"></a>Collection集合功能概述</h3><p>在这里可以看到Collection接口所提供的所有方法：</p><p><img src="/category/JavaSE-集合/collection_method.png" alt="Collection_Method"></p><p>其中，有几个比较常用的方法，比如方法add()添加一个元素到集合中，addAll()将指定集合中的所有元素添加到集合中，contains()方法检测集合中是否包含指定的元素，toArray()方法返回一个表示集合的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collection接口</span></span><br><span class="line"><span class="comment">//1、添加功能</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object obj)</span></span>;<span class="comment">//添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//添加一个集合的元素</span></span><br><span class="line"><span class="comment">//2、删除功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//移除所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;<span class="comment">//移除一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//移除一个集合的元素</span></span><br><span class="line"><span class="comment">//3、判断功能</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;<span class="comment">//判断集合中是否包含指定的元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//判断集合中是否包含指定的集合元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//判断集合是否为空</span></span><br><span class="line"><span class="comment">//4、获取功能</span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//5、长度功能</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="comment">//元素的个数</span></span><br><span class="line"><span class="comment">//6、交集功能</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//两个集合都有的元素</span></span><br><span class="line"><span class="comment">//7、把集合转为数组</span></span><br><span class="line">Object[] toArray();</span><br></pre></td></tr></table></figure><p>同时我们看方法列表有一个特别有意思的方法<code>boolean removeIf(Predicate&lt;? super E&gt;)</code></p><p>这是Java8新特性里加的方法，下面是他的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all of the elements of this collection that satisfy the given</span></span><br><span class="line"><span class="comment">     * predicate.  Errors or runtime exceptions thrown during iteration or by</span></span><br><span class="line"><span class="comment">     * the predicate are relayed to the caller.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implSpec</span></span></span><br><span class="line"><span class="comment">     * The default implementation traverses all elements of the collection using</span></span><br><span class="line"><span class="comment">     * its &#123;<span class="doctag">@link</span> #iterator&#125;.  Each matching element is removed using</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Iterator#remove()&#125;.  If the collection's iterator does not</span></span><br><span class="line"><span class="comment">     * support removal then an &#123;<span class="doctag">@code</span> UnsupportedOperationException&#125; will be</span></span><br><span class="line"><span class="comment">     * thrown on the first matching element.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filter a predicate which returns &#123;<span class="doctag">@code</span> true&#125; for elements to be</span></span><br><span class="line"><span class="comment">     *        removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if any elements were removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified filter is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if elements cannot be removed</span></span><br><span class="line"><span class="comment">     *         from this collection.  Implementations may throw this exception if a</span></span><br><span class="line"><span class="comment">     *         matching element cannot be removed or if, in general, removal is not</span></span><br><span class="line"><span class="comment">     *         supported.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(filter);</span><br><span class="line">        <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;E&gt; each = iterator();</span><br><span class="line">        <span class="keyword">while</span> (each.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filter.test(each.next())) &#123;</span><br><span class="line">                each.remove();</span><br><span class="line">                removed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这就是一个添加了判断的移除，并且可以实现自定义过滤器，并且是public default，并且这个方法在接口里，实际调用则是接口的实现类提供的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    list.add(<span class="number">4</span>);</span><br><span class="line">    list.removeIf(s -&gt; s%<span class="number">2</span>==<span class="number">0</span>);               <span class="comment">// 过滤掉模2等于0的数</span></span><br><span class="line">    list.forEach(s -&gt; System.out.println(s)); <span class="comment">// 输出 1 3</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    strings.add(<span class="string">"ab"</span>);</span><br><span class="line">    strings.add(<span class="string">"ac"</span>);</span><br><span class="line">    strings.add(<span class="string">"bc"</span>);</span><br><span class="line">    strings.add(<span class="string">"cd"</span>);</span><br><span class="line">    Predicate&lt;String&gt; predicate = (s) -&gt; s.startsWith(<span class="string">"a"</span>); <span class="comment">// 这里单独定义了过滤器</span></span><br><span class="line">    strings.removeIf(predicate);                            <span class="comment">// 过滤掉以"a"开头的元素</span></span><br><span class="line">    strings.forEach(s -&gt; System.out.println(s));            <span class="comment">// 输出 bc cd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collection集合继承体系"><a href="#Collection集合继承体系" class="headerlink" title="Collection集合继承体系"></a>Collection集合继承体系</h3><p><img src="/category/JavaSE-集合/collection_interface.png" alt="Collection集合继承体系"></p><p>可以看到Collection接口有四个子接口BeanContext、Set、List、Queue。</p><h4 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h4><h5 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for循环的一种</span></span><br><span class="line"><span class="keyword">for</span>(元素数据类型 变量:数组或者Collection集合)&#123;</span><br><span class="line">  使用变量即可，该变量就是元素</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简化数组和集合的遍历，增强for目标不能为null，所以最好使用前对其做非null判断</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">array.add(<span class="string">"hello"</span>);</span><br><span class="line">array.add(<span class="string">"world"</span>);</span><br><span class="line"><span class="keyword">for</span>(String s : array)&#123;</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>迭代器是遍历集合的一种方式，是以来集合存在的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c.add(<span class="string">"hello"</span>);</span><br><span class="line">c.add(<span class="string">"world"</span>);</span><br><span class="line"><span class="comment">//通过集合获取迭代器对象</span></span><br><span class="line">Iterator it = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">  String s = (String)it.next();</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代器为什么不定义一个类而是一个接口？</strong></p><p>假设迭代器定义的是一个类，这样我们就可以创建该类的对象，调用该类的方法实现集合的遍历，但是，Java中提供了很多的集合类，而这些集合类的数据结构是不同的，所以，存储的方式和遍历的方式应该是不同的，进而他们的遍历方式也应该是不一样的，最终就没有定义迭代器类。</p><p>而无论是哪种集合，都应该具备获取元素的操作，并且最好在辅助于判断功能。再提取这两个功能就是接口</p><p>那么在真正具体的实现类在哪里呢？再真正具体的子类中，以内部类的方式体现的。</p><p><strong>迭代器源码：</strong></p><p><img src="/category/JavaSE-集合/iterator1.png" alt="Iterator"></p><p><img src="/category/JavaSE-集合/iterator2.png" alt="Iterator"></p><h4 id="BeanContext"><a href="#BeanContext" class="headerlink" title="BeanContext"></a>BeanContext</h4><p>提供与 bean 上下文有关的类和接口。bean 上下文是一个 bean 的容器，它定义所包含 bean 的执行环境。但单个 bean 上下文中可能有几个 bean，一个 bean 上下文可以嵌套在另一个 bean 上下文中。</p><p><img src="/category/JavaSE-集合/BeanContext.png" alt="BeanContext"></p><h4 id="List-重点"><a href="#List-重点" class="headerlink" title="List(重点)"></a>List(重点)</h4><p>List接口扩展自Collection，它可以定义一个允许重复的有序集合（也称序列）。从List接口中的方法来看，List接口主要是增加了面向位置的操作，允许在指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器ListIterator，通常允许重复的元素。</p><p><img src="/category/JavaSE-集合/list_method.png" alt="List_Mehtod"></p><p><strong>List集合的特有功能：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,Object element)</span></span>;<span class="comment">//在指定位置添加元素</span></span><br><span class="line"><span class="comment">//获取功能</span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//获取指定位置的元素</span></span><br><span class="line"><span class="comment">//列表迭代器</span></span><br><span class="line"><span class="function">ListIterator <span class="title">listIterator</span><span class="params">()</span></span>;<span class="comment">//:List集合特有的迭代器</span></span><br><span class="line"><span class="comment">//删除功能</span></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//根据索引删除元素，返回被删除的元素</span></span><br><span class="line"><span class="comment">//修改功能</span></span><br><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,Object element)</span></span>;<span class="comment">//根据索引修改元素，返回被修饰的元素</span></span><br></pre></td></tr></table></figure><p><strong>数据结构简单分析</strong></p><p>数据结构之栈和队列：</p><ul><li>栈：先进后出</li><li>队列：先进先出</li><li>数组：查询快，增删慢</li><li>链表：查询慢，增删快</li></ul><p><img src="/category/JavaSE-集合/shujujiegou.png" alt="数据结构"></p><p>我们说的链表是单向链表，其实如果把头元素的地址给了最后一个元素的地址位置，就是循环列表，如果每个结点有3部分组成，就可以组成双向链表，如果再把前后的对应也连接起来，就成了双向循环链表。</p><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p><em>ArrayList</em>实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。除该类未实现同步外，其余跟<em>Vector</em>大致相同。每个<em>ArrayList</em>都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p><p><img src="/category/JavaSE-集合/arraylist.png" alt="ArrayList"></p><p>size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p><p>为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set()方法</span></span><br><span class="line"><span class="comment">//既然底层是一个数组ArrayList的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces the element at the specified position in this list with</span></span><br><span class="line"><span class="comment">     * the specified element.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index of the element to replace</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element element to be stored at the specified position</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);<span class="comment">//下标越界检查</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      private void rangeCheck(int index) &#123;</span></span><br><span class="line"><span class="comment">        if (index &gt;= size)</span></span><br><span class="line"><span class="comment">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;<span class="comment">//赋值到指定位置，复制的仅仅是引用</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get()方法</span></span><br><span class="line"><span class="comment">//get()方法唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  index index of the element to return</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);<span class="comment">//下标越界检查</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);<span class="comment">//返回下标元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add()</span></span><br><span class="line"><span class="comment">//ArrayList方法是add(E e)，add(int index, E e)。这两个方法都是向容器中添加新元素，这可能会导致capacity不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment">     * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment">     * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//扩容到原来的1.5倍</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);<span class="comment">//扩展空间并复制</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。</p><p><img src="/category/JavaSE-集合/array1.png" alt="ArrayList1"></p><p>空间的问题解决后，插入过程就显得非常简单。</p><p><img src="/category/JavaSE-集合/array2.png" alt="ArrayList2"></p><p>add(int index, E e)需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addAll()</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment">     * this list, in the order that they are returned by the</span></span><br><span class="line"><span class="comment">     * specified collection's Iterator.  The behavior of this operation is</span></span><br><span class="line"><span class="comment">     * undefined if the specified collection is modified while the operation</span></span><br><span class="line"><span class="comment">     * is in progress.  (This implies that the behavior of this call is</span></span><br><span class="line"><span class="comment">     * undefined if the specified collection is this list, and this</span></span><br><span class="line"><span class="comment">     * list is nonempty.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment">     * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment">     * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment">     * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment">     * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment">     * specified collection's iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index at which to insert the first element from the</span></span><br><span class="line"><span class="comment">     *              specified collection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//addAll()方法能够一次添加多个元素，根据位置不同也有两个把本，一个是在末尾添加的addAll(Collection&lt;? extends E&gt; c)方法，一个是从指定位置开始插入的addAll(int index, Collection&lt;? extends E&gt; c)方法。跟add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//addAll()的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove()</span></span><br><span class="line"><span class="comment">//remove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">     * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment">     * indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work:清除该位置的引用，让GC起作用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment">     * if it is present.  If the list does not contain the element, it is</span></span><br><span class="line"><span class="comment">     * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span></span><br><span class="line"><span class="comment">     * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment">     * changed as a result of the call).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//关于Java GC这里需要特别说明一下，有了垃圾收集器并不意味着一定不会有内存泄漏。对象能否被GC的依据是是否还有引用指向它，上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。</span></span><br></pre></td></tr></table></figure><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p><em>LinkedList</em>同时实现了<em>List</em>接口和<em>Deque</em>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（<em>Queue</em>），同时又可以看作一个栈（<em>Stack</em>）。这样看来，<em>LinkedList</em>简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<em>LinkedList</em>，一方面是因为Java官方已经声明不建议使用<em>Stack</em>类，更遗憾的是，Java里根本没有一个叫做<em>Queue</em>的类（它是个接口名字）。关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>（当作栈或队列使用时）有着更好的性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-集合/linklist1.png" alt="linkedlist"></p><p><em>LinkedList</em>底层<strong>通过双向链表实现</strong>，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟<em>List</em>接口相关的函数，双向链表的每个节点用内部类<em>Node</em>表示。<em>LinkedList</em>通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用Collections.synchronizedList()方法对其进行包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add()</span></span><br><span class="line"><span class="comment">//add()方法有两个版本，一个是add(E e)，该方法在LinkedList的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是add(int index, E element)，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</span></span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-集合/linkedlist2.png" alt="linkedlist"></p><p>结合上图，可以看出add(E e)的逻辑非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add(E e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;<span class="comment">//原来链表为空，这是插入的第一个元素</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add(int index, E element)的逻辑稍显复杂，可以分成两部，</p><p>1.先根据index找到要插入的位置；</p><p>2.修改引用，完成插入操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add(int index, E element)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);<span class="comment">//index &gt;= 0 &amp;&amp; index &lt;= size;</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)<span class="comment">//插入位置是末尾，包括列表为空的情况</span></span><br><span class="line">        add(element);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node&lt;E&gt; succ = node(index);<span class="comment">//1.先根据index找到要插入的位置</span></span><br><span class="line">        <span class="comment">//2.修改引用，完成插入操作。</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">//插入位置为0</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件index &lt; (size &gt;&gt; 1)，也即是index是靠近前端还是后端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove()</span></span><br><span class="line"><span class="comment">//remove()方法也有两个版本，一个是删除跟指定元素相等的第一个元素remove(Object o)，另一个是删除指定下标处的元素remove(int index)。</span></span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-集合/linkedlist3.png" alt="linkedlist"></p><p>两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候remove(Object o)调用的是元素的equals方法，而remove(int index)使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个revome()方法都是通过unlink(Node<e>x)方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。</e></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unlink(Node&lt;E&gt; x)，删除一个Node</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;<span class="comment">//删除的是第一个元素</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">//删除的是最后一个元素</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="keyword">null</span>;<span class="comment">//let GC work</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get()</span></span><br><span class="line"><span class="comment">//get(int index)得到指定下标处元素的引用，通过调用上文中提到的node(int index)方法实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);<span class="comment">//index &gt;= 0 &amp;&amp; index &lt; size;</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set()</span></span><br><span class="line"><span class="comment">//set(int index, E element)方法将指定下标处的元素修改成指定值，也是先通过node(int index)找到对应下表元素的引用，然后修改Node中item的值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;<span class="comment">//替换新值</span></span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义栈集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> LinkedList link;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    link = <span class="keyword">new</span> LinkedList();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    link.addFirst(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> link.removeFirst();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> link.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkList的特有功能</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Object e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Object e)</span></span>;</span><br><span class="line"><span class="comment">//获取功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getLast</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//删除功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">removeLst</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><h5 id="Vector的特有功能"><a href="#Vector的特有功能" class="headerlink" title="Vector的特有功能"></a><strong>Vector的特有功能</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"><span class="comment">//获取功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Enumeration <span class="title">elements</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Object <span class="title">nextElement</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Vector的遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">v.addElement(<span class="string">"hello"</span>);</span><br><span class="line">v.addElement(<span class="string">"world"</span>);</span><br><span class="line">v.addElement(<span class="string">"java"</span>);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; v.size(); x++)&#123;</span><br><span class="line">  String s = (String)v.elementAt(x);</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"> System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">Enumeration en = v.elements();<span class="comment">//返回的是实现类的对象</span></span><br><span class="line"><span class="keyword">while</span>(en.hasMoreElements())&#123;</span><br><span class="line">  String s = (String)en.nextElement();</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Set-重点"><a href="#Set-重点" class="headerlink" title="Set(重点)"></a>Set(重点)</h4><p>Set接口扩展自Collection，它与List的不同之处在于，规定Set的实例不包含重复的元素。AbstractSet是一个实现Set接口的抽象类，Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>散列集HashSet是一个用于实现Set接口的具体类，可以使用它的无参构造方法来创建空的散列集，也可以由一个现有的集合创建散列集。在散列集中，有两个名词需要关注，初始容量和客座率。实际上HashSet就是基于后面介绍的HashMap而实现的，客座率是确定在增加规则集之前，该规则集的饱满程度，当元素个数超过了容量与客座率的乘积时，容量就会自动翻倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHashSet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">"11111"</span>);</span><br><span class="line">        set.add(<span class="string">"22222"</span>);</span><br><span class="line">        set.add(<span class="string">"33333"</span>);</span><br><span class="line">        set.add(<span class="string">"44444"</span>);</span><br><span class="line">        set.add(<span class="string">"22222"</span>);</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        <span class="keyword">for</span> (String e : set) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从输出结果我们可以看到，规则集里最后有4个元素，而且在输出时元素还是无序的。</p><p>查看散列集HashSet的源码实现可以看到它内部是使用一个HashMap来存放元素的，因为HashSet的元素就是其内部HashMap的<strong>键集合</strong>，所以HashSet可以做到元素不重复。</p><p><strong>HashSet如何保证元素唯一性？</strong></p><p>底层数据结构是哈希表（元素是链表的数组）</p><p>哈希表依赖于哈希值存储</p><p>添加功能依赖两个方法：int hashCode();boolean equals(Object obj);</p><p>在这里，首先比较哈希值hashCode()是否相同，如果相同，元素重复，不添加。比较地址值或者走equals()，如果不同就直接添加到集合中。</p><p>如果类没有重写这两个方法，默认使用的Object()，一般来说不相同，而String类重写了hashCode()和equals()方法，所以他就可以把内容相同的字符串去掉，只留下一个。</p><h5 id="LinkHashSet"><a href="#LinkHashSet" class="headerlink" title="LinkHashSet"></a>LinkHashSet</h5><p>LinkedHashSet是继承自HashSet的，支持对规则集内的元素排序。HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。</p><p>底层数据结构由哈希表和链表组成</p><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>TreeSet扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。</p><p>使用元素的自然顺序对元素进行排序，或者根据创建set时提供的Comparator进行排序，具体取决于使用的构造方法</p><p>TreeSet如何保证元素的排序和唯一性？</p><p>底层数据结构是一种自平衡的二叉树（红黑树）</p><h6 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h6><p>Compar to</p><p>自然排序</p><p>真正的比较是依赖于元素的compare to 方法，而这个方定义在comparable里</p><p>要重写该方法，就必须先实现comparable接口</p><p>元素的唯一性和如何存储</p><p>第一个元素存储的时候，直接作为根节点存储</p><p>从第二个元素开始，每个元素从根节点开始比较</p><div class="table-container"><table><thead><tr><th>大</th><th>就作为右孩子</th></tr></thead><tbody><tr><td>小</td><td>作为左孩子</td></tr><tr><td>相等</td><td>不搭理</td></tr></tbody></table></div><p>元素是如何取出来的</p><p>从根节点开始，按照左中右的原则依次取出元素即可</p><p>保证元素的排序方式</p><p>自然排序</p><p>让元素所属的类实现Comparable接口</p><p>比较器排序</p><p>让集合构造方法接收Comparator的实现类对象</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>队列与栈是相对的一种数据结构。只允许在一端进行插入操作，而在另一端进行删除操作的线性表。栈的特点是后进先出，而队列的特点是先进先出。队列的用处很大，但大多都是在其他的数据结构中，比如，树的按层遍历，图的广度优先搜索等都需要使用队列做为辅助数据结构。</p><h5 id="单向队列"><a href="#单向队列" class="headerlink" title="单向队列"></a>单向队列</h5><p>单向队列比较简单，只能向队尾添加元素，从队头删除元素。比如最典型的排队买票例子，新来的人只能在队列后面，排到最前边的人才可以买票，买完了以后，离开队伍。这个过程是一个非常典型的队列。</p><p>定义队列的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object elem)</span></span>; <span class="comment">// 将一个元素放到队尾，如果成功，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">()</span></span>; <span class="comment">// 将一个元素从队头删除，如果成功，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个队列只要能入队，和出队就可以了。这个队列的接口就定义好了，具体的实现有很多种办法，例如，可以使用数组做存储，可以使用链表做存储。<br>其实大家页可以看一下JDK源码，在java.util.Queue中，可以看到队列的定义。只是它是泛型的。基本上，Queue.java中定义的接口都是进队，出队。只是行为有所不同。例如，remove如果失败，会抛出异常，而poll失败则返回null,但它俩其实都是从队头删除元素。</p><h5 id="单向队列-1"><a href="#单向队列-1" class="headerlink" title="单向队列"></a>单向队列</h5><p>如果一个队列的头和尾都支持元素入队，出队，那么这种队列就称为双向队列，英文是Deque。大家可以通过java.util.Deque来查看Deque的接口定义，这里节选一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the front of this deque if it is</span></span><br><span class="line"><span class="comment">     * possible to do so immediately without violating capacity restrictions,</span></span><br><span class="line"><span class="comment">     * throwing an &#123;<span class="doctag">@code</span> IllegalStateException&#125; if no space is currently</span></span><br><span class="line"><span class="comment">     * available.  When using a capacity-restricted deque, it is generally</span></span><br><span class="line"><span class="comment">     * preferable to use method &#123;<span class="doctag">@link</span> #offerFirst&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException if the element cannot be added at this</span></span><br><span class="line"><span class="comment">     *         time due to capacity restrictions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified element</span></span><br><span class="line"><span class="comment">     *         prevents it from being added to this deque</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified element is null and this</span></span><br><span class="line"><span class="comment">     *         deque does not permit null elements</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified</span></span><br><span class="line"><span class="comment">     *         element prevents it from being added to this deque</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最重要的也就是这4个，一大段英文，没啥意思，其实就是说，addFirst是向队头添加元素，如果不满足条件就会抛异常，然后定义了各种情况下抛出的异常类型。<br>只要记住队列是先进先出的数据结构就好了，今天不必要把这些东西都掌握，一步步来。</p><h5 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h5><p>Queue也继承自Collection，用来存放等待处理的集合，这种场景一般用于缓冲、并发访问。</p><p>Queue是用于在处理之前保存元素的集合。<br>除了基本的集合操作，队列提供了额外的插入、提取和检查操作。<br>每个方法都有两种形式:一种是在操作失败时抛出一个异常，另一个则返回一个特殊值(根据操作的不同)(返回null或false)。<br>插入操作的后一种形式是专门为有容量限制的队列实现而设计的;<br>在大多数实现中，插入操作不会失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//插入（抛出异常）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//插入（返回特殊值）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//移除（抛出异常）</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//移除（返回特殊值）</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//检查（抛出异常）</span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//检查（返回特殊值）</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出Queue接口没有什么神秘面纱，都不需要揭开。不存在花里胡哨，就只有这6个方法。额外的添加、删除、查询操作。</p><p>值得一提的是，Queue是个接口，它提供的add，offer方法初衷是希望子类能够禁止添加元素为null，这样可以避免在查询时返回null究竟是正确还是错误。实际上大多数Queue的实现类的确响应了Queue接口的规定，比如ArrayBlockingQueue，PriorityBlockingQueue等等。</p><p>但还是有一些实现类没有这样要求，比如LinkedList。</p><p>虽然 LinkedList 没有禁止添加 null，但是一般情况下 Queue 的实现类都不允许添加 null 元素，为啥呢？因为poll(),peek()方法在异常的时候会返回 null，你添加了null 以后，当获取时不好分辨究竟是否正确返回。</p><h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p>PriorityQueue又叫做优先级队列，保存队列元素的顺序不是按照及加入队列的顺序，而是按照队列元素的大小进行重新排序。因此当调用peek()或pool()方法取出队列中头部的元素时，并不是取出最先进入队列的元素，而是取出队列的最小元素。</p><blockquote><p>基于优先级堆的无界的优先级队列。</p><p>PriorityQueue的元素根据自然排序进行排序，或者按队列构建时提供的 Comparator进行排序，具体取决于使用的构造方法。</p><p>优先队列不允许 null 元素。</p><p>通过自然排序的PriorityQueue不允许插入不可比较的对象。</p><p>该队列的头是根据指定排序的最小元素。</p><p>如果多个元素都是最小值，则头部是其中的一个元素——任意选取一个。</p><p>队列检索操作poll、remove、peek和element访问队列头部的元素。</p><p>优先队列是无界的，但有一个内部容量，用于管理用于存储队列中元素的数组的大小。</p><p>基本上它的大小至少和队列大小一样大。</p><p>当元素被添加到优先队列时，它的容量会自动增长。增长策略的细节没有指定。</p></blockquote><p>一句话概括，PriorityQueue使用了一个高效的数据结构：堆。底层是使用数组保存数据。还会进行排序，优先将元素的最小值存到队头。</p><p><strong>PriorityQueue的排序方式</strong></p><p>PriorityQueue中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化时指定的排序方式进行排序。需要注意的是，当PriorityQueue中没有指定的Comparator时，加入PriorityQueue的元素必须实现了Comparable接口（元素是可以进行比较的），否则会导致 ClassCastException。</p><p><strong>PriorityQueue本质</strong></p><p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p><p><img src="/category/JavaSE-集合/pq1.png" alt="PriorityQueue"></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p><p>leftNo = parentNo*2+1</p><p>rightNo = parentNo*2+2</p><p>parentNo = (nodeNo-1)/2</p><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p><em>PriorityQueue</em>的peek()和element操作是常数时间，add(), offer(), 无参数的remove()以及poll()方法的时间复杂度都是<em>log(N)</em>。</p><p>PriorityQueue 本质也是一个动态数组，在这一方面与ArrayList是一致的。看一下它的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>PriorityQueue调用默认的构造方法时，使用默认的初始容量（<code>DEFAULT_IITIAL_CAPACITY = 11</code>）创建一个PriorityQueue，并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的Comparable）。</li><li>当使用指定容量的构造方法时，使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的Comparable）</li><li>当使用指定的初始容量创建一个 PriorityQueue，并根据指定的比较器comparator来排序其元素。当添加元素到集合时，会先检查数组是否还有余量，有余量则把新元素加入集合，没余量则调用 grow()方法增加容量，然后调用siftUp将新加入的元素排序插入对应位置。</li></ul><p>除了这些，还要注意的是：</p><ol><li>PriorityQueue不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue 实例，这时请使用线程安全的PriorityBlockingQueue 类。</li><li>不允许插入 null 元素。</li><li>PriorityQueue实现插入方法（offer、poll、remove() 和 add 方法） 的时间复杂度是O(log(n)) ；实现 remove(Object) 和 contains(Object) 方法的时间复杂度是O(n) ；实现检索方法（peek、element 和 size）的时间复杂度是O(1)。所以在遍历时，若不需要删除元素，则以peek的方式遍历每个元素。</li><li>方法iterator()中提供的迭代器并不保证以有序的方式遍历PriorityQueue中的元素。</li></ol><p><strong>方法剖析</strong></p><ul><li><strong>add()和offer()</strong></li></ul><p>add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p><p><img src="/category/JavaSE-集合/pq2.png" alt="pq2"></p><p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//offer(E e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null元素</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);<span class="comment">//自动扩容</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)<span class="comment">//队列原来为空，这是插入的第一个元素</span></span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，扩容函数grow()类似于ArrayList里的grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是siftUp(int k, E x)方法，该方法用于插入元素x并维持堆的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//siftUp()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//parentNo = (nodeNo-1)/2</span></span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)<span class="comment">//调用比较器的比较方法</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新加入的元素x可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x &gt;= queue[parent]为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><ul><li><strong>element()和peek()</strong></li></ul><p>element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以<strong>直接返回数组0下标处的那个元素即可</strong>。</p><p><img src="/category/JavaSE-集合/pq3.png" alt="pq"></p><p>代码也就非常简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//peek()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>remove()和poll()</strong></li></ul><p>remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><img src="/category/JavaSE-集合/pq4.png" alt="pq"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先记录0下标处的元素，并用最后一个元素替换0下标位置的元素，之后调用siftDown()方法对堆进行调整，最后返回原来0下标处的那个元素（也就是最小的那个元素）。重点是siftDown(int k, E x)方法，该方法的作用是<strong>从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//siftDown()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;<span class="comment">//leftNo = parentNo*2+1</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;<span class="comment">//然后用c取代原来的值</span></span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>remove(Object o)</strong></li></ul><p>remove(Object o)方法用于删除队列中跟o相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，remove(Object o)可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。</p><p><img src="/category/JavaSE-集合/pg5.png" alt="pg"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove(Object o)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">//情况1</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);<span class="comment">//情况2</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h5><p>Java里有一个叫做Stack的类，却没有叫做Queue的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了（次选是LinkedList）。</p><p>要讲栈和队列，首先要讲Deque接口。Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口：</p><p><img src="/category/JavaSE-集合/dequeue1.png" alt="Dequeue"></p><p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口：</p><p><img src="/category/JavaSE-集合/dequeue2.png" alt="Dequeue"></p><p>上面两个表共定义了<em>Deque</em>的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。<strong>一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（false或null）</strong>。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。<strong>虽然Deque的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看</strong>。明白了这一点讲解起来就会非常简单。</p><p><em>ArrayDeque</em>和<em>LinkedList</em>是<em>Deque</em>的两个通用实现，由于官方更推荐使用<em>AarryDeque</em>用作栈和队列，加之上一篇已经讲解过<em>LinkedList</em>，本文将着重讲解<em>ArrayDeque</em>的具体实现。</p><p>从名字可以看出<em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可能被看作起点或者终点。<em>ArrayDeque</em>是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。</p><p><img src="/category/JavaSE-集合/dequeue3.png" alt="Dequeue"></p><p>上图中我们看到，<strong>head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。</p><p><strong>方法剖析</strong></p><p>addFirst()</p><p>addFirst(E e)的作用是在<em>Deque</em>的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[—head] = e即可。</p><p><img src="/category/JavaSE-集合/dequeue4.png" alt="Dequeue"></p><p>实际需要考虑：</p><ol><li>空间是否够用，以及</li><li>下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addFirst(E e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;<span class="comment">//2.下标是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail)<span class="comment">//1.空间是否够用</span></span><br><span class="line">        doubleCapacity();<span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p>下标越界的处理解决起来非常简单，head = (head - 1) &amp; (elements.length - 1)就可以了，<strong>这段代码相当于取余，同时解决了head为负值的情况</strong>。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数（其实只可能是-1），则相当于对其取相对于elements.length的补码。</p><p>下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：</p><p><img src="/category/JavaSE-集合/dequeue5.png" alt="Dequeue"></p><p>图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//doubleCapacity()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> head == tail;</span><br><span class="line">    <span class="keyword">int</span> p = head;</span><br><span class="line">    <span class="keyword">int</span> n = elements.length;</span><br><span class="line">    <span class="keyword">int</span> r = n - p; <span class="comment">// head右边元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;<span class="comment">//原空间的2倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);</span><br><span class="line">    Object[] a = <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);<span class="comment">//复制右半部分，对应上图中绿色部分</span></span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);<span class="comment">//复制左半部分，对应上图中灰色部分</span></span><br><span class="line">    elements = (E[])a;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addLast()</p><p>addLast(E e)的作用是在<em>Deque</em>的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要elements[tail] = e;即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。</p><p><img src="/category/JavaSE-集合/dequeue6.png" alt="Dequeue"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    elements[tail] = e;<span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)<span class="comment">//下标越界处理</span></span><br><span class="line">        doubleCapacity();<span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下标越界处理方式addFirt()中已经讲过，不再赘述。</p><p>pollFirst()</p><p>pollFirst()的作用是删除并返回<em>Deque</em>首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回elements[head]即可，当然还需要处理下标的问题。由于ArrayDeque中不允许放入null，当elements[head] == null时，意味着容器为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E result = elements[head];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)<span class="comment">//null值意味着deque为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    elements[h] = <span class="keyword">null</span>;<span class="comment">//let GC work</span></span><br><span class="line">    head = (head + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);<span class="comment">//下标越界处理</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>pollLast()</strong></p><p>pollLast()的作用是删除并返回<em>Deque</em>尾端元素，也即是tail位置前面的那个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);<span class="comment">//tail的上一个位置是最后一个元素</span></span><br><span class="line">    E result = elements[t];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)<span class="comment">//null值意味着deque为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    elements[t] = <span class="keyword">null</span>;<span class="comment">//let GC work</span></span><br><span class="line">    tail = t;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>peekFirst()</p><p>peekFirst()的作用是返回但不删除<em>Deque</em>首端元素，也即是head位置处的元素，直接返回elements[head]即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elements[head]; <span class="comment">// elements[head] is null if deque empty</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>peekLast()</p><p>peekLast()的作用是返回但不删除<em>Deque</em>尾端元素，也即是tail位置前面的那个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collection集合总结"><a href="#Collection集合总结" class="headerlink" title="Collection集合总结"></a>Collection集合总结</h3><ul><li><p>List 有序，可重复</p></li><li><ul><li><p>ArrayList</p></li><li><ul><li>底层数据结构是数组，查询快，增删慢</li><li>线程不安全</li></ul></li><li><p>Vector</p></li><li><ul><li>底层数据结构是数组，查询快，增删慢</li><li>线程安全，效率低</li></ul></li><li><p>LinkedList</p></li><li><ul><li>底层数据结构是链表，查询慢，增删快</li><li>线程不安全，效率高</li></ul></li></ul></li><li><p>Set 无序，唯一</p></li><li><ul><li><p>HashSet</p></li><li><ul><li>底层数据结构是哈希表</li><li>如何保证元素的唯一性的呢？</li></ul></li></ul></li></ul><p>依赖两个方法：hashCode(),equals()</p><p>开发中自动生成这个两个方法即可</p><ul><li><p>LinkedHashSet</p></li><li><ul><li>底层数据结构是链表和哈希表</li><li>由链表保证元素有序</li><li>有哈希表保证元素唯一</li></ul></li></ul><ul><li><p>TreeSet</p></li><li><ul><li><p>底层数据结构是红黑树</p></li><li><p>如何保证元素排序的呢？</p></li><li><ul><li>自然排序</li><li>比较器排序</li></ul></li><li><p>如何保证元素的唯一性的呢？</p></li><li><ul><li>根据比较的返回值是否是0来决定</li></ul></li></ul></li></ul><p>针对Collection集合我们到底使用谁呢？</p><p>唯一吗？</p><ul><li>是：Set<ul><li>排序吗？<ul><li>是：TreeSet</li><li>否：HashSet</li></ul></li></ul></li></ul><p>如果你知道是Set，但不知道是哪个Set，就用HashSet</p><ul><li>否：List<ul><li>要安全吗？<ul><li>是：Vector</li><li>否：ArrayList或者LinkedList<ul><li>查询多：ArrayList</li><li>增删多：LinkedList</li></ul></li></ul></li></ul></li></ul><p>如果你知道是List，但不知道是哪个List，就用ArrayList</p><p>如果你知道是Collection集合，但不知道使用谁，就用ArrayList</p><p>如果你知道用集合，就用ArrayList</p><p>在集合中常见的数据结构</p><p>ArrayXxx：底层数据结构是数据，查询快，增删慢</p><p>LinkedXxx：底层数据结构是链表，查询慢，增删快</p><p>HashXxx：底层数据结构是哈希表，依赖两个方法：hashCode()和equals()</p><p>TreeXxx：底层数据结构是二叉树，两种排序方法：自然排序和比较器排序</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE面向对象,集合,HashSet,ArrayList
    
    </summary>
    
      <category term="JavaSE集合框架" scheme="https://www.ysmjjsy.com/categories/JavaSE%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-面向对象2</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-面向对象2/</id>
    <published>2017-08-20T06:13:27.000Z</published>
    <updated>2019-08-30T02:05:26.662Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:20:24 GMT+0800 (GMT+08:00) --><h1 id="面向对象2"><a href="#面向对象2" class="headerlink" title="面向对象2"></a>面向对象2</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为超类，基类或父类，新类称为子类。派生类等。子类比超类拥有的功能更加丰富。</p><p>在通过扩展父类定义子类的时候，仅需要指出子类与超类的不同之处。因为在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。由于子类的构造器不能访问父类的私有域，所以必须利用父类的构造器对这部分私有域进行初始化，我们可以通过super实现对父类构造器的调用，使用super调用构造器的语句必须是子类构造器的第一条语句。</p><p>如果子类的构造器没有显示的调用父类构造器，则将自动的调用超类默认的构造器，如果超类没有不带参数的构造器，并且子类的构造器中又没有显示的调用超类其他的构造器，则Java编译器将报告错误。</p><p>由一个公共超类派生出来的所有类的集合被称为继承层次，从某个特定的类到其祖先的路径称为该类的继承链。把多个类中相同的内容给提取出来定义到一个类中例如</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span></span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"吃饭"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"睡觉"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span></span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"吃饭"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"睡觉"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种情况，可以把公共的提取出来，然后去继承提取的那个类，也就是父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span>&#123;</span><br><span class="line">  <span class="comment">//animal类可以看作所有动物类的父类，任何动物都可以有名字，年龄，都会吃饭睡觉，所以将这些公共的提取出来，那么子类只需要继承这个类便拥有这些方法以及成员变量</span></span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"吃饭"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"睡觉"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> <span class="keyword">extends</span> <span class="title">animal</span>()</span>&#123;</span><br><span class="line">  <span class="comment">//这里子类dog就拥有父类animal的成员变量以及方法，可以对其赋值或者方法的重写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> <span class="keyword">extends</span> <span class="title">animal</span>()</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样的extends关系就叫做继承，但是继承中子类不能继承父类的私有成员，构造方法(但可以通过super去访问)，继承体现的是is a的关系，在java中只支持单继承，但可以多层继承(继承体系)</p><p>继承的标准格式就是：<code>class 子类名 extends 父类名{}</code></p><h3 id="使用了继承有什么好处呢？"><a href="#使用了继承有什么好处呢？" class="headerlink" title="使用了继承有什么好处呢？"></a>使用了继承有什么好处呢？</h3><ul><li>提高了代码的复用性</li><li><h3 id="提高了代码的维护性"><a href="#提高了代码的维护性" class="headerlink" title="提高了代码的维护性"></a>提高了代码的维护性</h3></li><li>让类与类之间产生了关系，是多态的前提(同时这一点也是弊端，当类与类之间产生了关系，就不可避免的会有耦合，然而在开发原则里明确表示：低耦合高内聚，当耦合度高了可以这么形容，”牵一发而动全身“)</li></ul><p>假设我们有这么一个需求，有一家做信息检索的公司，他们需要对手机的各个品牌做一个统计以及对比，现在需要开发一个软件，需要编写entity，在使用继承并且掌握现有知识的前提下如何去设计呢？</p><p>首先我们应该分析一下，这家公司对产品内不同品牌进行对比，那么主题是手机，手机下有不同的品牌</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设我们手机有这些功能以及参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">double</span> size;</span><br><span class="line">  String color;</span><br><span class="line">  String name;</span><br><span class="line">  String cpu_id;</span><br><span class="line">  <span class="keyword">int</span> ram_size;</span><br><span class="line">  <span class="keyword">int</span> rom_size;</span><br><span class="line">  <span class="keyword">int</span> camera_pixel;<span class="comment">//摄像头像素</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhoto</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"拍照"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我现在有一个华为手机，那么我定义一个类HuaweiPhone继承Phone</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">  <span class="comment">//在这里我就不用每添加一个品牌再去写那些共有的特性，而是去继承父类，如果功能有特殊的那么重写或新加</span></span><br><span class="line">  <span class="keyword">int</span> camera_num; <span class="comment">//摄像头数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeMaxPhoto</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"夜拍，徕卡相机拍更厉害的照片"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同样小米手机，等其他手机也是类似，当我们新加一个手机品牌那么只需要继承这个类即可，再去写我们特有的功能</span></span><br></pre></td></tr></table></figure><p>在上述代码中可能会好奇，为什么只是写了一个关键字extends，子类便可以使用父类的成员变量，成员方法。</p><h3 id="继承中构造方法："><a href="#继承中构造方法：" class="headerlink" title="继承中构造方法："></a>继承中构造方法：</h3><p>在继承体系中，子类会继承父类中的数据，可能还会使用父类的数据。那么我们知道，在一个类中，给成员变量赋值有两种方法，一种是用方法赋值，一种是构造方法赋值。用构造方法赋值在new一个对象时需要对有参的构造方法传入值。而构造方法当自己没有声明，java会帮你写一个无参的构造方法。但是当你写了一个有参的构造方法如果还要使用无参的构造方法必须声名一个。系统不会再帮你生成无参构造方法。</p><p>在这里，子类的构造方法默认访问了父类中空参数的构造方法，从而构造出父类对象。</p><p>构造方法用于初始化一个实例对象，所以static修饰是没有任何意义的;多个线程不会同时创建内存地址相同的同一个对象，所以synchronized修饰没有意义;</p><p>构造方法不能被子类继承，所以final和abstract修饰没有意义</p><p>构造方法是没有返回类型的，void也不行。</p><p>当用户没有给java类定义明确的构造方法的时候,java为我们提供了一个默认的构造方法,这个构造方法没有参数,修饰符是public并且方法体为空。如果用户有定义构造方法，就不会有默认构造方法！！！<br>其实默认的构造方法还分为两种,一种就是刚刚说过的隐藏的构造方法,另一种就是显示定义的默认构造方法.<br>如果一个类中定义了一个或者多个构造方法,并且每一个构造方法都是带有参数形式的,那么这个类就没有默认的构造方法（需要显示的声明无参构造方法）</p><h4 id="this与super："><a href="#this与super：" class="headerlink" title="this与super："></a>this与super：</h4><p><strong>“this”的用法：</strong></p><p>实例方法中可以使用this关键字,它指向正在执行方法的类的实例对象,当然static方法中是不可以使用this对象的,因为静态方法不属于类的实例对象;而构造方法中同样可以使用this关键字,构造器中的this是指向同一个对象中不同参数的另一个构造器。</p><ol><li>构造方法中通过this关键字调用其他构造方法时,那么这句代码必须放在第一行,否则会编译错误。</li><li>构造方法中只能通过this调用一次其他的构造方法。</li></ol><p><strong>“super”的用法：</strong></p><p>实例方法和构造方法中的super关键字都用于去指向父类,实例方法中的super关键字是去调用父类当中的某个方法</p><p>构造器中使用super关键字调用父类中的构造器</p><p>在实例化子类对象时,程序会先调用父类的默认构造方法,然后再执行子类的构造方法。</p><p>在实例化类的对象时,类中的成员变量会首先进行初始化,如果其中的成员变量有对象，那么它们也会按照顺序执行初始化工作。在所有类成员初始化完成后，才调用对象所在类的构造方法创建对象。构造方法作用就是初始化。</p><p>如果一个类中有静态对象,那么他会在非静态对象初始化前进行初始化,但只初始化一次。而非静态对象每次调用时都要初始化。</p><p>程序中主类的静态变量会在main()方法执行前初始化</p><p>一个类初始化顺序：父类的静态成员—&gt;子类的静态成员—&gt;父类的非静态成员—&gt;父类的默认构造函数被调用—&gt;子类的非静态对象（变量）—&gt; 子类的构造函数。</p><h3 id="继承中成员方法的关系"><a href="#继承中成员方法的关系" class="headerlink" title="继承中成员方法的关系"></a>继承中成员方法的关系</h3><p>子类中的方法和父类中的方法声明不一样 直接调用</p><p>子类中的方法和父类中的方法声明一样：</p><ul><li>通过子类调用方法：<ul><li>先找子类中看有没有这个方法，有就使用</li><li>再看父类有没有这个方法，有就使用</li><li>如果没有就报错</li></ul></li></ul><h3 id="方法重写与方法重载"><a href="#方法重写与方法重载" class="headerlink" title="方法重写与方法重载"></a>方法重写与方法重载</h3><p>方法重写（Override）：子类中出现了和父类中方法声明一模一样的方法</p><p>方法重载（Overload）：本类中出现的方法名一样，参数列表不同的方法。与返回值无关</p><p>子类对象调用方法的时候：</p><ul><li>先找子类本身，再找父类</li></ul><p>方法重写的应用：</p><ul><li>当子类需要父类的功能，而功能主体子类有自己的特有内容时，可以重写父类中的方法。</li><li>这样，即沿袭了父类的功能，又定义了子类特有的内容。</li></ul><p>注意事项：</p><ul><li>父类中私有的方法不能被重写</li><li>子类重写父类方法是，访问权限不能更低</li><li>父类静态方法，子类必须通过静态方法进行重写</li></ul><p>子类重写父类方法的时候，最好声明一模一样</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>同一个对象（事务），在不同时刻体现出来的不同状态</p><p>比如小米手机是小米手机同样也是手机</p><p>在上面的例子中当<code>Phone p = new XiaomiPhone()</code></p><p>可以看作是多态</p><h4 id="多态的前提："><a href="#多态的前提：" class="headerlink" title="多态的前提："></a>多态的前提：</h4><ul><li>要有继承关系，</li></ul><ul><li>要有方法重写（也可以没有，但是没有这个就没有意义）</li><li>要有父类引用子类对象<code>fu f = new zi()</code></li></ul><h4 id="多态中成员访问特点："><a href="#多态中成员访问特点：" class="headerlink" title="多态中成员访问特点："></a>多态中成员访问特点：</h4><p>成员变量</p><ul><li>编译看左边，运行看左边</li></ul><p>构造方法</p><ul><li>创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化</li></ul><p>成员方法</p><ul><li>编译看左边，运行看右边</li></ul><p>静态方法</p><ul><li>编译看左边，运行看左边</li></ul><p>（静态和类相关，算不上重写，所以访问还是左边的）</p><p>由于成员方法存在方法重写，所以它运行看右边。</p><h4 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h4><p>提高了代码的维护性（继承保证）</p><p>提高了代码的扩展性（多态保证）</p><h4 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h4><p>不能使用子类的特有功能。</p><p>父类使用子类特有功能</p><ul><li>创建子类对象调用方法即可（可以，但是很多时候不合理，而且太占内存）</li></ul><ul><li>把父类的引用强制转换为子类的引用（向下转型）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象间转型问题</span></span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Zi z = <span class="keyword">new</span> (Zi)f;<span class="comment">//要求该f必须能够转换为Zi的</span></span><br></pre></td></tr></table></figure><p>多态中的内存图解：</p><p><img src="/category/JavaSE-面向对象2/duotai.png" alt="多态继承中内存图解"></p><p>对象变化内存图解：</p><p><img src="/category/JavaSE-面向对象2/duotai2.png" alt="对象变化内存图解"></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。</p><p>对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。</p><p>使用封装有三大好处：</p><ul><li>良好的封装能够减少耦合。</li><li>类内部的结构可以自由修改。</li><li>可以对成员进行更精确的控制。</li><li>隐藏信息，实现细节。</li></ul><p>所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。可以对成员变量进行更精确的控制</p><h3 id="Package关键字"><a href="#Package关键字" class="headerlink" title="Package关键字"></a>Package关键字</h3><h4 id="包的概述："><a href="#包的概述：" class="headerlink" title="包的概述："></a>包的概述：</h4><ul><li><p>其实就是文件夹</p></li><li><p>作用：</p></li><li><ul><li>把对相同的类名放到不同的包中</li><li>对类进行分类管理</li></ul></li></ul><h4 id="包的定义："><a href="#包的定义：" class="headerlink" title="包的定义："></a>包的定义：</h4><p>Package 包名；</p><p>多级包用.分开</p><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li>package语句必须是程序的第一条可执行的代码</li><li>package语句在一个java文件中只能有一个</li><li>如果没有package，默认表示无包名</li></ul><h4 id="带包的编译和运行："><a href="#带包的编译和运行：" class="headerlink" title="带包的编译和运行："></a>带包的编译和运行：</h4><ul><li><p>手动式</p></li><li><ol><li>编写一个带包的Java文件</li><li>通过Javac命令编译该Java文件</li><li>手动创建包名</li><li>把b步骤的class文件放到c步骤的最低层包</li><li>回到和包根目录在同一个目录的地方，然后运行带包运行</li></ol></li><li><p>自动式</p></li><li><ol><li>编写一个带包的java文件</li><li>javac编译的时候带上-d即可</li></ol></li></ul><p>Javac -d .HelloWorld.java</p><ol><li>回到和包根目录在同一个目录的地方，然后运行带包运行</li></ol><h3 id="import关键字的概述和使用"><a href="#import关键字的概述和使用" class="headerlink" title="import关键字的概述和使用"></a>import关键字的概述和使用</h3><p>导包：</p><p>格式：import 包名；</p><p>这种方式导入是到类的名称。</p><p>注意：我们用谁就导谁</p><p>面试题：</p><p>package，import，class有没有顺序关系？</p><p>有</p><p>package&gt;import&gt;class</p><p>package：只能有一个</p><p>import：可以有多个</p><p>class：可以有多个，建议是一个</p><h3 id="四种权限修饰符"><a href="#四种权限修饰符" class="headerlink" title="四种权限修饰符"></a>四种权限修饰符</h3><div class="table-container"><table><thead><tr><th></th><th>本类</th><th>同一个包下（子类和无关类）</th><th>不同包下（子类）</th><th>不同包下（无关类）</th></tr></thead><tbody><tr><td>private</td><td>Y</td><td></td><td></td><td></td></tr><tr><td>默认（default）</td><td>Y</td><td>Y</td><td></td><td></td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td></td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table></div><h3 id="类及其组成所使用的常见修饰符"><a href="#类及其组成所使用的常见修饰符" class="headerlink" title="类及其组成所使用的常见修饰符"></a>类及其组成所使用的常见修饰符</h3><p><strong>修饰符：</strong></p><p>权限修饰符：private，默认修饰符，protected，public</p><p>状态修饰符：static，final</p><p>抽象修饰符：abstract</p><p><strong>类：</strong></p><p>权限修饰符：默认修饰符，public</p><p>状态修饰符：final</p><p>抽象修饰符：abstract</p><p>用的最多的就是public</p><p><strong>成员变量：</strong></p><p>权限修饰符：private，默认修饰符，protected，public</p><p>状态修饰符：static，final</p><p>用的最多的就是，private</p><p><strong>构造方法：</strong></p><p>权限修饰符：private，默认修饰符，protected，public</p><p>用的最多的就是public</p><p><strong>成员方法：</strong></p><p>权限修饰符：private，默认修饰符，protected，public</p><p>状态修饰符：static，final</p><p>抽象修饰符：abstract</p><p>用的最多的就是public</p><p><strong>除此以外的组合规则：</strong></p><p>成员变量：public static final</p><p>成员方法：public static</p><p>public abstract</p><p>public final</p><h2 id="类初始化过程"><a href="#类初始化过程" class="headerlink" title="类初始化过程"></a>类初始化过程</h2><h4 id="类初始化过程-1"><a href="#类初始化过程-1" class="headerlink" title="类初始化过程"></a>类初始化过程</h4><p>加载class文件进内存</p><p>在栈内存开辟空间</p><p>在对内存为类对象开辟空间</p><p>对对象的成员变量进行默认初始化</p><p>对对象的成员变量进行显示初始化</p><p>通过构造方法对对象的成员变量赋值</p><p>对象初始化完毕，吧对象地址复制给变量</p><h4 id="对象析构与finalize方法："><a href="#对象析构与finalize方法：" class="headerlink" title="对象析构与finalize方法："></a>对象析构与finalize方法：</h4><p>在析构器中最常见的操作是回收分配给对象的存储空间，但Java不支持析构器，可以为任何一个类添加finalize方法，将在垃圾回收器清除对象之前调用。</p><h4 id="动态绑定："><a href="#动态绑定：" class="headerlink" title="动态绑定："></a>动态绑定：</h4><p>调用对象方法的执行过程：</p><p>编译器查看对象的声明类型和方法名</p><p>编译器查看调用方法时提供的参数类型</p><p>如果是private方法、static方法、final方法、或者构造器，那么编译器将准备的知道该调用哪个方法，这种调用方式为静态绑定。</p><p>调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。</p><p>当程序运行时，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。</p><p>虚拟机为了节省开销和时间，为每个类预先创建了一个方法表。</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>把类定义在其他类的内部，这个类就被称为内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类的访问特点"><a href="#内部类的访问特点" class="headerlink" title="内部类的访问特点"></a>内部类的访问特点</h3><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">      i.show();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类位置："><a href="#内部类位置：" class="headerlink" title="内部类位置："></a>内部类位置：</h3><p>成员位置：在成员位置定义的类，称为成员内部类。</p><p>局部位置：在局部位置定义的类，称为局部内部类</p><p>成员内部类：</p><p>如何直接访问内部类的成员：</p><p>外部类名.内部类名 对象名 = 外部类对象.内部类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringp[] args)</span></span>&#123;</span><br><span class="line">      Outer.Inner oi = <span class="keyword">new</span> Outer().new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>成员内部类的修饰符：</p><p>private 为了保证数据的安全性</p><p>static 为了方便访问数据</p><p>注意：静态内部类访问的外部类数据必须用静态修饰</p><p>成员内部类被静态修饰后的访问方式是：</p><p>格式：外部类名.内部类名 对象名 = new 外部类名.内部类名();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num2 = <span class="number">100</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Outer.Inner oi = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">    oi.show();</span><br><span class="line">    oi.show2();</span><br><span class="line">    <span class="comment">//show2另一种调用方式</span></span><br><span class="line">    Outer.Inner.show2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部内部类：</p><ul><li>可以直接访问外部类的成员</li><li>在局部位置，可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能</li></ul><p>面试题：</p><p>局部内部类访问局部变量的注意事项？</p><ul><li>局部内部类访问局部变量必须用final修饰</li><li>为什么呢？</li></ul><p>局部变量是随着方法的额调用而调用，随着调用完毕而消失。</p><p>而堆内存的内容并不会立即消失，所以我们加final修饰。</p><p>加入final修饰后，这个变量就常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Inner i = <span class="keyword">new</span> Inner()</span><br><span class="line">    i.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>就是内部类的简化写法</p><p>前提：存在一个类或者接口</p><p>这里的类可以是具体类也可以是抽象类</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或者接口名()&#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质是什么呢？</p><p>是一个继承了该类或者实现了该接口的子类匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Inter()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类的方法调用"><a href="#匿名内部类的方法调用" class="headerlink" title="匿名内部类的方法调用"></a>匿名内部类的方法调用</h4><p>调用一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Inter()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用多个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Inter i = <span class="keyword">new</span> Inter()&#123;<span class="comment">//多态</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"show"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"show2"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">i.show();</span><br><span class="line">i.show2();</span><br></pre></td></tr></table></figure><h4 id="匿名内部类在开发中的应用："><a href="#匿名内部类在开发中的应用：" class="headerlink" title="匿名内部类在开发中的应用："></a>匿名内部类在开发中的应用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span></span>&#123;</span><br><span class="line">  <span class="comment">//接口名作为形式参数</span></span><br><span class="line">  <span class="comment">//这里需要的不是接口，而是接口的实现类的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    p.study();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"好好学习，天天向上"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    PersonDemo pd = <span class="keyword">new</span> PersonDemo();</span><br><span class="line">    Person p = <span class="keyword">new</span> Person();</span><br><span class="line">    pd.method(p);</span><br><span class="line">    Systemout.println(<span class="string">"------"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//匿名内部类在开发中的使用</span></span><br><span class="line">    <span class="comment">//匿名内部类的本质是继承类或者实现了接口的子类匿名对象</span></span><br><span class="line">    pd.method(<span class="keyword">new</span> Person()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"好好学习，天天向上"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据</p><p>内部类可以对同一个包中的其他类隐藏起来</p><p>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷</p><p>内部类可以直接访问外部类的成员，包括私有</p><p>外部类要访问内部类的成员，必须创建对象</p><p>内部类的位置:</p><p>成员位置:成员内部类</p><p>外部类名.内部类名 对象名 = 外部类对象.内部类对象</p><p>private:私有。 外部类创建方法，方法内创建对象，调用内部类方法。</p><p>Static(为了方便访问数据)内部类用静态修饰是因为内部类可以看出是外部类的成员,内部类被静态修饰后，访问外部类数据必须用静态修饰</p><p>局部位置:局部内部类</p><p>使用内部类访问对象状态:</p><p>内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。</p><p>内部类的特殊语法规则:</p><p>OuterClass.this:表示外围类引用</p><p>OuterClass.InnerClass:在外围类的作用域之后，引用内部类</p><p>局部内部类:</p><p>局部类不能用public或private访问说明符进行声明。它的作用域被限定在声明这个具备类的块中。</p><p>局部类有一个优势，即对外部世界可以完全的隐藏起来。</p><p>可以直接访问外部类成员</p><p>在局部位置，可以创建内部类对象，通过内部类对象，通过对象内部类方法，来使用局部内部类功能</p><p>匿名内部类:</p><p>假如只创建这个类的一个对象，就不必命名，这种类被称为匿名内部类</p><p>new SuperType(construction parameters)</p><p>{</p><p>Inner class methods and data</p><p>}</p><p>由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器，取而代之的是，将构造器参数传递给超类构造器，尤其是内部类实现接口的时候，不能有任何构造参数。</p><p>前提:存在一个类或者接口，这里的类可以是具体类也可以是抽象类</p><p>new 类名或者接口名(){</p><p>重写方法;</p><p>}</p><p>本质是一个继承了该类或者实现了该接口的子类匿名对象</p><p>静态内部类:</p><p>有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象，为此，可以将内部类声明为static，以便取消产生的引用</p></blockquote><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>我们把一个不是具体的功能成为抽象的功能，而一个类中如果有抽象的功能，该类必须是抽象类。</p><h3 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a>抽象类的特点</h3><ul><li>抽象类和抽象方法必须用abstract关键字修饰</li><li>抽象类中不一定有抽象方法，但是有抽象方法的类必须定义为抽象类</li><li>抽象类不能实例化<ul><li>因为它不是具体的</li><li>抽象类有构造方法，但是不能实例化？构造方法的作用是什么呢？<ul><li>用于子类访问父类数据的初始化</li></ul></li></ul></li><li>抽象的子类<ul><li>如果不想重写抽象方法，该子类是一个抽象类</li><li>重写所有的抽象方法，这个时候子类是一个具体的类</li></ul></li></ul><p>抽象类的实例化其实是靠具体的子类实现的。是多态的方式</p><p>Phone p = new HuaweiPhone();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">  <span class="comment">//没有方法体&#123;&#125;，抽象方法不能有具体实现，空方法体也会报错</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">takePhone</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类是抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类是具体类，重写抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> <span class="keyword">extends</span> <span class="title">phone</span></span>&#123;</span><br><span class="line">  <span class="function">pulic <span class="keyword">void</span> <span class="title">takePhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建对象，Phone是抽象的，无法实例化，通过多态方式</span></span><br><span class="line">    Phone p = <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">    p.takePhone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类的成员特点"><a href="#抽象类的成员特点" class="headerlink" title="抽象类的成员特点"></a>抽象类的成员特点</h3><ul><li>成员变量：既可以是变量，也可以是常量。</li><li>构造方法：有<ul><li>用于子类访问父类数据的初始化</li></ul></li><li>成员方法：既可以是抽象的，也可以是非抽象的</li></ul><p><strong>抽象类的成员方法特性：</strong></p><p>一个类如果没有抽象方法，可不可以定义为抽象类？如果可以，有什么意义</p><ul><li>可以</li><li>不让创建对象</li></ul><p><strong>abstract不能和哪些关键字共存</strong></p><p>private 冲突</p><p>final 冲突</p><p>static 无意义</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote><p>接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。接口中的所有方法属于public，因此在声明方法时，不必提供关键字public。接口中不能含有实例域，也不能在接口中实现方法。提供实例域和方法的任务应该由实现接口的那个类完成，因此，可以将接口看成是没有实例域的抽象类，但概念有一定区别。</p></blockquote><p>定义接口 public interface 类名</p><p>类实现接口 class 类名 implements 接口名</p><p>接口中的域将被自动设为public static final</p><p>接口不能实例化，可以按照多态的方式来实例化</p><p>接口的子类:</p><ul><li>可以使抽象类，意义不大</li><li>可以是具体类，要重写接口中的所有抽象方法(推荐)</li></ul><p>接口的成员特点:</p><ul><li>成员变量: 只能是常量，并且是静态的</li><li>默认修饰符:public static final</li><li>构造方法:接口没有构造方法</li><li>成员方法:只能是抽象方法</li><li>默认修饰符:public abstract</li></ul><p>具体类多态（几乎没有）</p><p>抽象类多态（常用）</p><p>接口多态（最常用）</p><p><strong>接口与回调:</strong></p><p>回掉是一种常见的程序设计模式，在这种模式中，可以指出某个特定事件发生时应该采取的动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Phone5G</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fast</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类实现接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">implements</span> <span class="title">Phone5G</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体类实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> <span class="keyword">implements</span> <span class="title">Phone5G</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fast</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"实现5G更快了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">InterfaceDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Phone5G p = <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">      p.fast();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的成员特点"><a href="#接口的成员特点" class="headerlink" title="接口的成员特点"></a>接口的成员特点</h3><ul><li>成员变量：只能是常量，并且是静态的。<ul><li>默认修饰符：public static final</li></ul></li></ul><ul><li>构造方法：接口中没有构造方法</li><li>成员方法：只能是抽象方法<ul><li>默认修饰符： public abstract</li></ul></li></ul><h3 id="类与类，类与接口，接口与接口之间的关系"><a href="#类与类，类与接口，接口与接口之间的关系" class="headerlink" title="类与类，类与接口，接口与接口之间的关系"></a>类与类，类与接口，接口与接口之间的关系</h3><ul><li>类与类：<ul><li>继承关系，只能单继承，可以多层继承</li></ul></li><li>类与接口：<ul><li>实现关系，可以单实线，也可以多实现</li><li>并且还可以再继承一个类的同时实现多个接口</li></ul></li><li>接口与接口：<ul><li>继承关系，可以单继承，也可以多继承</li></ul></li></ul><h3 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h3><ul><li>成员区别</li><li><ul><li>抽象类：</li><li><ul><li>成员变量</li><li><ul><li>可以变量可以常量</li></ul></li><li>构造方法</li><li><ul><li>有</li></ul></li><li>成员方法</li><li><ul><li>可以抽象可以非抽象</li></ul></li></ul></li><li>接口：</li><li><ul><li>成员变量</li><li><ul><li>只可以常量</li></ul></li><li>成员方法</li><li><ul><li>只可以抽象</li></ul></li></ul></li></ul></li><li>关系区别</li><li><ul><li>类与类</li><li><ul><li>继承，单继承</li></ul></li><li>类与接口</li><li><ul><li>实现，单实现，多实现</li></ul></li><li>接口与接口</li><li><ul><li>继承，单继承，多继承</li></ul></li></ul></li><li>设计理念区别</li><li><ul><li>抽象类<ul><li>被继承体现的是：“is a“的关系。抽象类中定义的是该继承体系的共性功能</li></ul></li><li>接口</li><li><ul><li>被实现体现的是：“like a”的关系。接口中定义的是该继承体系的扩展功能</li></ul></li></ul></li></ul><h2 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h2><p>当拷贝一个变量时，原始变量与拷贝变量引用同一个对象，改变一个变量所引用的对象将会对另一个变量产生影响。如果创建一个对象的新的copy，它的最初状态与原始对象一样，但以后将可以各自改变各自的状态，那就需要使用clone方法。</p><p>Clone方法是Object类的一个proteced方法克隆需要实现Cloneable接口（标记接口），使用public访问修饰符重新定义clone方法</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE面向对象,继承、多态、封装、内部类的概述。
    
    </summary>
    
      <category term="JavaSE面向对象" scheme="https://www.ysmjjsy.com/categories/JavaSE%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-基础语法</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-基础语法/</id>
    <published>2017-08-16T13:33:02.000Z</published>
    <updated>2019-08-16T09:38:14.734Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 16 2019 17:38:47 GMT+0800 (GMT+08:00) --><h1 id="JavaSE-基础语法"><a href="#JavaSE-基础语法" class="headerlink" title="JavaSE-基础语法"></a>JavaSE-基础语法</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>被Java语言赋予特定含义的单词</p><p>特点：全部小写，goto和const作为保留字存在</p><div class="table-container"><table><thead><tr><th style="text-align:center">abstract</th><th style="text-align:center">assert</th><th style="text-align:center">boolean</th><th style="text-align:center">break</th><th style="text-align:center">byte</th></tr></thead><tbody><tr><td style="text-align:center"><strong>case</strong></td><td style="text-align:center"><strong>catch</strong></td><td style="text-align:center"><strong>char</strong></td><td style="text-align:center"><strong>class</strong></td><td style="text-align:center"><strong>const</strong></td></tr><tr><td style="text-align:center"><strong>continue</strong></td><td style="text-align:center"><strong>default</strong></td><td style="text-align:center"><strong>do</strong></td><td style="text-align:center"><strong>double</strong></td><td style="text-align:center"><strong>else</strong></td></tr><tr><td style="text-align:center"><strong>enum</strong></td><td style="text-align:center"><strong>extends</strong></td><td style="text-align:center"><strong>final</strong></td><td style="text-align:center"><strong>finally</strong></td><td style="text-align:center"><strong>float</strong></td></tr><tr><td style="text-align:center"><strong>for</strong></td><td style="text-align:center"><strong>goto</strong></td><td style="text-align:center"><strong>if</strong></td><td style="text-align:center"><strong>implements</strong></td><td style="text-align:center"><strong>import</strong></td></tr><tr><td style="text-align:center"><strong>instanceof</strong></td><td style="text-align:center"><strong>int</strong></td><td style="text-align:center"><strong>interface</strong></td><td style="text-align:center"><strong>long</strong></td><td style="text-align:center"><strong>native</strong></td></tr><tr><td style="text-align:center"><strong>new</strong></td><td style="text-align:center"><strong>package</strong></td><td style="text-align:center"><strong>private</strong></td><td style="text-align:center"><strong>protected</strong></td><td style="text-align:center"><strong>public</strong></td></tr><tr><td style="text-align:center"><strong>return</strong></td><td style="text-align:center"><strong>strictfp</strong></td><td style="text-align:center"><strong>short</strong></td><td style="text-align:center"><strong>static</strong></td><td style="text-align:center"><strong>super</strong></td></tr><tr><td style="text-align:center"><strong>switch</strong></td><td style="text-align:center"><strong>synchronized</strong></td><td style="text-align:center"><strong>this</strong></td><td style="text-align:center"><strong>throw</strong></td><td style="text-align:center"><strong>throws</strong></td></tr><tr><td style="text-align:center"><strong>transient</strong></td><td style="text-align:center"><strong>try</strong></td><td style="text-align:center"><strong>void</strong></td><td style="text-align:center"><strong>volatile</strong></td><td style="text-align:center"><strong>while</strong></td></tr></tbody></table></div><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>给类、接口、方法、变量等起名的字符序列</p><p>组成规则：数字、字母、下划线和$（见名知意），不能以数字开头，不能是java中的关键字，区分大小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> size01 = <span class="number">25.0F</span>;</span><br><span class="line"><span class="keyword">double</span> size_02 = <span class="number">30.23</span>;</span><br><span class="line"><span class="keyword">char</span> size$<span class="number">03</span> = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>在程序执行过程中，其值不发生改变的量，常量在编译阶段会存入到调用这个常量的方法所在类的常量池中。并且调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。</p><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><p>“a”、”hello”、等双引号括起来的常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><h4 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h4><p>1、2、123等数值类型常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="小数常量"><a href="#小数常量" class="headerlink" title="小数常量"></a>小数常量</h4><p>12.345等小数形式常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">12.32F</span>;</span><br></pre></td></tr></table></figure><h4 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h4><p>‘a’、’A’、’0’等用单引号括起来的常量</p><p>可与是英文字母、数字、标点符号以及由转义序列来表示的特殊字符。’\u0000’表示一个空白字符，即在单引号之间没有任何字符，之所以能这样表示，是因为Java采用Unicode字符集，Unicode字符以\u开头，空白字符在Unicode码表中对应的值为’\u0000’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">'A'</span>;</span><br></pre></td></tr></table></figure><h4 id="布尔常量"><a href="#布尔常量" class="headerlink" title="布尔常量"></a>布尔常量</h4><p>只有两种值类型的常量：true/false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="自定义常量"><a href="#自定义常量" class="headerlink" title="自定义常量"></a>自定义常量</h3><p>利用关键字final指示常量，表示这个变量只能被赋值一次，且常量名建议使用全大写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量就是程序运行中可变的量，定义格式：数据类型 变量名 = 初始化值;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>在Java中，每一个变量属于一种数据类型，在生命变量时，变量所属的类型位于变量之前，变量就是指在程序执行过程中值在某个范围内可以发生改变的量。声明一个变量后，必须使用赋值语句对变量进行显示初始化，变量的声明尽可能靠近变量第一次使用的地方。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h3><p>Java种基本数据类型有4类8种</p><p>分别为：</p><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">0</td><td style="text-align:center">8bit == 1byte</td><td style="text-align:center">-128~127</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">0</td><td style="text-align:center">16bit == 2byte</td><td style="text-align:center">-32768~32767</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">0</td><td style="text-align:center">32bit == 4byte</td><td style="text-align:center">-2147483648~2147483647</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">0L</td><td style="text-align:center">64bit == 8byte</td><td style="text-align:center">-9223372036854775808~9223372036854775807</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">8L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b4 = <span class="number">3</span> + <span class="number">4</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里不报错是因为右边先进行计算，得到数值然后进行判断，是否在byte的范围内，</span></span><br><span class="line"><span class="comment">如果在就不报错，如果不在就报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//byte b5 = 100+150; 报错</span></span><br></pre></td></tr></table></figure><h4 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">0.0f</td><td style="text-align:center">32bit == 4byte</td><td style="text-align:center">1.4E-45~3.4028235E38</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">0.0</td><td style="text-align:center">64bit == 8byte</td><td style="text-align:center">4.9E-324~1.7976931348623157E308</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浮点数</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">4.0F</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//float f2 = 3.14; 报错</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以看到这里会报错，是因为在定义浮点类型数据的时候如果不加修饰符默认是double类型</span></span><br><span class="line"><span class="comment">当double赋值给float，大类型转小类型则会报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">float</span> f3 = <span class="number">3.1415F</span>;</span><br><span class="line"><span class="keyword">float</span> f4 = (<span class="keyword">float</span>) <span class="number">3.1415</span>; <span class="comment">//这里加了强制类型转换，所以也不报错</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">那f3、f4有什么区别吗？</span></span><br><span class="line"><span class="comment">f3定义的是一个float类型，f4最初定义的是一个double类型，然后强制转换成float类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">‘\u0000’</td><td style="text-align:center">16bit == 2byte</td><td style="text-align:center">0~6553</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符类型</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">布尔类型</td><td style="text-align:center">false</td><td style="text-align:center">8bit == 1byte</td><td style="text-align:center">true/false</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布尔类型</span></span><br><span class="line"><span class="keyword">boolean</span> bool = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>数据类型转换:(隐式转换)<br>byte、short、char —&gt; int —&gt; long —&gt; float —&gt; double<br>byte、short、char之间不参与相互转换，直接转换成int类型参与运算<br>强制类型转换:(强制转换)<br>格式:<br>目标数据类型 变量名 = (目标数据类型) (被转换的数据)<br>强制类型转换会损失精度。</p><h3 id="2、引用类型"><a href="#2、引用类型" class="headerlink" title="2、引用类型"></a>2、引用类型</h3><p>底层结构和基本类型差别较大</p><ul><li>类类型</li></ul><p>当传入的值是一个类类型时，需要传入的是该类的对象</p><ul><li>接口类型</li></ul><p>当传入值是一个接口类型时，需要传入的是该接口的实现类对象</p><ul><li>数组类型</li><li>枚举</li><li>注解</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>+、-、*、/、%、++、—</p><p>++在前，先自增再运算，++在后先运算再自增</p><p>—同理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span>；</span><br><span class="line">b = <span class="number">4</span>；</span><br><span class="line">b = a++;<span class="comment">//在这里，++在后，先赋值再自增</span></span><br><span class="line">System.out.println(<span class="string">"a: "</span>+ a+<span class="string">"b: "</span>+b);<span class="comment">//a = 4 , b = 4</span></span><br><span class="line">c = a;</span><br><span class="line">c = ++b;</span><br><span class="line">System.out.println(<span class="string">"b: "</span>+ b+<span class="string">"c: "</span>+c);<span class="comment">//b = 5 , c = 5</span></span><br><span class="line">d = c;</span><br><span class="line">d = --a + b--;</span><br><span class="line">System.out.println(<span class="string">"a: "</span>+ a+<span class="string">"b: "</span>+b+<span class="string">"d "</span>+d);<span class="comment">//a = 3 , b = 4 , d = 8</span></span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>=、+=、-=、*=、/=、%=</p><p>=代表赋值运算符，将右边的值赋给左边</p><p>在这里需要注意+=、-=、<em>=、/=、%=。这代表的是一个运算符，相对于+、-、</em>、/，如果在等号两边数据类型不一致时，+=会进行自动类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">2</span>;</span><br><span class="line">a = a + b; <span class="comment">//这里会报错，因为a和b是byte类型，执行完相加赋值给a时会自动转为int类型，而a是byte类型，就会出现类型不匹配问题这里相当于 a = (int) a + b;</span></span><br><span class="line">a += b; <span class="comment">//这里不会报错，+=在运算时会自动进行类型转换</span></span><br></pre></td></tr></table></figure><p><strong>总结：+ 、+=举例</strong></p><p>+：在编译将右边表达式结果计算出来后，和左边的变量类型比较精度，如果左边的精度低于右边的结果的精度，编译器会显式的报错，告诉程序员去强制转型。所以（a = a+b;）会报错，最后将表达式的结果复制到变量所在的内存区</p><p>+=：编译器自动隐式直接将+=运算符后面的操作数强制装换为前面变量的类型，然后在变量所在的内存区上直接根据右边的操作数修改左边变量内存存储的二进制数值所以 （a += b;）不报错最后达到和赋值运算符相同的目的。与前者相比，由于后者是位操作，效率也较前者高。</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>==、！=、&gt;、&lt;、&gt;=、&lt;=</p><p>==代表判断是否相等，比较运算符返回值都是boolean类型</p><p>在这里需要注意的是，==比较基本数据类型时比较的是值，比较引用类型时比较的是两个对象的地址值</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>&amp;、|、^、!、&amp;&amp;、||</p><p>逻辑运算符用来连接boolean类型的表达式</p><p>&amp;(逻辑与)：有false则false</p><p>|(逻辑或)：有true则true</p><p>^(异或)：相同则false，不同则true</p><p>!(非)：非true则false，非false则true</p><p>&amp;&amp;(短路与)：和&amp;相同，不过有短路效果，左边是false，右边不执行</p><p>||(短路或)：和|相同，有短路效果，左边是true，右边不执行</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>操作二进制</p><p>&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;、&amp;、|、^、~</p><ul><li>&lt;&lt;：左移，空位补0，被移除的最高位丢弃<ul><li>3 &lt;&lt; 2 = 12 ——- 3 <em>2 </em>2 = 12</li></ul></li><li>.&gt;&gt;：右移，被移位的二进制最高位是0，右移后，空缺位补0，最高位是1.最高位补1<ul><li>3 &gt;&gt; 1 = 1 ——- 3/2=1</li></ul></li><li>.&gt;&gt;&gt;：无符号右移，被移位二进制最高位无论是0或者是1，空缺位都用0补<ul><li>3 &gt;&gt;&gt; 1 = 1 ——- 3/2=1</li></ul></li><li>&amp;：与运算，任何二进制位和0进行&amp;运算，结果是0，和1进行&amp;运算结果是原值<ul><li>6&amp;3=2</li></ul></li><li>|：或运算，任何二进制位和0进行|运算，结果是原值，和1进行|运算结果是1<ul><li>6|3=7</li></ul></li><li>^：异或运算，任何相同二进制位进行^运算，结果是0，不相同二进制位^运算结果是1<ul><li>6^3=5</li><li>一个数据对另外一个数据异或两次，该数不变</li></ul></li><li>~：反码<ul><li>~6=-7</li></ul></li></ul><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>格式：比较表达式?表达式1:表达式2;</p><p>执行流程：首先计算比较表达式的值，是true就执行表达式1，是false就执行表达式2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">a &gt; b ? ++a : ++b;</span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>If(condition) statement</p><p>这里的条件必须用括号括起来</p><p>If(condition) statement1 else statement2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">    a++;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a == b)&#123;</span><br><span class="line">    a--;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    b++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>当条件是true时，while循环执行一条语句。</p><p>While(condition) statement</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"这是一个死循环"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><p>先执行语句，再检测循环条件</p><p>Do statement while (condition);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我数到第"</span>+n+<span class="string">"个数了"</span>);</span><br><span class="line">  &#125;<span class="keyword">while</span>(n&gt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="确定循环"><a href="#确定循环" class="headerlink" title="确定循环"></a>确定循环</h3><p>for(初始化语句;判断条件语句;控制条件语句){循环体语句;}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//九九乘法表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">9</span>; x++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= x; y++) &#123;</span><br><span class="line">    System.out.println(x + <span class="string">"*"</span> + y + <span class="string">"="</span> + x * y + <span class="string">"\t"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h4><p>Java有一种功能很强的循环结构，可以用来依次处理数组中的每个元素</p><p>for(variable: collection) statement</p><h3 id="多重选择"><a href="#多重选择" class="headerlink" title="多重选择"></a>多重选择</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Switch (chioce)<span class="comment">//这里可选择数据类型有：基本数据类型，引用类型String，以及枚举和基本类型的封装类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">…</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">…</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">defalut:</span><br><span class="line">…</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在这里简单说一下break、continue、return三者的区别？</strong></p><p><strong>break语句</strong>的使用场合主要是switch语句和循环结构。在循环结构中使用break语句，如果执行了break语句，那么就退出循环，接着执行循环结构下面的第一条语句。如果在多重嵌套循环中使用break语句，当执行break语句的时候，退出的是它所在的循环结构，对外层循环没有任何影响。如果循环结构里有switch语句，并且在switch语句中使用了break语句，当执行switch语句中的break语句时，仅退出switch语句，不会退出外面的循环结构。</p><p>break可以跳出单层循环，也可以跳出多层循环（需要标签语句配合）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"我数到第"</span>+n+<span class="string">"个数了"</span>);</span><br><span class="line">  <span class="keyword">break</span>;<span class="comment">//这里可以看到，break跳出do-while循环，接着执行while循环</span></span><br><span class="line">&#125;<span class="keyword">while</span>(n&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(n&lt;<span class="number">100</span>)&#123;</span><br><span class="line">  System.out.println(<span class="string">"这是一个循环"</span>);</span><br><span class="line">  n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我数到第1个数了</span></span><br><span class="line"><span class="comment">这是一个循环</span></span><br><span class="line"><span class="comment">这是一个循环</span></span><br><span class="line"><span class="comment">这是一个循环</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>continue语句</strong>是最特殊的，因为它并没有真的退出循环，而是只结束本次循环体的执行，所以在使用continue的时候要注意这一点。</p><p>在for循环中，首先执行表达式1（注意表达式1在整个循环中仅执行一次），接着执行表达式2，如果满足条件，那么执行循环体，如果在循环体中执行了continue语句，那么就跳转到表达式3处执行，接下进行下一次循环，执行表达式2，看是否满足条件；在while循环中，如果执行了continue语句，那么就直接跳转到表达式处，开始下一次的循环判断；在do while循环体中如果执行了continue语句，那么就跳转到表达式处进行下一次的循环判断，</p><p><strong>return语句</strong>，如果在程序中遇到return语句，那么代码就退出该函数的执行，返回到函数的调用处，如果是main()函数，那么结束整个程序的运行。</p><p><a href="https://www.infoq.cn/article/HPohK0NfIssFx41yO*e2" target="_blank" rel="noopener">JavaSE12扩展Switch语句</a></p><h2 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h2><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类:BigInteger和BigDecimal。前者实现了任意精度的整数运算，后者实现了任意精度的浮点数运算。</p><p>使用静态的valueOf方法可以将普通的数值转换为大数值</p><p>处理大数值用大数值类中的add和multiply方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a = BigInteger.valueOf(<span class="number">100</span>);</span><br><span class="line">BigInteger c = a.add(b);  <span class="comment">//c=a+b;</span></span><br><span class="line">BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="number">2</span>)));<span class="comment">//d=c*(b+2)</span></span><br></pre></td></tr></table></figure><ul><li>BigInteger：任意精度的整数运算</li></ul><ul><li>BigDecimal：任意精度的浮点数运算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 下面的方法都来自：java.math.BigInteger 包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">mod</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回这个大整数和另一个大整数 other 的和、差、积、商以及余数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 如果这个大整数与另一个大整数 other 相等，返回 0；</span></span></span><br><span class="line"><span class="function"><span class="comment">如果这个大整数小于另一个大整数 other，返回负数；否则，返回正数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigInteger <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回值等于 x 的大整数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">add</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">subtract</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">multiply</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">divide</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回这个大实数和另一个大实数 other 的和、差、积、商。</span></span></span><br><span class="line"><span class="function"><span class="comment">在此，需要注意的是：想要计算商，必须给出舍入方式，例如  RoundingModel.HALF_UP */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 如果这个大实数与另一个大实数 other 相等，返回 0；</span></span></span><br><span class="line"><span class="function"><span class="comment">如果这个大实数小于另一个大实数 other，返回负数；否则，返回正数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigDecimal <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigDecimal <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> scale)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回值等于 x 或者 x/10^(scale) 的大实数 */</span></span></span><br></pre></td></tr></table></figure><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><p>进制也就是进位制，是人们规定的一种进位方法。<br>对于任何一种进制—-X进制，就表示某一位置上的数运算时是逢X进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x进制就是逢x进位。</p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p><img src="/category/JavaSE-基础语法/二进制.png" alt="二进制"></p><p>用8个这样的信号来表示一个数据，这个数据的单位叫做：字节</p><p>1 byte = 8 bit</p><p>1k = 1024byte</p><p>1m = 1024k</p><p>通过数字1,0来表示开关，这样由1,0组成的数据就是二进制数据</p><p>二进制数有两个特点：它由两个基本数字0，1组成，二进制数运算规律是逢二进一。</p><p>为区别于其它进制数，二进制数的书写通常在数的右下方注上基数2，或加后面加B表示。</p><p>例如：二进制数10110011可以写成（10110011）2，或写成10110011B</p><h3 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h3><p>把二进制的数据，从右开始，每三位一组合，最左边不够的时候，补0。然后分别计算出对应的十进制数值，最后，再把每个十进制数据组合起来，就是一个八进制数据。</p><p><img src="/category/JavaSE-基础语法/八进制.png" alt="八进制"></p><h3 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h3><p>人们通常使用的是十进制。它的特点有两个：有0，1，2….9十个基本数字组成，十进制数运算是按“逢十进一”的规则进行的.</p><h3 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h3><p>把二进制的数据从右开始，每四位一组合，最左边不够的时候补0.然后分别进算出对应的的十进制数值，最后，再把每个十进制数据组合起来，就是一个十六进制数据。</p><p><img src="/category/JavaSE-基础语法/十六进制.png" alt="十六进制"></p><h3 id="不同进制的组成"><a href="#不同进制的组成" class="headerlink" title="不同进制的组成"></a>不同进制的组成</h3><div class="table-container"><table><thead><tr><th><strong>二进制</strong></th><th><strong>由0,1组成，以0b开头</strong></th></tr></thead><tbody><tr><td><strong>八进制</strong></td><td><strong>由0,1…7组成，以0开头</strong></td></tr><tr><td><strong>十进制</strong></td><td><strong>由0,1…9组成，整数默认是十进制</strong></td></tr><tr><td><strong>十六进制</strong></td><td><strong>由0,1…9,a,b,c,d,e,f(大小均可)组成，以0x开头</strong></td></tr></tbody></table></div><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><h4 id="其他进制到十进制的转换"><a href="#其他进制到十进制的转换" class="headerlink" title="其他进制到十进制的转换"></a>其他进制到十进制的转换</h4><p><img src="/category/JavaSE-基础语法/toten.png" alt="十进制"></p><p><img src="/category/JavaSE-基础语法/twoten.png" alt="进制转换"></p><h4 id="十进制到其他进制的转换"><a href="#十进制到其他进制的转换" class="headerlink" title="十进制到其他进制的转换"></a>十进制到其他进制的转换</h4><p><img src="/category/JavaSE-基础语法/tento.png" alt="十进制"></p><h4 id="8421码（进制的快速转换）"><a href="#8421码（进制的快速转换）" class="headerlink" title="8421码（进制的快速转换）"></a>8421码（进制的快速转换）</h4><p><img src="/category/JavaSE-基础语法/8421.png" alt="8421"></p><h3 id="有符号数据表示"><a href="#有符号数据表示" class="headerlink" title="有符号数据表示"></a>有符号数据表示</h3><p>在计算机内，有符号数由3种表示法：原码、反码和补码。所有的数据的运算都是采用补码进行的。</p><ul><li><strong>原码</strong><ul><li>就是二进制定点表示法，即最高位为符号位，”0“表示正，”1“表示负，其余位表示数值大小。</li></ul></li><li><strong>反码</strong><ul><li>正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。</li></ul></li><li><strong>补码</strong><ul><li>正数的补码与其原码相同；负数的补码是在其反码的末位+1。</li></ul></li></ul><p><strong>+7、-7的原码反码补码表示：</strong></p><p><img src="/category/JavaSE-基础语法/71.png" alt="原码"></p><p><img src="/category/JavaSE-基础语法/72.png" alt="反码"></p><p><img src="/category/JavaSE-基础语法/73.png" alt="补码"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE基础语法
    
    </summary>
    
      <category term="JavaSE基础语法" scheme="https://www.ysmjjsy.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-面向对象</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-面向对象/</id>
    <published>2017-08-16T13:33:02.000Z</published>
    <updated>2019-08-16T09:32:10.463Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 16 2019 17:33:28 GMT+0800 (GMT+08:00) --><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是构造对象的模板或蓝图，类可以看作是一组对象的集合。一类事物的抽象。举个很简单的例子，经常会听到很多人说：“我不是那类人”。比如那一类就可以理解为“类”。那对象呢，对象就是”我“。在类与类之间，最常见的关系有：依赖（uses-a）、聚合（has-a）、继承（is-a）</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>由类构造对象的过程称为创建类的实例，而这个示例就是对象，对于每个特定的类实例（对象）都有一组特定的实例域值，这些值的集合就是这个对象的当前状态。对象中的数据称为实例域，操作数据的过程称为方法。</p><p><strong>对象的三个主要特征：</strong></p><p><strong>对象的行为，对象的状态，对象标识</strong></p><p>对象状态的改变必须通过调用方法实现</p><p>作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。</p><p>要想使用对象，必须首先构造对象，并指定其初始状态，然后对对象应用方法。</p><p>在Java中，使用构造器构造新实例。构造器是一种特殊的方法，用来构造并初始化对象，构造器的名字应该与类名相同。</p><p>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象，任何对象变量的值都是对存储在另外一个地方的一个对象的引用，new操作符的返回值也是一个引用。如果将一个方法应用于一个值为null的对象上，就会产生错误。局部变量不会自动初始化为null，必须通过调用new或将他们呢设置为null进行初始化</p><h3 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h3><p><img src="/category/JavaSE-面向对象/对象内存图.jpg" alt="对象内存图"></p><p>在Java1.8之后永久区（PremGen）没有，方法区改为MetaSpace物理内存</p><p>具体可以看这篇文章：</p><p><a href="https://crowhawk.github.io/2017/08/09/jvm_1/" target="_blank" rel="noopener">Java内存区域与Java对象</a></p><h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><p>定义这个对象的信息</p><p>成员变量与局部变量的区别</p><div class="table-container"><table><thead><tr><th></th><th>在类中位置</th><th>在内存中位置</th><th>生命周期</th><th>初始化值</th></tr></thead><tbody><tr><td>成员变量</td><td>在类中方法外</td><td>在堆内存</td><td>随着对象创建而存在，随着对象消失而消失</td><td>有默认初始化值</td></tr><tr><td>局部变量</td><td>在方法内或者方法声明上</td><td>在栈内存</td><td>随着方法调用而存在，随着方法调用完毕而消失</td><td>没有默认初始化值，必须先定义赋值再使用</td></tr></tbody></table></div><p>注意：当局部变量名称和成员变量名称一致时，采用就近原则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    String name;<span class="comment">//默认值为null</span></span><br><span class="line">    <span class="keyword">int</span> age;<span class="comment">//默认值为0</span></span><br><span class="line">    <span class="keyword">int</span> num;<span class="comment">//默认值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">3</span>;<span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(<span class="string">"这里有"</span>+num+<span class="string">"只小猫"</span>);<span class="comment">//输出为3</span></span><br><span class="line">      Cat c = <span class="keyword">new</span> Cat();<span class="comment">//创建Cat对象</span></span><br><span class="line">        c.name=<span class="string">"大大"</span>;</span><br><span class="line">        c.age=<span class="number">18</span>;</span><br><span class="line">        System.out.println(c.name+c.age);<span class="comment">//大大18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法就是函数，函数在Java中被称为方法。方法是完成特定功能的代码块</p><p>方法在内存中位于方法区</p><p>方法是随着调用才会加载</p><p>方法与方法是平级关系，不能嵌套定义</p><p>方法定义时候参数之间用逗号隔开</p><p>方法调用升级后不用再传递数据类型</p><p>如果方法有明确返回值，一定要有return带回一个值</p><p>格式：修饰符 返回值类型 方法名 (参数类型 参数名1,参数类型 参数名2…){函数体; return 返回值;}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name,Date date)</span></span>&#123;</span><br><span class="line">  System.out.println(date+<span class="string">"吃了"</span>+name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">MyName</span><span class="params">(String firstName,String lastName)</span></span>&#123;</span><br><span class="line">  String myname = firstName+lastName;</span><br><span class="line">  <span class="keyword">return</span> myname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-面向对象/方法调用.png" alt="方法调用"></p><h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可</p><p>特点：与返回值类型无关，只看方法名和参数列表，在调用时虚拟机通过参数列表的不同来区分同名方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><p><strong>形参：</strong>方法被调用时需要传递进来的参数，如：show(int a)中的a，它只有在show被调用期间a才有意义，也就是会被分配内存空间，在方法show执行完成后，a就会被销毁释放空间，也就是不存在了</p><p><strong>实参：</strong>方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//实参</span></span><br><span class="line">  show(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int a=10;中的a在被调用之前就已经创建并初始化，在调用show方法时，他被当做参数传入，所以这个a是实参。<br>而show(int a)中的a只有在show被调用时它的生命周期才开始，而在show调用结束之后，它也随之被JVM释放掉，，所以这个a是形参。</p><p>当形式参数和返回值类型是引用类型时会和基本类型不同：</p><p>形参和返回值是类类型：实际传入的是该类对象</p><p>形参和返回值是抽象类：实际传入的是该抽象类的子类对象</p><p>形参和返回值是接口：需要的是该接口的实现类对象</p><h4 id="Java到底是值传递还是传引用？"><a href="#Java到底是值传递还是传引用？" class="headerlink" title="Java到底是值传递还是传引用？"></a>Java到底是值传递还是传引用？</h4><p>首先在Java里面有两种数据类型，基本数据类型与引用类型。</p><p>基本类型直接保存在变量中，引用类型变量保存的只是实际对象的地址，一般这种变量为”引用“，引用指向实际对象，实际对象中保存着内容。</p><p>按值调用(call by value):表示方法接收的是调用者提供的值</p><p>按引用调用(call byreference):表示方法接收的是调用者提供的变量地址</p><ul><li>一个方法不能修改一个基本数据类型的参数（数值型和布尔型）</li><li>一个方法可以改变一个对象参数的状态</li><li>一个方法不能让对象参数引用一个新的对象</li></ul><p>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。Java语言总是采用按值调用，也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。按引用调用，方法得到是对象引用及其他的拷贝同时引用同一个对象。</p><p><img src="/category/JavaSE-面向对象/数组内存图.png" alt="数组内存图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;<span class="comment">//变量num保存着1这个值</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//变量arr在栈内存保存的是这个数组在堆内存的地址值，这个地址值引用堆内存的数组实际值</span></span><br></pre></td></tr></table></figure><p>=：表示赋值运算符，对于基本数据类型，赋值运算符会直接改变变量的值，原本的值被覆盖，对于引用类型，赋值运算符改变引用中的地址值，而不是在堆内存的实际值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];<span class="comment">//这里并不会改变原本数组的值，而只是把新数组的引用赋值给arr</span></span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-面向对象/数组内存图2.png" alt="Java内存图2"></p><p>局部变量和方法参数在jvm中的储存方法是相同的，都是在栈上开辟空间来储存的，随着进入方法开辟，退出方法回收。以32位JVM为例，boolean/byte/short/char/int/float以及引用都是分配4字节空间，long/double分配8字节空间。对于每个方法来说，最多占用多少空间是一定的，这在编译时就可以计算好。</p><p>我们都知道JVM内存模型中有，stack和heap的存在，但是更准确的说，是每个线程都分配一个独享的stack，所有线程共享一个heap。对于每个方法的局部变量来说，是绝对无法被其他方法，甚至其他线程的同一方法所访问到的，更别说修改。</p><p>当我们在方法中声明一个 int i = 0，或者 Object obj = null 时，仅仅涉及stack，不影响到heap，当我们 new Object() 时，会在heap中开辟一段内存并初始化Object对象。当我们将这个对象赋予obj变量时，仅仅是stack中代表obj的那4个字节变更为这个对象的地址。</p><p>当我们声明一个数组时，如int[] arr = new int[10]，因为数组也是对象，arr实际上是引用，stack上仅仅占用4字节空间，new int[10]会在heap中开辟一个数组对象，然后arr指向它。</p><p>当我们声明一个二维数组时，如 <code>int[][] arr2 = new int[2]4]</code>，arr2同样仅在stack中占用4个字节，会在内存中开辟一个长度为2的，类型为int[]的数组，然后arr2指向这个数组。这个数组内部有两个引用（大小为4字节），分别指向两个长度为4的类型为int的数组。</p><p>所以当我们传递一个数组引用给一个方法时，数组的元素是可以被改变的，但是无法让数组引用指向新的数组。</p><p><strong>那Java是如何存储各种类型的数据呢？</strong></p><p>Java语言并不能操纵内存，一切都是由JVM来管理控制的，因此Java内存区域的划分也就是JVM的区域划分。详细底层可以参考：<a href="https://juejin.im/post/5bce68226fb9a05ce46a0476#heading-9" target="_blank" rel="noopener">Java的值传递和引用传递</a></p><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>匿名对象就是没有名字的对象（是对象的一种简化表示形式）</p><p>匿名对象调用完毕就是垃圾，可以被垃圾回收器回收。</p><p>匿名对象可以作为实际参数传递</p><p><strong>对象调用方法仅仅一次的时候：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带名字的调用</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">s.show();</span><br><span class="line">s.show();</span><br><span class="line">System.out.println(<span class="string">"-------"</span>);</span><br><span class="line"><span class="comment">//匿名对象调用方法</span></span><br><span class="line"><span class="keyword">new</span> Student().show();</span><br><span class="line"><span class="keyword">new</span> Student().show();<span class="comment">//不同的是，这里是创建了一个新的对象，并不是一个对象调用两次</span></span><br><span class="line"><span class="comment">//对于匿名对象，任何时候使用==比较，返回值是false</span></span><br><span class="line">System.out.println(<span class="string">"-------"</span>)</span><br></pre></td></tr></table></figure><p><strong>作为实际参数传递：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StudentDemo sd = <span class="keyword">new</span> StudentDemo();</span><br><span class="line">sd.method(<span class="keyword">new</span> Student());<span class="comment">//这里是method方法参数是一个学生类对象，这里使用匿名对象传入</span></span><br><span class="line"><span class="keyword">new</span> StudentDemo().method(<span class="keyword">new</span> Student());<span class="comment">//链式编程，等同于上面</span></span><br></pre></td></tr></table></figure><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>代表所在类的对象引用</p><p>方法被哪个对象调用，this就代表哪个对象</p><p>当局部变量隐藏成员变量，可以使用this</p><p>this可以看作是一个变量，它的值是当前对象的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;<span class="comment">//这个age是形参age，就近原则</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      这里的this是区分局部的形参age和成员变量this，</span></span><br><span class="line"><span class="comment">      这个this.age相当于Dog d = new Dog;d.age;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">growDog</span><span class="params">()</span></span>&#123;<span class="comment">//这个方法需要一个Dog对象的返回值</span></span><br><span class="line">        age++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//this相当于Dog类的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ageNow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"今年我"</span>+age+<span class="string">"岁了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog(<span class="number">3</span>);</span><br><span class="line">        d.growDog().ageNow();</span><br><span class="line">      <span class="comment">//这里可以说是一个链式编程，创建dog类对象调用growDog方法，返回dog类对象再调用ageNow方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序执行流程详解：</p><p><img src="/category/JavaSE-面向对象/dog.png" alt="内存图解"></p><p><img src="/category/JavaSE-面向对象/dog2.png" alt="内存图解2"></p><p>由上可以看出来，this一般出现在方法里，代表调用者，一开始this并不确定是谁，只有当谁调用了这个方法或者谁创建了这个对象，那么this就代表谁。</p><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final：最终的意思。常见的是它可以修饰类，方法，变量。</p><p>特点：</p><ul><li>final可以修饰类，该类不能被继承。</li><li>final可以修饰方法，该方法不能被重写。（覆盖，复写）</li><li>final可以修饰变量，该变量不能被重新赋值，因为这个变量其实是常量。</li></ul><p>当final修饰局部变量的问题：</p><p>基本类型：基本类型的值不能发生改变</p><p>引用类型：引用类型的地址值不能发生改变，但是该对象堆内存的值可以改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">  x = <span class="number">200</span>;</span><br><span class="line">  System.out.println(<span class="string">"x:"</span>+x);<span class="comment">//x:200</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> y = <span class="number">300</span>;</span><br><span class="line">  <span class="comment">//y = 400; 报错，无法为最终变量赋值</span></span><br><span class="line">  Student s = <span class="keyword">new</span> Student();<span class="comment">//Student类里有一个final int age = 10;</span></span><br><span class="line">  System.out.println(s.age);</span><br><span class="line">  <span class="comment">//s.age = 20;报错</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> Student ss = <span class="keyword">new</span> Student();<span class="comment">//final修饰引用类型，去掉Student上age的final</span></span><br><span class="line">  ss.age = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">//重新分配内存空间</span></span><br><span class="line">  <span class="comment">//ss = new Student(); 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final修饰变量的初始化时机：</p><p>被final修饰的变量只能赋值一次</p><p>在构造方法完毕前(非静态常量)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">finalDemo</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> num2;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//num2 = 20;报错</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">finalDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//num2 = 20;报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于继承中方法有一个现象：方法重写</p><p>所以父类的功能就会被子类给覆盖掉。</p><p>有时候我们不想让子类去覆盖掉父类的功能，只能让他使用。</p><p>这个时候，针对这种情况，Java就提供了一个关键字：final</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>针对多个对象有共同的相同的成员变量值的时候，Java就提供了一个关键字来修饰：static</p><p><strong>static的特点：</strong>（可以修饰成员变量、成员方法）</p><ul><li>随着类的加载而加载</li><li>优先于对象存在</li><li>被类的所有对象共享</li><li>可以通过类名调用（也可以通过对象名-一般不选择这种）</li></ul><p>静态修饰的内容一般我们称其为：与类相关的，类成员</p><p><strong>static关键字注意事项：</strong></p><ul><li><p>在静态方法中是没有this关键字的</p><ul><li>静态是随着类的加载而加载，this是随着对象的创建而存在。</li><li>静态比对象先存在</li></ul></li><li><p>静态方法只能访问静态的成员变量和静态的成员方法</p></li><li><ul><li><p>静态方法：</p></li><li><ul><li>成员变量：只能访问静态变量</li><li>成员方法：只能访问静态成员方法</li></ul></li><li><p>非静态方法：</p></li><li><ul><li>成员变量：可以是静态的，也可以是非静态的</li><li>成员方法：可以是静态的成员方法，也可以是非静态的成员方法</li></ul></li><li><p>静态只能访问静态</p></li></ul></li></ul><p><strong>静态变量和成员变量的区别：</strong></p><ul><li>所属不同<ul><li>静态变量属于类，所以也称为类变量</li><li>成员变量属于对象，所以也称为实例变量（对象变量）</li></ul></li><li>内存中位置不同<ul><li>静态变量存储于方法区的静态区</li><li>成与变量存储于堆内存</li></ul></li><li>内存出现时间不同<ul><li>静态变量随着类的加载而加载，随着类的消失而消失</li><li>成员变量随着对象的创建而存在，也可以通过对象调用</li></ul></li><li>调用不同<ul><li>静态变量可以通过类名调用，也可以通过对象调用</li><li>成员变量只能通过对象名调用</li></ul></li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>给对象的数据进行初始化</p><p>格式：</p><ul><li>方法名与类名相同</li><li>没有返回值类型，连void都没有</li><li>没有具体的返回值</li></ul><p>构造方法的注意事项：</p><p>如果我们没有给出构造方法，系统将自动提供一个无参构造方法</p><p>如果我们给出了构造方法，系统将不再提供默认的无参构造方法</p><p>如果我们还想使用无参构造方法，就必须自己给出。建议永远给出</p><p>给成员变量赋值有两种方式：</p><ul><li>setXxx()</li><li>构造方法</li></ul><h3 id="类的组成"><a href="#类的组成" class="headerlink" title="类的组成"></a>类的组成</h3><p>成员变量</p><p>构造方法</p><p>成员方法：</p><p>根据返回值：void与非void</p><p>根据形式参数列表：空参与非空参</p><p><strong>Student类初始化过程：</strong></p><p><img src="/category/JavaSE-面向对象/类初始化.png" alt="类初始化过程"></p><p>类初始化过程：</p><ol><li>加载class文件进内存</li><li>在栈内存开辟空间</li><li>在对内存为类对象开辟空间</li><li>对对象的成员变量进行默认初始化</li><li>对对象的成员变量进行显示初始化</li><li>通过构造方法对对象的成员变量赋值</li><li>对象初始化完毕，吧对象地址复制给变量</li></ol><p><strong>对象析构与finalize方法：</strong></p><p>在析构器中最常见的操作是回收分配给对象的存储空间，但Java不支持析构器，可以为任何一个类添加finalize方法，将在垃圾回收器清除对象之前调用。</p><p><strong>动态绑定：</strong></p><p>调用对象方法的执行过程：</p><p>编译器查看对象的声明类型和方法名</p><p>编译器查看调用方法时提供的参数类型</p><p>如果是private方法、static方法、final方法、或者构造器，那么编译器将准备的知道该调用哪个方法，这种调用方式为静态绑定。</p><p>调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。</p><p>当程序运行时，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。</p><p>虚拟机为了节省开销和时间，为每个类预先创建了一个方法表。</p><p><strong>什么时候定义成员变量：</strong></p><p>如果这个变量是用来描述这个类的信息的，那么该变量就应该定义为成员变量</p><p>变量的范围越小越好，因为能及时收回</p><p><strong>main方法格式</strong>：</p><p><img src="/category/JavaSE-面向对象/main.png" alt="main"></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>在Java中，使用{ }括起来的代码被称为代码块</p><p>根据其位置和声明不同，可以分为</p><p><strong>局部代码块：</strong></p><p>局部位置，用于限定变量的生命周期，及早释放，提高内存利用率</p><p><strong>构造代码块</strong></p><ul><li>在类中的成员位置，用{ }括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。</li></ul><p>作用：</p><p>可以把多个构造方法中的共同代码放到一起，对对象进行初始化。</p><p><strong>静态代码块：</strong></p><p>在类中的成员位置，用{ }括起来的代码，只不过它用static修饰了</p><p>对类的数据进行初始化，仅仅只执行一次</p><p>作用：</p><p>一般是对类进行初始化</p><p>面试题：</p><p>静态代码块，构造代码块，构造方法的执行顺序？</p><p>静态代码块 — 构造代码块 — 构造方法</p><p>静态代码块：只执行一次</p><p>构造代码块：每次调用构造方法都执行</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE面向对象
    
    </summary>
    
      <category term="JavaSE面向对象" scheme="https://www.ysmjjsy.com/categories/JavaSE%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>HelloJava</title>
    <link href="https://www.ysmjjsy.com/category/HelloJava/"/>
    <id>https://www.ysmjjsy.com/category/HelloJava/</id>
    <published>2017-08-06T01:23:12.000Z</published>
    <updated>2019-08-06T01:29:36.159Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 06 2019 09:30:03 GMT+0800 (GMT+08:00) --><h1 id="gt-HelloJava"><a href="#gt-HelloJava" class="headerlink" title="-&gt;HelloJava!"></a>-&gt;HelloJava!</h1><blockquote><p>Goya：<br>Java是一门伟大的艺术，至少在我看来是的了，也许如果没有Java出现会出现别的类似编程语言，但是因为它的存在，促进了互联网的&gt;发展。<br>当我第一次接触Java是在初中，那时候有的塞班系统的手机上会出现一个Java的一些小游戏或者小应用，回忆中的样子应该是如此。<br>到了大学，大二开始学习Java知道了这门著名的编程语言。<br>那时候老师也不会将很多学习Java先要了解的一些知识，只是告诉你James Gosling发明了Java，并且在Sun公司，之后Sun被Oracle收购等等一些常识。然后便开始了Java语言的学习，那时候只知道按部就班的安装那些必备软件，然后开始敲。</p></blockquote><p>学习Java我认为首先需要了解一下什么是Java？它用来干什么？它怎么实现的？它发展是什么？<br>我想在这个大时代背景下，程序员，编程，代码几乎人人皆知。而退十年来讲，都是陌生的。<br>随着时代的发展，让这些一部分人知道的事务变成众人皆知的事务，这就是互联网的进步以及大时代的笼罩下造成的氛围。你离开了这些就仿佛一个原始人，这么说也许太片面，但离了这些产品那真的会回退一个时代。<br>很多人都说互联网时代已经告去，大数据人工智能时代来临并飞速发展，那么怎么来，靠什么发展。我想这就是为什么电子信息专业的火爆以及许多人认为的“高薪资”。</p><hr><h1 id="那什么是Java"><a href="#那什么是Java" class="headerlink" title="那什么是Java"></a>那什么是Java</h1><ul><li><p>在1990年代之前，比较熟知的C、C++、SQL等著名语言被开发</p></li><li><p>在1990年代，推动编程语言发展的思想则是“提升程序员的生产力”，出现了很多快速应用程序开发，这些语言大都有相应的集成开发环境，也大多是面向对象的编程语言。像Java、Python、Ruby、Visual Basic、JavaScript、PHP等。而Java的出现则更加保守。</p></li></ul><p>所以Java的产生可以理解为一门可以提高程序员生产力的语言。<br>而那时候的Java叫Oak，是为了服务家用电器等小型系统的编程语言。<br>但那时候这种智能化电器则不像现在般火爆。于是Sun便开始改造。</p><blockquote><p>摘自维基百科：<br>Java编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在Java SE 1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装/拆箱特性。Sun对Java语言的解释是：“Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”<br>Java不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了Java程序的运行效率。但在J2SE1.4.2发布后，Java的运行速度有了大幅提升。<br>与传统类型不同，Sun公司在推出Java时就将其作为开放的技术。全球的Java开发公司被要求所设计的Java软件必须相互兼容。“Java语言靠群体的力量而非公司的力量”是Sun公司的口号之一，并获得了广大软件开发商的认同。这与微软公司所倡导的注重精英和封闭式的模式完全不同，此外，微软公司后来推出了与之竞争的.NET平台以及模仿Java的C#语言。后来Sun公司被甲骨文公司并购，Java也随之成为甲骨文公司的产品。</p></blockquote><p>总结下来就是Java是一个面向对象的拥有“简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”这些特点的语言。并且是一门开源语言（开放源代码全世界人学习或者修改加入自己的想法，但是Sun公司拥有Java的一部分权力）</p><p>那么首先我们可以分析一下，什么是编程语言：</p><blockquote><p>编程语言是用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。</p></blockquote><p><strong>所以Java就是一门我们可以根据Java的语法规则写出来的代码，它来编译成计算机识别的指令来操作计算机或者其他设备的语言。</strong></p><h2 id="那么Java如何识别我们写的代码再编译成计算机识别的指令呢？"><a href="#那么Java如何识别我们写的代码再编译成计算机识别的指令呢？" class="headerlink" title="那么Java如何识别我们写的代码再编译成计算机识别的指令呢？"></a>那么Java如何识别我们写的代码再编译成计算机识别的指令呢？</h2><p>举一个例子：我们写一个<strong>HelloWorld.java</strong><br><em>这个时候可以不用纠结这些看不懂</em><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"HelloWorld!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后通过控制台执行javac<br><img src="/category/HelloJava/javac.png" alt="javac"></p><p>可以看到在HelloWorld.java同级目录生成一个.class文件<br><img src="/category/HelloJava/javaclass.png" alt="classlocation"></p><p>接着执行java命令<br><img src="/category/HelloJava/java.png" alt="java"></p><p>可以看到我们写的代码被计算机所解释编译执行，输出HelloWorld</p><h3 id="那么这个javac是什么呢？"><a href="#那么这个javac是什么呢？" class="headerlink" title="那么这个javac是什么呢？"></a>那么这个javac是什么呢？</h3><ul><li>当安装好jdk后可以在jdk安装目录bin文件夹下看到这个脚本。</li><li>它是用来编译java程序的源代码，但是它本质是基于jdk标准类库中的javac类库实现，所以java的编译器实质是一个java程序</li><li>javac又被称为前端编译器，仅负责源代码与字节码之间的转换，而在jvm内部还存在一个后置编译器（根据热点探测技术，可以将最有价值的字节码转换为机器码执行从而提升java程序的运行效率）</li><li>javac 的意义就在于 将源码编译为字节码，同时做一些词法，语法，语义上的检查，最后生成可供jvm运行的字节码文件。</li><li>可以在lib中的tools jar包中sun.tools.javac;包下管理者java前端编译器的class文件，Main类中的main方法执行的是javac程序的执行入口。</li><li>同时在bin目录下可以看到很多脚本文件，比如java、javaw等</li></ul><h3 id="那这个-class文件又是什么呢？"><a href="#那这个-class文件又是什么呢？" class="headerlink" title="那这个.class文件又是什么呢？"></a>那这个.class文件又是什么呢？</h3><p>.class文件又称<strong>字节码文件</strong>，它就是java帮我们进行的第一道翻译工作后的结果，这道翻译工作就是javac，可以理解为将源码编译为字节码，同时做一些词法，语法，语义上的检查，最后生成的.class文件供jvm运行。这一过程就叫<strong>编译</strong>，更准确的是称为<strong>前端编译</strong>。.class文件也就是<strong>前端编译</strong>产生的代码。</p><h3 id="前端编译："><a href="#前端编译：" class="headerlink" title="前端编译："></a>前端编译：</h3><p><img src="/category/HelloJava/before.png" alt="Alt text"><br><strong>词法分析</strong>：词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，将字符序列转换为标记（token）序列的过程。这里的标记是一个字符串，是构成源代码的最小单位。在这个过程中，词法分析器还会对标记进行分类 。<br>词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。<br><strong>语法分析</strong>：语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述。<br><strong>将源代码中的字符流构造成抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方法。填充符号表： 符号表是一组符号地址和符号信息构成的表格。</strong><br><strong>注解处理器处理</strong>：我们平时使用的Java注解，本质就是用来对语法树做出修改，处理器的任务便是在编译是识别出这些注解同时修改抽象语法树。<br><strong>语义分析与字节码生成</strong>：<br>语义分析是编译过程的一个逻辑阶段， 语义分析的任务是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。<br>语义分析的一个重要部分就是类型检查。比如很多语言要求数组下标必须为整数，如果使用浮点数作为下标，编译器就必须报错。再比如，很多语言允许某些类型转换，称为自动类型转换。</p><ul><li>标注检查：语义分析的第一个步骤，用来检查包括诸如使用的变量是否已经声明、变量与赋值之间的数据类型是否能够匹配。其中有一个重要的步骤就是常量折叠<br>如：int a = 3 + 2， javap查看生成的class字节码，iconst指令向操作数栈中压入的是常量值5，这样在运行时期就不会CPU的运算量重新计算。</li><li>数据及控制流分析<br>用于检查诸如局部变量在使用前是否已经赋值，方法的每条路径上是否都有返回值，受查异常是否都被正常处理等问题。</li><li>解语法糖（desugar）<br>Java中我们经常使用的语法糖有泛型、自动装箱/拆箱、遍历循环、条件编译等.. 由于这些语法在运行时无法被识别，因此需要在编译阶段就将他们还原回简单的基础语法结构。</li><li>泛型<br>泛型的本质是参数化类型的应用，参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。<br>在Java中，泛型只在源码中存在，一旦经常编译，就会替换成原来的原生类型并且在相应的地方加上了强制类型转换代码。这一过程也叫做类型擦除</li><li>自动装箱/拆箱<br>基本类型自动装箱成包装类型，包装类型拆箱成基本类型，大多数Java程序员都已经了解。只是使用上有些地方需要注意，比方包装类型在使用“==”进行比较时，只有遇到算术运算时才会自动拆箱。</li><li>遍历循环<br>诸如 for(int i : list) {} 这样的loop循环在编译后都会转换成对数据结构iterator的调用</li><li>条件编译<br>对于if和常量搭配使用，在编译器发现不会执行到的语句块，将不会出现在编译之后的class文件当中</li><li>生成字节码class文件<br>在Compiler生成class文件时，不仅仅将前面步骤生成的信息转化成字节码，还会进行少量的代码添加和转换工作，如<init>和<clinit>就是在该阶段添加进class文件当中，如果Compiler发现代码中没有任何构造器，那么将会添加一个无参数的、访问性与当前类一致的构造器（也即经常所说的默认无参构造器）</clinit></init></li></ul><h3 id="后端编译"><a href="#后端编译" class="headerlink" title="后端编译"></a>后端编译</h3><p>在Java中，javac执行的结果就是得到一个字节码，而这个字节码其实就是一种中间代码。</p><p>然后得到的class文件并不能被机器所识别。这个时候就通过JVM来解释字节码，将其翻译成对应的机器指令，逐条读入，逐条解释执行，这是传统的JVM解释器的功能，为了解决这种效率问题，引入了JIT技术。（即使编译器）<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html" target="_blank" rel="noopener">深入浅出JIT编译</a></p><p>当JVM通过类加载器加载class文件里的字节码后，会通过解释器解释称汇编指令最终再转译成CPU可以识别的机器指令，解释器是软件来实现的，主要是为了实现同一份 Java 字节码可以在不同的硬件平台上运行，而将汇编指令转换成机器指令由硬件直接实现。<br><img src="/category/HelloJava/later.png" alt="later"><br>从软件层面上， class 文件被加载进虚拟机后，类信息会存放在方法区，在实际运行的时候会执行方法区中的代码，在 JVM 中所有的线程共享堆内存和方法区，而每个线程有自己独立的 Java 方法栈，本地方法栈（面向 native 方法），PC寄存器（存放线程执行位置），当调用一个方法的时候， Java 虚拟机会在当前线程对应的方法栈中压入一个栈帧，用来存放 Java 字节码操作数以及局部变量，这个方法执行完会弹出栈帧，一个线程会连续执行多个方法，对应不同的栈帧的压入和弹出，压入栈帧后就是 JVM 解释执行的过程了。</p><p>JAVA程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p><p>HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。</p><p>当 JVM 执行代码时，它并不立即开始编译代码。首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。</p><p>在机器上，执行java -version命令就可以看到自己安装的JDK中JIT是哪种模式:<br><img src="/category/HelloJava/javaversion.png" alt="-version"></p><h4 id="热点检测"><a href="#热点检测" class="headerlink" title="热点检测"></a>热点检测</h4><p>上面我们说过，要想触发JIT，首先需要识别出热点代码。目前主要的热点代码识别方式是热点探测（Hot Spot Detection），有以下两种：</p><ol><li>基于采样的方式探测（Sample Based Hot Spot Detection) ：周期性检测各个线程的栈顶，发现某个方法经常出险在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因干扰热点探测。</li><li>基于计数器的热点探测（Counter Based Hot Spot Detection)。采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。<br>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。<br>方法计数器。顾名思义，就是记录一个方法被调用次数的计数器。<br>回边计数器。是记录方法中的for或者while的运行次数的计数器。</li></ol><h4 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h4><p>前面提到过，JIT除了具有缓存的功能外，还会对代码做各种优化。说到这里，不得不佩服HotSpot的开发者，他们在JIT中对于代码优化真的算是面面俱到了。</p><p><strong>经过前端编译与后端编译，最终我们的java文件被机器所执行。</strong></p><h2 id="JDK、JRE与JVM："><a href="#JDK、JRE与JVM：" class="headerlink" title="JDK、JRE与JVM："></a>JDK、JRE与JVM：</h2><p><img src="/category/HelloJava/jdk.png" alt="JDK"></p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>Java Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。<br>最主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了属于自己的JDK。<br>JDK有以下三种版本：<br>J2SE， standard edition，标准版，是我们通常用的一个版本<br>J2EE， enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序<br>J2ME，micro edtion，主要用于移动设备、嵌入式设备上的java应用程序</p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>Java Runtime Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>我们刚生成的.class文件就是通过jvm来编译执行<br>Java Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的组成包括 JVM 指令集，符号表以及一些补助信息。</p><h2 id="至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。"><a href="#至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。" class="headerlink" title="至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。"></a>至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Java入门
    
    </summary>
    
      <category term="Java入门" scheme="https://www.ysmjjsy.com/categories/Java%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
