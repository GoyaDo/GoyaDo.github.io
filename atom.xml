<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余生梦见皆是缘</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ysmjjsy.com/"/>
  <updated>2019-08-27T09:32:51.026Z</updated>
  <id>https://www.ysmjjsy.com/</id>
  
  <author>
    <name>Goya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSE-面向对象2</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-面向对象2/</id>
    <published>2017-08-20T06:13:27.000Z</published>
    <updated>2019-08-27T09:32:51.026Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 27 2019 17:33:21 GMT+0800 (GMT+08:00) --><h1 id="面向对象2"><a href="#面向对象2" class="headerlink" title="面向对象2"></a>面向对象2</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为超类，基类或父类，新类称为子类。派生类等。子类比超类拥有的功能更加丰富。</p><p>在通过扩展父类定义子类的时候，仅需要指出子类与超类的不同之处。因为在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。由于子类的构造器不能访问父类的私有域，所以必须利用父类的构造器对这部分私有域进行初始化，我们可以通过super实现对父类构造器的调用，使用super调用构造器的语句必须是子类构造器的第一条语句。</p><p>如果子类的构造器没有显示的调用父类构造器，则将自动的调用超类默认的构造器，如果超类没有不带参数的构造器，并且子类的构造器中又没有显示的调用超类其他的构造器，则Java编译器将报告错误。</p><p>由一个公共超类派生出来的所有类的集合被称为继承层次，从某个特定的类到其祖先的路径称为该类的继承链。把多个类中相同的内容给提取出来定义到一个类中例如</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span></span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"吃饭"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"睡觉"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span></span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"吃饭"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"睡觉"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种情况，可以把公共的提取出来，然后去继承提取的那个类，也就是父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span>&#123;</span><br><span class="line">  <span class="comment">//animal类可以看作所有动物类的父类，任何动物都可以有名字，年龄，都会吃饭睡觉，所以将这些公共的提取出来，那么子类只需要继承这个类便拥有这些方法以及成员变量</span></span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"吃饭"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"睡觉"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> <span class="keyword">extends</span> <span class="title">animal</span>()</span>&#123;</span><br><span class="line">  <span class="comment">//这里子类dog就拥有父类animal的成员变量以及方法，可以对其赋值或者方法的重写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> <span class="keyword">extends</span> <span class="title">animal</span>()</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样的extends关系就叫做继承，但是继承中子类不能继承父类的私有成员，构造方法(但可以通过super去访问)，继承体现的是is a的关系，在java中只支持单继承，但可以多层继承(继承体系)</p><p>继承的标准格式就是：<code>class 子类名 extends 父类名{}</code></p><h3 id="使用了继承有什么好处呢？"><a href="#使用了继承有什么好处呢？" class="headerlink" title="使用了继承有什么好处呢？"></a>使用了继承有什么好处呢？</h3><ul><li>提高了代码的复用性</li><li><h3 id="提高了代码的维护性"><a href="#提高了代码的维护性" class="headerlink" title="提高了代码的维护性"></a>提高了代码的维护性</h3></li><li>让类与类之间产生了关系，是多态的前提(同时这一点也是弊端，当类与类之间产生了关系，就不可避免的会有耦合，然而在开发原则里明确表示：低耦合高内聚，当耦合度高了可以这么形容，”牵一发而动全身“)</li></ul><p>假设我们有这么一个需求，有一家做信息检索的公司，他们需要对手机的各个品牌做一个统计以及对比，现在需要开发一个软件，需要编写entity，在使用继承并且掌握现有知识的前提下如何去设计呢？</p><p>首先我们应该分析一下，这家公司对产品内不同品牌进行对比，那么主题是手机，手机下有不同的品牌</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设我们手机有这些功能以及参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">double</span> size;</span><br><span class="line">  String color;</span><br><span class="line">  String name;</span><br><span class="line">  String cpu_id;</span><br><span class="line">  <span class="keyword">int</span> ram_size;</span><br><span class="line">  <span class="keyword">int</span> rom_size;</span><br><span class="line">  <span class="keyword">int</span> camera_pixel;<span class="comment">//摄像头像素</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhoto</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"拍照"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我现在有一个华为手机，那么我定义一个类HuaweiPhone继承Phone</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">  <span class="comment">//在这里我就不用每添加一个品牌再去写那些共有的特性，而是去继承父类，如果功能有特殊的那么重写或新加</span></span><br><span class="line">  <span class="keyword">int</span> camera_num; <span class="comment">//摄像头数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeMaxPhoto</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"夜拍，徕卡相机拍更厉害的照片"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同样小米手机，等其他手机也是类似，当我们新加一个手机品牌那么只需要继承这个类即可，再去写我们特有的功能</span></span><br></pre></td></tr></table></figure><p>在上述代码中可能会好奇，为什么只是写了一个关键字extends，子类便可以使用父类的成员变量，成员方法。</p><h3 id="继承中构造方法："><a href="#继承中构造方法：" class="headerlink" title="继承中构造方法："></a>继承中构造方法：</h3><p>在继承体系中，子类会继承父类中的数据，可能还会使用父类的数据。那么我们知道，在一个类中，给成员变量赋值有两种方法，一种是用方法赋值，一种是构造方法赋值。用构造方法赋值在new一个对象时需要对有参的构造方法传入值。而构造方法当自己没有声明，java会帮你写一个无参的构造方法。但是当你写了一个有参的构造方法如果还要使用无参的构造方法必须声名一个。系统不会再帮你生成无参构造方法。</p><p>在这里，子类的构造方法默认访问了父类中空参数的构造方法，从而构造出父类对象。</p><p>构造方法用于初始化一个实例对象，所以static修饰是没有任何意义的;多个线程不会同时创建内存地址相同的同一个对象，所以synchronized修饰没有意义;</p><p>构造方法不能被子类继承，所以final和abstract修饰没有意义</p><p>构造方法是没有返回类型的，void也不行。</p><p>当用户没有给java类定义明确的构造方法的时候,java为我们提供了一个默认的构造方法,这个构造方法没有参数,修饰符是public并且方法体为空。如果用户有定义构造方法，就不会有默认构造方法！！！<br>其实默认的构造方法还分为两种,一种就是刚刚说过的隐藏的构造方法,另一种就是显示定义的默认构造方法.<br>如果一个类中定义了一个或者多个构造方法,并且每一个构造方法都是带有参数形式的,那么这个类就没有默认的构造方法（需要显示的声明无参构造方法）</p><h4 id="this与super："><a href="#this与super：" class="headerlink" title="this与super："></a>this与super：</h4><p><strong>“this”的用法：</strong></p><p>实例方法中可以使用this关键字,它指向正在执行方法的类的实例对象,当然static方法中是不可以使用this对象的,因为静态方法不属于类的实例对象;而构造方法中同样可以使用this关键字,构造器中的this是指向同一个对象中不同参数的另一个构造器。</p><ol><li>构造方法中通过this关键字调用其他构造方法时,那么这句代码必须放在第一行,否则会编译错误。</li><li>构造方法中只能通过this调用一次其他的构造方法。</li></ol><p><strong>“super”的用法：</strong></p><p>实例方法和构造方法中的super关键字都用于去指向父类,实例方法中的super关键字是去调用父类当中的某个方法</p><p>构造器中使用super关键字调用父类中的构造器</p><p>在实例化子类对象时,程序会先调用父类的默认构造方法,然后再执行子类的构造方法。</p><p>在实例化类的对象时,类中的成员变量会首先进行初始化,如果其中的成员变量有对象，那么它们也会按照顺序执行初始化工作。在所有类成员初始化完成后，才调用对象所在类的构造方法创建对象。构造方法作用就是初始化。</p><p>如果一个类中有静态对象,那么他会在非静态对象初始化前进行初始化,但只初始化一次。而非静态对象每次调用时都要初始化。</p><p>程序中主类的静态变量会在main()方法执行前初始化</p><p>一个类初始化顺序：父类的静态成员—&gt;子类的静态成员—&gt;父类的非静态成员—&gt;父类的默认构造函数被调用—&gt;子类的非静态对象（变量）—&gt; 子类的构造函数。</p><h3 id="继承中成员方法的关系"><a href="#继承中成员方法的关系" class="headerlink" title="继承中成员方法的关系"></a>继承中成员方法的关系</h3><p>子类中的方法和父类中的方法声明不一样 直接调用</p><p>子类中的方法和父类中的方法声明一样：</p><ul><li>通过子类调用方法：<ul><li>先找子类中看有没有这个方法，有就使用</li><li>再看父类有没有这个方法，有就使用</li><li>如果没有就报错</li></ul></li></ul><h3 id="方法重写与方法重载"><a href="#方法重写与方法重载" class="headerlink" title="方法重写与方法重载"></a>方法重写与方法重载</h3><p>方法重写（Override）：子类中出现了和父类中方法声明一模一样的方法</p><p>方法重载（Overload）：本类中出现的方法名一样，参数列表不同的方法。与返回值无关</p><p>子类对象调用方法的时候：</p><ul><li>先找子类本身，再找父类</li></ul><p>方法重写的应用：</p><ul><li>当子类需要父类的功能，而功能主体子类有自己的特有内容时，可以重写父类中的方法。</li><li>这样，即沿袭了父类的功能，又定义了子类特有的内容。</li></ul><p>注意事项：</p><ul><li>父类中私有的方法不能被重写</li><li>子类重写父类方法是，访问权限不能更低</li><li>父类静态方法，子类必须通过静态方法进行重写</li></ul><p>子类重写父类方法的时候，最好声明一模一样</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>同一个对象（事务），在不同时刻体现出来的不同状态</p><p>比如小米手机是小米手机同样也是手机</p><p>在上面的例子中当<code>Phone p = new XiaomiPhone()</code></p><p>可以看作是多态</p><h4 id="多态的前提："><a href="#多态的前提：" class="headerlink" title="多态的前提："></a>多态的前提：</h4><ul><li>要有继承关系，</li></ul><ul><li>要有方法重写（也可以没有，但是没有这个就没有意义）</li><li>要有父类引用子类对象<code>fu f = new zi()</code></li></ul><h4 id="多态中成员访问特点："><a href="#多态中成员访问特点：" class="headerlink" title="多态中成员访问特点："></a>多态中成员访问特点：</h4><p>成员变量</p><ul><li>编译看左边，运行看左边</li></ul><p>构造方法</p><ul><li>创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化</li></ul><p>成员方法</p><ul><li>编译看左边，运行看右边</li></ul><p>静态方法</p><ul><li>编译看左边，运行看左边</li></ul><p>（静态和类相关，算不上重写，所以访问还是左边的）</p><p>由于成员方法存在方法重写，所以它运行看右边。</p><h4 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h4><p>提高了代码的维护性（继承保证）</p><p>提高了代码的扩展性（多态保证）</p><h4 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h4><p>不能使用子类的特有功能。</p><p>父类使用子类特有功能</p><ul><li>创建子类对象调用方法即可（可以，但是很多时候不合理，而且太占内存）</li></ul><ul><li>把父类的引用强制转换为子类的引用（向下转型）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象间转型问题</span></span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Zi z = <span class="keyword">new</span> (Zi)f;<span class="comment">//要求该f必须能够转换为Zi的</span></span><br></pre></td></tr></table></figure><p>多态中的内存图解：</p><p><img src="/category/JavaSE-面向对象2/duotai.png" alt="多态继承中内存图解"></p><p>对象变化内存图解：</p><p><img src="/category/JavaSE-面向对象2/duotai2.png" alt="对象变化内存图解"></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。</p><p>对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。</p><p>使用封装有三大好处：</p><ul><li>良好的封装能够减少耦合。</li><li>类内部的结构可以自由修改。</li><li>可以对成员进行更精确的控制。</li><li>隐藏信息，实现细节。</li></ul><p>所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。可以对成员变量进行更精确的控制</p><h3 id="Package关键字"><a href="#Package关键字" class="headerlink" title="Package关键字"></a>Package关键字</h3><h4 id="包的概述："><a href="#包的概述：" class="headerlink" title="包的概述："></a>包的概述：</h4><ul><li><p>其实就是文件夹</p></li><li><p>作用：</p></li><li><ul><li>把对相同的类名放到不同的包中</li><li>对类进行分类管理</li></ul></li></ul><h4 id="包的定义："><a href="#包的定义：" class="headerlink" title="包的定义："></a>包的定义：</h4><p>Package 包名；</p><p>多级包用.分开</p><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li>package语句必须是程序的第一条可执行的代码</li><li>package语句在一个java文件中只能有一个</li><li>如果没有package，默认表示无包名</li></ul><h4 id="带包的编译和运行："><a href="#带包的编译和运行：" class="headerlink" title="带包的编译和运行："></a>带包的编译和运行：</h4><ul><li><p>手动式</p></li><li><ol><li>编写一个带包的Java文件</li><li>通过Javac命令编译该Java文件</li><li>手动创建包名</li><li>把b步骤的class文件放到c步骤的最低层包</li><li>回到和包根目录在同一个目录的地方，然后运行带包运行</li></ol></li><li><p>自动式</p></li><li><ol><li>编写一个带包的java文件</li><li>javac编译的时候带上-d即可</li></ol></li></ul><p>Javac -d .HelloWorld.java</p><ol><li>回到和包根目录在同一个目录的地方，然后运行带包运行</li></ol><h3 id="import关键字的概述和使用"><a href="#import关键字的概述和使用" class="headerlink" title="import关键字的概述和使用"></a>import关键字的概述和使用</h3><p>导包：</p><p>格式：import 包名；</p><p>这种方式导入是到类的名称。</p><p>注意：我们用谁就导谁</p><p>面试题：</p><p>package，import，class有没有顺序关系？</p><p>有</p><p>package&gt;import&gt;class</p><p>package：只能有一个</p><p>import：可以有多个</p><p>class：可以有多个，建议是一个</p><h3 id="四种权限修饰符"><a href="#四种权限修饰符" class="headerlink" title="四种权限修饰符"></a>四种权限修饰符</h3><div class="table-container"><table><thead><tr><th></th><th>本类</th><th>同一个包下（子类和无关类）</th><th>不同包下（子类）</th><th>不同包下（无关类）</th></tr></thead><tbody><tr><td>private</td><td>Y</td><td></td><td></td><td></td></tr><tr><td>默认（default）</td><td>Y</td><td>Y</td><td></td><td></td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td></td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table></div><h3 id="类及其组成所使用的常见修饰符"><a href="#类及其组成所使用的常见修饰符" class="headerlink" title="类及其组成所使用的常见修饰符"></a>类及其组成所使用的常见修饰符</h3><p><strong>修饰符：</strong></p><p>权限修饰符：private，默认修饰符，protected，public</p><p>状态修饰符：static，final</p><p>抽象修饰符：abstract</p><p><strong>类：</strong></p><p>权限修饰符：默认修饰符，public</p><p>状态修饰符：final</p><p>抽象修饰符：abstract</p><p>用的最多的就是public</p><p><strong>成员变量：</strong></p><p>权限修饰符：private，默认修饰符，protected，public</p><p>状态修饰符：static，final</p><p>用的最多的就是，private</p><p><strong>构造方法：</strong></p><p>权限修饰符：private，默认修饰符，protected，public</p><p>用的最多的就是public</p><p><strong>成员方法：</strong></p><p>权限修饰符：private，默认修饰符，protected，public</p><p>状态修饰符：static，final</p><p>抽象修饰符：abstract</p><p>用的最多的就是public</p><p><strong>除此以外的组合规则：</strong></p><p>成员变量：public static final</p><p>成员方法：public static</p><p>public abstract</p><p>public final</p><h2 id="类初始化过程"><a href="#类初始化过程" class="headerlink" title="类初始化过程"></a>类初始化过程</h2><h4 id="类初始化过程-1"><a href="#类初始化过程-1" class="headerlink" title="类初始化过程"></a>类初始化过程</h4><p>加载class文件进内存</p><p>在栈内存开辟空间</p><p>在对内存为类对象开辟空间</p><p>对对象的成员变量进行默认初始化</p><p>对对象的成员变量进行显示初始化</p><p>通过构造方法对对象的成员变量赋值</p><p>对象初始化完毕，吧对象地址复制给变量</p><h4 id="对象析构与finalize方法："><a href="#对象析构与finalize方法：" class="headerlink" title="对象析构与finalize方法："></a>对象析构与finalize方法：</h4><p>在析构器中最常见的操作是回收分配给对象的存储空间，但Java不支持析构器，可以为任何一个类添加finalize方法，将在垃圾回收器清除对象之前调用。</p><h4 id="动态绑定："><a href="#动态绑定：" class="headerlink" title="动态绑定："></a>动态绑定：</h4><p>调用对象方法的执行过程：</p><p>编译器查看对象的声明类型和方法名</p><p>编译器查看调用方法时提供的参数类型</p><p>如果是private方法、static方法、final方法、或者构造器，那么编译器将准备的知道该调用哪个方法，这种调用方式为静态绑定。</p><p>调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。</p><p>当程序运行时，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。</p><p>虚拟机为了节省开销和时间，为每个类预先创建了一个方法表。</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>把类定义在其他类的内部，这个类就被称为内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类的访问特点"><a href="#内部类的访问特点" class="headerlink" title="内部类的访问特点"></a>内部类的访问特点</h3><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">      i.show();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类位置："><a href="#内部类位置：" class="headerlink" title="内部类位置："></a>内部类位置：</h3><p>成员位置：在成员位置定义的类，称为成员内部类。</p><p>局部位置：在局部位置定义的类，称为局部内部类</p><p>成员内部类：</p><p>如何直接访问内部类的成员：</p><p>外部类名.内部类名 对象名 = 外部类对象.内部类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringp[] args)</span></span>&#123;</span><br><span class="line">      Outer.Inner oi = <span class="keyword">new</span> Outer().new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>成员内部类的修饰符：</p><p>private 为了保证数据的安全性</p><p>static 为了方便访问数据</p><p>注意：静态内部类访问的外部类数据必须用静态修饰</p><p>成员内部类被静态修饰后的访问方式是：</p><p>格式：外部类名.内部类名 对象名 = new 外部类名.内部类名();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num2 = <span class="number">100</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Outer.Inner oi = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">    oi.show();</span><br><span class="line">    oi.show2();</span><br><span class="line">    <span class="comment">//show2另一种调用方式</span></span><br><span class="line">    Outer.Inner.show2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部内部类：</p><ul><li>可以直接访问外部类的成员</li><li>在局部位置，可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能</li></ul><p>面试题：</p><p>局部内部类访问局部变量的注意事项？</p><ul><li>局部内部类访问局部变量必须用final修饰</li><li>为什么呢？</li></ul><p>局部变量是随着方法的额调用而调用，随着调用完毕而消失。</p><p>而堆内存的内容并不会立即消失，所以我们加final修饰。</p><p>加入final修饰后，这个变量就常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Inner i = <span class="keyword">new</span> Inner()</span><br><span class="line">    i.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>就是内部类的简化写法</p><p>前提：存在一个类或者接口</p><p>这里的类可以是具体类也可以是抽象类</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或者接口名()&#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质是什么呢？</p><p>是一个继承了该类或者实现了该接口的子类匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Inter()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类的方法调用"><a href="#匿名内部类的方法调用" class="headerlink" title="匿名内部类的方法调用"></a>匿名内部类的方法调用</h4><p>调用一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Inter()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用多个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Inter i = <span class="keyword">new</span> Inter()&#123;<span class="comment">//多态</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"show"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"show2"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">i.show();</span><br><span class="line">i.show2();</span><br></pre></td></tr></table></figure><h4 id="匿名内部类在开发中的应用："><a href="#匿名内部类在开发中的应用：" class="headerlink" title="匿名内部类在开发中的应用："></a>匿名内部类在开发中的应用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span></span>&#123;</span><br><span class="line">  <span class="comment">//接口名作为形式参数</span></span><br><span class="line">  <span class="comment">//这里需要的不是接口，而是接口的实现类的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    p.study();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"好好学习，天天向上"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    PersonDemo pd = <span class="keyword">new</span> PersonDemo();</span><br><span class="line">    Person p = <span class="keyword">new</span> Person();</span><br><span class="line">    pd.method(p);</span><br><span class="line">    Systemout.println(<span class="string">"------"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//匿名内部类在开发中的使用</span></span><br><span class="line">    <span class="comment">//匿名内部类的本质是继承类或者实现了接口的子类匿名对象</span></span><br><span class="line">    pd.method(<span class="keyword">new</span> Person()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"好好学习，天天向上"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据</p><p>内部类可以对同一个包中的其他类隐藏起来</p><p>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷</p><p>内部类可以直接访问外部类的成员，包括私有</p><p>外部类要访问内部类的成员，必须创建对象</p><p>内部类的位置:</p><p>成员位置:成员内部类</p><p>外部类名.内部类名 对象名 = 外部类对象.内部类对象</p><p>private:私有。 外部类创建方法，方法内创建对象，调用内部类方法。</p><p>Static(为了方便访问数据)内部类用静态修饰是因为内部类可以看出是外部类的成员,内部类被静态修饰后，访问外部类数据必须用静态修饰</p><p>局部位置:局部内部类</p><p>使用内部类访问对象状态:</p><p>内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。</p><p>内部类的特殊语法规则:</p><p>OuterClass.this:表示外围类引用</p><p>OuterClass.InnerClass:在外围类的作用域之后，引用内部类</p><p>局部内部类:</p><p>局部类不能用public或private访问说明符进行声明。它的作用域被限定在声明这个具备类的块中。</p><p>局部类有一个优势，即对外部世界可以完全的隐藏起来。</p><p>可以直接访问外部类成员</p><p>在局部位置，可以创建内部类对象，通过内部类对象，通过对象内部类方法，来使用局部内部类功能</p><p>匿名内部类:</p><p>假如只创建这个类的一个对象，就不必命名，这种类被称为匿名内部类</p><p>new SuperType(construction parameters)</p><p>{</p><p>Inner class methods and data</p><p>}</p><p>由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器，取而代之的是，将构造器参数传递给超类构造器，尤其是内部类实现接口的时候，不能有任何构造参数。</p><p>前提:存在一个类或者接口，这里的类可以是具体类也可以是抽象类</p><p>new 类名或者接口名(){</p><p>重写方法;</p><p>}</p><p>本质是一个继承了该类或者实现了该接口的子类匿名对象</p><p>静态内部类:</p><p>有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象，为此，可以将内部类声明为static，以便取消产生的引用</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE面向对象,继承、多态、封装、内部类的概述。
    
    </summary>
    
      <category term="JavaSE面向对象" scheme="https://www.ysmjjsy.com/categories/JavaSE%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-基础语法</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-基础语法/</id>
    <published>2017-08-16T13:33:02.000Z</published>
    <updated>2019-08-16T09:38:14.734Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 16 2019 17:38:47 GMT+0800 (GMT+08:00) --><h1 id="JavaSE-基础语法"><a href="#JavaSE-基础语法" class="headerlink" title="JavaSE-基础语法"></a>JavaSE-基础语法</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>被Java语言赋予特定含义的单词</p><p>特点：全部小写，goto和const作为保留字存在</p><div class="table-container"><table><thead><tr><th style="text-align:center">abstract</th><th style="text-align:center">assert</th><th style="text-align:center">boolean</th><th style="text-align:center">break</th><th style="text-align:center">byte</th></tr></thead><tbody><tr><td style="text-align:center"><strong>case</strong></td><td style="text-align:center"><strong>catch</strong></td><td style="text-align:center"><strong>char</strong></td><td style="text-align:center"><strong>class</strong></td><td style="text-align:center"><strong>const</strong></td></tr><tr><td style="text-align:center"><strong>continue</strong></td><td style="text-align:center"><strong>default</strong></td><td style="text-align:center"><strong>do</strong></td><td style="text-align:center"><strong>double</strong></td><td style="text-align:center"><strong>else</strong></td></tr><tr><td style="text-align:center"><strong>enum</strong></td><td style="text-align:center"><strong>extends</strong></td><td style="text-align:center"><strong>final</strong></td><td style="text-align:center"><strong>finally</strong></td><td style="text-align:center"><strong>float</strong></td></tr><tr><td style="text-align:center"><strong>for</strong></td><td style="text-align:center"><strong>goto</strong></td><td style="text-align:center"><strong>if</strong></td><td style="text-align:center"><strong>implements</strong></td><td style="text-align:center"><strong>import</strong></td></tr><tr><td style="text-align:center"><strong>instanceof</strong></td><td style="text-align:center"><strong>int</strong></td><td style="text-align:center"><strong>interface</strong></td><td style="text-align:center"><strong>long</strong></td><td style="text-align:center"><strong>native</strong></td></tr><tr><td style="text-align:center"><strong>new</strong></td><td style="text-align:center"><strong>package</strong></td><td style="text-align:center"><strong>private</strong></td><td style="text-align:center"><strong>protected</strong></td><td style="text-align:center"><strong>public</strong></td></tr><tr><td style="text-align:center"><strong>return</strong></td><td style="text-align:center"><strong>strictfp</strong></td><td style="text-align:center"><strong>short</strong></td><td style="text-align:center"><strong>static</strong></td><td style="text-align:center"><strong>super</strong></td></tr><tr><td style="text-align:center"><strong>switch</strong></td><td style="text-align:center"><strong>synchronized</strong></td><td style="text-align:center"><strong>this</strong></td><td style="text-align:center"><strong>throw</strong></td><td style="text-align:center"><strong>throws</strong></td></tr><tr><td style="text-align:center"><strong>transient</strong></td><td style="text-align:center"><strong>try</strong></td><td style="text-align:center"><strong>void</strong></td><td style="text-align:center"><strong>volatile</strong></td><td style="text-align:center"><strong>while</strong></td></tr></tbody></table></div><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>给类、接口、方法、变量等起名的字符序列</p><p>组成规则：数字、字母、下划线和$（见名知意），不能以数字开头，不能是java中的关键字，区分大小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> size01 = <span class="number">25.0F</span>;</span><br><span class="line"><span class="keyword">double</span> size_02 = <span class="number">30.23</span>;</span><br><span class="line"><span class="keyword">char</span> size$<span class="number">03</span> = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>在程序执行过程中，其值不发生改变的量，常量在编译阶段会存入到调用这个常量的方法所在类的常量池中。并且调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。</p><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><p>“a”、”hello”、等双引号括起来的常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><h4 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h4><p>1、2、123等数值类型常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="小数常量"><a href="#小数常量" class="headerlink" title="小数常量"></a>小数常量</h4><p>12.345等小数形式常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">12.32F</span>;</span><br></pre></td></tr></table></figure><h4 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h4><p>‘a’、’A’、’0’等用单引号括起来的常量</p><p>可与是英文字母、数字、标点符号以及由转义序列来表示的特殊字符。’\u0000’表示一个空白字符，即在单引号之间没有任何字符，之所以能这样表示，是因为Java采用Unicode字符集，Unicode字符以\u开头，空白字符在Unicode码表中对应的值为’\u0000’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">'A'</span>;</span><br></pre></td></tr></table></figure><h4 id="布尔常量"><a href="#布尔常量" class="headerlink" title="布尔常量"></a>布尔常量</h4><p>只有两种值类型的常量：true/false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="自定义常量"><a href="#自定义常量" class="headerlink" title="自定义常量"></a>自定义常量</h3><p>利用关键字final指示常量，表示这个变量只能被赋值一次，且常量名建议使用全大写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量就是程序运行中可变的量，定义格式：数据类型 变量名 = 初始化值;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>在Java中，每一个变量属于一种数据类型，在生命变量时，变量所属的类型位于变量之前，变量就是指在程序执行过程中值在某个范围内可以发生改变的量。声明一个变量后，必须使用赋值语句对变量进行显示初始化，变量的声明尽可能靠近变量第一次使用的地方。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h3><p>Java种基本数据类型有4类8种</p><p>分别为：</p><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">0</td><td style="text-align:center">8bit == 1byte</td><td style="text-align:center">-128~127</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">0</td><td style="text-align:center">16bit == 2byte</td><td style="text-align:center">-32768~32767</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">0</td><td style="text-align:center">32bit == 4byte</td><td style="text-align:center">-2147483648~2147483647</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">0L</td><td style="text-align:center">64bit == 8byte</td><td style="text-align:center">-9223372036854775808~9223372036854775807</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">8L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b4 = <span class="number">3</span> + <span class="number">4</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里不报错是因为右边先进行计算，得到数值然后进行判断，是否在byte的范围内，</span></span><br><span class="line"><span class="comment">如果在就不报错，如果不在就报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//byte b5 = 100+150; 报错</span></span><br></pre></td></tr></table></figure><h4 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">0.0f</td><td style="text-align:center">32bit == 4byte</td><td style="text-align:center">1.4E-45~3.4028235E38</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">0.0</td><td style="text-align:center">64bit == 8byte</td><td style="text-align:center">4.9E-324~1.7976931348623157E308</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浮点数</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">4.0F</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//float f2 = 3.14; 报错</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以看到这里会报错，是因为在定义浮点类型数据的时候如果不加修饰符默认是double类型</span></span><br><span class="line"><span class="comment">当double赋值给float，大类型转小类型则会报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">float</span> f3 = <span class="number">3.1415F</span>;</span><br><span class="line"><span class="keyword">float</span> f4 = (<span class="keyword">float</span>) <span class="number">3.1415</span>; <span class="comment">//这里加了强制类型转换，所以也不报错</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">那f3、f4有什么区别吗？</span></span><br><span class="line"><span class="comment">f3定义的是一个float类型，f4最初定义的是一个double类型，然后强制转换成float类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">‘\u0000’</td><td style="text-align:center">16bit == 2byte</td><td style="text-align:center">0~6553</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符类型</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">布尔类型</td><td style="text-align:center">false</td><td style="text-align:center">8bit == 1byte</td><td style="text-align:center">true/false</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布尔类型</span></span><br><span class="line"><span class="keyword">boolean</span> bool = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>数据类型转换:(隐式转换)<br>byte、short、char —&gt; int —&gt; long —&gt; float —&gt; double<br>byte、short、char之间不参与相互转换，直接转换成int类型参与运算<br>强制类型转换:(强制转换)<br>格式:<br>目标数据类型 变量名 = (目标数据类型) (被转换的数据)<br>强制类型转换会损失精度。</p><h3 id="2、引用类型"><a href="#2、引用类型" class="headerlink" title="2、引用类型"></a>2、引用类型</h3><p>底层结构和基本类型差别较大</p><ul><li>类类型</li></ul><p>当传入的值是一个类类型时，需要传入的是该类的对象</p><ul><li>接口类型</li></ul><p>当传入值是一个接口类型时，需要传入的是该接口的实现类对象</p><ul><li>数组类型</li><li>枚举</li><li>注解</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>+、-、*、/、%、++、—</p><p>++在前，先自增再运算，++在后先运算再自增</p><p>—同理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span>；</span><br><span class="line">b = <span class="number">4</span>；</span><br><span class="line">b = a++;<span class="comment">//在这里，++在后，先赋值再自增</span></span><br><span class="line">System.out.println(<span class="string">"a: "</span>+ a+<span class="string">"b: "</span>+b);<span class="comment">//a = 4 , b = 4</span></span><br><span class="line">c = a;</span><br><span class="line">c = ++b;</span><br><span class="line">System.out.println(<span class="string">"b: "</span>+ b+<span class="string">"c: "</span>+c);<span class="comment">//b = 5 , c = 5</span></span><br><span class="line">d = c;</span><br><span class="line">d = --a + b--;</span><br><span class="line">System.out.println(<span class="string">"a: "</span>+ a+<span class="string">"b: "</span>+b+<span class="string">"d "</span>+d);<span class="comment">//a = 3 , b = 4 , d = 8</span></span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>=、+=、-=、*=、/=、%=</p><p>=代表赋值运算符，将右边的值赋给左边</p><p>在这里需要注意+=、-=、<em>=、/=、%=。这代表的是一个运算符，相对于+、-、</em>、/，如果在等号两边数据类型不一致时，+=会进行自动类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">2</span>;</span><br><span class="line">a = a + b; <span class="comment">//这里会报错，因为a和b是byte类型，执行完相加赋值给a时会自动转为int类型，而a是byte类型，就会出现类型不匹配问题这里相当于 a = (int) a + b;</span></span><br><span class="line">a += b; <span class="comment">//这里不会报错，+=在运算时会自动进行类型转换</span></span><br></pre></td></tr></table></figure><p><strong>总结：+ 、+=举例</strong></p><p>+：在编译将右边表达式结果计算出来后，和左边的变量类型比较精度，如果左边的精度低于右边的结果的精度，编译器会显式的报错，告诉程序员去强制转型。所以（a = a+b;）会报错，最后将表达式的结果复制到变量所在的内存区</p><p>+=：编译器自动隐式直接将+=运算符后面的操作数强制装换为前面变量的类型，然后在变量所在的内存区上直接根据右边的操作数修改左边变量内存存储的二进制数值所以 （a += b;）不报错最后达到和赋值运算符相同的目的。与前者相比，由于后者是位操作，效率也较前者高。</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>==、！=、&gt;、&lt;、&gt;=、&lt;=</p><p>==代表判断是否相等，比较运算符返回值都是boolean类型</p><p>在这里需要注意的是，==比较基本数据类型时比较的是值，比较引用类型时比较的是两个对象的地址值</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>&amp;、|、^、!、&amp;&amp;、||</p><p>逻辑运算符用来连接boolean类型的表达式</p><p>&amp;(逻辑与)：有false则false</p><p>|(逻辑或)：有true则true</p><p>^(异或)：相同则false，不同则true</p><p>!(非)：非true则false，非false则true</p><p>&amp;&amp;(短路与)：和&amp;相同，不过有短路效果，左边是false，右边不执行</p><p>||(短路或)：和|相同，有短路效果，左边是true，右边不执行</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>操作二进制</p><p>&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;、&amp;、|、^、~</p><ul><li>&lt;&lt;：左移，空位补0，被移除的最高位丢弃<ul><li>3 &lt;&lt; 2 = 12 ——- 3 <em>2 </em>2 = 12</li></ul></li><li>.&gt;&gt;：右移，被移位的二进制最高位是0，右移后，空缺位补0，最高位是1.最高位补1<ul><li>3 &gt;&gt; 1 = 1 ——- 3/2=1</li></ul></li><li>.&gt;&gt;&gt;：无符号右移，被移位二进制最高位无论是0或者是1，空缺位都用0补<ul><li>3 &gt;&gt;&gt; 1 = 1 ——- 3/2=1</li></ul></li><li>&amp;：与运算，任何二进制位和0进行&amp;运算，结果是0，和1进行&amp;运算结果是原值<ul><li>6&amp;3=2</li></ul></li><li>|：或运算，任何二进制位和0进行|运算，结果是原值，和1进行|运算结果是1<ul><li>6|3=7</li></ul></li><li>^：异或运算，任何相同二进制位进行^运算，结果是0，不相同二进制位^运算结果是1<ul><li>6^3=5</li><li>一个数据对另外一个数据异或两次，该数不变</li></ul></li><li>~：反码<ul><li>~6=-7</li></ul></li></ul><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>格式：比较表达式?表达式1:表达式2;</p><p>执行流程：首先计算比较表达式的值，是true就执行表达式1，是false就执行表达式2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">a &gt; b ? ++a : ++b;</span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>If(condition) statement</p><p>这里的条件必须用括号括起来</p><p>If(condition) statement1 else statement2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">    a++;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a == b)&#123;</span><br><span class="line">    a--;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    b++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>当条件是true时，while循环执行一条语句。</p><p>While(condition) statement</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"这是一个死循环"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><p>先执行语句，再检测循环条件</p><p>Do statement while (condition);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我数到第"</span>+n+<span class="string">"个数了"</span>);</span><br><span class="line">  &#125;<span class="keyword">while</span>(n&gt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="确定循环"><a href="#确定循环" class="headerlink" title="确定循环"></a>确定循环</h3><p>for(初始化语句;判断条件语句;控制条件语句){循环体语句;}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//九九乘法表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">9</span>; x++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= x; y++) &#123;</span><br><span class="line">    System.out.println(x + <span class="string">"*"</span> + y + <span class="string">"="</span> + x * y + <span class="string">"\t"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h4><p>Java有一种功能很强的循环结构，可以用来依次处理数组中的每个元素</p><p>for(variable: collection) statement</p><h3 id="多重选择"><a href="#多重选择" class="headerlink" title="多重选择"></a>多重选择</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Switch (chioce)<span class="comment">//这里可选择数据类型有：基本数据类型，引用类型String，以及枚举和基本类型的封装类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">…</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">…</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">defalut:</span><br><span class="line">…</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在这里简单说一下break、continue、return三者的区别？</strong></p><p><strong>break语句</strong>的使用场合主要是switch语句和循环结构。在循环结构中使用break语句，如果执行了break语句，那么就退出循环，接着执行循环结构下面的第一条语句。如果在多重嵌套循环中使用break语句，当执行break语句的时候，退出的是它所在的循环结构，对外层循环没有任何影响。如果循环结构里有switch语句，并且在switch语句中使用了break语句，当执行switch语句中的break语句时，仅退出switch语句，不会退出外面的循环结构。</p><p>break可以跳出单层循环，也可以跳出多层循环（需要标签语句配合）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"我数到第"</span>+n+<span class="string">"个数了"</span>);</span><br><span class="line">  <span class="keyword">break</span>;<span class="comment">//这里可以看到，break跳出do-while循环，接着执行while循环</span></span><br><span class="line">&#125;<span class="keyword">while</span>(n&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(n&lt;<span class="number">100</span>)&#123;</span><br><span class="line">  System.out.println(<span class="string">"这是一个循环"</span>);</span><br><span class="line">  n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我数到第1个数了</span></span><br><span class="line"><span class="comment">这是一个循环</span></span><br><span class="line"><span class="comment">这是一个循环</span></span><br><span class="line"><span class="comment">这是一个循环</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>continue语句</strong>是最特殊的，因为它并没有真的退出循环，而是只结束本次循环体的执行，所以在使用continue的时候要注意这一点。</p><p>在for循环中，首先执行表达式1（注意表达式1在整个循环中仅执行一次），接着执行表达式2，如果满足条件，那么执行循环体，如果在循环体中执行了continue语句，那么就跳转到表达式3处执行，接下进行下一次循环，执行表达式2，看是否满足条件；在while循环中，如果执行了continue语句，那么就直接跳转到表达式处，开始下一次的循环判断；在do while循环体中如果执行了continue语句，那么就跳转到表达式处进行下一次的循环判断，</p><p><strong>return语句</strong>，如果在程序中遇到return语句，那么代码就退出该函数的执行，返回到函数的调用处，如果是main()函数，那么结束整个程序的运行。</p><p><a href="https://www.infoq.cn/article/HPohK0NfIssFx41yO*e2" target="_blank" rel="noopener">JavaSE12扩展Switch语句</a></p><h2 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h2><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类:BigInteger和BigDecimal。前者实现了任意精度的整数运算，后者实现了任意精度的浮点数运算。</p><p>使用静态的valueOf方法可以将普通的数值转换为大数值</p><p>处理大数值用大数值类中的add和multiply方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a = BigInteger.valueOf(<span class="number">100</span>);</span><br><span class="line">BigInteger c = a.add(b);  <span class="comment">//c=a+b;</span></span><br><span class="line">BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="number">2</span>)));<span class="comment">//d=c*(b+2)</span></span><br></pre></td></tr></table></figure><ul><li>BigInteger：任意精度的整数运算</li></ul><ul><li>BigDecimal：任意精度的浮点数运算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 下面的方法都来自：java.math.BigInteger 包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">mod</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回这个大整数和另一个大整数 other 的和、差、积、商以及余数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 如果这个大整数与另一个大整数 other 相等，返回 0；</span></span></span><br><span class="line"><span class="function"><span class="comment">如果这个大整数小于另一个大整数 other，返回负数；否则，返回正数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigInteger <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回值等于 x 的大整数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">add</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">subtract</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">multiply</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">divide</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回这个大实数和另一个大实数 other 的和、差、积、商。</span></span></span><br><span class="line"><span class="function"><span class="comment">在此，需要注意的是：想要计算商，必须给出舍入方式，例如  RoundingModel.HALF_UP */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 如果这个大实数与另一个大实数 other 相等，返回 0；</span></span></span><br><span class="line"><span class="function"><span class="comment">如果这个大实数小于另一个大实数 other，返回负数；否则，返回正数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigDecimal <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigDecimal <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> scale)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回值等于 x 或者 x/10^(scale) 的大实数 */</span></span></span><br></pre></td></tr></table></figure><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><p>进制也就是进位制，是人们规定的一种进位方法。<br>对于任何一种进制—-X进制，就表示某一位置上的数运算时是逢X进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x进制就是逢x进位。</p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p><img src="/category/JavaSE-基础语法/二进制.png" alt="二进制"></p><p>用8个这样的信号来表示一个数据，这个数据的单位叫做：字节</p><p>1 byte = 8 bit</p><p>1k = 1024byte</p><p>1m = 1024k</p><p>通过数字1,0来表示开关，这样由1,0组成的数据就是二进制数据</p><p>二进制数有两个特点：它由两个基本数字0，1组成，二进制数运算规律是逢二进一。</p><p>为区别于其它进制数，二进制数的书写通常在数的右下方注上基数2，或加后面加B表示。</p><p>例如：二进制数10110011可以写成（10110011）2，或写成10110011B</p><h3 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h3><p>把二进制的数据，从右开始，每三位一组合，最左边不够的时候，补0。然后分别计算出对应的十进制数值，最后，再把每个十进制数据组合起来，就是一个八进制数据。</p><p><img src="/category/JavaSE-基础语法/八进制.png" alt="八进制"></p><h3 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h3><p>人们通常使用的是十进制。它的特点有两个：有0，1，2….9十个基本数字组成，十进制数运算是按“逢十进一”的规则进行的.</p><h3 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h3><p>把二进制的数据从右开始，每四位一组合，最左边不够的时候补0.然后分别进算出对应的的十进制数值，最后，再把每个十进制数据组合起来，就是一个十六进制数据。</p><p><img src="/category/JavaSE-基础语法/十六进制.png" alt="十六进制"></p><h3 id="不同进制的组成"><a href="#不同进制的组成" class="headerlink" title="不同进制的组成"></a>不同进制的组成</h3><div class="table-container"><table><thead><tr><th><strong>二进制</strong></th><th><strong>由0,1组成，以0b开头</strong></th></tr></thead><tbody><tr><td><strong>八进制</strong></td><td><strong>由0,1…7组成，以0开头</strong></td></tr><tr><td><strong>十进制</strong></td><td><strong>由0,1…9组成，整数默认是十进制</strong></td></tr><tr><td><strong>十六进制</strong></td><td><strong>由0,1…9,a,b,c,d,e,f(大小均可)组成，以0x开头</strong></td></tr></tbody></table></div><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><h4 id="其他进制到十进制的转换"><a href="#其他进制到十进制的转换" class="headerlink" title="其他进制到十进制的转换"></a>其他进制到十进制的转换</h4><p><img src="/category/JavaSE-基础语法/toten.png" alt="十进制"></p><p><img src="/category/JavaSE-基础语法/twoten.png" alt="进制转换"></p><h4 id="十进制到其他进制的转换"><a href="#十进制到其他进制的转换" class="headerlink" title="十进制到其他进制的转换"></a>十进制到其他进制的转换</h4><p><img src="/category/JavaSE-基础语法/tento.png" alt="十进制"></p><h4 id="8421码（进制的快速转换）"><a href="#8421码（进制的快速转换）" class="headerlink" title="8421码（进制的快速转换）"></a>8421码（进制的快速转换）</h4><p><img src="/category/JavaSE-基础语法/8421.png" alt="8421"></p><h3 id="有符号数据表示"><a href="#有符号数据表示" class="headerlink" title="有符号数据表示"></a>有符号数据表示</h3><p>在计算机内，有符号数由3种表示法：原码、反码和补码。所有的数据的运算都是采用补码进行的。</p><ul><li><strong>原码</strong><ul><li>就是二进制定点表示法，即最高位为符号位，”0“表示正，”1“表示负，其余位表示数值大小。</li></ul></li><li><strong>反码</strong><ul><li>正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。</li></ul></li><li><strong>补码</strong><ul><li>正数的补码与其原码相同；负数的补码是在其反码的末位+1。</li></ul></li></ul><p><strong>+7、-7的原码反码补码表示：</strong></p><p><img src="/category/JavaSE-基础语法/71.png" alt="原码"></p><p><img src="/category/JavaSE-基础语法/72.png" alt="反码"></p><p><img src="/category/JavaSE-基础语法/73.png" alt="补码"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE基础语法
    
    </summary>
    
      <category term="JavaSE基础语法" scheme="https://www.ysmjjsy.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-面向对象</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-面向对象/</id>
    <published>2017-08-16T13:33:02.000Z</published>
    <updated>2019-08-16T09:32:10.463Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 16 2019 17:33:28 GMT+0800 (GMT+08:00) --><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是构造对象的模板或蓝图，类可以看作是一组对象的集合。一类事物的抽象。举个很简单的例子，经常会听到很多人说：“我不是那类人”。比如那一类就可以理解为“类”。那对象呢，对象就是”我“。在类与类之间，最常见的关系有：依赖（uses-a）、聚合（has-a）、继承（is-a）</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>由类构造对象的过程称为创建类的实例，而这个示例就是对象，对于每个特定的类实例（对象）都有一组特定的实例域值，这些值的集合就是这个对象的当前状态。对象中的数据称为实例域，操作数据的过程称为方法。</p><p><strong>对象的三个主要特征：</strong></p><p><strong>对象的行为，对象的状态，对象标识</strong></p><p>对象状态的改变必须通过调用方法实现</p><p>作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。</p><p>要想使用对象，必须首先构造对象，并指定其初始状态，然后对对象应用方法。</p><p>在Java中，使用构造器构造新实例。构造器是一种特殊的方法，用来构造并初始化对象，构造器的名字应该与类名相同。</p><p>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象，任何对象变量的值都是对存储在另外一个地方的一个对象的引用，new操作符的返回值也是一个引用。如果将一个方法应用于一个值为null的对象上，就会产生错误。局部变量不会自动初始化为null，必须通过调用new或将他们呢设置为null进行初始化</p><h3 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h3><p><img src="/category/JavaSE-面向对象/对象内存图.jpg" alt="对象内存图"></p><p>在Java1.8之后永久区（PremGen）没有，方法区改为MetaSpace物理内存</p><p>具体可以看这篇文章：</p><p><a href="https://crowhawk.github.io/2017/08/09/jvm_1/" target="_blank" rel="noopener">Java内存区域与Java对象</a></p><h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><p>定义这个对象的信息</p><p>成员变量与局部变量的区别</p><div class="table-container"><table><thead><tr><th></th><th>在类中位置</th><th>在内存中位置</th><th>生命周期</th><th>初始化值</th></tr></thead><tbody><tr><td>成员变量</td><td>在类中方法外</td><td>在堆内存</td><td>随着对象创建而存在，随着对象消失而消失</td><td>有默认初始化值</td></tr><tr><td>局部变量</td><td>在方法内或者方法声明上</td><td>在栈内存</td><td>随着方法调用而存在，随着方法调用完毕而消失</td><td>没有默认初始化值，必须先定义赋值再使用</td></tr></tbody></table></div><p>注意：当局部变量名称和成员变量名称一致时，采用就近原则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    String name;<span class="comment">//默认值为null</span></span><br><span class="line">    <span class="keyword">int</span> age;<span class="comment">//默认值为0</span></span><br><span class="line">    <span class="keyword">int</span> num;<span class="comment">//默认值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">3</span>;<span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(<span class="string">"这里有"</span>+num+<span class="string">"只小猫"</span>);<span class="comment">//输出为3</span></span><br><span class="line">      Cat c = <span class="keyword">new</span> Cat();<span class="comment">//创建Cat对象</span></span><br><span class="line">        c.name=<span class="string">"大大"</span>;</span><br><span class="line">        c.age=<span class="number">18</span>;</span><br><span class="line">        System.out.println(c.name+c.age);<span class="comment">//大大18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法就是函数，函数在Java中被称为方法。方法是完成特定功能的代码块</p><p>方法在内存中位于方法区</p><p>方法是随着调用才会加载</p><p>方法与方法是平级关系，不能嵌套定义</p><p>方法定义时候参数之间用逗号隔开</p><p>方法调用升级后不用再传递数据类型</p><p>如果方法有明确返回值，一定要有return带回一个值</p><p>格式：修饰符 返回值类型 方法名 (参数类型 参数名1,参数类型 参数名2…){函数体; return 返回值;}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name,Date date)</span></span>&#123;</span><br><span class="line">  System.out.println(date+<span class="string">"吃了"</span>+name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">MyName</span><span class="params">(String firstName,String lastName)</span></span>&#123;</span><br><span class="line">  String myname = firstName+lastName;</span><br><span class="line">  <span class="keyword">return</span> myname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-面向对象/方法调用.png" alt="方法调用"></p><h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可</p><p>特点：与返回值类型无关，只看方法名和参数列表，在调用时虚拟机通过参数列表的不同来区分同名方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><p><strong>形参：</strong>方法被调用时需要传递进来的参数，如：show(int a)中的a，它只有在show被调用期间a才有意义，也就是会被分配内存空间，在方法show执行完成后，a就会被销毁释放空间，也就是不存在了</p><p><strong>实参：</strong>方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//实参</span></span><br><span class="line">  show(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int a=10;中的a在被调用之前就已经创建并初始化，在调用show方法时，他被当做参数传入，所以这个a是实参。<br>而show(int a)中的a只有在show被调用时它的生命周期才开始，而在show调用结束之后，它也随之被JVM释放掉，，所以这个a是形参。</p><p>当形式参数和返回值类型是引用类型时会和基本类型不同：</p><p>形参和返回值是类类型：实际传入的是该类对象</p><p>形参和返回值是抽象类：实际传入的是该抽象类的子类对象</p><p>形参和返回值是接口：需要的是该接口的实现类对象</p><h4 id="Java到底是值传递还是传引用？"><a href="#Java到底是值传递还是传引用？" class="headerlink" title="Java到底是值传递还是传引用？"></a>Java到底是值传递还是传引用？</h4><p>首先在Java里面有两种数据类型，基本数据类型与引用类型。</p><p>基本类型直接保存在变量中，引用类型变量保存的只是实际对象的地址，一般这种变量为”引用“，引用指向实际对象，实际对象中保存着内容。</p><p>按值调用(call by value):表示方法接收的是调用者提供的值</p><p>按引用调用(call byreference):表示方法接收的是调用者提供的变量地址</p><ul><li>一个方法不能修改一个基本数据类型的参数（数值型和布尔型）</li><li>一个方法可以改变一个对象参数的状态</li><li>一个方法不能让对象参数引用一个新的对象</li></ul><p>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。Java语言总是采用按值调用，也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。按引用调用，方法得到是对象引用及其他的拷贝同时引用同一个对象。</p><p><img src="/category/JavaSE-面向对象/数组内存图.png" alt="数组内存图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;<span class="comment">//变量num保存着1这个值</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//变量arr在栈内存保存的是这个数组在堆内存的地址值，这个地址值引用堆内存的数组实际值</span></span><br></pre></td></tr></table></figure><p>=：表示赋值运算符，对于基本数据类型，赋值运算符会直接改变变量的值，原本的值被覆盖，对于引用类型，赋值运算符改变引用中的地址值，而不是在堆内存的实际值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];<span class="comment">//这里并不会改变原本数组的值，而只是把新数组的引用赋值给arr</span></span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-面向对象/数组内存图2.png" alt="Java内存图2"></p><p>局部变量和方法参数在jvm中的储存方法是相同的，都是在栈上开辟空间来储存的，随着进入方法开辟，退出方法回收。以32位JVM为例，boolean/byte/short/char/int/float以及引用都是分配4字节空间，long/double分配8字节空间。对于每个方法来说，最多占用多少空间是一定的，这在编译时就可以计算好。</p><p>我们都知道JVM内存模型中有，stack和heap的存在，但是更准确的说，是每个线程都分配一个独享的stack，所有线程共享一个heap。对于每个方法的局部变量来说，是绝对无法被其他方法，甚至其他线程的同一方法所访问到的，更别说修改。</p><p>当我们在方法中声明一个 int i = 0，或者 Object obj = null 时，仅仅涉及stack，不影响到heap，当我们 new Object() 时，会在heap中开辟一段内存并初始化Object对象。当我们将这个对象赋予obj变量时，仅仅是stack中代表obj的那4个字节变更为这个对象的地址。</p><p>当我们声明一个数组时，如int[] arr = new int[10]，因为数组也是对象，arr实际上是引用，stack上仅仅占用4字节空间，new int[10]会在heap中开辟一个数组对象，然后arr指向它。</p><p>当我们声明一个二维数组时，如 <code>int[][] arr2 = new int[2]4]</code>，arr2同样仅在stack中占用4个字节，会在内存中开辟一个长度为2的，类型为int[]的数组，然后arr2指向这个数组。这个数组内部有两个引用（大小为4字节），分别指向两个长度为4的类型为int的数组。</p><p>所以当我们传递一个数组引用给一个方法时，数组的元素是可以被改变的，但是无法让数组引用指向新的数组。</p><p><strong>那Java是如何存储各种类型的数据呢？</strong></p><p>Java语言并不能操纵内存，一切都是由JVM来管理控制的，因此Java内存区域的划分也就是JVM的区域划分。详细底层可以参考：<a href="https://juejin.im/post/5bce68226fb9a05ce46a0476#heading-9" target="_blank" rel="noopener">Java的值传递和引用传递</a></p><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>匿名对象就是没有名字的对象（是对象的一种简化表示形式）</p><p>匿名对象调用完毕就是垃圾，可以被垃圾回收器回收。</p><p>匿名对象可以作为实际参数传递</p><p><strong>对象调用方法仅仅一次的时候：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带名字的调用</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">s.show();</span><br><span class="line">s.show();</span><br><span class="line">System.out.println(<span class="string">"-------"</span>);</span><br><span class="line"><span class="comment">//匿名对象调用方法</span></span><br><span class="line"><span class="keyword">new</span> Student().show();</span><br><span class="line"><span class="keyword">new</span> Student().show();<span class="comment">//不同的是，这里是创建了一个新的对象，并不是一个对象调用两次</span></span><br><span class="line"><span class="comment">//对于匿名对象，任何时候使用==比较，返回值是false</span></span><br><span class="line">System.out.println(<span class="string">"-------"</span>)</span><br></pre></td></tr></table></figure><p><strong>作为实际参数传递：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StudentDemo sd = <span class="keyword">new</span> StudentDemo();</span><br><span class="line">sd.method(<span class="keyword">new</span> Student());<span class="comment">//这里是method方法参数是一个学生类对象，这里使用匿名对象传入</span></span><br><span class="line"><span class="keyword">new</span> StudentDemo().method(<span class="keyword">new</span> Student());<span class="comment">//链式编程，等同于上面</span></span><br></pre></td></tr></table></figure><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>代表所在类的对象引用</p><p>方法被哪个对象调用，this就代表哪个对象</p><p>当局部变量隐藏成员变量，可以使用this</p><p>this可以看作是一个变量，它的值是当前对象的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;<span class="comment">//这个age是形参age，就近原则</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      这里的this是区分局部的形参age和成员变量this，</span></span><br><span class="line"><span class="comment">      这个this.age相当于Dog d = new Dog;d.age;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">growDog</span><span class="params">()</span></span>&#123;<span class="comment">//这个方法需要一个Dog对象的返回值</span></span><br><span class="line">        age++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//this相当于Dog类的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ageNow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"今年我"</span>+age+<span class="string">"岁了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog(<span class="number">3</span>);</span><br><span class="line">        d.growDog().ageNow();</span><br><span class="line">      <span class="comment">//这里可以说是一个链式编程，创建dog类对象调用growDog方法，返回dog类对象再调用ageNow方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序执行流程详解：</p><p><img src="/category/JavaSE-面向对象/dog.png" alt="内存图解"></p><p><img src="/category/JavaSE-面向对象/dog2.png" alt="内存图解2"></p><p>由上可以看出来，this一般出现在方法里，代表调用者，一开始this并不确定是谁，只有当谁调用了这个方法或者谁创建了这个对象，那么this就代表谁。</p><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final：最终的意思。常见的是它可以修饰类，方法，变量。</p><p>特点：</p><ul><li>final可以修饰类，该类不能被继承。</li><li>final可以修饰方法，该方法不能被重写。（覆盖，复写）</li><li>final可以修饰变量，该变量不能被重新赋值，因为这个变量其实是常量。</li></ul><p>当final修饰局部变量的问题：</p><p>基本类型：基本类型的值不能发生改变</p><p>引用类型：引用类型的地址值不能发生改变，但是该对象堆内存的值可以改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">  x = <span class="number">200</span>;</span><br><span class="line">  System.out.println(<span class="string">"x:"</span>+x);<span class="comment">//x:200</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> y = <span class="number">300</span>;</span><br><span class="line">  <span class="comment">//y = 400; 报错，无法为最终变量赋值</span></span><br><span class="line">  Student s = <span class="keyword">new</span> Student();<span class="comment">//Student类里有一个final int age = 10;</span></span><br><span class="line">  System.out.println(s.age);</span><br><span class="line">  <span class="comment">//s.age = 20;报错</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> Student ss = <span class="keyword">new</span> Student();<span class="comment">//final修饰引用类型，去掉Student上age的final</span></span><br><span class="line">  ss.age = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">//重新分配内存空间</span></span><br><span class="line">  <span class="comment">//ss = new Student(); 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final修饰变量的初始化时机：</p><p>被final修饰的变量只能赋值一次</p><p>在构造方法完毕前(非静态常量)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">finalDemo</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> num2;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//num2 = 20;报错</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">finalDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//num2 = 20;报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于继承中方法有一个现象：方法重写</p><p>所以父类的功能就会被子类给覆盖掉。</p><p>有时候我们不想让子类去覆盖掉父类的功能，只能让他使用。</p><p>这个时候，针对这种情况，Java就提供了一个关键字：final</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>针对多个对象有共同的相同的成员变量值的时候，Java就提供了一个关键字来修饰：static</p><p><strong>static的特点：</strong>（可以修饰成员变量、成员方法）</p><ul><li>随着类的加载而加载</li><li>优先于对象存在</li><li>被类的所有对象共享</li><li>可以通过类名调用（也可以通过对象名-一般不选择这种）</li></ul><p>静态修饰的内容一般我们称其为：与类相关的，类成员</p><p><strong>static关键字注意事项：</strong></p><ul><li><p>在静态方法中是没有this关键字的</p><ul><li>静态是随着类的加载而加载，this是随着对象的创建而存在。</li><li>静态比对象先存在</li></ul></li><li><p>静态方法只能访问静态的成员变量和静态的成员方法</p></li><li><ul><li><p>静态方法：</p></li><li><ul><li>成员变量：只能访问静态变量</li><li>成员方法：只能访问静态成员方法</li></ul></li><li><p>非静态方法：</p></li><li><ul><li>成员变量：可以是静态的，也可以是非静态的</li><li>成员方法：可以是静态的成员方法，也可以是非静态的成员方法</li></ul></li><li><p>静态只能访问静态</p></li></ul></li></ul><p><strong>静态变量和成员变量的区别：</strong></p><ul><li>所属不同<ul><li>静态变量属于类，所以也称为类变量</li><li>成员变量属于对象，所以也称为实例变量（对象变量）</li></ul></li><li>内存中位置不同<ul><li>静态变量存储于方法区的静态区</li><li>成与变量存储于堆内存</li></ul></li><li>内存出现时间不同<ul><li>静态变量随着类的加载而加载，随着类的消失而消失</li><li>成员变量随着对象的创建而存在，也可以通过对象调用</li></ul></li><li>调用不同<ul><li>静态变量可以通过类名调用，也可以通过对象调用</li><li>成员变量只能通过对象名调用</li></ul></li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>给对象的数据进行初始化</p><p>格式：</p><ul><li>方法名与类名相同</li><li>没有返回值类型，连void都没有</li><li>没有具体的返回值</li></ul><p>构造方法的注意事项：</p><p>如果我们没有给出构造方法，系统将自动提供一个无参构造方法</p><p>如果我们给出了构造方法，系统将不再提供默认的无参构造方法</p><p>如果我们还想使用无参构造方法，就必须自己给出。建议永远给出</p><p>给成员变量赋值有两种方式：</p><ul><li>setXxx()</li><li>构造方法</li></ul><h3 id="类的组成"><a href="#类的组成" class="headerlink" title="类的组成"></a>类的组成</h3><p>成员变量</p><p>构造方法</p><p>成员方法：</p><p>根据返回值：void与非void</p><p>根据形式参数列表：空参与非空参</p><p><strong>Student类初始化过程：</strong></p><p><img src="/category/JavaSE-面向对象/类初始化.png" alt="类初始化过程"></p><p>类初始化过程：</p><ol><li>加载class文件进内存</li><li>在栈内存开辟空间</li><li>在对内存为类对象开辟空间</li><li>对对象的成员变量进行默认初始化</li><li>对对象的成员变量进行显示初始化</li><li>通过构造方法对对象的成员变量赋值</li><li>对象初始化完毕，吧对象地址复制给变量</li></ol><p><strong>对象析构与finalize方法：</strong></p><p>在析构器中最常见的操作是回收分配给对象的存储空间，但Java不支持析构器，可以为任何一个类添加finalize方法，将在垃圾回收器清除对象之前调用。</p><p><strong>动态绑定：</strong></p><p>调用对象方法的执行过程：</p><p>编译器查看对象的声明类型和方法名</p><p>编译器查看调用方法时提供的参数类型</p><p>如果是private方法、static方法、final方法、或者构造器，那么编译器将准备的知道该调用哪个方法，这种调用方式为静态绑定。</p><p>调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。</p><p>当程序运行时，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。</p><p>虚拟机为了节省开销和时间，为每个类预先创建了一个方法表。</p><p><strong>什么时候定义成员变量：</strong></p><p>如果这个变量是用来描述这个类的信息的，那么该变量就应该定义为成员变量</p><p>变量的范围越小越好，因为能及时收回</p><p><strong>main方法格式</strong>：</p><p><img src="/category/JavaSE-面向对象/main.png" alt="main"></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>在Java中，使用{ }括起来的代码被称为代码块</p><p>根据其位置和声明不同，可以分为</p><p><strong>局部代码块：</strong></p><p>局部位置，用于限定变量的生命周期，及早释放，提高内存利用率</p><p><strong>构造代码块</strong></p><ul><li>在类中的成员位置，用{ }括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。</li></ul><p>作用：</p><p>可以把多个构造方法中的共同代码放到一起，对对象进行初始化。</p><p><strong>静态代码块：</strong></p><p>在类中的成员位置，用{ }括起来的代码，只不过它用static修饰了</p><p>对类的数据进行初始化，仅仅只执行一次</p><p>作用：</p><p>一般是对类进行初始化</p><p>面试题：</p><p>静态代码块，构造代码块，构造方法的执行顺序？</p><p>静态代码块 — 构造代码块 — 构造方法</p><p>静态代码块：只执行一次</p><p>构造代码块：每次调用构造方法都执行</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE面向对象
    
    </summary>
    
      <category term="JavaSE面向对象" scheme="https://www.ysmjjsy.com/categories/JavaSE%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>HelloJava</title>
    <link href="https://www.ysmjjsy.com/category/HelloJava/"/>
    <id>https://www.ysmjjsy.com/category/HelloJava/</id>
    <published>2017-08-06T01:23:12.000Z</published>
    <updated>2019-08-06T01:29:36.159Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 06 2019 09:30:03 GMT+0800 (GMT+08:00) --><h1 id="gt-HelloJava"><a href="#gt-HelloJava" class="headerlink" title="-&gt;HelloJava!"></a>-&gt;HelloJava!</h1><blockquote><p>Goya：<br>Java是一门伟大的艺术，至少在我看来是的了，也许如果没有Java出现会出现别的类似编程语言，但是因为它的存在，促进了互联网的&gt;发展。<br>当我第一次接触Java是在初中，那时候有的塞班系统的手机上会出现一个Java的一些小游戏或者小应用，回忆中的样子应该是如此。<br>到了大学，大二开始学习Java知道了这门著名的编程语言。<br>那时候老师也不会将很多学习Java先要了解的一些知识，只是告诉你James Gosling发明了Java，并且在Sun公司，之后Sun被Oracle收购等等一些常识。然后便开始了Java语言的学习，那时候只知道按部就班的安装那些必备软件，然后开始敲。</p></blockquote><p>学习Java我认为首先需要了解一下什么是Java？它用来干什么？它怎么实现的？它发展是什么？<br>我想在这个大时代背景下，程序员，编程，代码几乎人人皆知。而退十年来讲，都是陌生的。<br>随着时代的发展，让这些一部分人知道的事务变成众人皆知的事务，这就是互联网的进步以及大时代的笼罩下造成的氛围。你离开了这些就仿佛一个原始人，这么说也许太片面，但离了这些产品那真的会回退一个时代。<br>很多人都说互联网时代已经告去，大数据人工智能时代来临并飞速发展，那么怎么来，靠什么发展。我想这就是为什么电子信息专业的火爆以及许多人认为的“高薪资”。</p><hr><h1 id="那什么是Java"><a href="#那什么是Java" class="headerlink" title="那什么是Java"></a>那什么是Java</h1><ul><li><p>在1990年代之前，比较熟知的C、C++、SQL等著名语言被开发</p></li><li><p>在1990年代，推动编程语言发展的思想则是“提升程序员的生产力”，出现了很多快速应用程序开发，这些语言大都有相应的集成开发环境，也大多是面向对象的编程语言。像Java、Python、Ruby、Visual Basic、JavaScript、PHP等。而Java的出现则更加保守。</p></li></ul><p>所以Java的产生可以理解为一门可以提高程序员生产力的语言。<br>而那时候的Java叫Oak，是为了服务家用电器等小型系统的编程语言。<br>但那时候这种智能化电器则不像现在般火爆。于是Sun便开始改造。</p><blockquote><p>摘自维基百科：<br>Java编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在Java SE 1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装/拆箱特性。Sun对Java语言的解释是：“Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”<br>Java不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了Java程序的运行效率。但在J2SE1.4.2发布后，Java的运行速度有了大幅提升。<br>与传统类型不同，Sun公司在推出Java时就将其作为开放的技术。全球的Java开发公司被要求所设计的Java软件必须相互兼容。“Java语言靠群体的力量而非公司的力量”是Sun公司的口号之一，并获得了广大软件开发商的认同。这与微软公司所倡导的注重精英和封闭式的模式完全不同，此外，微软公司后来推出了与之竞争的.NET平台以及模仿Java的C#语言。后来Sun公司被甲骨文公司并购，Java也随之成为甲骨文公司的产品。</p></blockquote><p>总结下来就是Java是一个面向对象的拥有“简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”这些特点的语言。并且是一门开源语言（开放源代码全世界人学习或者修改加入自己的想法，但是Sun公司拥有Java的一部分权力）</p><p>那么首先我们可以分析一下，什么是编程语言：</p><blockquote><p>编程语言是用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。</p></blockquote><p><strong>所以Java就是一门我们可以根据Java的语法规则写出来的代码，它来编译成计算机识别的指令来操作计算机或者其他设备的语言。</strong></p><h2 id="那么Java如何识别我们写的代码再编译成计算机识别的指令呢？"><a href="#那么Java如何识别我们写的代码再编译成计算机识别的指令呢？" class="headerlink" title="那么Java如何识别我们写的代码再编译成计算机识别的指令呢？"></a>那么Java如何识别我们写的代码再编译成计算机识别的指令呢？</h2><p>举一个例子：我们写一个<strong>HelloWorld.java</strong><br><em>这个时候可以不用纠结这些看不懂</em><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"HelloWorld!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后通过控制台执行javac<br><img src="/category/HelloJava/javac.png" alt="javac"></p><p>可以看到在HelloWorld.java同级目录生成一个.class文件<br><img src="/category/HelloJava/javaclass.png" alt="classlocation"></p><p>接着执行java命令<br><img src="/category/HelloJava/java.png" alt="java"></p><p>可以看到我们写的代码被计算机所解释编译执行，输出HelloWorld</p><h3 id="那么这个javac是什么呢？"><a href="#那么这个javac是什么呢？" class="headerlink" title="那么这个javac是什么呢？"></a>那么这个javac是什么呢？</h3><ul><li>当安装好jdk后可以在jdk安装目录bin文件夹下看到这个脚本。</li><li>它是用来编译java程序的源代码，但是它本质是基于jdk标准类库中的javac类库实现，所以java的编译器实质是一个java程序</li><li>javac又被称为前端编译器，仅负责源代码与字节码之间的转换，而在jvm内部还存在一个后置编译器（根据热点探测技术，可以将最有价值的字节码转换为机器码执行从而提升java程序的运行效率）</li><li>javac 的意义就在于 将源码编译为字节码，同时做一些词法，语法，语义上的检查，最后生成可供jvm运行的字节码文件。</li><li>可以在lib中的tools jar包中sun.tools.javac;包下管理者java前端编译器的class文件，Main类中的main方法执行的是javac程序的执行入口。</li><li>同时在bin目录下可以看到很多脚本文件，比如java、javaw等</li></ul><h3 id="那这个-class文件又是什么呢？"><a href="#那这个-class文件又是什么呢？" class="headerlink" title="那这个.class文件又是什么呢？"></a>那这个.class文件又是什么呢？</h3><p>.class文件又称<strong>字节码文件</strong>，它就是java帮我们进行的第一道翻译工作后的结果，这道翻译工作就是javac，可以理解为将源码编译为字节码，同时做一些词法，语法，语义上的检查，最后生成的.class文件供jvm运行。这一过程就叫<strong>编译</strong>，更准确的是称为<strong>前端编译</strong>。.class文件也就是<strong>前端编译</strong>产生的代码。</p><h3 id="前端编译："><a href="#前端编译：" class="headerlink" title="前端编译："></a>前端编译：</h3><p><img src="/category/HelloJava/before.png" alt="Alt text"><br><strong>词法分析</strong>：词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，将字符序列转换为标记（token）序列的过程。这里的标记是一个字符串，是构成源代码的最小单位。在这个过程中，词法分析器还会对标记进行分类 。<br>词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。<br><strong>语法分析</strong>：语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述。<br><strong>将源代码中的字符流构造成抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方法。填充符号表： 符号表是一组符号地址和符号信息构成的表格。</strong><br><strong>注解处理器处理</strong>：我们平时使用的Java注解，本质就是用来对语法树做出修改，处理器的任务便是在编译是识别出这些注解同时修改抽象语法树。<br><strong>语义分析与字节码生成</strong>：<br>语义分析是编译过程的一个逻辑阶段， 语义分析的任务是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。<br>语义分析的一个重要部分就是类型检查。比如很多语言要求数组下标必须为整数，如果使用浮点数作为下标，编译器就必须报错。再比如，很多语言允许某些类型转换，称为自动类型转换。</p><ul><li>标注检查：语义分析的第一个步骤，用来检查包括诸如使用的变量是否已经声明、变量与赋值之间的数据类型是否能够匹配。其中有一个重要的步骤就是常量折叠<br>如：int a = 3 + 2， javap查看生成的class字节码，iconst指令向操作数栈中压入的是常量值5，这样在运行时期就不会CPU的运算量重新计算。</li><li>数据及控制流分析<br>用于检查诸如局部变量在使用前是否已经赋值，方法的每条路径上是否都有返回值，受查异常是否都被正常处理等问题。</li><li>解语法糖（desugar）<br>Java中我们经常使用的语法糖有泛型、自动装箱/拆箱、遍历循环、条件编译等.. 由于这些语法在运行时无法被识别，因此需要在编译阶段就将他们还原回简单的基础语法结构。</li><li>泛型<br>泛型的本质是参数化类型的应用，参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。<br>在Java中，泛型只在源码中存在，一旦经常编译，就会替换成原来的原生类型并且在相应的地方加上了强制类型转换代码。这一过程也叫做类型擦除</li><li>自动装箱/拆箱<br>基本类型自动装箱成包装类型，包装类型拆箱成基本类型，大多数Java程序员都已经了解。只是使用上有些地方需要注意，比方包装类型在使用“==”进行比较时，只有遇到算术运算时才会自动拆箱。</li><li>遍历循环<br>诸如 for(int i : list) {} 这样的loop循环在编译后都会转换成对数据结构iterator的调用</li><li>条件编译<br>对于if和常量搭配使用，在编译器发现不会执行到的语句块，将不会出现在编译之后的class文件当中</li><li>生成字节码class文件<br>在Compiler生成class文件时，不仅仅将前面步骤生成的信息转化成字节码，还会进行少量的代码添加和转换工作，如<init>和<clinit>就是在该阶段添加进class文件当中，如果Compiler发现代码中没有任何构造器，那么将会添加一个无参数的、访问性与当前类一致的构造器（也即经常所说的默认无参构造器）</clinit></init></li></ul><h3 id="后端编译"><a href="#后端编译" class="headerlink" title="后端编译"></a>后端编译</h3><p>在Java中，javac执行的结果就是得到一个字节码，而这个字节码其实就是一种中间代码。</p><p>然后得到的class文件并不能被机器所识别。这个时候就通过JVM来解释字节码，将其翻译成对应的机器指令，逐条读入，逐条解释执行，这是传统的JVM解释器的功能，为了解决这种效率问题，引入了JIT技术。（即使编译器）<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html" target="_blank" rel="noopener">深入浅出JIT编译</a></p><p>当JVM通过类加载器加载class文件里的字节码后，会通过解释器解释称汇编指令最终再转译成CPU可以识别的机器指令，解释器是软件来实现的，主要是为了实现同一份 Java 字节码可以在不同的硬件平台上运行，而将汇编指令转换成机器指令由硬件直接实现。<br><img src="/category/HelloJava/later.png" alt="later"><br>从软件层面上， class 文件被加载进虚拟机后，类信息会存放在方法区，在实际运行的时候会执行方法区中的代码，在 JVM 中所有的线程共享堆内存和方法区，而每个线程有自己独立的 Java 方法栈，本地方法栈（面向 native 方法），PC寄存器（存放线程执行位置），当调用一个方法的时候， Java 虚拟机会在当前线程对应的方法栈中压入一个栈帧，用来存放 Java 字节码操作数以及局部变量，这个方法执行完会弹出栈帧，一个线程会连续执行多个方法，对应不同的栈帧的压入和弹出，压入栈帧后就是 JVM 解释执行的过程了。</p><p>JAVA程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p><p>HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。</p><p>当 JVM 执行代码时，它并不立即开始编译代码。首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。</p><p>在机器上，执行java -version命令就可以看到自己安装的JDK中JIT是哪种模式:<br><img src="/category/HelloJava/javaversion.png" alt="-version"></p><h4 id="热点检测"><a href="#热点检测" class="headerlink" title="热点检测"></a>热点检测</h4><p>上面我们说过，要想触发JIT，首先需要识别出热点代码。目前主要的热点代码识别方式是热点探测（Hot Spot Detection），有以下两种：</p><ol><li>基于采样的方式探测（Sample Based Hot Spot Detection) ：周期性检测各个线程的栈顶，发现某个方法经常出险在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因干扰热点探测。</li><li>基于计数器的热点探测（Counter Based Hot Spot Detection)。采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。<br>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。<br>方法计数器。顾名思义，就是记录一个方法被调用次数的计数器。<br>回边计数器。是记录方法中的for或者while的运行次数的计数器。</li></ol><h4 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h4><p>前面提到过，JIT除了具有缓存的功能外，还会对代码做各种优化。说到这里，不得不佩服HotSpot的开发者，他们在JIT中对于代码优化真的算是面面俱到了。</p><p><strong>经过前端编译与后端编译，最终我们的java文件被机器所执行。</strong></p><h2 id="JDK、JRE与JVM："><a href="#JDK、JRE与JVM：" class="headerlink" title="JDK、JRE与JVM："></a>JDK、JRE与JVM：</h2><p><img src="/category/HelloJava/jdk.png" alt="JDK"></p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>Java Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。<br>最主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了属于自己的JDK。<br>JDK有以下三种版本：<br>J2SE， standard edition，标准版，是我们通常用的一个版本<br>J2EE， enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序<br>J2ME，micro edtion，主要用于移动设备、嵌入式设备上的java应用程序</p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>Java Runtime Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>我们刚生成的.class文件就是通过jvm来编译执行<br>Java Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的组成包括 JVM 指令集，符号表以及一些补助信息。</p><h2 id="至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。"><a href="#至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。" class="headerlink" title="至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。"></a>至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Java入门
    
    </summary>
    
      <category term="Java入门" scheme="https://www.ysmjjsy.com/categories/Java%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
