<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余生梦见皆是缘</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ysmjjsy.com/"/>
  <updated>2019-08-30T08:19:19.669Z</updated>
  <id>https://www.ysmjjsy.com/</id>
  
  <author>
    <name>Goya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSE-API</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-API/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-API/</id>
    <published>2017-08-25T08:15:23.000Z</published>
    <updated>2019-08-30T08:19:19.669Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:20:24 GMT+0800 (GMT+08:00) --><h1 id="JavaSE-常用API"><a href="#JavaSE-常用API" class="headerlink" title="JavaSE-常用API"></a>JavaSE-常用API</h1><h2 id="GregorianCalendar类"><a href="#GregorianCalendar类" class="headerlink" title="GregorianCalendar类"></a>GregorianCalendar类</h2><p>Date类用来表示时间点，并且官方目前推荐用GregorianCalendar类</p><p>GregorianCalendar类用来表示更为通用的日历表示法</p><p>GregorianCalendar类扩展一个更通用的Calendar类，这个类描述了日历的一般属性</p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>new GregorianCalendar():构造一个新对象，用于表示对象构造时的日期和时间。</p><p>new GregorianCalendar(1999，11，31):用给定日期和时间构造一个Gregorian日历对象</p><p>要想查询某个时间点的年月日等信息，应该使用GregorianCalendar类的get方法，为了表达希望得到的项，需要借助于Calendar类中定义的一些常量，比如Calendar.Month或Calendar.DAY_OF_WEEK;</p><p>还有设置年月日的set方法。</p><p>get方法和set、add方法在概念上有区别，get方法仅仅查看并返回对象的状态，而set和add方法却对对象的状态进行修改。对实例域做出修改的方法称为更改器方法，仅访问实例域而不进行修改的方法称为访问其方法。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>void add(int field, int amount):对给定的时间域增加指定数量的时间</p><p>int getFirstDayOfWeek():获得当前用户所在地区，一个星期中的第一天。</p><p>void setTime(Date time):将日历设置为指定的时间点.</p><p>Date getTime():获得这个日历对象当前值所表达的时间点</p><p>String[]getShortWeekdays()</p><p>String[]getShortMonths ()</p><p>String[]getWeekdays()</p><p>String[]getMonths ()</p><p>获得当前地区的星期几或几月份的名称，利用Calendar的星期和月份常量作为数组索引值.</p><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>它为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span> <span class="params">(<span class="keyword">int</span> field)</span>:<span class="comment">//返回给定日历字段的值，日历类中的每个日历字段都是静态的成员变量，并且时int类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> field,<span class="keyword">int</span> amount)</span>:<span class="comment">//根据给定的日历字段和对应的时间，来对当前的日历进行操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date)</span>:<span class="comment">//设置当前日历的年月日</span></span></span><br></pre></td></tr></table></figure><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>可以使用Object类型的变量引用任何类型的对象，Object类型的变量只能用于作为各种值得通用持有者。要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的类型转换。</p><p>在Java中，只有基本类型不是对象。所有的数组类型都属于Object类。</p><p>构造方法：public Object()</p><h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a>hashCode()方法</h3><p>散列码(hash code)是由对象导出的一个整数值,散列码是没有规律的。hashCode方法定义在Object类中，每个对象都有一个默认的散列码,其值为对象的存储地址.</p><p>int hash(Object…objects):返回一个散列码，由提供的所有对象的散列码组合而得到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">    System.out.println(p.hashCode());<span class="comment">//11299397</span></span><br><span class="line">    Phone p2 = <span class="keyword">new</span> Phone();</span><br><span class="line">    System.out.println(p2.hashCode());<span class="comment">//24446859</span></span><br><span class="line">    Phone p3 = p1;</span><br><span class="line">    System.out.println(p3.hashCode());<span class="comment">//11299397</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass()方法"></a>getClass()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final  Class &lt;？&gt; getClass（）</span><br></pre></td></tr></table></figure><p>返回此运行时类Object返回的 Class对象是由static synchronized所表示的类的方法锁定的对象。</p><p><strong>实际结果的类型是Class&lt;? extends |X|&gt; 其中|X|是静态类型上其表达的擦除getClass被调用。</strong>例如，此代码片段中不需要强制转换：</p><p><code>Number n = 0;</code><br><code>Class&lt;? extends Number&gt; c = n.getClass();</code></p><p>返回：</p><p>在<code>Class</code>表示运行时类此对象的对象。在<code>Class</code>表示运行时类此对象的对象。</p><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><p>返回对象的字符串表示，默认是由类的全路径+’@’+哈希值的十六进制表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public  String  toString()</span><br></pre></td></tr></table></figure><p>返回对象的字符串表示形式。通常，该 toString方法返回一个“文本表示”此对象的字符串。结果应该是一个简洁但信息丰富的表示，便于人们阅读。建议所有子类都重写此方法。</p><p>toString类 的方法Object返回一个字符串，该字符串由对象为实例的类的名称，符号字符“ @`”和对象的哈希码的无符号十六进制表示组成。换句话说，此方法返回一个等于值的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName()+<span class="string">'@'</span>+ Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure><ul><li><p>返回：</p><p>对象的字符串表示形式。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer类下的一个静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toHexString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//把一个整数转成一个十六进制表示的字符串</span></span><br></pre></td></tr></table></figure><p>一般toString()方法返回的值是没有意义的，所以我们需要对其重写，一般在子类重写该方法</p><p>建议把该类的所有成员变量值组成返回即可，也可以根据自己需求</p><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals（Object  obj）</span><br></pre></td></tr></table></figure><p>指示某个其他对象是否“等于”此对象。</p><p>该equals方法在非null对象引用上实现等价关系：</p><ul><li>它是<em>自反的</em>：对于任何非空引用值 x，x.equals(x)应该返回 true。</li><li>它是<em>对称的</em>：对于任何非空引用值 x和y，x.equals(y)应该返回true当且仅当 y.equals(x)回报true。</li><li>它是<em>传递</em>性：对于任何非空的参考值 x，y以及z，如果 x.equals(y)回报率true和 y.equals(z)回报率true，那么 x.equals(z)应该返回true。</li><li>它是<em>一致的</em>：对于任何非空引用值 x以及一致返回 或一致返回的y多次调用 ，前提是不修改在对象比较中使用的信息。 x.equals(y) true false equals</li><li>对于任何非空引用值x， x.equals(null)应返回false。</li></ul><p>equals类 的方法Object实现了对象上最具辨别力的等价关系; 即，对于任何非空的参考值x和 y，该方法返回true当且仅当x和y指代相同的对象（x == y具有值true）。</p><p>请注意，通常需要在重写此hashCode方法时覆盖该方法，以便维护该hashCode方法的常规协定，该协定声明相等的对象必须具有相等的哈希代码。</p><h4 id="equals方法的常用格式："><a href="#equals方法的常用格式：" class="headerlink" title="equals方法的常用格式："></a>equals方法的常用格式：</h4><ol><li><p>显示参数命名为otherObject，稍后需要将他转换成另一个叫做other的变量。</p></li><li><p>检测this与otherObject是否引用同一个对象:</p><p><code>if(otherObject== null) return false;</code></p></li><li><p>比较this与otherObject是否属于同一个类，如果equals的语义在每个子类中有所改变，就是用getClass检测:</p><p><code>if(getClass()!=otherObject.getClass())return false;</code></p><p>如果所有子类都拥有统一的语义，就使用instanceof检测:</p><p><code>if(!otherObjectinstanceof ClassName)) return false;</code></p></li><li><p>将otherObject转换为相应的类型变量:</p><p><code>ClassNameother = (ClassName)otherObject</code></p></li><li><p>使用==比较基本类型域，使用equals比较对象域，如果都匹配，返回true，否则返回false</p><p><code>returnfield1 == other.field1&amp;&amp;Object.equals(field2,other.field2)&amp;&amp;.. .;</code></p></li><li><p>如果在子类中重新定义equals，就要在其中包含调用super.equals(other)</p></li></ol><p><strong>equals方法指示其他某个对象是否与此对象”相等”.这个方法默认情况下比较的是地址值，比较地址值一般来说意义不大，所以需要重写该方法，一般用来比较对象的成员变量值是否相同</strong></p><blockquote><p>==：</p><p>基本类型：比较的就是值是否相同</p><p>引用类型：比较的就是地址值是否相同</p></blockquote><p>demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">  <span class="comment">//return true</span></span><br><span class="line">  <span class="comment">//这里改进phone的equals方法，根据这里比较的成员变量决定返回true或false</span></span><br><span class="line">  <span class="comment">//因为name是String类型，所以不能用==比较，应该用equals</span></span><br><span class="line">  <span class="comment">//String类的equals方法是重写Object类的，比较的是字符串内容是否相同</span></span><br><span class="line">  <span class="comment">//我们比较的是手机类的成员变量，所以要向下转型</span></span><br><span class="line">  Phone p = (Phone)obj;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="keyword">this</span>.size == p.size)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><p>确定不存在对该对象的更多引用时，由于对象的垃圾回收器调用此方法。用于垃圾回收，但是什么时候回收不知道</p><p>当垃圾回收器</p><p>protected void finalize（）throw Throwable</p><blockquote><p>当垃圾收集确定没有对该对象的更多引用时，由对象上的垃圾收集器调用。子类重写finalize处置系统资源或执行其他清理的方法。</p><p>一般合同finalize是，如果Java TM虚拟机确定不再有任何方法可以通过任何尚未死亡的线程访问此对象，则会调用它，除非采取了一些操作通过最终确定一些其他准备完成的对象或类。该finalize方法可以采取任何动作，包括使该对象再次可用于其他线程; finalize然而，通常的目的是在对象被不可撤销地丢弃之前执行清理操作。例如，表示输入/输出连接的对象的finalize方法可能会执行显式I / O事务，以在永久丢弃对象之前断开连接。</p><p>finalize类 的方法不Object执行特殊操作; 它只是正常返回。子类 Object可以覆盖此定义。</p><p>Java编程语言不保证哪个线程将为finalize任何给定对象调用该方法。但是，可以保证，调用finalize时，调用finalize的线程不会持有任何用户可见的同步锁。如果finalize方法抛出未捕获的异常，则忽略该异常并终止该对象的终止。</p><p>在finalize为一个对象调用该方法之后，在Java虚拟机再次确定不再有任何方法可以通过任何尚未死亡的线程访问该对象之前不再采取任何操作，包括可能的操作准备好最终确定的其他对象或类，此时可以丢弃该对象。</p><p>finalize对于任何给定对象，Java虚拟机永远不会多次调用该方法。</p><p>该finalize方法抛出的任何异常都会导致暂停此对象的终结，但会被忽略。</p><p>抛出：</p><p>Throwable- Exception通过这种方法提出的</p></blockquote><h3 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone()方法"></a>clone()方法</h3><p>protected Object clone（）throw CloneNotSupportedException</p><p>Cloneable:此类实现了Cloneable接口，以指示Object.clone()方法可以合法的对该类实例进行按字段赋值，这个接口是个标记接口，告诉我们实现该接口就可以实现对象的复制了</p><p>创建并返回此对象的副本。“复制”的确切含义可能取决于对象的类别。一般意图是，对于任何对象x，表达式：<br>x.clone（）！= x<br>将是真的，那表达式：<br>x.clone（）。getClass（）== x.getClass（）<br>会true，但这些不是绝对的要求。通常情况是：<br>x.clone（）。等于（x）的<br>将是true，这不是一个绝对的要求。<br>按照惯例，返回的对象应该通过调用获得 super.clone。如果一个类及其所有超类（除了 Object）遵守这个约定，那将是这种情况 x.clone().getClass() == x.getClass()。</p><p>按照惯例，此方法返回的对象应独立于此对象（正在克隆）。要实现此独立性，可能需要在返回super.clone之前修改返回的对象的一个​​或多个字段。通常，这意味着复制包含被克隆对象的内部“深层结构”的任何可变对象，并使用对副本的引用替换对这些对象的引用。如果一个类只包含原始字段或对不可变对象的引用，那么通常情况下super.clone 不需要修改返回的对象中的任何字段。</p><p>clone类 的方法Object执行特定的克隆操作。首先，如果此对象的类未实现接口Cloneable，则 CloneNotSupportedException抛出a。请注意，所有数组都被认为是实现接口，Cloneable并且clone数组类型方法的返回类型T[] 是T[]T是任何引用或基本类型。否则，此方法创建此对象的类的新实例，并使用该对象的相应字段的内容初始化其所有字段，就像通过赋值一样; 这些字段的内容本身不会被克隆。因此，该方法执行该对象的“浅拷贝”，而不是“深拷贝”操作。</p><p>该类Object本身并不实现接口 Cloneable，因此clone在类的对象上调用该方法Object将导致在运行时抛出异常。</p><p>返回：<br>这个实例的克隆。<br>抛出：<br>CloneNotSupportedException- 如果对象的类不支持该Cloneable接口。覆盖该clone方法的子类也可以抛出此异常以指示无法克隆实例。</p><p>要想实现对象克隆，那么对象所在的类需要实现一个Cloneable接口</p><h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><p>System类下有一个静态的字段</p><p><code>public static final InputStream in;</code>标准的输入流，对应着键盘输入</p><p><code>InputStream is = System.in</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class Demo&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> y = Demo.x;</span><br><span class="line">Phone p = Demo.p;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">Scanner(InputStream source);</span><br><span class="line"><span class="comment">//基本用法</span></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> x = sc.nexInt();</span><br></pre></td></tr></table></figure><h4 id="Scanner类的成员方法"><a href="#Scanner类的成员方法" class="headerlink" title="Scanner类的成员方法"></a>Scanner类的成员方法</h4><p>基本格式:</p><p>hasNextXxx()：判断是否还有下一个输入项，其中Xxx可以是Int，Double等，如果需要判断是否包含下一个字符串则可以省略Xxx</p><p>nextXxx()：获取下一个输入想，Xxx和上面的方法中Xxx相同</p><p>默认情况下，Scanner使用空格，回车等作为分隔符</p><p>常用方法</p><p>public int nextInt()</p><p>public String nextLine()</p><h2 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h2><p>字符串是由多个字符组成的一串数据，也可以看成是一个字符数组。</p><ul><li>字符串字面值“abc“也可以看成是一个字符串对象</li><li>字符串是常量，一旦被赋值，就不能被改变<ul><li>字符串的内容不能改变，而不是引用不能改变</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String  a = <span class="string">"123"</span>;</span><br><span class="line"></span><br><span class="line">String b = <span class="string">"123"</span>;</span><br><span class="line"></span><br><span class="line">a  == b ;<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为引用的是同一个123</span></span><br></pre></td></tr></table></figure><h4 id="堆内存里有个字符串常量池-gt-本质是一个数组"><a href="#堆内存里有个字符串常量池-gt-本质是一个数组" class="headerlink" title="堆内存里有个字符串常量池-&gt;本质是一个数组"></a>堆内存里有个字符串常量池-&gt;本质是一个数组</h4><p><code>String s = &quot;123&quot;;</code><br>池中没有新的数据则添加数据，如果有，则指向<br>在采用直接赋值过程中，对于字符串而言可以实现池数据的自动保存，这样如果再有相同数据定义时，减少想通过对象产生，提升操作性能</p><p><code>String s = new String(&quot;123&quot;);</code><br>开辟两块堆内存空间，而只会使用一块，而另外一个由于字符串常量所定义的匿名对象会成为垃圾空间<br>实际上是属于一种自己专用的内存空间，但是在String类里面也提供有帮助开发者实现手工入池</p><h4 id="两种方法的区别"><a href="#两种方法的区别" class="headerlink" title="两种方法的区别:"></a>两种方法的区别:</h4><p>1-&gt;只会产生一个实例化对象，并且可以自动保存到对象池中，以实现该字符串实例的重用</p><p>2-&gt;会产生两个实例化对象，并且不会自动入池，无法对对象重用，但是可以利用intern()方法手工入池</p><h4 id="String对象-常量-池"><a href="#String对象-常量-池" class="headerlink" title="String对象(常量)池"></a>String对象(常量)池</h4><p>对象池的主要目的是实现数据的共享处理，以Spring对象池为例，里面的内容主要就是为了重用，重用就是为了共享设计，但是在在Java之中对象（常量）池实际上可分为两种</p><p><strong>静态常量池：</strong></p><p>指的是程序(.*class)在加载时候会自动将此程序之中保存的字符串、普通的常量、类和方法的信息等等，全部进行分配;</p><p><strong>运行时常量池：</strong></p><p>指的是程序(.*class)加载之后，里面可能有一些变量，这个时候提供的常量池。</p><h4 id="空串和Null串"><a href="#空串和Null串" class="headerlink" title="空串和Null串:"></a>空串和Null串:</h4><p>空串有自己的串长度和内容，String变量可以存放一个特殊的值，名为null，有时候要检查一个字符串既不是null也不为空串，需要使用</p><p>if(str !=null &amp;&amp;str.length()!= 0)</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span>:<span class="comment">//空构造</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span>:<span class="comment">//把字节数组转成在字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes,<span class="keyword">int</span> index,<span class="keyword">int</span> length)</span>:<span class="comment">//把字节数组的一部分转成字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value)</span>:<span class="comment">//把字符数组转成字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value,<span class="keyword">int</span> index,<span class="keyword">int</span> count)</span>:<span class="comment">//把字符数组的一部分转成字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span>:<span class="comment">//把字符串常量值转成字符串</span></span></span><br></pre></td></tr></table></figure><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看程序写结果</span></span><br><span class="line"><span class="comment">//字符串如果是变量相加，先开空间，再拼接</span></span><br><span class="line"><span class="comment">//字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则就创建</span></span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = <span class="string">"helloworld"</span>;</span><br><span class="line">System.out.println(s3 == s1+s2);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3.equals(s1+s2));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//通过反编译可知，这里已经做了处理</span></span><br><span class="line">System.out.println(s3 ==<span class="string">"hello"</span>+<span class="string">"world"</span>);<span class="comment">//true--&gt;s3=="helloworld"</span></span><br><span class="line">System.out.println(s3.equals(<span class="string">"hello"</span>+<span class="string">"world"</span>));<span class="comment">//true--&gt;s3.equals("helloworld")</span></span><br></pre></td></tr></table></figure><h4 id="String类的判断功能"><a href="#String类的判断功能" class="headerlink" title="String类的判断功能"></a>String类的判断功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>:<span class="comment">//比较字符串的内容是否相同，区分大小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String str)</span>:<span class="comment">//比较字符串的内容是否相同，忽略大小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span>:<span class="comment">//判断大字符串中是否包含小字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startWith</span><span class="params">(String str)</span>:<span class="comment">//判断字符串是否以某个指定的字符串开头</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String str)</span>:<span class="comment">//判断字符串是否以某个指定的字符串结尾</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>:<span class="comment">//判断字符串是否为空</span></span></span><br><span class="line"><span class="function"><span class="comment">//注意：字符串内容为空和字符串对象为空</span></span></span><br><span class="line"><span class="function">String s </span>= <span class="string">""</span>;</span><br><span class="line">String s = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h4 id="String类的获取功能"><a href="#String类的获取功能" class="headerlink" title="String类的获取功能"></a>String类的获取功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>:<span class="comment">//获取字符串的长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>:<span class="comment">//获取指定索引位置的字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span>:<span class="comment">//返回指定字符在此字符串中第一次出现处的索引</span></span></span><br><span class="line"><span class="function"><span class="comment">//在这里是int类型而不是char类型，是因为'a'和97都可以代表'a'</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Stirng str)</span>:<span class="comment">//返回指定字符出中第一次出现处的索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch,<span class="keyword">int</span> fromIndex)</span>:<span class="comment">//返回指定字符串在此字符串中从指定位置后第一次出现处的索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str,<span class="keyword">int</span> fromIndex)</span>:<span class="comment">//返回指定字符串在此字符串中从中指定位置后第一次出现处的索引</span></span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span>:<span class="comment">//从指定位置开始截取字符串，默认到末尾</span></span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>:<span class="comment">//从指定位置开始到指定位置结束截取字符串</span></span></span><br></pre></td></tr></table></figure><h4 id="字符串的遍历"><a href="#字符串的遍历" class="headerlink" title="字符串的遍历"></a>字符串的遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;s.length();x++)&#123;</span><br><span class="line">  System.out.println(s.charAt(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="统计大小写个数案例"><a href="#统计大小写个数案例" class="headerlink" title="统计大小写个数案例"></a>统计大小写个数案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个字符串</span></span><br><span class="line">String s = <span class="string">"Hello123World"</span>;</span><br><span class="line"><span class="comment">//定义三个统计变量</span></span><br><span class="line"><span class="keyword">int</span> bigCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> smallCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> numberCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历字符串，得到每一个字符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;s.length();x++)&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = s.charAt(x);</span><br><span class="line">  <span class="comment">//判断该字符到底属于那种类型</span></span><br><span class="line">  <span class="keyword">if</span>(ch&gt;=<span class="string">'a'</span> &amp;&amp; ch&lt;=<span class="string">'z'</span>)&#123;</span><br><span class="line">    smallCount++;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">'A'</span> &amp;&amp; ch&lt;=<span class="string">'Z'</span>)&#123;</span><br><span class="line">    bigCount++;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">'0'</span> &amp;&amp; ch&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    numberCount++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">System.out.println(<span class="string">"大写字母"</span>+bigCount+<span class="string">"个"</span>);</span><br><span class="line">System.out.println(<span class="string">"小写字母"</span>+smallCount+<span class="string">"个"</span>);</span><br><span class="line">System.out.println(<span class="string">"数字"</span>+numberCount+<span class="string">"个"</span>);</span><br></pre></td></tr></table></figure><h4 id="String类的转换功能"><a href="#String类的转换功能" class="headerlink" title="String类的转换功能"></a>String类的转换功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getBytes():<span class="comment">//把字符串转换为字节数组</span></span><br><span class="line"><span class="keyword">char</span>[] toCharArray():<span class="comment">//把字符串转换为字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span>[] chs)</span>:<span class="comment">//把字符数组转成字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span>:<span class="comment">//把int类型的数组转成字符串,注意：String类的valueOf()方法可以把任意类型的数据转成字符串</span></span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span>:<span class="comment">//把字符串转成小写</span></span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span>:<span class="comment">//把字符串转成大写</span></span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span>:<span class="comment">//把字符串拼接</span></span></span><br></pre></td></tr></table></figure><h5 id="字符串首字母大写，其他转小写"><a href="#字符串首字母大写，其他转小写" class="headerlink" title="字符串首字母大写，其他转小写"></a>字符串首字母大写，其他转小写</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = s.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase().concat(s.substring(<span class="number">1</span>).toLowerCase());</span><br></pre></td></tr></table></figure><h4 id="String类的其他功能"><a href="#String类的其他功能" class="headerlink" title="String类的其他功能"></a>String类的其他功能</h4><h5 id="String类的替换功能"><a href="#String类的替换功能" class="headerlink" title="String类的替换功能"></a>String类的替换功能</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> old,<span class="keyword">char</span> new)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(String old,String new)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="去除字符串两空格"><a href="#去除字符串两空格" class="headerlink" title="去除字符串两空格"></a>去除字符串两空格</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h5 id="按字典顺序比较两个字符串"><a href="#按字典顺序比较两个字符串" class="headerlink" title="按字典顺序比较两个字符串"></a>按字典顺序比较两个字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span></span>;</span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br><span class="line">String s3 = <span class="string">"abc"</span>;</span><br><span class="line">String s4 = <span class="string">"xyz"</span>;</span><br><span class="line">System.out.println(s1.compareTo(s2));<span class="comment">//0</span></span><br><span class="line">System.out.println(s1.compareTo(s3));<span class="comment">//7</span></span><br><span class="line">System.out.println(s1.compareTo(s4));<span class="comment">//-16至于这里为什么是-16，可以想想</span></span><br></pre></td></tr></table></figure><h5 id="int数组拼接成字符串案例"><a href="#int数组拼接成字符串案例" class="headerlink" title="int数组拼接成字符串案例"></a>int数组拼接成字符串案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个明确：返回值类型：String 参数列表：int[] arr</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">arrayToString</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义一个字符串</span></span><br><span class="line">  String s = <span class="string">""</span>;</span><br><span class="line">  <span class="comment">//先把字符串拼接一个"["</span></span><br><span class="line">  s += <span class="string">"["</span>;</span><br><span class="line">  <span class="comment">//遍历int数组，得到每一个元素</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length;x++)&#123;</span><br><span class="line">    <span class="comment">//先判断该元素是否是最后一个</span></span><br><span class="line">    <span class="keyword">if</span>(x==arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">//是就直接拼接元素和"]"</span></span><br><span class="line">      s +=arr[x];</span><br><span class="line">      s += <span class="string">"]"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//拼接元素和逗号以及空格</span></span><br><span class="line">      s += arr[x];</span><br><span class="line">      s += <span class="string">", "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字符反转"><a href="#字符反转" class="headerlink" title="字符反转"></a>字符反转</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个明确，返回值类型：String 参数列表：String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverse</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义一个新字符串</span></span><br><span class="line">  String result = <span class="string">""</span>;</span><br><span class="line">  <span class="comment">//把字符串转成字符数组</span></span><br><span class="line">  <span class="keyword">char</span>[] chs = line.toCharArray();</span><br><span class="line">  <span class="comment">//倒着遍历字符串，得到每一个字符</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x = chs.length-<span class="number">1</span>;x&gt;=<span class="number">0</span>;x--)&#123;</span><br><span class="line">    <span class="comment">//用新字符串把每一个字符拼接起来</span></span><br><span class="line">    result += chs[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在大串中查找小串出现的次数案例"><a href="#在大串中查找小串出现的次数案例" class="headerlink" title="在大串中查找小串出现的次数案例"></a>在大串中查找小串出现的次数案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义大串</span></span><br><span class="line">  String maxString=<span class="string">"woaijavazhenaijavawoaizhavazhenaijava"</span>;</span><br><span class="line">  <span class="comment">//定义小串</span></span><br><span class="line">  String minString=<span class="string">"java"</span>;</span><br><span class="line">  <span class="comment">//功能实现</span></span><br><span class="line">  <span class="keyword">int</span> count = getCount(maxString,minString);</span><br><span class="line">  System.out.println(<span class="string">"java在大串中出现了"</span>+count+<span class="string">"次"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">(String maxString,String minString)</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义一个统计变量，初始值是0</span></span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> index;</span><br><span class="line">  <span class="comment">//先查，赋值，判断</span></span><br><span class="line">  <span class="keyword">while</span>((index = maxString.indexOf(minStirng))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    count++;</span><br><span class="line">    maxString = maxString.subString(index+minString.length());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h5><p>字符串 -&gt; %s<br>字 符 -&gt; %c<br>整 数 -&gt; %d<br>小 数 -&gt; %f</p><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p>线程安全的可变字符串</p><p>StringBuffer和String的区别</p><p>StringBuffer长度和内容可变，String不可变</p><p>如果使用StringBuffer做字符串的拼接，不会浪费太多的资源</p><h3 id="StringBuffer类的构造方法"><a href="#StringBuffer类的构造方法" class="headerlink" title="StringBuffer类的构造方法"></a>StringBuffer类的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span>:<span class="comment">//无参构造方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span>:<span class="comment">//指定容量的字符串缓冲区对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span>:<span class="comment">//指定字符串内容的字符串缓冲区对象</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//StringBuffer的方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span>:<span class="comment">//返回当前容量，理论值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>:<span class="comment">//返回长度(字符数)，实际值</span></span></span><br></pre></td></tr></table></figure><h3 id="StringBuffer的添加功能"><a href="#StringBuffer的添加功能" class="headerlink" title="StringBuffer的添加功能"></a>StringBuffer的添加功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span>:<span class="comment">//可以把任意类型数据添加到字符串缓冲区里面，并返回字符串缓冲区本身</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset,String str)</span>:<span class="comment">//在指定位置把任意类型的数据插入到字符串缓冲区里面，并返回字符串缓冲区本身</span></span></span><br></pre></td></tr></table></figure><h3 id="StringBuffer的删除功能"><a href="#StringBuffer的删除功能" class="headerlink" title="StringBuffer的删除功能"></a>StringBuffer的删除功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span>:<span class="comment">//删除指定位置的字符，并返回本身</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>:<span class="comment">//删除从指定位置开始指定位置结束的内容，并返回本身</span></span></span><br></pre></td></tr></table></figure><h3 id="StringBuffer的替换功能"><a href="#StringBuffer的替换功能" class="headerlink" title="StringBuffer的替换功能"></a>StringBuffer的替换功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,String str)</span>:<span class="comment">//从start开始到end用str替换</span></span></span><br></pre></td></tr></table></figure><h3 id="StringBuffer的反转功能"><a href="#StringBuffer的反转功能" class="headerlink" title="StringBuffer的反转功能"></a>StringBuffer的反转功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">reverse</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="StringBuffer的截取功能"><a href="#StringBuffer的截取功能" class="headerlink" title="StringBuffer的截取功能"></a>StringBuffer的截取功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这里返回值类型是String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="String和StringBuffer的相互转换"><a href="#String和StringBuffer的相互转换" class="headerlink" title="String和StringBuffer的相互转换"></a>String和StringBuffer的相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String --&gt; StringBuffer</span></span><br><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">//方法1，通过构造方法</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(s);</span><br><span class="line"><span class="comment">//方法2，通过append方法</span></span><br><span class="line">String Buffer sb2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb2.append(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuffer --&gt; String</span></span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">"java"</span>);</span><br><span class="line"><span class="comment">//方法1，通过构造方法</span></span><br><span class="line">String str = <span class="keyword">new</span> String(buffer);</span><br><span class="line"><span class="comment">//方法2，通过toString()方法</span></span><br><span class="line">String str2 = buffer.toString();</span><br></pre></td></tr></table></figure><h3 id="用StringBuffer做数组拼接指定格式字符串"><a href="#用StringBuffer做数组拼接指定格式字符串" class="headerlink" title="用StringBuffer做数组拼接指定格式字符串"></a>用StringBuffer做数组拼接指定格式字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">arrToString2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">  sb.append(<span class="string">"["</span>)；</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;arr.length;x++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(x == arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">        sb.apend(arr[x]);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sb.append(arr[x]).append(<span class="string">", "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  sb.append(<span class="string">"]"</span>);</span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串反转功能"><a href="#字符串反转功能" class="headerlink" title="字符串反转功能"></a>字符串反转功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverse2</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断一个字符串是否对称"><a href="#判断一个字符串是否对称" class="headerlink" title="判断一个字符串是否对称"></a>判断一个字符串是否对称</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//把字符串转成字符数组</span></span><br><span class="line">  <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>,end = chs.length-<span class="number">1</span>;start&lt;=end;start++,end--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(chas[start]!=chs[end])&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-StringBuffer-StringBuilder的区别"><a href="#String-StringBuffer-StringBuilder的区别" class="headerlink" title="String,StringBuffer,StringBuilder的区别"></a>String,StringBuffer,StringBuilder的区别</h3><p>String是内容不可变的，StringBuffer，StringBuilder是内容可变的</p><p>StringBuffer是同步的，数据安全，效率低，StringBuilder是不同步的，数据不安全，效率高</p><p>String作为参数传递，效果和基本类型作为参数传递是一样的，形式参数的改变不影响实际参数</p><p><strong>StringBuffer和数组的区别？</strong></p><p>二者都可以看出是一个容器，装其他的数据</p><p>但是，StringBuffer的数据最终是一个字符串数据</p><p>而数组可以放置多种数据，但必须是同一种数据类型</p><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>Arrays：针对数组进行操作的工具类，比如说排序和查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span>:<span class="comment">//把数组转成字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span>:<span class="comment">//对数组进行排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> key)</span>:<span class="comment">//二分查找</span></span></span><br></pre></td></tr></table></figure><h2 id="基本包装类"><a href="#基本包装类" class="headerlink" title="基本包装类"></a>基本包装类</h2><p>所有的基本类型都有一个与之对应的类，这些类称为包装器:Integer、Long、Double、Short、Byte、Character、Void、Boolean。前六个类派生于公共的超类Number。对象包装器类是不可变的，一旦构造了包装器，就不允许更改包装在其中的值，同时，包装器类还是final，因此不能定义它们的子类。</p><p>自动装箱: list.add(3);</p><p>list.add(Integer.valueOf(3));</p><p>自动拆箱: int n = list.gei(i);</p><p>Int n = list.gei(i).intValue();</p><p>参数数量可变的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span>… values)</span></span>&#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了对基本数据类型进行更多的操作，更方便的操作，Java就针对每一种基本数据类型提供了对应的类类型，包装类类型</p><p>byte —&gt;Byte</p><p>short —&gt; Short</p><p>int —&gt; Integer</p><p>long —&gt; Long</p><p>float —&gt; Float</p><p>double —&gt; Double</p><p>char —&gt; Character</p><p>boolean —&gt; Boolean</p><h3 id="Integer的构造方法"><a href="#Integer的构造方法" class="headerlink" title="Integer的构造方法"></a>Integer的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span> <span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"><span class="comment">//这里这个字符出啊必须是由数字字符组成</span></span></span><br></pre></td></tr></table></figure><h3 id="String和int类型的相互转换"><a href="#String和int类型的相互转换" class="headerlink" title="String和int类型的相互转换"></a>String和int类型的相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> --&gt; String</span><br><span class="line">String.valueOf(number)</span><br><span class="line">String --&gt; <span class="keyword">int</span></span><br><span class="line">Integer.parseInt(s)</span><br></pre></td></tr></table></figure><h3 id="Integer中进制转换的操作"><a href="#Integer中进制转换的操作" class="headerlink" title="Integer中进制转换的操作"></a>Integer中进制转换的操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用的基本进制转换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toBinaryString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toOctalString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toHexString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//十进制到其他进制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> radix)</span></span>;</span><br><span class="line"><span class="comment">//其他进制到十进制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s,<span class="keyword">int</span> radix)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="JDK5自动装箱和拆箱"><a href="#JDK5自动装箱和拆箱" class="headerlink" title="JDK5自动装箱和拆箱"></a>JDK5自动装箱和拆箱</h3><p>自动装箱：把基本类型转换为包装类类型</p><p>自动拆箱：把包装类类型转换为基本类型</p><p><strong>注意：</strong></p><p>在使用Integer x = null;代码机会出现NullPointerException，建议先判断是否为null，然后再使用</p><p>Integer的数据直接赋值，如果在-128到127之间，会直接从缓冲池里获取数据</p><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>Character类在对象中包装一个基本类型char的值</p><p>该类提供了几种方法，以确定字符的类型（小写字母，数字，等等），并将字符从大写转换成小写，反之亦然</p><p>构造方法：<code>Character(char value)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUpperCase</span><span class="params">(<span class="keyword">char</span> ch)</span>:<span class="comment">//判断给定的字符是否是大写字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLowerCase</span><span class="params">(<span class="keyword">char</span> ch)</span>:<span class="comment">//判断给定的字符是否是小写字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> ch)</span>:<span class="comment">//判断给定的字符是否是数字字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">toUpperCase</span><span class="params">(<span class="keyword">char</span> ch)</span>:<span class="comment">//把给定的字符转换为大写字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">toLowerCase</span><span class="params">(<span class="keyword">char</span> ch)</span>:<span class="comment">//把给定的字符转换为小写字符</span></span></span><br></pre></td></tr></table></figure><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>用于数学运算的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> E</span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span>:<span class="comment">//绝对值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> a)</span>:<span class="comment">//向上取整</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> a)</span>:<span class="comment">//向下取整</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>:<span class="comment">//最大值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span>:<span class="comment">//a的b次幂</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">()</span>:<span class="comment">//随机数[0.0,1.0)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">round</span><span class="params">(<span class="keyword">float</span> a)</span>:<span class="comment">//四舍五入</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> a)</span>:<span class="comment">//正平方根</span></span></span><br></pre></td></tr></table></figure><h3 id="获取任意范围内的随机数"><a href="#获取任意范围内的随机数" class="headerlink" title="获取任意范围内的随机数"></a>获取任意范围内的随机数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入开始数:"</span>);</span><br><span class="line">    <span class="keyword">int</span> start = sc.nextInt();</span><br><span class="line">    System.out.println(<span class="string">"请输入结束数:"</span>);</span><br><span class="line">    <span class="keyword">int</span> end = sc.nextInt();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;<span class="number">100</span>;x++)&#123;</span><br><span class="line">      <span class="comment">//调用功能</span></span><br><span class="line">      <span class="keyword">int</span> num = getRandom(start,end);</span><br><span class="line">      <span class="comment">//输出结果</span></span><br><span class="line">      System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回值类型：int 参数列表int start，int end</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = (<span class="keyword">int</span>)(Math.random()*end)+start;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><p>产生随机数的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span>:<span class="comment">//没有给种子，用的是默认种子，是当前时间的毫秒值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">(<span class="keyword">long</span> seed)</span>:<span class="comment">//给出指定的种子</span></span></span><br><span class="line"><span class="function"><span class="comment">//给定种子后，每次得到的随机数是相同的</span></span></span><br><span class="line"><span class="function"><span class="comment">//成员方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span>:<span class="comment">//返回的是int范围内的随机数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> n)</span>:<span class="comment">//返回的是[0,n)范围内的随机数</span></span></span><br></pre></td></tr></table></figure><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p>System类包含一些有用的类字段和方法，它不能被实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span>:<span class="comment">//运行垃圾回收器，等同于调用了Runtime里的gc()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span>:<span class="comment">//终止当前正在运行的Java虚拟机，参数用作状态码；根据惯例，非0的状态码表示异常终止</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span>:<span class="comment">//返回以毫秒为单位的当前时间</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">arraycopy</span><span class="params">(Object src,<span class="keyword">int</span> srcPos,Object dest,<span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span>:<span class="comment">//从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束</span></span></span><br></pre></td></tr></table></figure><h2 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h2><p>可以让超过Integer范围内的数据进行运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">BigInteger(String val);</span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">add</span><span class="params">(BigInteger val)</span>:<span class="comment">//加</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">subtract</span><span class="params">(BigInteger val)</span>:<span class="comment">//减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">multiply</span><span class="params">(BigInteger val)</span>:<span class="comment">//乘</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">divide</span><span class="params">(BigInteger val)</span>:<span class="comment">//除</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger[] <span class="title">divideAndRemainder</span><span class="params">(BigInteger val)</span>:<span class="comment">//返回商和余数的数组</span></span></span><br></pre></td></tr></table></figure><h2 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h2><p>不可变的、任意精度的有符号十进制数，可以解决数据丢失问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BigDecimal</span><span class="params">(String val)</span></span>;</span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">add</span><span class="params">(BigDecimal val)</span>:<span class="comment">//加</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">subtract</span><span class="params">(BigDecimal augend)</span>:<span class="comment">//减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">multiply</span><span class="params">(BigDecimal subtrahend)</span>:<span class="comment">//乘</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">divide</span><span class="params">(BigDecimal multipicand)</span>:<span class="comment">//除</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal[] <span class="title">divide</span><span class="params">(BigDecimal divisor,<span class="keyword">int</span> scale,<span class="keyword">int</span> roundingMode)</span>:<span class="comment">//返回商和余数的数组</span></span></span><br></pre></td></tr></table></figure><h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><p>表示特定的瞬间，精确到毫秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">Date():<span class="comment">//根据当前的默认毫秒值创建日期对象</span></span><br><span class="line">Date(<span class="keyword">long</span> date):<span class="comment">//根据给定的毫秒值创建日期对象</span></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span>:<span class="comment">//获取时间，以毫秒为单位</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">long</span> time)</span>:<span class="comment">//设置时间</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//从Date得到一个毫秒值</span></span></span><br><span class="line"><span class="function">  <span class="comment">//getTime()</span></span></span><br><span class="line"><span class="function"><span class="comment">//把一个毫秒值转换为Date</span></span></span><br><span class="line"><span class="function">  <span class="comment">//构造方法</span></span></span><br><span class="line"><span class="function">  <span class="comment">//setTime(long time)</span></span></span><br></pre></td></tr></table></figure><h3 id="DateFormat类实现日期和字符串的相互转换"><a href="#DateFormat类实现日期和字符串的相互转换" class="headerlink" title="DateFormat类实现日期和字符串的相互转换"></a>DateFormat类实现日期和字符串的相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Date --&gt; String(格式化)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">format</span><span class="params">(Date date)</span></span>;</span><br><span class="line"><span class="comment">//String --&gt;Date(解析)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String source)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DateFormat:可以进行日期和字符串的格式化和解析，但是由于是抽象类，所以使用具体子类SimpleDateFormat</span></span><br><span class="line"><span class="comment">//SimpleDateFormat的构造方法</span></span><br><span class="line">SimpleDateFormat():<span class="comment">//默认模式</span></span><br><span class="line">SimpleDateFormat(String pattern):<span class="comment">//给定的模式</span></span><br><span class="line"><span class="comment">//这个模式的字符串(年-y，月-M，日-d，时-H，分-m，秒-s)</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date date = new Date();</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);</span><br><span class="line">String str = sdf.format(date);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p><code>parse()</code>:解析字符串</p><h2 id="UUID类"><a href="#UUID类" class="headerlink" title="UUID类"></a>UUID类</h2><p>是一种生成无重复字符串的一种程序类，这种程序类的主要功能是根据时间戳实现一个自动的无重复的字符串定义</p><p><code>UUID.randomUUID();</code></p><h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><p>进行null的相关处理，在以前进行程序开发的时候，如果为了防止程序中出现空指向的异常，可以以追加有null的验证。</p><p>在引用接受的一方往往都是被动的进行判断，在Java中提供Optional这个类，可以实现null的处理操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt;empty(); <span class="comment">//返回空数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;<span class="comment">//获取数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span></span>; <span class="comment">//保存数据，但是不允许出现null.如果在保存数据时候存在null，则会抛出NullPointerException异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span></span>; <span class="comment">//保存数据，允许为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span></span>; <span class="comment">//空的时候返回其它数据</span></span><br></pre></td></tr></table></figure><h2 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h2><p>解决线程同步问题<br>在ThreadLocal类里面存放两个对象，一个线程对象，一个数据对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作数据对象：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span></span>;<span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span>;<span class="comment">//设置数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;<span class="comment">//取出数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;<span class="comment">//删除数据</span></span><br></pre></td></tr></table></figure><p>每一个线程通过ThreadLocal只允许保存一个数据</p><h2 id="Base64加密与解密"><a href="#Base64加密与解密" class="headerlink" title="Base64加密与解密"></a>Base64加密与解密</h2><p>Base64类里面有两个内部类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Base64.Encoder:进行加密处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] encode(<span class="keyword">byte</span>[] src);</span><br><span class="line"><span class="comment">//Base64.Decoder:进行解密处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] decode(String src);</span><br></pre></td></tr></table></figure><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><p>比较器</p><p><code>public int ComparTo();</code></p><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p>挽救型比较器</p><h2 id="CharSequence接口"><a href="#CharSequence接口" class="headerlink" title="CharSequence接口"></a>CharSequence接口</h2><p>三个常用子类<br>String StringBuffer StringBuilder</p><p>描述的是一个字符串</p><h2 id="AutoCloseable接口"><a href="#AutoCloseable接口" class="headerlink" title="AutoCloseable接口"></a>AutoCloseable接口</h2><p>日资源开发的处理，以实现资源的自动关闭（释放资源)<br>jdk1.7后，该接口只有一个方法:</p><p><code>public void close() throws Exception</code></p><p>除了实现这个接口，还得实现异常处理，要跟异常捆绑在一起</p><h2 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h2><p>描述运行时状态，是唯一一个与JVM运行状态有关的类，并且都会默认提供有一个该类的实例化对象<br>构造方法私有，单类设计模式，<br><code>getRuntime()</code> 获取实例化对象<br><code>availableProcessors()</code> 方法可以获取本机的CPU内核数<br><code>maxMermory()</code> 获取最大内存空间，默认配置本机系统内存的四分之一<br><code>totalMemory()</code> 获取可用内存空间，默认配置本机系统内存六十四分之一<br><code>freeMemory()</code> 获取空闲内存空间<br><code>gc()</code> 手工进行GC处理</p><p>垃圾收集器，是可以由系统自动调用垃圾释放功能，也可以自己手工调用</p><h2 id="Cleanner类"><a href="#Cleanner类" class="headerlink" title="Cleanner类"></a>Cleanner类</h2><p>进行finialize()方法替代<br>在新一代的清除回收处理的过程之中，更多情况下考虑的是多线程的使用，即，为了防止有可能造成的延迟处理，许多对象回收前的处理都是单独通过一个线程完成的</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE常用API
    
    </summary>
    
      <category term="JavaSE常用API" scheme="https://www.ysmjjsy.com/categories/JavaSE%E5%B8%B8%E7%94%A8API/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-Map容器</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E9%9B%86%E5%90%882/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-集合2/</id>
    <published>2017-08-23T10:35:42.000Z</published>
    <updated>2019-09-09T09:33:30.073Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 09 2019 17:35:24 GMT+0800 (GMT+08:00) --><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>Map，图，是一种存储键值对映射的容器类，在Map中键可以是任意类型的对象，但不能有重复的键，每个键都对应一个值，真正存储在图中的是键值构成的条目。</p><p><strong>Map和Collection集合的区别：</strong></p><p>Map容器存储元素是成对出现的，Map集合的键是唯一的，值是可重复的</p><p>Collection集合存储元素是单独出现的，Set是唯一的，List是可重复的</p><p>Map容器的数据结构值针对键有效，跟值无关</p><p>Collection集合的数据结构是针对元素有效</p><p>下面是接口Map的类结构。</p><p><img src="/category/JavaSE-集合2/map.png" alt="map"></p><p><img src="/category/JavaSE-集合2/map1.png" alt="map"></p><p>从上面这张图中我们可以看到接口Map提供了很多查询、更新和获取存储的键值对的方法，更新包括方法clear()、put()、putAll()、remove()等等，查询方法包括containsKey、containsValue等等。Map接口常用的有三个具体实现类，分别是HashMap、LinkedHashMap、TreeMap。</p><h2 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h2><ul><li><p>键找值</p></li><li><ul><li>获取所有的键的集合</li><li>遍历键的集合，得到每一个键</li><li>根据键到集合中去找值</li></ul></li><li><p>键值对对象找键和值</p></li><li><ul><li>获取所有键值对对象的集合</li><li>遍历键值对对象的集合，获取每一个键值对对象</li><li>根据键值对对象去获取键和值。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"><span class="comment">//创建元素并添加集合</span></span><br><span class="line">map.put(<span class="string">"a"</span>,<span class="string">"A"</span>);</span><br><span class="line">map.put(<span class="string">"b"</span>,<span class="string">"B"</span>);</span><br><span class="line">map.put(<span class="string">"c"</span>,<span class="string">"C"</span>);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">Set&lt;String&gt; set = map.keySet();</span><br><span class="line"><span class="comment">//遍历键的集合，获取得到每一个键</span></span><br><span class="line"><span class="keyword">for</span>(String key:set)&#123;</span><br><span class="line">  <span class="comment">//根据键去找值</span></span><br><span class="line">  String value = map.get(key);</span><br><span class="line">  System.out.println(key+<span class="string">"---"</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set&lt;map.Entry&lt;K,V&gt;&gt; entrySet():返回的是键值对对象的集合</span></span><br><span class="line"><span class="comment">//创建集合对象</span></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">"a"</span>,<span class="string">"A"</span>);</span><br><span class="line">map.put(<span class="string">"b"</span>,<span class="string">"B"</span>);</span><br><span class="line">map.put(<span class="string">"c"</span>,<span class="string">"C"</span>);</span><br><span class="line"><span class="comment">//获取所有键值对对象的集合</span></span><br><span class="line">Set&lt;Map.Entry&lt;String,String&gt;&gt; set = map.entrySet();</span><br><span class="line"><span class="comment">//遍历键值对对象的集合，得到每一个键值对对象</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Stirng,String&gt; me :set)&#123;</span><br><span class="line">  <span class="comment">//根据键值对对象获取键和值</span></span><br><span class="line">  String key = me.getKey();</span><br><span class="line">  String value = me.getValue();</span><br><span class="line">  System.out.println(key+<span class="string">"---"</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap是基于哈希表的Map接口的非同步实现，继承自AbstractMap，AbstractMap是部分实现Map接口的抽象类。在平时的开发中，HashMap的使用还是比较多的。</p><p><em>HashSet</em>和<em>HashMap</em>,二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong>HashSet里面有一个HashMap（适配器模式）</strong>。</p><p><em>HashMap</em>实现了<em>Map</em>接口，允许放入null元素，除该类未实现同步外，其余跟Hashtable大致相同，跟<em>TreeMap</em>不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个<em>HashMap</em>的顺序可能会不同。<br>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。<strong>Java HashMap采用的是冲突链表方式</strong>。</p><p><img src="/category/JavaSE-集合2/hm1.jpg" alt="HashMap"></p><p>从上图容易看出，如果选择合适的哈希函数，put()和get()方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</p><p>有两个参数可以影响<em>HashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>在之前的版本中，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当链表中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>哈希表内部使用Entry[]数组存放数据(Entry是封装键值对的对象)</p><p>数组默认的初始容量是16(可以通过构造方法参数指定)</p><p>数组容量会翻倍增长—StringBuilder翻倍+2</p><p>将对向放入到<em>HashMap</em>或<em>HashSet</em>中时，有两个方法需要特别关心：hashCode()和equals()。<strong>hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要@Override hashCode()和equals()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造函数 ( Hash值键值下一个节点 )</span></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-集合2/hm2.png" alt="HashMap"></p><p>Key.hashCode() 获得键的哈希值</p><p>使用哈希值和数组长度，来计算下标</p><p>把键值对封装成Entry实例</p><p>把Entry实例放入i 位置</p><p>空位置，直接放入</p><p>有数据，依次使用equals()进行比较是否相等</p><p>如果有相等的，覆盖值</p><p>如果没有相等的，链表连接在一起，放在链表头部，后进先出（碰撞）</p><p>负载率，加载因子到0.75(数据数量/容量)</p><p>新建翻倍容量的新数组</p><p>所有数据重新执行哈希运算，放入新数组</p><p>问题：</p><p>如果碰撞过多会造成效率低，所以尽可能要去避免。所以hashcode方法和equals重写的时候尽量严谨一些，并且尽量保持一致（对象一样，生成的hashcode值一样）</p><p>Jdk1.8之后</p><p>链表长度到8，会转成红黑树（平衡的二叉树）</p><p>树上的数据减少到6，会转回成链表</p><p>hashCode()</p><p>Object()方法</p><p>默认实现，使用内存地址作为哈希值，可以重写hashCode()方法，使用属性数据来计算产生哈希值</p><p>HashSet底层如何优化：</p><p>尽可能让对象的哈希值不通过</p><p>方法：</p><p>基本类型可以加值</p><p>引用类型就加哈希值</p><p>//哈希值尽量的分散</p><p>int p = 31; //固定</p><p>int r =1; //可以改变</p><p>r= r * p + x;</p><p>r= r * p + y;</p><p>returnr;</p><h3 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h3><ul><li><strong>get()</strong></li></ul><p>get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.getValue()。因此getEntry()是算法的核心。<br>算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过key.equals(k)方法来判断是否是要找的那个entry。</p><p><img src="/category/JavaSE-集合2/hm3.png" alt="HashMap"></p><p>上图中hash(k)&amp;(table.length-1)等价于hash(k)%table.length，原因是<em>HashMap</em>要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getEntry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-<span class="number">1</span>)];<span class="comment">//得到冲突链表</span></span><br><span class="line">         e != <span class="keyword">null</span>; e = e.next) &#123;<span class="comment">//依次遍历冲突链表中的每个entry</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//依据equals()方法判断是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>put()</strong></li></ul><p>put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry，插入方式为<strong>头插法</strong>。</p><p><img src="/category/JavaSE-集合2/hm4.png" alt="HashMap"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//自动扩容，并重新哈希</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">//hash%table.length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在冲突链表头部插入新的entry</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>remove()</strong></li></ul><p>remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry（修改链表的相应指针）。查找过程跟getEntry()过程类似。</p><p><img src="/category/JavaSE-集合2/hm5.png" alt="HashMap"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//removeEntryForKey()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//hash&amp;(table.length-1)</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">//得到冲突链表</span></span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">//遍历冲突链表</span></span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">//找到要删除的entry</span></span><br><span class="line">            modCount++; size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;<span class="comment">//删除的是冲突链表的第一个entry</span></span><br><span class="line">            <span class="keyword">else</span> prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e; e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>前面已经说过<em>HashSet</em>是对<em>HashMap</em>的简单包装，对<em>HashSet</em>的函数调用都会转换成合适的<em>HashMap</em>方法，因此<em>HashSet</em>的实现非常简单，只有不到300行代码。这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet是对HashMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="comment">//HashSet里面有一个HashMap</span></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用hash(int h)方法所计算得到的hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中，<strong>(n - 1) &amp; hash</strong>用于计算对象应该保存在table数组的哪个索引处。HashMap底层数组的长度总是2的n次方，当数组长度为2的n次幂的时候，<strong>(n - 1) &amp; hash</strong> 算得的index相同的几率较小，数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p></blockquote><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap继承自HashMap，它主要是用链表实现来扩展HashMap类，HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们插入图的顺序排序，也可以按它们最后一次被访问的顺序排序。</p><p><em>LinkedHashSet</em>和<em>LinkedHashMap</em>在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong>LinkedHashSet里面有一个LinkedHashMap（适配器模式）</strong>。</p><p><em>LinkedHashMap</em>实现了<em>Map</em>接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是<em>linked list</em>和<em>HashMap</em>的混合体，也就是说它同时满足<em>HashMap</em>和<em>linked list</em>的某些特性。<strong>可将LinkedHashMap看作采用linked list增强的HashMap。</strong></p><p><img src="/category/JavaSE-集合2/ls1.png" alt="LinkedHashMap"></p><p>事实上<em>LinkedHashMap</em>是<em>HashMap</em>的直接子类，<strong>二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表（doubly-linked list）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同</strong>。上图给出了<em>LinkedHashMap</em>的结构图，主体部分跟<em>HashMap</em>完全一样，多了header指向双向链表的头部（是一个哑元），<strong>该双向链表的迭代顺序就是entry的插入顺序</strong>。</p><p>除了可以保迭代历顺序，这种结构还有一个好处：<strong>迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可</strong>，也就是说<em>LinkedHashMap</em>的迭代时间就只跟entry的个数相关，而跟table的大小无关。</p><p>有两个参数可以影响<em>LinkedHashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到<em>LinkedHashMap</em>或<em>LinkedHashSet</em>中时，有两个方法需要特别关心：hashCode()和equals()。<strong>hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要@Override hashCode()和equals()方法。</p><p>通过如下方式可以得到一个跟源<em>Map<strong>迭代顺序</strong>一样的LinkedHashMap</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Map m)</span> </span>&#123;</span><br><span class="line">    Map copy = <span class="keyword">new</span> LinkedHashMap(m);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出于性能原因，<em>LinkedHashMap</em>是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>LinkedHashMap</em>包装成（wrapped）同步的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> LinkedHashMap(...));</span><br></pre></td></tr></table></figure><ul><li><strong>get()</strong></li></ul><p>get(Object key)方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样</p><ul><li><strong>put()</strong></li></ul><p>put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于get()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry。</p><p>注意，这里的<strong>插入有两重含义</strong>：</p><ol><li>从table的角度看，新的entry需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的entry插入到冲突链表的头部。</li><li>从header的角度看，新的entry需要插入到双向链表的尾部。</li></ol><p><img src="/category/JavaSE-集合2/ls2.png" alt="LinkedHashMap"></p><p>addEntry()代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.addEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">// 自动扩容，并重新哈希</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">// hash%table.length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.在冲突链表头部插入新的entry</span></span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</span><br><span class="line">    table[bucketIndex] = e;</span><br><span class="line">    <span class="comment">// 2.在双向链表的尾部插入新的entry</span></span><br><span class="line">    e.addBefore(header);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中用到了addBefore()方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。addBefore()的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</span><br><span class="line">    after  = existingEntry;</span><br><span class="line">    before = existingEntry.before;</span><br><span class="line">    before.after = <span class="keyword">this</span>;</span><br><span class="line">    after.before = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码只是简单修改相关entry的引用而已。</p><ul><li><strong>remove()</strong></li></ul><p>remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry（修改链表的相应引用）。查找过程跟get()方法类似。</p><p>注意，这里的<strong>删除也有两重含义</strong>：</p><blockquote><ol><li>从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li><li>从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li></ol></blockquote><p><img src="/category/JavaSE-集合2/ls3.png" alt="LinkedHashMap"></p><p>removeEntryForKey()对应的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.removeEntryForKey()，删除key值对应的entry</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">// hash&amp;(table.length-1)</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">// 得到冲突链表</span></span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">// 遍历冲突链表</span></span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">// 找到要删除的entry</span></span><br><span class="line">            modCount++; size--;</span><br><span class="line">            <span class="comment">// 1. 将e从对应bucket的冲突链表中删除</span></span><br><span class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;</span><br><span class="line">            <span class="keyword">else</span> prev.next = next;</span><br><span class="line">            <span class="comment">// 2. 将e从双向链表中删除</span></span><br><span class="line">            e.before.after = e.after;</span><br><span class="line">            e.after.before = e.before;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e; e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>前面已经说过<em>LinkedHashSet</em>是对<em>LinkedHashMap</em>的简单包装，对<em>LinkedHashSet</em>的函数调用都会转换成合适的<em>LinkedHashMap</em>方法，因此<em>LinkedHashSet</em>的实现非常简单，这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// LinkedHashSet里面有一个LinkedHashMap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的。</p><p>在实际使用中，如果更新图时不需要保持图中元素的顺序，就使用HashMap，如果需要保持图中元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap。</p><h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p><em>WeakHashMap</em>，从名字可以看出它是某种 <em>Map</em>。它的特殊之处在于 <em>WeakHashMap</em> 里的entry可能会被GC自动删除，即使程序员没有调用remove()或者clear()方法。</p><p>更直观的说，当使用 <em>WeakHashMap</em> 时，即使没有显示的添加或删除任何元素，也可能发生如下情况：</p><blockquote><ul><li>调用两次size()方法返回不同的值；</li><li>两次调用isEmpty()方法，第一次返回false，第二次返回true；</li><li>两次调用containsKey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；</li><li>两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。</li></ul></blockquote><p>遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉？其实不然，<em>WeekHashMap</em> 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。</p><p>要明白 <em>WeekHashMap</em> 的工作原理，还需要引入一个概念：弱引用（WeakReference）。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象（基本意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的“有效引用”并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。</p><p><em>WeakHashMap</em> 内部是通过弱引用来管理entry的，弱引用的特性对应到 <em>WeakHashMap</em> 上意味着什么呢？将一对key, value放入到 <em>WeakHashMap</em> 里并不能避免该key值被GC回收，除非在 <em>WeakHashMap</em> 之外还有对该key的强引用。</p><p>关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。</p><p><strong>具体实现</strong></p><p>WeakHashMap的存储结构类似于HashMap</p><p><strong>Weak HashSet?</strong></p><p>既然有 <em>WeekHashMap</em>，是否有 <em>WeekHashSet</em> 呢？答案是没有:( 。不过Java <em>Collections</em>工具类给出了解决方案，Collections.newSetFromMap(Map<e ,boolean>map)方法可以将任何 <em>Map</em>包装成一个<em>Set</em>。通过如下方式可以快速得到一个 <em>Weak HashSet</em>：</e></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将WeakHashMap包装成一个Set</span></span><br><span class="line">Set&lt;Object&gt; weakHashSet = Collections.newSetFromMap(</span><br><span class="line">        <span class="keyword">new</span> WeakHashMap&lt;Object, Boolean&gt;());</span><br></pre></td></tr></table></figure><p>不出你所料，newSetFromMap()方法只是对传入的 <em>Map</em>做了简单包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collections.newSetFromMap()用于将任何Map包装成一个Set</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">newSetFromMap</span><span class="params">(Map&lt;E, Boolean&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SetFromMap&lt;&gt;(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SetFromMap</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;E, Boolean&gt; m;  <span class="comment">// The backing map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;E&gt; s;       <span class="comment">// Its keySet</span></span><br><span class="line">    SetFromMap(Map&lt;E, Boolean&gt; map) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Map is non-empty"</span>);</span><br><span class="line">        m = map;</span><br><span class="line">        s = map.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123;        m.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> m.size(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> m.isEmpty(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> m.containsKey(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span>   </span>&#123; <span class="keyword">return</span> m.remove(o) != <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; <span class="keyword">return</span> m.put(e, Boolean.TRUE) == <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> s.iterator(); &#125;</span><br><span class="line">    <span class="keyword">public</span> Object[] toArray()         &#123; <span class="keyword">return</span> s.toArray(); &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)     &#123; <span class="keyword">return</span> s.toArray(a); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> s.toString(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>             </span>&#123; <span class="keyword">return</span> s.hashCode(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span>   </span>&#123; <span class="keyword">return</span> o == <span class="keyword">this</span> || s.equals(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;<span class="keyword">return</span> s.containsAll(c);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>   </span>&#123;<span class="keyword">return</span> s.removeAll(c);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>   </span>&#123;<span class="keyword">return</span> s.retainAll(c);&#125;</span><br><span class="line">    <span class="comment">// addAll is the only inherited implementation</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>Hashtable和前面介绍的HashMap很类似，它也是一个散列表，存储的内容是键值对映射，不同之处在于，Hashtable是继承自Dictionary的，Hashtable中的函数都是同步的，这意味着它也是线程安全的，另外，Hashtable中key和value都不可以为null。</p><p>上面的三个集合类都是在Java2之前推出的容器类，可以看到，尽管在使用中效率比较低，但是它们都是线程安全的。下面介绍两个特殊的集合类。</p><h2 id="Map总结"><a href="#Map总结" class="headerlink" title="Map总结"></a>Map总结</h2><ul><li><p>Map</p></li><li><ul><li>Map集合的数据结构仅仅针对键有效，与值无关。</li><li>存储的键值对形式的元素，键唯一，值可重复。</li></ul></li></ul><ul><li><p>HashMap</p></li><li><ul><li><p>底层数据结构是哈希表</p></li><li><p>哈希表依赖两个方法：hashCode()和equals()</p></li><li><p>执行顺序：</p></li><li><ul><li><p>首先判断hashCode()值是否相同</p></li><li><ul><li><p>是：继续执行equals(),看其返回值</p></li><li><ul><li>是true：说明元素重复，不添加</li><li>是false：就直接添加到集合</li></ul></li><li><p>否：就直接添加到集合</p></li></ul></li><li><p>最终：自动生成hashCode()和equals()即可</p></li></ul></li><li><p>LinkedHashSet</p></li><li><ul><li>底层数据结构由链表和哈希表组成</li><li>由链表保证元素有序</li><li>由哈希表保证元素唯一</li></ul></li></ul></li><li><p>Hashtable</p></li><li><ul><li><p>底层数据结构是哈希表.线程安全，效率低</p></li><li><p>哈希表依赖两个方法：hashCode()和equals()</p></li><li><p>执行顺序：</p></li><li><ul><li><p>首先判断hashCode()值是否相同</p></li><li><ul><li><p>是：继续执行equals(),看其返回值</p></li><li><ul><li>是true：说明元素重复，不添加</li><li>是false：就直接添加到集合</li></ul></li><li><p>否：就直接添加到集合</p></li></ul></li><li><p>最终：自动生成hashCode()和equals()即可</p></li></ul></li></ul></li><li><p>TreeMap</p></li><li><ul><li><p>底层数据结构是红黑树（是一种平衡的二叉树）</p></li><li><p>如何保证元素唯一性呢？</p></li><li><ul><li>根据比较的返回值是否是0来确定</li></ul></li><li><p>如何保证元素的排序呢？</p></li><li><ul><li><p>两种方式</p></li><li><ul><li><p>自然排序（元素具备比较性）</p></li><li><ul><li>让元素所属的类实现Comparable接口</li></ul></li><li><p>比较器排序（集合具备比较性）</p></li><li><ul><li>让集合接受一个Comparator的实现类对象</li></ul></li></ul></li></ul></li></ul></li></ul><p>集合的常见方法及遍历方式</p><p>Collection：</p><p>add()</p><p>remove()</p><p>contains()</p><p>iterator()</p><p>size()</p><p>遍历：</p><p>增强for</p><p>迭代器</p><ul><li>List</li></ul><p>get（）</p><p>遍历：</p><p>普通for</p><ul><li>Set</li></ul><p>Map：</p><p>put()</p><p>remove()</p><p>containskey(),containsValue()</p><p>keySet()</p><p>get()</p><p>value()</p><p>entrySet()</p><p>size()</p><p>遍历：</p><p>根据键找值</p><p>根据键值对对象分别找键和值</p><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>针对集合操作的工具类，有对集合进行排序和二分查找的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span>;<span class="comment">//排序，默认情况下是自然排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">binarySearch</span><span class="params">(List&lt;?&gt; list,T key)</span></span>;<span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;T&gt; list)</span></span>;<span class="comment">//反转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list)</span></span>;<span class="comment">//随机置换</span></span><br></pre></td></tr></table></figure><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="体介绍"><a href="#体介绍" class="headerlink" title="体介绍"></a>体介绍</h2><p>Java <em>TreeMap</em>实现了<em>SortedMap</em>接口，也就是说会按照key的大小顺序对<em>Map</em>中的元素进行排序，key大小的评判可以通过其本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator）。</p><p><strong>TreeMap底层通过红黑树（Red-Black tree）实现</strong>，也就意味着containsKey(), get(), put(), remove()都有着log(n)的时间复杂度。其具体算法实现参照了《算法导论》。</p><p><img src="/category/JavaSE-集合2/hh1.png" alt="红黑树"></p><p>出于性能原因，<em>TreeMap</em>是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>TreeMap</em>包装成（wrapped）同步的：</p><p>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(…));</p><p><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一陪</strong>。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。</li><li>对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。</li></ol><p>在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的条件。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>前文说到当查找树的结构发生改变时，红黑树的条件可能被破坏，需要通过调整使得查找树重新满足红黑树的条件。调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：<strong>左旋（Rotate Left），右旋（RotateRight）</strong>。</p><h2 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h2><p>左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/category/JavaSE-集合2/hh2.png" alt="红黑树"></p><p><em>TreeMap</em>中左旋代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rotate Left</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a><strong>右旋</strong></h2><p>右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/category/JavaSE-集合2/hh3.png" alt="红黑树"></p><p><em>TreeMap</em>中右旋代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rotate Right</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法剖析-1"><a href="#方法剖析-1" class="headerlink" title="方法剖析"></a>方法剖析</h2><ul><li><strong>get()</strong></li></ul><p>get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.value。因此getEntry()是算法的核心。算法思想是根据key的自然顺序（或者比较器顺序）对二叉查找树进行查找，直到找到满足k.compareTo(p.key) == 0的entry。</p><p><img src="/category/JavaSE-集合2/hh4.png" alt="红黑树"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getEntry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)<span class="comment">//不允许key值为null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)<span class="comment">//向左找</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">//向右找</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>put()</strong></li></ul><p>put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束，还需要进行调整（旋转，改变某些节点的颜色）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) t = t.left;<span class="comment">//向左找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) t = t.right;<span class="comment">//向右找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);<span class="comment">//创建并插入新的entry</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) parent.left = e;</span><br><span class="line">    <span class="keyword">else</span> parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);<span class="comment">//调整</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的插入部分并不难理解：首先在红黑树上找到合适的位置，然后创建新的entry并插入（当然，新插入的节点一定是树的叶子）。难点是调整函数fixAfterInsertion()，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。</p><p><img src="/category/JavaSE-集合2/hh5.png" alt="红黑树"></p><p>调整函数fixAfterInsertion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树调整函数fixAfterInsertion()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;<span class="comment">//如果y为null，则视为BLACK</span></span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况1</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">// 情况1</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况1</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       <span class="comment">// 情况2</span></span><br><span class="line">                    rotateLeft(x);                         <span class="comment">// 情况2</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况3</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况3</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));        <span class="comment">// 情况3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况4</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">// 情况4</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况4</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况4</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       <span class="comment">// 情况5</span></span><br><span class="line">                    rotateRight(x);                        <span class="comment">// 情况5</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况6</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况6</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));         <span class="comment">// 情况6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>remove()</strong></li></ul><p>remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry<k ,v>entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束，因此有可能要进行调整。</k></p><h2 id="寻找节点后继"><a href="#寻找节点后继" class="headerlink" title="寻找节点后继"></a>寻找节点后继</h2><p>对于一棵二叉查找树，给定节点t，其后继（树种比大于t的最小的那个元素）可以通过如下方式找到：</p><blockquote><ol><li>t的右子树不空，则t的后继是其右子树中最小的那个元素。</li><li>t的右孩子为空，则t的后继是其第一个向左走的祖先。</li></ol></blockquote><p>后继节点在红黑树的删除操作中将会用到。</p><p><img src="/category/JavaSE-集合2/hm6.png" alt="红黑树"></p><p>TreeMap</p><p>中寻找节点后继的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 寻找节点后继函数successor()</span><br><span class="line">static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123;</span><br><span class="line">    if (t == null)</span><br><span class="line">        return null;</span><br><span class="line">    else if (t.right != null) &#123;// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素</span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        while (p.left != null)</span><br><span class="line">            p = p.left;</span><br><span class="line">        return p;</span><br><span class="line">    &#125; else &#123;// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先</span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        while (p != null &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>remove()</strong></p><p>remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry<k ,v>entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。</k></p><p>getEntry()函数前面已经讲解过，这里重点放deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixAfterDeletion(Entry<k ,v>x)进行调整。</k></p><p><strong>由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整</strong>。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况：</p><blockquote><ol><li>删除点p的左右子树都为空，或者只有一棵子树非空。</li><li>删除点p的左右子树都非空。</li></ol></blockquote><p>对于上述情况1，处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）；对于情况2，可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1，可以画画看）。</p><p>基于以上逻辑，红黑树的节点删除函数deleteEntry()代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红黑树entry删除函数deleteEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;<span class="comment">// 2. 删除点p的左右子树都非空。</span></span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);<span class="comment">// 后继</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;<span class="comment">// 1. 删除点p只有一棵子树非空。</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);<span class="comment">// 调整</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 1. 删除点p的左右子树都为空</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);<span class="comment">// 调整</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数fixAfterDeletion()。首先请思考一下，删除了哪些点才会导致调整？<strong>只有删除点是BLACK的时候，才会触发调整函数</strong>，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。</p><p>跟上文中讲过的fixAfterInsertion()函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种：1.改变某些节点的颜色，2.对某些节点进行旋转。</p><p><img src="/category/JavaSE-集合2/hh7.png" alt="红黑树"></p><p>上述图解的总体思想是：将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则：a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环（因为x为红色）；b).一旦进入情况3和情况4，一定会退出循环（因为x为root）。</p><p>删除后调整函数fixAfterDeletion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况1</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况1</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况1</span></span><br><span class="line">                sib = rightOf(parentOf(x));             <span class="comment">// 情况1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 情况2</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 情况2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);       <span class="comment">// 情况3</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 情况3</span></span><br><span class="line">                    rotateRight(sib);                   <span class="comment">// 情况3</span></span><br><span class="line">                    sib = rightOf(parentOf(x));         <span class="comment">// 情况3</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况4</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况4</span></span><br><span class="line">                setColor(rightOf(sib), BLACK);          <span class="comment">// 情况4</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况4</span></span><br><span class="line">                x = root;                               <span class="comment">// 情况4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 跟前四种情况对称</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况5</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况5</span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况5</span></span><br><span class="line">                sib = leftOf(parentOf(x));              <span class="comment">// 情况5</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 情况6</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 情况6</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);      <span class="comment">// 情况7</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 情况7</span></span><br><span class="line">                    rotateLeft(sib);                    <span class="comment">// 情况7</span></span><br><span class="line">                    sib = leftOf(parentOf(x));          <span class="comment">// 情况7</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况8</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况8</span></span><br><span class="line">                setColor(leftOf(sib), BLACK);           <span class="comment">// 情况8</span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况8</span></span><br><span class="line">                x = root;                               <span class="comment">// 情况8</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>前面已经说过TreeSet是对TeeMap的简单包装，对TreeSet的函数调用都会转换成合适的TeeMap方法，因此TreeSet的实现非常简单。这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet是对TreeMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = <span class="keyword">new</span> TreeMap&lt;E,Object&gt;();<span class="comment">// TreeSet里面有一个TreeMap</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE面向对象,集合,HashMap,红黑树
    
    </summary>
    
      <category term="JavaSE集合框架" scheme="https://www.ysmjjsy.com/categories/JavaSE%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-Collection集合</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E9%9B%86%E5%90%88/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-集合/</id>
    <published>2017-08-23T08:15:37.000Z</published>
    <updated>2019-09-09T09:33:38.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 09 2019 17:35:24 GMT+0800 (GMT+08:00) --><h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p>数据既可以存储基本数据类型，也可以存储引用类型，它存储引用类型的时候的数组就叫对象数组</p><p>假如有一个学生类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> vodi <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建学生数组(对象数组)</span></span><br><span class="line">    Student[] students = <span class="keyword">new</span> Student(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//创建5个学生对象并赋值</span></span><br><span class="line">    Student s1 = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">18</span>);</span><br><span class="line">    Student s2 = <span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="number">19</span>);</span><br><span class="line">    Student s3 = <span class="keyword">new</span> Student(<span class="string">"王五"</span>,<span class="number">20</span>);</span><br><span class="line">    Student s4 = <span class="keyword">new</span> Student(<span class="string">"赵六"</span>,<span class="number">21</span>);</span><br><span class="line">    Student s5 = <span class="keyword">new</span> Student(<span class="string">"陈七"</span>,<span class="number">22</span>);</span><br><span class="line">    <span class="comment">//把学生对象放到数组中</span></span><br><span class="line">    student[<span class="number">0</span>] = s1;</span><br><span class="line">    student[<span class="number">1</span>] = s2;</span><br><span class="line">    student[<span class="number">2</span>] = s3;</span><br><span class="line">    student[<span class="number">3</span>] = s4;</span><br><span class="line">    student[<span class="number">4</span>] = s5;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x&lt;student.length;x++)&#123;</span><br><span class="line">      Student s = student[x];</span><br><span class="line">      System.out.println(s.getName()+<span class="string">"---"</span>+s.getAge);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>定义方法时候不知道定义多少个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line">修饰符 返回值类型 方法名(数据类型... 变量名)&#123;&#125;</span><br><span class="line"><span class="comment">//这里的变量其实是一个数组，如果一个方法有可变参数，并且有多个参数，那么可变参数肯定是最后一个</span></span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>在面向对象的语言中，对事务的描述都是通过对象体现的，为了方便多个对象进行操作，我们就必须把这多个对象进行存储，而不能是一个基本的变量，应该是一个容器类型的变量。而学过的容器类型的有数组和StringBuffer，StringBuffer的结果是一个字符串，不能满足要求。当选择数组作为容器，这就是对象数组，然而对象数组长度是固定的，不能满足变化的需求，这就产生了集合容器。</p><p>数据结构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。Java提供了几个能有效地组织和操作数据的数据结构，这些数据结构通常称为Java集合框架。</p><p>Java容器里只能放对象，对于基本类型（int, long, float, double等），需要将其包装成对象类型后（Integer, Long, Float, Double等）才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</p><p>由于Java里对象都在堆上，且对象只能通过引用访问，容器里放的其实是对象的引用而不是对象本身</p><p><strong>数组和集合的区别？</strong></p><ul><li><p>长度区别</p><ul><li>数组的长度固定</li><li>集合长度可变</li></ul></li><li><p>内容不同</p><ul><li>数组存储的是同一种类型的元素</li><li>集合可以存储不同类型的元素</li></ul></li><li><p>元素的数据类型问题</p><ul><li>数组可以存储基本数据类型，也可以存储引用数据类型</li><li>集合只能存储引用类型</li></ul><h3 id="集合继承体系"><a href="#集合继承体系" class="headerlink" title="集合继承体系"></a>集合继承体系</h3><p><img src="/category/JavaSE-集合/集合继承体系.png" alt="集合继承体系"></p></li></ul><p><em>Map</em>接口没有继承自<em>Collection</em>接口，因为<em>Map</em>表示的是关联式容器而不是集合。但Java为我们提供了从<em>Map</em>转换到<em>Collection</em>的方法，可以方便的将<em>Map</em>切换到集合视图。</p><p>上图中提供了<em>Queue</em>接口，却没有<em>Stack</em>，这是因为<em>Stack</em>的功能已被JDK 1.6引入的<em>Deque</em>取代</p><h3 id="Collection集合功能概述"><a href="#Collection集合功能概述" class="headerlink" title="Collection集合功能概述"></a>Collection集合功能概述</h3><p>在这里可以看到Collection接口所提供的所有方法：</p><p><img src="/category/JavaSE-集合/collection_method.png" alt="Collection_Method"></p><p>其中，有几个比较常用的方法，比如方法add()添加一个元素到集合中，addAll()将指定集合中的所有元素添加到集合中，contains()方法检测集合中是否包含指定的元素，toArray()方法返回一个表示集合的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collection接口</span></span><br><span class="line"><span class="comment">//1、添加功能</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object obj)</span></span>;<span class="comment">//添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//添加一个集合的元素</span></span><br><span class="line"><span class="comment">//2、删除功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//移除所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;<span class="comment">//移除一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//移除一个集合的元素</span></span><br><span class="line"><span class="comment">//3、判断功能</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;<span class="comment">//判断集合中是否包含指定的元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//判断集合中是否包含指定的集合元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//判断集合是否为空</span></span><br><span class="line"><span class="comment">//4、获取功能</span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//5、长度功能</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="comment">//元素的个数</span></span><br><span class="line"><span class="comment">//6、交集功能</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//两个集合都有的元素</span></span><br><span class="line"><span class="comment">//7、把集合转为数组</span></span><br><span class="line">Object[] toArray();</span><br></pre></td></tr></table></figure><p>同时我们看方法列表有一个特别有意思的方法<code>boolean removeIf(Predicate&lt;? super E&gt;)</code></p><p>这是Java8新特性里加的方法，下面是他的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all of the elements of this collection that satisfy the given</span></span><br><span class="line"><span class="comment">     * predicate.  Errors or runtime exceptions thrown during iteration or by</span></span><br><span class="line"><span class="comment">     * the predicate are relayed to the caller.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implSpec</span></span></span><br><span class="line"><span class="comment">     * The default implementation traverses all elements of the collection using</span></span><br><span class="line"><span class="comment">     * its &#123;<span class="doctag">@link</span> #iterator&#125;.  Each matching element is removed using</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Iterator#remove()&#125;.  If the collection's iterator does not</span></span><br><span class="line"><span class="comment">     * support removal then an &#123;<span class="doctag">@code</span> UnsupportedOperationException&#125; will be</span></span><br><span class="line"><span class="comment">     * thrown on the first matching element.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filter a predicate which returns &#123;<span class="doctag">@code</span> true&#125; for elements to be</span></span><br><span class="line"><span class="comment">     *        removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if any elements were removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified filter is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if elements cannot be removed</span></span><br><span class="line"><span class="comment">     *         from this collection.  Implementations may throw this exception if a</span></span><br><span class="line"><span class="comment">     *         matching element cannot be removed or if, in general, removal is not</span></span><br><span class="line"><span class="comment">     *         supported.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(filter);</span><br><span class="line">        <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;E&gt; each = iterator();</span><br><span class="line">        <span class="keyword">while</span> (each.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filter.test(each.next())) &#123;</span><br><span class="line">                each.remove();</span><br><span class="line">                removed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这就是一个添加了判断的移除，并且可以实现自定义过滤器，并且是public default，并且这个方法在接口里，实际调用则是接口的实现类提供的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    list.add(<span class="number">4</span>);</span><br><span class="line">    list.removeIf(s -&gt; s%<span class="number">2</span>==<span class="number">0</span>);               <span class="comment">// 过滤掉模2等于0的数</span></span><br><span class="line">    list.forEach(s -&gt; System.out.println(s)); <span class="comment">// 输出 1 3</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    strings.add(<span class="string">"ab"</span>);</span><br><span class="line">    strings.add(<span class="string">"ac"</span>);</span><br><span class="line">    strings.add(<span class="string">"bc"</span>);</span><br><span class="line">    strings.add(<span class="string">"cd"</span>);</span><br><span class="line">    Predicate&lt;String&gt; predicate = (s) -&gt; s.startsWith(<span class="string">"a"</span>); <span class="comment">// 这里单独定义了过滤器</span></span><br><span class="line">    strings.removeIf(predicate);                            <span class="comment">// 过滤掉以"a"开头的元素</span></span><br><span class="line">    strings.forEach(s -&gt; System.out.println(s));            <span class="comment">// 输出 bc cd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collection集合继承体系"><a href="#Collection集合继承体系" class="headerlink" title="Collection集合继承体系"></a>Collection集合继承体系</h3><p><img src="/category/JavaSE-集合/collection_interface.png" alt="Collection集合继承体系"></p><p>可以看到Collection接口有四个子接口BeanContext、Set、List、Queue。</p><h4 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h4><h5 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for循环的一种</span></span><br><span class="line"><span class="keyword">for</span>(元素数据类型 变量:数组或者Collection集合)&#123;</span><br><span class="line">  使用变量即可，该变量就是元素</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简化数组和集合的遍历，增强for目标不能为null，所以最好使用前对其做非null判断</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">array.add(<span class="string">"hello"</span>);</span><br><span class="line">array.add(<span class="string">"world"</span>);</span><br><span class="line"><span class="keyword">for</span>(String s : array)&#123;</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>迭代器是遍历集合的一种方式，是以来集合存在的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c.add(<span class="string">"hello"</span>);</span><br><span class="line">c.add(<span class="string">"world"</span>);</span><br><span class="line"><span class="comment">//通过集合获取迭代器对象</span></span><br><span class="line">Iterator it = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">  String s = (String)it.next();</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代器为什么不定义一个类而是一个接口？</strong></p><p>假设迭代器定义的是一个类，这样我们就可以创建该类的对象，调用该类的方法实现集合的遍历，但是，Java中提供了很多的集合类，而这些集合类的数据结构是不同的，所以，存储的方式和遍历的方式应该是不同的，进而他们的遍历方式也应该是不一样的，最终就没有定义迭代器类。</p><p>而无论是哪种集合，都应该具备获取元素的操作，并且最好在辅助于判断功能。再提取这两个功能就是接口</p><p>那么在真正具体的实现类在哪里呢？再真正具体的子类中，以内部类的方式体现的。</p><p><strong>迭代器源码：</strong></p><p><img src="/category/JavaSE-集合/iterator1.png" alt="Iterator"></p><p><img src="/category/JavaSE-集合/iterator2.png" alt="Iterator"></p><h4 id="BeanContext"><a href="#BeanContext" class="headerlink" title="BeanContext"></a>BeanContext</h4><p>提供与 bean 上下文有关的类和接口。bean 上下文是一个 bean 的容器，它定义所包含 bean 的执行环境。但单个 bean 上下文中可能有几个 bean，一个 bean 上下文可以嵌套在另一个 bean 上下文中。</p><p><img src="/category/JavaSE-集合/BeanContext.png" alt="BeanContext"></p><h4 id="List-重点"><a href="#List-重点" class="headerlink" title="List(重点)"></a>List(重点)</h4><p>List接口扩展自Collection，它可以定义一个允许重复的有序集合（也称序列）。从List接口中的方法来看，List接口主要是增加了面向位置的操作，允许在指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器ListIterator，通常允许重复的元素。</p><p><img src="/category/JavaSE-集合/list_method.png" alt="List_Mehtod"></p><p><strong>List集合的特有功能：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,Object element)</span></span>;<span class="comment">//在指定位置添加元素</span></span><br><span class="line"><span class="comment">//获取功能</span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//获取指定位置的元素</span></span><br><span class="line"><span class="comment">//列表迭代器</span></span><br><span class="line"><span class="function">ListIterator <span class="title">listIterator</span><span class="params">()</span></span>;<span class="comment">//:List集合特有的迭代器</span></span><br><span class="line"><span class="comment">//删除功能</span></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//根据索引删除元素，返回被删除的元素</span></span><br><span class="line"><span class="comment">//修改功能</span></span><br><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,Object element)</span></span>;<span class="comment">//根据索引修改元素，返回被修饰的元素</span></span><br></pre></td></tr></table></figure><p><strong>数据结构简单分析</strong></p><p>数据结构之栈和队列：</p><ul><li>栈：先进后出</li><li>队列：先进先出</li><li>数组：查询快，增删慢</li><li>链表：查询慢，增删快</li></ul><p><img src="/category/JavaSE-集合/shujujiegou.png" alt="数据结构"></p><p>我们说的链表是单向链表，其实如果把头元素的地址给了最后一个元素的地址位置，就是循环列表，如果每个结点有3部分组成，就可以组成双向链表，如果再把前后的对应也连接起来，就成了双向循环链表。</p><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p><em>ArrayList</em>实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。除该类未实现同步外，其余跟<em>Vector</em>大致相同。每个<em>ArrayList</em>都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p><p><img src="/category/JavaSE-集合/arraylist.png" alt="ArrayList"></p><p>size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p><p>为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set()方法</span></span><br><span class="line"><span class="comment">//既然底层是一个数组ArrayList的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces the element at the specified position in this list with</span></span><br><span class="line"><span class="comment">     * the specified element.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index of the element to replace</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element element to be stored at the specified position</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);<span class="comment">//下标越界检查</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      private void rangeCheck(int index) &#123;</span></span><br><span class="line"><span class="comment">        if (index &gt;= size)</span></span><br><span class="line"><span class="comment">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;<span class="comment">//赋值到指定位置，复制的仅仅是引用</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get()方法</span></span><br><span class="line"><span class="comment">//get()方法唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  index index of the element to return</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);<span class="comment">//下标越界检查</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);<span class="comment">//返回下标元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add()</span></span><br><span class="line"><span class="comment">//ArrayList方法是add(E e)，add(int index, E e)。这两个方法都是向容器中添加新元素，这可能会导致capacity不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment">     * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment">     * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//扩容到原来的1.5倍</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);<span class="comment">//扩展空间并复制</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。</p><p><img src="/category/JavaSE-集合/array1.png" alt="ArrayList1"></p><p>空间的问题解决后，插入过程就显得非常简单。</p><p><img src="/category/JavaSE-集合/array2.png" alt="ArrayList2"></p><p>add(int index, E e)需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addAll()</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment">     * this list, in the order that they are returned by the</span></span><br><span class="line"><span class="comment">     * specified collection's Iterator.  The behavior of this operation is</span></span><br><span class="line"><span class="comment">     * undefined if the specified collection is modified while the operation</span></span><br><span class="line"><span class="comment">     * is in progress.  (This implies that the behavior of this call is</span></span><br><span class="line"><span class="comment">     * undefined if the specified collection is this list, and this</span></span><br><span class="line"><span class="comment">     * list is nonempty.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment">     * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment">     * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment">     * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment">     * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment">     * specified collection's iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index at which to insert the first element from the</span></span><br><span class="line"><span class="comment">     *              specified collection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//addAll()方法能够一次添加多个元素，根据位置不同也有两个把本，一个是在末尾添加的addAll(Collection&lt;? extends E&gt; c)方法，一个是从指定位置开始插入的addAll(int index, Collection&lt;? extends E&gt; c)方法。跟add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//addAll()的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove()</span></span><br><span class="line"><span class="comment">//remove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">     * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment">     * indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work:清除该位置的引用，让GC起作用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment">     * if it is present.  If the list does not contain the element, it is</span></span><br><span class="line"><span class="comment">     * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span></span><br><span class="line"><span class="comment">     * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment">     * changed as a result of the call).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//关于Java GC这里需要特别说明一下，有了垃圾收集器并不意味着一定不会有内存泄漏。对象能否被GC的依据是是否还有引用指向它，上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。</span></span><br></pre></td></tr></table></figure><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p><em>LinkedList</em>同时实现了<em>List</em>接口和<em>Deque</em>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（<em>Queue</em>），同时又可以看作一个栈（<em>Stack</em>）。这样看来，<em>LinkedList</em>简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<em>LinkedList</em>，一方面是因为Java官方已经声明不建议使用<em>Stack</em>类，更遗憾的是，Java里根本没有一个叫做<em>Queue</em>的类（它是个接口名字）。关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>（当作栈或队列使用时）有着更好的性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-集合/linklist1.png" alt="linkedlist"></p><p><em>LinkedList</em>底层<strong>通过双向链表实现</strong>，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟<em>List</em>接口相关的函数，双向链表的每个节点用内部类<em>Node</em>表示。<em>LinkedList</em>通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用Collections.synchronizedList()方法对其进行包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add()</span></span><br><span class="line"><span class="comment">//add()方法有两个版本，一个是add(E e)，该方法在LinkedList的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是add(int index, E element)，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</span></span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-集合/linkedlist2.png" alt="linkedlist"></p><p>结合上图，可以看出add(E e)的逻辑非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add(E e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;<span class="comment">//原来链表为空，这是插入的第一个元素</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add(int index, E element)的逻辑稍显复杂，可以分成两部，</p><p>1.先根据index找到要插入的位置；</p><p>2.修改引用，完成插入操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add(int index, E element)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);<span class="comment">//index &gt;= 0 &amp;&amp; index &lt;= size;</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)<span class="comment">//插入位置是末尾，包括列表为空的情况</span></span><br><span class="line">        add(element);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node&lt;E&gt; succ = node(index);<span class="comment">//1.先根据index找到要插入的位置</span></span><br><span class="line">        <span class="comment">//2.修改引用，完成插入操作。</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">//插入位置为0</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件index &lt; (size &gt;&gt; 1)，也即是index是靠近前端还是后端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove()</span></span><br><span class="line"><span class="comment">//remove()方法也有两个版本，一个是删除跟指定元素相等的第一个元素remove(Object o)，另一个是删除指定下标处的元素remove(int index)。</span></span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-集合/linkedlist3.png" alt="linkedlist"></p><p>两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候remove(Object o)调用的是元素的equals方法，而remove(int index)使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个revome()方法都是通过unlink(Node<e>x)方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。</e></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unlink(Node&lt;E&gt; x)，删除一个Node</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;<span class="comment">//删除的是第一个元素</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">//删除的是最后一个元素</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="keyword">null</span>;<span class="comment">//let GC work</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get()</span></span><br><span class="line"><span class="comment">//get(int index)得到指定下标处元素的引用，通过调用上文中提到的node(int index)方法实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);<span class="comment">//index &gt;= 0 &amp;&amp; index &lt; size;</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set()</span></span><br><span class="line"><span class="comment">//set(int index, E element)方法将指定下标处的元素修改成指定值，也是先通过node(int index)找到对应下表元素的引用，然后修改Node中item的值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;<span class="comment">//替换新值</span></span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义栈集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> LinkedList link;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    link = <span class="keyword">new</span> LinkedList();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    link.addFirst(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> link.removeFirst();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> link.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkList的特有功能</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Object e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Object e)</span></span>;</span><br><span class="line"><span class="comment">//获取功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getLast</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//删除功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">removeLst</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><h5 id="Vector的特有功能"><a href="#Vector的特有功能" class="headerlink" title="Vector的特有功能"></a><strong>Vector的特有功能</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"><span class="comment">//获取功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Enumeration <span class="title">elements</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Object <span class="title">nextElement</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Vector的遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">v.addElement(<span class="string">"hello"</span>);</span><br><span class="line">v.addElement(<span class="string">"world"</span>);</span><br><span class="line">v.addElement(<span class="string">"java"</span>);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; v.size(); x++)&#123;</span><br><span class="line">  String s = (String)v.elementAt(x);</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"> System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">Enumeration en = v.elements();<span class="comment">//返回的是实现类的对象</span></span><br><span class="line"><span class="keyword">while</span>(en.hasMoreElements())&#123;</span><br><span class="line">  String s = (String)en.nextElement();</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Set-重点"><a href="#Set-重点" class="headerlink" title="Set(重点)"></a>Set(重点)</h4><p>Set接口扩展自Collection，它与List的不同之处在于，规定Set的实例不包含重复的元素。AbstractSet是一个实现Set接口的抽象类，Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>散列集HashSet是一个用于实现Set接口的具体类，可以使用它的无参构造方法来创建空的散列集，也可以由一个现有的集合创建散列集。在散列集中，有两个名词需要关注，初始容量和客座率。实际上HashSet就是基于后面介绍的HashMap而实现的，客座率是确定在增加规则集之前，该规则集的饱满程度，当元素个数超过了容量与客座率的乘积时，容量就会自动翻倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHashSet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">"11111"</span>);</span><br><span class="line">        set.add(<span class="string">"22222"</span>);</span><br><span class="line">        set.add(<span class="string">"33333"</span>);</span><br><span class="line">        set.add(<span class="string">"44444"</span>);</span><br><span class="line">        set.add(<span class="string">"22222"</span>);</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        <span class="keyword">for</span> (String e : set) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从输出结果我们可以看到，规则集里最后有4个元素，而且在输出时元素还是无序的。</p><p>查看散列集HashSet的源码实现可以看到它内部是使用一个HashMap来存放元素的，因为HashSet的元素就是其内部HashMap的<strong>键集合</strong>，所以HashSet可以做到元素不重复。</p><p><strong>HashSet如何保证元素唯一性？</strong></p><p>底层数据结构是哈希表（元素是链表的数组）</p><p>哈希表依赖于哈希值存储</p><p>添加功能依赖两个方法：int hashCode();boolean equals(Object obj);</p><p>在这里，首先比较哈希值hashCode()是否相同，如果相同，元素重复，不添加。比较地址值或者走equals()，如果不同就直接添加到集合中。</p><p>如果类没有重写这两个方法，默认使用的Object()，一般来说不相同，而String类重写了hashCode()和equals()方法，所以他就可以把内容相同的字符串去掉，只留下一个。</p><h5 id="LinkHashSet"><a href="#LinkHashSet" class="headerlink" title="LinkHashSet"></a>LinkHashSet</h5><p>LinkedHashSet是继承自HashSet的，支持对规则集内的元素排序。HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。</p><p>底层数据结构由哈希表和链表组成</p><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>TreeSet扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。</p><p>使用元素的自然顺序对元素进行排序，或者根据创建set时提供的Comparator进行排序，具体取决于使用的构造方法</p><p>TreeSet如何保证元素的排序和唯一性？</p><p>底层数据结构是一种自平衡的二叉树（红黑树）</p><h6 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h6><p>Compar to</p><p>自然排序</p><p>真正的比较是依赖于元素的compare to 方法，而这个方定义在comparable里</p><p>要重写该方法，就必须先实现comparable接口</p><p>元素的唯一性和如何存储</p><p>第一个元素存储的时候，直接作为根节点存储</p><p>从第二个元素开始，每个元素从根节点开始比较</p><div class="table-container"><table><thead><tr><th>大</th><th>就作为右孩子</th></tr></thead><tbody><tr><td>小</td><td>作为左孩子</td></tr><tr><td>相等</td><td>不搭理</td></tr></tbody></table></div><p>元素是如何取出来的</p><p>从根节点开始，按照左中右的原则依次取出元素即可</p><p>保证元素的排序方式</p><p>自然排序</p><p>让元素所属的类实现Comparable接口</p><p>比较器排序</p><p>让集合构造方法接收Comparator的实现类对象</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>队列与栈是相对的一种数据结构。只允许在一端进行插入操作，而在另一端进行删除操作的线性表。栈的特点是后进先出，而队列的特点是先进先出。队列的用处很大，但大多都是在其他的数据结构中，比如，树的按层遍历，图的广度优先搜索等都需要使用队列做为辅助数据结构。</p><h5 id="单向队列"><a href="#单向队列" class="headerlink" title="单向队列"></a>单向队列</h5><p>单向队列比较简单，只能向队尾添加元素，从队头删除元素。比如最典型的排队买票例子，新来的人只能在队列后面，排到最前边的人才可以买票，买完了以后，离开队伍。这个过程是一个非常典型的队列。</p><p>定义队列的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object elem)</span></span>; <span class="comment">// 将一个元素放到队尾，如果成功，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">()</span></span>; <span class="comment">// 将一个元素从队头删除，如果成功，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个队列只要能入队，和出队就可以了。这个队列的接口就定义好了，具体的实现有很多种办法，例如，可以使用数组做存储，可以使用链表做存储。<br>其实大家页可以看一下JDK源码，在java.util.Queue中，可以看到队列的定义。只是它是泛型的。基本上，Queue.java中定义的接口都是进队，出队。只是行为有所不同。例如，remove如果失败，会抛出异常，而poll失败则返回null,但它俩其实都是从队头删除元素。</p><h5 id="单向队列-1"><a href="#单向队列-1" class="headerlink" title="单向队列"></a>单向队列</h5><p>如果一个队列的头和尾都支持元素入队，出队，那么这种队列就称为双向队列，英文是Deque。大家可以通过java.util.Deque来查看Deque的接口定义，这里节选一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the front of this deque if it is</span></span><br><span class="line"><span class="comment">     * possible to do so immediately without violating capacity restrictions,</span></span><br><span class="line"><span class="comment">     * throwing an &#123;<span class="doctag">@code</span> IllegalStateException&#125; if no space is currently</span></span><br><span class="line"><span class="comment">     * available.  When using a capacity-restricted deque, it is generally</span></span><br><span class="line"><span class="comment">     * preferable to use method &#123;<span class="doctag">@link</span> #offerFirst&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException if the element cannot be added at this</span></span><br><span class="line"><span class="comment">     *         time due to capacity restrictions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified element</span></span><br><span class="line"><span class="comment">     *         prevents it from being added to this deque</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified element is null and this</span></span><br><span class="line"><span class="comment">     *         deque does not permit null elements</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified</span></span><br><span class="line"><span class="comment">     *         element prevents it from being added to this deque</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最重要的也就是这4个，一大段英文，没啥意思，其实就是说，addFirst是向队头添加元素，如果不满足条件就会抛异常，然后定义了各种情况下抛出的异常类型。<br>只要记住队列是先进先出的数据结构就好了，今天不必要把这些东西都掌握，一步步来。</p><h5 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h5><p>Queue也继承自Collection，用来存放等待处理的集合，这种场景一般用于缓冲、并发访问。</p><p>Queue是用于在处理之前保存元素的集合。<br>除了基本的集合操作，队列提供了额外的插入、提取和检查操作。<br>每个方法都有两种形式:一种是在操作失败时抛出一个异常，另一个则返回一个特殊值(根据操作的不同)(返回null或false)。<br>插入操作的后一种形式是专门为有容量限制的队列实现而设计的;<br>在大多数实现中，插入操作不会失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//插入（抛出异常）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//插入（返回特殊值）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//移除（抛出异常）</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//移除（返回特殊值）</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//检查（抛出异常）</span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//检查（返回特殊值）</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出Queue接口没有什么神秘面纱，都不需要揭开。不存在花里胡哨，就只有这6个方法。额外的添加、删除、查询操作。</p><p>值得一提的是，Queue是个接口，它提供的add，offer方法初衷是希望子类能够禁止添加元素为null，这样可以避免在查询时返回null究竟是正确还是错误。实际上大多数Queue的实现类的确响应了Queue接口的规定，比如ArrayBlockingQueue，PriorityBlockingQueue等等。</p><p>但还是有一些实现类没有这样要求，比如LinkedList。</p><p>虽然 LinkedList 没有禁止添加 null，但是一般情况下 Queue 的实现类都不允许添加 null 元素，为啥呢？因为poll(),peek()方法在异常的时候会返回 null，你添加了null 以后，当获取时不好分辨究竟是否正确返回。</p><h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p>PriorityQueue又叫做优先级队列，保存队列元素的顺序不是按照及加入队列的顺序，而是按照队列元素的大小进行重新排序。因此当调用peek()或pool()方法取出队列中头部的元素时，并不是取出最先进入队列的元素，而是取出队列的最小元素。</p><blockquote><p>基于优先级堆的无界的优先级队列。</p><p>PriorityQueue的元素根据自然排序进行排序，或者按队列构建时提供的 Comparator进行排序，具体取决于使用的构造方法。</p><p>优先队列不允许 null 元素。</p><p>通过自然排序的PriorityQueue不允许插入不可比较的对象。</p><p>该队列的头是根据指定排序的最小元素。</p><p>如果多个元素都是最小值，则头部是其中的一个元素——任意选取一个。</p><p>队列检索操作poll、remove、peek和element访问队列头部的元素。</p><p>优先队列是无界的，但有一个内部容量，用于管理用于存储队列中元素的数组的大小。</p><p>基本上它的大小至少和队列大小一样大。</p><p>当元素被添加到优先队列时，它的容量会自动增长。增长策略的细节没有指定。</p></blockquote><p>一句话概括，PriorityQueue使用了一个高效的数据结构：堆。底层是使用数组保存数据。还会进行排序，优先将元素的最小值存到队头。</p><p><strong>PriorityQueue的排序方式</strong></p><p>PriorityQueue中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化时指定的排序方式进行排序。需要注意的是，当PriorityQueue中没有指定的Comparator时，加入PriorityQueue的元素必须实现了Comparable接口（元素是可以进行比较的），否则会导致 ClassCastException。</p><p><strong>PriorityQueue本质</strong></p><p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p><p><img src="/category/JavaSE-集合/pq1.png" alt="PriorityQueue"></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p><p>leftNo = parentNo*2+1</p><p>rightNo = parentNo*2+2</p><p>parentNo = (nodeNo-1)/2</p><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p><em>PriorityQueue</em>的peek()和element操作是常数时间，add(), offer(), 无参数的remove()以及poll()方法的时间复杂度都是<em>log(N)</em>。</p><p>PriorityQueue 本质也是一个动态数组，在这一方面与ArrayList是一致的。看一下它的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>PriorityQueue调用默认的构造方法时，使用默认的初始容量（<code>DEFAULT_IITIAL_CAPACITY = 11</code>）创建一个PriorityQueue，并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的Comparable）。</li><li>当使用指定容量的构造方法时，使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的Comparable）</li><li>当使用指定的初始容量创建一个 PriorityQueue，并根据指定的比较器comparator来排序其元素。当添加元素到集合时，会先检查数组是否还有余量，有余量则把新元素加入集合，没余量则调用 grow()方法增加容量，然后调用siftUp将新加入的元素排序插入对应位置。</li></ul><p>除了这些，还要注意的是：</p><ol><li>PriorityQueue不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue 实例，这时请使用线程安全的PriorityBlockingQueue 类。</li><li>不允许插入 null 元素。</li><li>PriorityQueue实现插入方法（offer、poll、remove() 和 add 方法） 的时间复杂度是O(log(n)) ；实现 remove(Object) 和 contains(Object) 方法的时间复杂度是O(n) ；实现检索方法（peek、element 和 size）的时间复杂度是O(1)。所以在遍历时，若不需要删除元素，则以peek的方式遍历每个元素。</li><li>方法iterator()中提供的迭代器并不保证以有序的方式遍历PriorityQueue中的元素。</li></ol><p><strong>方法剖析</strong></p><ul><li><strong>add()和offer()</strong></li></ul><p>add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p><p><img src="/category/JavaSE-集合/pq2.png" alt="pq2"></p><p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//offer(E e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null元素</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);<span class="comment">//自动扩容</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)<span class="comment">//队列原来为空，这是插入的第一个元素</span></span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，扩容函数grow()类似于ArrayList里的grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是siftUp(int k, E x)方法，该方法用于插入元素x并维持堆的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//siftUp()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//parentNo = (nodeNo-1)/2</span></span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)<span class="comment">//调用比较器的比较方法</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新加入的元素x可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x &gt;= queue[parent]为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><ul><li><strong>element()和peek()</strong></li></ul><p>element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以<strong>直接返回数组0下标处的那个元素即可</strong>。</p><p><img src="/category/JavaSE-集合/pq3.png" alt="pq"></p><p>代码也就非常简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//peek()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>remove()和poll()</strong></li></ul><p>remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><img src="/category/JavaSE-集合/pq4.png" alt="pq"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先记录0下标处的元素，并用最后一个元素替换0下标位置的元素，之后调用siftDown()方法对堆进行调整，最后返回原来0下标处的那个元素（也就是最小的那个元素）。重点是siftDown(int k, E x)方法，该方法的作用是<strong>从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//siftDown()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;<span class="comment">//leftNo = parentNo*2+1</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;<span class="comment">//然后用c取代原来的值</span></span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>remove(Object o)</strong></li></ul><p>remove(Object o)方法用于删除队列中跟o相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，remove(Object o)可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。</p><p><img src="/category/JavaSE-集合/pg5.png" alt="pg"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove(Object o)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">//情况1</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);<span class="comment">//情况2</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h5><p>Java里有一个叫做Stack的类，却没有叫做Queue的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了（次选是LinkedList）。</p><p>要讲栈和队列，首先要讲Deque接口。Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口：</p><p><img src="/category/JavaSE-集合/dequeue1.png" alt="Dequeue"></p><p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口：</p><p><img src="/category/JavaSE-集合/dequeue2.png" alt="Dequeue"></p><p>上面两个表共定义了<em>Deque</em>的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。<strong>一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（false或null）</strong>。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。<strong>虽然Deque的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看</strong>。明白了这一点讲解起来就会非常简单。</p><p><em>ArrayDeque</em>和<em>LinkedList</em>是<em>Deque</em>的两个通用实现，由于官方更推荐使用<em>AarryDeque</em>用作栈和队列，加之上一篇已经讲解过<em>LinkedList</em>，本文将着重讲解<em>ArrayDeque</em>的具体实现。</p><p>从名字可以看出<em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可能被看作起点或者终点。<em>ArrayDeque</em>是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。</p><p><img src="/category/JavaSE-集合/dequeue3.png" alt="Dequeue"></p><p>上图中我们看到，<strong>head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。</p><p><strong>方法剖析</strong></p><p>addFirst()</p><p>addFirst(E e)的作用是在<em>Deque</em>的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[—head] = e即可。</p><p><img src="/category/JavaSE-集合/dequeue4.png" alt="Dequeue"></p><p>实际需要考虑：</p><ol><li>空间是否够用，以及</li><li>下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addFirst(E e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;<span class="comment">//2.下标是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail)<span class="comment">//1.空间是否够用</span></span><br><span class="line">        doubleCapacity();<span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p>下标越界的处理解决起来非常简单，head = (head - 1) &amp; (elements.length - 1)就可以了，<strong>这段代码相当于取余，同时解决了head为负值的情况</strong>。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数（其实只可能是-1），则相当于对其取相对于elements.length的补码。</p><p>下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：</p><p><img src="/category/JavaSE-集合/dequeue5.png" alt="Dequeue"></p><p>图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//doubleCapacity()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> head == tail;</span><br><span class="line">    <span class="keyword">int</span> p = head;</span><br><span class="line">    <span class="keyword">int</span> n = elements.length;</span><br><span class="line">    <span class="keyword">int</span> r = n - p; <span class="comment">// head右边元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;<span class="comment">//原空间的2倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);</span><br><span class="line">    Object[] a = <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);<span class="comment">//复制右半部分，对应上图中绿色部分</span></span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);<span class="comment">//复制左半部分，对应上图中灰色部分</span></span><br><span class="line">    elements = (E[])a;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addLast()</p><p>addLast(E e)的作用是在<em>Deque</em>的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要elements[tail] = e;即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。</p><p><img src="/category/JavaSE-集合/dequeue6.png" alt="Dequeue"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    elements[tail] = e;<span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)<span class="comment">//下标越界处理</span></span><br><span class="line">        doubleCapacity();<span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下标越界处理方式addFirt()中已经讲过，不再赘述。</p><p>pollFirst()</p><p>pollFirst()的作用是删除并返回<em>Deque</em>首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回elements[head]即可，当然还需要处理下标的问题。由于ArrayDeque中不允许放入null，当elements[head] == null时，意味着容器为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E result = elements[head];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)<span class="comment">//null值意味着deque为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    elements[h] = <span class="keyword">null</span>;<span class="comment">//let GC work</span></span><br><span class="line">    head = (head + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);<span class="comment">//下标越界处理</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>pollLast()</strong></p><p>pollLast()的作用是删除并返回<em>Deque</em>尾端元素，也即是tail位置前面的那个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);<span class="comment">//tail的上一个位置是最后一个元素</span></span><br><span class="line">    E result = elements[t];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)<span class="comment">//null值意味着deque为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    elements[t] = <span class="keyword">null</span>;<span class="comment">//let GC work</span></span><br><span class="line">    tail = t;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>peekFirst()</p><p>peekFirst()的作用是返回但不删除<em>Deque</em>首端元素，也即是head位置处的元素，直接返回elements[head]即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elements[head]; <span class="comment">// elements[head] is null if deque empty</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>peekLast()</p><p>peekLast()的作用是返回但不删除<em>Deque</em>尾端元素，也即是tail位置前面的那个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collection集合总结"><a href="#Collection集合总结" class="headerlink" title="Collection集合总结"></a>Collection集合总结</h3><ul><li><p>List 有序，可重复</p></li><li><ul><li><p>ArrayList</p></li><li><ul><li>底层数据结构是数组，查询快，增删慢</li><li>线程不安全</li></ul></li><li><p>Vector</p></li><li><ul><li>底层数据结构是数组，查询快，增删慢</li><li>线程安全，效率低</li></ul></li><li><p>LinkedList</p></li><li><ul><li>底层数据结构是链表，查询慢，增删快</li><li>线程不安全，效率高</li></ul></li></ul></li><li><p>Set 无序，唯一</p></li><li><ul><li><p>HashSet</p></li><li><ul><li>底层数据结构是哈希表</li><li>如何保证元素的唯一性的呢？</li></ul></li></ul></li></ul><p>依赖两个方法：hashCode(),equals()</p><p>开发中自动生成这个两个方法即可</p><ul><li><p>LinkedHashSet</p></li><li><ul><li>底层数据结构是链表和哈希表</li><li>由链表保证元素有序</li><li>有哈希表保证元素唯一</li></ul></li></ul><ul><li><p>TreeSet</p></li><li><ul><li><p>底层数据结构是红黑树</p></li><li><p>如何保证元素排序的呢？</p></li><li><ul><li>自然排序</li><li>比较器排序</li></ul></li><li><p>如何保证元素的唯一性的呢？</p></li><li><ul><li>根据比较的返回值是否是0来决定</li></ul></li></ul></li></ul><p>针对Collection集合我们到底使用谁呢？</p><p>唯一吗？</p><ul><li>是：Set<ul><li>排序吗？<ul><li>是：TreeSet</li><li>否：HashSet</li></ul></li></ul></li></ul><p>如果你知道是Set，但不知道是哪个Set，就用HashSet</p><ul><li>否：List<ul><li>要安全吗？<ul><li>是：Vector</li><li>否：ArrayList或者LinkedList<ul><li>查询多：ArrayList</li><li>增删多：LinkedList</li></ul></li></ul></li></ul></li></ul><p>如果你知道是List，但不知道是哪个List，就用ArrayList</p><p>如果你知道是Collection集合，但不知道使用谁，就用ArrayList</p><p>如果你知道用集合，就用ArrayList</p><p>在集合中常见的数据结构</p><p>ArrayXxx：底层数据结构是数据，查询快，增删慢</p><p>LinkedXxx：底层数据结构是链表，查询慢，增删快</p><p>HashXxx：底层数据结构是哈希表，依赖两个方法：hashCode()和equals()</p><p>TreeXxx：底层数据结构是二叉树，两种排序方法：自然排序和比较器排序</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE面向对象,集合,HashSet,ArrayList
    
    </summary>
    
      <category term="JavaSE集合框架" scheme="https://www.ysmjjsy.com/categories/JavaSE%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-面向对象2</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-面向对象2/</id>
    <published>2017-08-20T06:13:27.000Z</published>
    <updated>2019-08-30T02:05:26.662Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:20:24 GMT+0800 (GMT+08:00) --><h1 id="面向对象2"><a href="#面向对象2" class="headerlink" title="面向对象2"></a>面向对象2</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为超类，基类或父类，新类称为子类。派生类等。子类比超类拥有的功能更加丰富。</p><p>在通过扩展父类定义子类的时候，仅需要指出子类与超类的不同之处。因为在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。由于子类的构造器不能访问父类的私有域，所以必须利用父类的构造器对这部分私有域进行初始化，我们可以通过super实现对父类构造器的调用，使用super调用构造器的语句必须是子类构造器的第一条语句。</p><p>如果子类的构造器没有显示的调用父类构造器，则将自动的调用超类默认的构造器，如果超类没有不带参数的构造器，并且子类的构造器中又没有显示的调用超类其他的构造器，则Java编译器将报告错误。</p><p>由一个公共超类派生出来的所有类的集合被称为继承层次，从某个特定的类到其祖先的路径称为该类的继承链。把多个类中相同的内容给提取出来定义到一个类中例如</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span></span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"吃饭"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"睡觉"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span></span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"吃饭"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"睡觉"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种情况，可以把公共的提取出来，然后去继承提取的那个类，也就是父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span>&#123;</span><br><span class="line">  <span class="comment">//animal类可以看作所有动物类的父类，任何动物都可以有名字，年龄，都会吃饭睡觉，所以将这些公共的提取出来，那么子类只需要继承这个类便拥有这些方法以及成员变量</span></span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"吃饭"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">"睡觉"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> <span class="keyword">extends</span> <span class="title">animal</span>()</span>&#123;</span><br><span class="line">  <span class="comment">//这里子类dog就拥有父类animal的成员变量以及方法，可以对其赋值或者方法的重写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> <span class="keyword">extends</span> <span class="title">animal</span>()</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样的extends关系就叫做继承，但是继承中子类不能继承父类的私有成员，构造方法(但可以通过super去访问)，继承体现的是is a的关系，在java中只支持单继承，但可以多层继承(继承体系)</p><p>继承的标准格式就是：<code>class 子类名 extends 父类名{}</code></p><h3 id="使用了继承有什么好处呢？"><a href="#使用了继承有什么好处呢？" class="headerlink" title="使用了继承有什么好处呢？"></a>使用了继承有什么好处呢？</h3><ul><li>提高了代码的复用性</li><li><h3 id="提高了代码的维护性"><a href="#提高了代码的维护性" class="headerlink" title="提高了代码的维护性"></a>提高了代码的维护性</h3></li><li>让类与类之间产生了关系，是多态的前提(同时这一点也是弊端，当类与类之间产生了关系，就不可避免的会有耦合，然而在开发原则里明确表示：低耦合高内聚，当耦合度高了可以这么形容，”牵一发而动全身“)</li></ul><p>假设我们有这么一个需求，有一家做信息检索的公司，他们需要对手机的各个品牌做一个统计以及对比，现在需要开发一个软件，需要编写entity，在使用继承并且掌握现有知识的前提下如何去设计呢？</p><p>首先我们应该分析一下，这家公司对产品内不同品牌进行对比，那么主题是手机，手机下有不同的品牌</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设我们手机有这些功能以及参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">double</span> size;</span><br><span class="line">  String color;</span><br><span class="line">  String name;</span><br><span class="line">  String cpu_id;</span><br><span class="line">  <span class="keyword">int</span> ram_size;</span><br><span class="line">  <span class="keyword">int</span> rom_size;</span><br><span class="line">  <span class="keyword">int</span> camera_pixel;<span class="comment">//摄像头像素</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhoto</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"拍照"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我现在有一个华为手机，那么我定义一个类HuaweiPhone继承Phone</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">  <span class="comment">//在这里我就不用每添加一个品牌再去写那些共有的特性，而是去继承父类，如果功能有特殊的那么重写或新加</span></span><br><span class="line">  <span class="keyword">int</span> camera_num; <span class="comment">//摄像头数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeMaxPhoto</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"夜拍，徕卡相机拍更厉害的照片"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同样小米手机，等其他手机也是类似，当我们新加一个手机品牌那么只需要继承这个类即可，再去写我们特有的功能</span></span><br></pre></td></tr></table></figure><p>在上述代码中可能会好奇，为什么只是写了一个关键字extends，子类便可以使用父类的成员变量，成员方法。</p><h3 id="继承中构造方法："><a href="#继承中构造方法：" class="headerlink" title="继承中构造方法："></a>继承中构造方法：</h3><p>在继承体系中，子类会继承父类中的数据，可能还会使用父类的数据。那么我们知道，在一个类中，给成员变量赋值有两种方法，一种是用方法赋值，一种是构造方法赋值。用构造方法赋值在new一个对象时需要对有参的构造方法传入值。而构造方法当自己没有声明，java会帮你写一个无参的构造方法。但是当你写了一个有参的构造方法如果还要使用无参的构造方法必须声名一个。系统不会再帮你生成无参构造方法。</p><p>在这里，子类的构造方法默认访问了父类中空参数的构造方法，从而构造出父类对象。</p><p>构造方法用于初始化一个实例对象，所以static修饰是没有任何意义的;多个线程不会同时创建内存地址相同的同一个对象，所以synchronized修饰没有意义;</p><p>构造方法不能被子类继承，所以final和abstract修饰没有意义</p><p>构造方法是没有返回类型的，void也不行。</p><p>当用户没有给java类定义明确的构造方法的时候,java为我们提供了一个默认的构造方法,这个构造方法没有参数,修饰符是public并且方法体为空。如果用户有定义构造方法，就不会有默认构造方法！！！<br>其实默认的构造方法还分为两种,一种就是刚刚说过的隐藏的构造方法,另一种就是显示定义的默认构造方法.<br>如果一个类中定义了一个或者多个构造方法,并且每一个构造方法都是带有参数形式的,那么这个类就没有默认的构造方法（需要显示的声明无参构造方法）</p><h4 id="this与super："><a href="#this与super：" class="headerlink" title="this与super："></a>this与super：</h4><p><strong>“this”的用法：</strong></p><p>实例方法中可以使用this关键字,它指向正在执行方法的类的实例对象,当然static方法中是不可以使用this对象的,因为静态方法不属于类的实例对象;而构造方法中同样可以使用this关键字,构造器中的this是指向同一个对象中不同参数的另一个构造器。</p><ol><li>构造方法中通过this关键字调用其他构造方法时,那么这句代码必须放在第一行,否则会编译错误。</li><li>构造方法中只能通过this调用一次其他的构造方法。</li></ol><p><strong>“super”的用法：</strong></p><p>实例方法和构造方法中的super关键字都用于去指向父类,实例方法中的super关键字是去调用父类当中的某个方法</p><p>构造器中使用super关键字调用父类中的构造器</p><p>在实例化子类对象时,程序会先调用父类的默认构造方法,然后再执行子类的构造方法。</p><p>在实例化类的对象时,类中的成员变量会首先进行初始化,如果其中的成员变量有对象，那么它们也会按照顺序执行初始化工作。在所有类成员初始化完成后，才调用对象所在类的构造方法创建对象。构造方法作用就是初始化。</p><p>如果一个类中有静态对象,那么他会在非静态对象初始化前进行初始化,但只初始化一次。而非静态对象每次调用时都要初始化。</p><p>程序中主类的静态变量会在main()方法执行前初始化</p><p>一个类初始化顺序：父类的静态成员—&gt;子类的静态成员—&gt;父类的非静态成员—&gt;父类的默认构造函数被调用—&gt;子类的非静态对象（变量）—&gt; 子类的构造函数。</p><h3 id="继承中成员方法的关系"><a href="#继承中成员方法的关系" class="headerlink" title="继承中成员方法的关系"></a>继承中成员方法的关系</h3><p>子类中的方法和父类中的方法声明不一样 直接调用</p><p>子类中的方法和父类中的方法声明一样：</p><ul><li>通过子类调用方法：<ul><li>先找子类中看有没有这个方法，有就使用</li><li>再看父类有没有这个方法，有就使用</li><li>如果没有就报错</li></ul></li></ul><h3 id="方法重写与方法重载"><a href="#方法重写与方法重载" class="headerlink" title="方法重写与方法重载"></a>方法重写与方法重载</h3><p>方法重写（Override）：子类中出现了和父类中方法声明一模一样的方法</p><p>方法重载（Overload）：本类中出现的方法名一样，参数列表不同的方法。与返回值无关</p><p>子类对象调用方法的时候：</p><ul><li>先找子类本身，再找父类</li></ul><p>方法重写的应用：</p><ul><li>当子类需要父类的功能，而功能主体子类有自己的特有内容时，可以重写父类中的方法。</li><li>这样，即沿袭了父类的功能，又定义了子类特有的内容。</li></ul><p>注意事项：</p><ul><li>父类中私有的方法不能被重写</li><li>子类重写父类方法是，访问权限不能更低</li><li>父类静态方法，子类必须通过静态方法进行重写</li></ul><p>子类重写父类方法的时候，最好声明一模一样</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>同一个对象（事务），在不同时刻体现出来的不同状态</p><p>比如小米手机是小米手机同样也是手机</p><p>在上面的例子中当<code>Phone p = new XiaomiPhone()</code></p><p>可以看作是多态</p><h4 id="多态的前提："><a href="#多态的前提：" class="headerlink" title="多态的前提："></a>多态的前提：</h4><ul><li>要有继承关系，</li></ul><ul><li>要有方法重写（也可以没有，但是没有这个就没有意义）</li><li>要有父类引用子类对象<code>fu f = new zi()</code></li></ul><h4 id="多态中成员访问特点："><a href="#多态中成员访问特点：" class="headerlink" title="多态中成员访问特点："></a>多态中成员访问特点：</h4><p>成员变量</p><ul><li>编译看左边，运行看左边</li></ul><p>构造方法</p><ul><li>创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化</li></ul><p>成员方法</p><ul><li>编译看左边，运行看右边</li></ul><p>静态方法</p><ul><li>编译看左边，运行看左边</li></ul><p>（静态和类相关，算不上重写，所以访问还是左边的）</p><p>由于成员方法存在方法重写，所以它运行看右边。</p><h4 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h4><p>提高了代码的维护性（继承保证）</p><p>提高了代码的扩展性（多态保证）</p><h4 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h4><p>不能使用子类的特有功能。</p><p>父类使用子类特有功能</p><ul><li>创建子类对象调用方法即可（可以，但是很多时候不合理，而且太占内存）</li></ul><ul><li>把父类的引用强制转换为子类的引用（向下转型）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象间转型问题</span></span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Zi z = <span class="keyword">new</span> (Zi)f;<span class="comment">//要求该f必须能够转换为Zi的</span></span><br></pre></td></tr></table></figure><p>多态中的内存图解：</p><p><img src="/category/JavaSE-面向对象2/duotai.png" alt="多态继承中内存图解"></p><p>对象变化内存图解：</p><p><img src="/category/JavaSE-面向对象2/duotai2.png" alt="对象变化内存图解"></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。</p><p>对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。</p><p>使用封装有三大好处：</p><ul><li>良好的封装能够减少耦合。</li><li>类内部的结构可以自由修改。</li><li>可以对成员进行更精确的控制。</li><li>隐藏信息，实现细节。</li></ul><p>所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。可以对成员变量进行更精确的控制</p><h3 id="Package关键字"><a href="#Package关键字" class="headerlink" title="Package关键字"></a>Package关键字</h3><h4 id="包的概述："><a href="#包的概述：" class="headerlink" title="包的概述："></a>包的概述：</h4><ul><li><p>其实就是文件夹</p></li><li><p>作用：</p></li><li><ul><li>把对相同的类名放到不同的包中</li><li>对类进行分类管理</li></ul></li></ul><h4 id="包的定义："><a href="#包的定义：" class="headerlink" title="包的定义："></a>包的定义：</h4><p>Package 包名；</p><p>多级包用.分开</p><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li>package语句必须是程序的第一条可执行的代码</li><li>package语句在一个java文件中只能有一个</li><li>如果没有package，默认表示无包名</li></ul><h4 id="带包的编译和运行："><a href="#带包的编译和运行：" class="headerlink" title="带包的编译和运行："></a>带包的编译和运行：</h4><ul><li><p>手动式</p></li><li><ol><li>编写一个带包的Java文件</li><li>通过Javac命令编译该Java文件</li><li>手动创建包名</li><li>把b步骤的class文件放到c步骤的最低层包</li><li>回到和包根目录在同一个目录的地方，然后运行带包运行</li></ol></li><li><p>自动式</p></li><li><ol><li>编写一个带包的java文件</li><li>javac编译的时候带上-d即可</li></ol></li></ul><p>Javac -d .HelloWorld.java</p><ol><li>回到和包根目录在同一个目录的地方，然后运行带包运行</li></ol><h3 id="import关键字的概述和使用"><a href="#import关键字的概述和使用" class="headerlink" title="import关键字的概述和使用"></a>import关键字的概述和使用</h3><p>导包：</p><p>格式：import 包名；</p><p>这种方式导入是到类的名称。</p><p>注意：我们用谁就导谁</p><p>面试题：</p><p>package，import，class有没有顺序关系？</p><p>有</p><p>package&gt;import&gt;class</p><p>package：只能有一个</p><p>import：可以有多个</p><p>class：可以有多个，建议是一个</p><h3 id="四种权限修饰符"><a href="#四种权限修饰符" class="headerlink" title="四种权限修饰符"></a>四种权限修饰符</h3><div class="table-container"><table><thead><tr><th></th><th>本类</th><th>同一个包下（子类和无关类）</th><th>不同包下（子类）</th><th>不同包下（无关类）</th></tr></thead><tbody><tr><td>private</td><td>Y</td><td></td><td></td><td></td></tr><tr><td>默认（default）</td><td>Y</td><td>Y</td><td></td><td></td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td></td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table></div><h3 id="类及其组成所使用的常见修饰符"><a href="#类及其组成所使用的常见修饰符" class="headerlink" title="类及其组成所使用的常见修饰符"></a>类及其组成所使用的常见修饰符</h3><p><strong>修饰符：</strong></p><p>权限修饰符：private，默认修饰符，protected，public</p><p>状态修饰符：static，final</p><p>抽象修饰符：abstract</p><p><strong>类：</strong></p><p>权限修饰符：默认修饰符，public</p><p>状态修饰符：final</p><p>抽象修饰符：abstract</p><p>用的最多的就是public</p><p><strong>成员变量：</strong></p><p>权限修饰符：private，默认修饰符，protected，public</p><p>状态修饰符：static，final</p><p>用的最多的就是，private</p><p><strong>构造方法：</strong></p><p>权限修饰符：private，默认修饰符，protected，public</p><p>用的最多的就是public</p><p><strong>成员方法：</strong></p><p>权限修饰符：private，默认修饰符，protected，public</p><p>状态修饰符：static，final</p><p>抽象修饰符：abstract</p><p>用的最多的就是public</p><p><strong>除此以外的组合规则：</strong></p><p>成员变量：public static final</p><p>成员方法：public static</p><p>public abstract</p><p>public final</p><h2 id="类初始化过程"><a href="#类初始化过程" class="headerlink" title="类初始化过程"></a>类初始化过程</h2><h4 id="类初始化过程-1"><a href="#类初始化过程-1" class="headerlink" title="类初始化过程"></a>类初始化过程</h4><p>加载class文件进内存</p><p>在栈内存开辟空间</p><p>在对内存为类对象开辟空间</p><p>对对象的成员变量进行默认初始化</p><p>对对象的成员变量进行显示初始化</p><p>通过构造方法对对象的成员变量赋值</p><p>对象初始化完毕，吧对象地址复制给变量</p><h4 id="对象析构与finalize方法："><a href="#对象析构与finalize方法：" class="headerlink" title="对象析构与finalize方法："></a>对象析构与finalize方法：</h4><p>在析构器中最常见的操作是回收分配给对象的存储空间，但Java不支持析构器，可以为任何一个类添加finalize方法，将在垃圾回收器清除对象之前调用。</p><h4 id="动态绑定："><a href="#动态绑定：" class="headerlink" title="动态绑定："></a>动态绑定：</h4><p>调用对象方法的执行过程：</p><p>编译器查看对象的声明类型和方法名</p><p>编译器查看调用方法时提供的参数类型</p><p>如果是private方法、static方法、final方法、或者构造器，那么编译器将准备的知道该调用哪个方法，这种调用方式为静态绑定。</p><p>调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。</p><p>当程序运行时，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。</p><p>虚拟机为了节省开销和时间，为每个类预先创建了一个方法表。</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>把类定义在其他类的内部，这个类就被称为内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类的访问特点"><a href="#内部类的访问特点" class="headerlink" title="内部类的访问特点"></a>内部类的访问特点</h3><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">      i.show();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类位置："><a href="#内部类位置：" class="headerlink" title="内部类位置："></a>内部类位置：</h3><p>成员位置：在成员位置定义的类，称为成员内部类。</p><p>局部位置：在局部位置定义的类，称为局部内部类</p><p>成员内部类：</p><p>如何直接访问内部类的成员：</p><p>外部类名.内部类名 对象名 = 外部类对象.内部类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringp[] args)</span></span>&#123;</span><br><span class="line">      Outer.Inner oi = <span class="keyword">new</span> Outer().new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>成员内部类的修饰符：</p><p>private 为了保证数据的安全性</p><p>static 为了方便访问数据</p><p>注意：静态内部类访问的外部类数据必须用静态修饰</p><p>成员内部类被静态修饰后的访问方式是：</p><p>格式：外部类名.内部类名 对象名 = new 外部类名.内部类名();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num2 = <span class="number">100</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Outer.Inner oi = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">    oi.show();</span><br><span class="line">    oi.show2();</span><br><span class="line">    <span class="comment">//show2另一种调用方式</span></span><br><span class="line">    Outer.Inner.show2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部内部类：</p><ul><li>可以直接访问外部类的成员</li><li>在局部位置，可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能</li></ul><p>面试题：</p><p>局部内部类访问局部变量的注意事项？</p><ul><li>局部内部类访问局部变量必须用final修饰</li><li>为什么呢？</li></ul><p>局部变量是随着方法的额调用而调用，随着调用完毕而消失。</p><p>而堆内存的内容并不会立即消失，所以我们加final修饰。</p><p>加入final修饰后，这个变量就常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Inner i = <span class="keyword">new</span> Inner()</span><br><span class="line">    i.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>就是内部类的简化写法</p><p>前提：存在一个类或者接口</p><p>这里的类可以是具体类也可以是抽象类</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或者接口名()&#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质是什么呢？</p><p>是一个继承了该类或者实现了该接口的子类匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Inter()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类的方法调用"><a href="#匿名内部类的方法调用" class="headerlink" title="匿名内部类的方法调用"></a>匿名内部类的方法调用</h4><p>调用一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Inter()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用多个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Inter i = <span class="keyword">new</span> Inter()&#123;<span class="comment">//多态</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"show"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"show2"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">i.show();</span><br><span class="line">i.show2();</span><br></pre></td></tr></table></figure><h4 id="匿名内部类在开发中的应用："><a href="#匿名内部类在开发中的应用：" class="headerlink" title="匿名内部类在开发中的应用："></a>匿名内部类在开发中的应用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span></span>&#123;</span><br><span class="line">  <span class="comment">//接口名作为形式参数</span></span><br><span class="line">  <span class="comment">//这里需要的不是接口，而是接口的实现类的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    p.study();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"好好学习，天天向上"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    PersonDemo pd = <span class="keyword">new</span> PersonDemo();</span><br><span class="line">    Person p = <span class="keyword">new</span> Person();</span><br><span class="line">    pd.method(p);</span><br><span class="line">    Systemout.println(<span class="string">"------"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//匿名内部类在开发中的使用</span></span><br><span class="line">    <span class="comment">//匿名内部类的本质是继承类或者实现了接口的子类匿名对象</span></span><br><span class="line">    pd.method(<span class="keyword">new</span> Person()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"好好学习，天天向上"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据</p><p>内部类可以对同一个包中的其他类隐藏起来</p><p>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷</p><p>内部类可以直接访问外部类的成员，包括私有</p><p>外部类要访问内部类的成员，必须创建对象</p><p>内部类的位置:</p><p>成员位置:成员内部类</p><p>外部类名.内部类名 对象名 = 外部类对象.内部类对象</p><p>private:私有。 外部类创建方法，方法内创建对象，调用内部类方法。</p><p>Static(为了方便访问数据)内部类用静态修饰是因为内部类可以看出是外部类的成员,内部类被静态修饰后，访问外部类数据必须用静态修饰</p><p>局部位置:局部内部类</p><p>使用内部类访问对象状态:</p><p>内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。</p><p>内部类的特殊语法规则:</p><p>OuterClass.this:表示外围类引用</p><p>OuterClass.InnerClass:在外围类的作用域之后，引用内部类</p><p>局部内部类:</p><p>局部类不能用public或private访问说明符进行声明。它的作用域被限定在声明这个具备类的块中。</p><p>局部类有一个优势，即对外部世界可以完全的隐藏起来。</p><p>可以直接访问外部类成员</p><p>在局部位置，可以创建内部类对象，通过内部类对象，通过对象内部类方法，来使用局部内部类功能</p><p>匿名内部类:</p><p>假如只创建这个类的一个对象，就不必命名，这种类被称为匿名内部类</p><p>new SuperType(construction parameters)</p><p>{</p><p>Inner class methods and data</p><p>}</p><p>由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器，取而代之的是，将构造器参数传递给超类构造器，尤其是内部类实现接口的时候，不能有任何构造参数。</p><p>前提:存在一个类或者接口，这里的类可以是具体类也可以是抽象类</p><p>new 类名或者接口名(){</p><p>重写方法;</p><p>}</p><p>本质是一个继承了该类或者实现了该接口的子类匿名对象</p><p>静态内部类:</p><p>有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象，为此，可以将内部类声明为static，以便取消产生的引用</p></blockquote><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>我们把一个不是具体的功能成为抽象的功能，而一个类中如果有抽象的功能，该类必须是抽象类。</p><h3 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a>抽象类的特点</h3><ul><li>抽象类和抽象方法必须用abstract关键字修饰</li><li>抽象类中不一定有抽象方法，但是有抽象方法的类必须定义为抽象类</li><li>抽象类不能实例化<ul><li>因为它不是具体的</li><li>抽象类有构造方法，但是不能实例化？构造方法的作用是什么呢？<ul><li>用于子类访问父类数据的初始化</li></ul></li></ul></li><li>抽象的子类<ul><li>如果不想重写抽象方法，该子类是一个抽象类</li><li>重写所有的抽象方法，这个时候子类是一个具体的类</li></ul></li></ul><p>抽象类的实例化其实是靠具体的子类实现的。是多态的方式</p><p>Phone p = new HuaweiPhone();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">  <span class="comment">//没有方法体&#123;&#125;，抽象方法不能有具体实现，空方法体也会报错</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">takePhone</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类是抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类是具体类，重写抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> <span class="keyword">extends</span> <span class="title">phone</span></span>&#123;</span><br><span class="line">  <span class="function">pulic <span class="keyword">void</span> <span class="title">takePhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建对象，Phone是抽象的，无法实例化，通过多态方式</span></span><br><span class="line">    Phone p = <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">    p.takePhone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类的成员特点"><a href="#抽象类的成员特点" class="headerlink" title="抽象类的成员特点"></a>抽象类的成员特点</h3><ul><li>成员变量：既可以是变量，也可以是常量。</li><li>构造方法：有<ul><li>用于子类访问父类数据的初始化</li></ul></li><li>成员方法：既可以是抽象的，也可以是非抽象的</li></ul><p><strong>抽象类的成员方法特性：</strong></p><p>一个类如果没有抽象方法，可不可以定义为抽象类？如果可以，有什么意义</p><ul><li>可以</li><li>不让创建对象</li></ul><p><strong>abstract不能和哪些关键字共存</strong></p><p>private 冲突</p><p>final 冲突</p><p>static 无意义</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote><p>接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。接口中的所有方法属于public，因此在声明方法时，不必提供关键字public。接口中不能含有实例域，也不能在接口中实现方法。提供实例域和方法的任务应该由实现接口的那个类完成，因此，可以将接口看成是没有实例域的抽象类，但概念有一定区别。</p></blockquote><p>定义接口 public interface 类名</p><p>类实现接口 class 类名 implements 接口名</p><p>接口中的域将被自动设为public static final</p><p>接口不能实例化，可以按照多态的方式来实例化</p><p>接口的子类:</p><ul><li>可以使抽象类，意义不大</li><li>可以是具体类，要重写接口中的所有抽象方法(推荐)</li></ul><p>接口的成员特点:</p><ul><li>成员变量: 只能是常量，并且是静态的</li><li>默认修饰符:public static final</li><li>构造方法:接口没有构造方法</li><li>成员方法:只能是抽象方法</li><li>默认修饰符:public abstract</li></ul><p>具体类多态（几乎没有）</p><p>抽象类多态（常用）</p><p>接口多态（最常用）</p><p><strong>接口与回调:</strong></p><p>回掉是一种常见的程序设计模式，在这种模式中，可以指出某个特定事件发生时应该采取的动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Phone5G</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fast</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类实现接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">implements</span> <span class="title">Phone5G</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体类实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> <span class="keyword">implements</span> <span class="title">Phone5G</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fast</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"实现5G更快了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">InterfaceDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Phone5G p = <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">      p.fast();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的成员特点"><a href="#接口的成员特点" class="headerlink" title="接口的成员特点"></a>接口的成员特点</h3><ul><li>成员变量：只能是常量，并且是静态的。<ul><li>默认修饰符：public static final</li></ul></li></ul><ul><li>构造方法：接口中没有构造方法</li><li>成员方法：只能是抽象方法<ul><li>默认修饰符： public abstract</li></ul></li></ul><h3 id="类与类，类与接口，接口与接口之间的关系"><a href="#类与类，类与接口，接口与接口之间的关系" class="headerlink" title="类与类，类与接口，接口与接口之间的关系"></a>类与类，类与接口，接口与接口之间的关系</h3><ul><li>类与类：<ul><li>继承关系，只能单继承，可以多层继承</li></ul></li><li>类与接口：<ul><li>实现关系，可以单实线，也可以多实现</li><li>并且还可以再继承一个类的同时实现多个接口</li></ul></li><li>接口与接口：<ul><li>继承关系，可以单继承，也可以多继承</li></ul></li></ul><h3 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h3><ul><li>成员区别</li><li><ul><li>抽象类：</li><li><ul><li>成员变量</li><li><ul><li>可以变量可以常量</li></ul></li><li>构造方法</li><li><ul><li>有</li></ul></li><li>成员方法</li><li><ul><li>可以抽象可以非抽象</li></ul></li></ul></li><li>接口：</li><li><ul><li>成员变量</li><li><ul><li>只可以常量</li></ul></li><li>成员方法</li><li><ul><li>只可以抽象</li></ul></li></ul></li></ul></li><li>关系区别</li><li><ul><li>类与类</li><li><ul><li>继承，单继承</li></ul></li><li>类与接口</li><li><ul><li>实现，单实现，多实现</li></ul></li><li>接口与接口</li><li><ul><li>继承，单继承，多继承</li></ul></li></ul></li><li>设计理念区别</li><li><ul><li>抽象类<ul><li>被继承体现的是：“is a“的关系。抽象类中定义的是该继承体系的共性功能</li></ul></li><li>接口</li><li><ul><li>被实现体现的是：“like a”的关系。接口中定义的是该继承体系的扩展功能</li></ul></li></ul></li></ul><h2 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h2><p>当拷贝一个变量时，原始变量与拷贝变量引用同一个对象，改变一个变量所引用的对象将会对另一个变量产生影响。如果创建一个对象的新的copy，它的最初状态与原始对象一样，但以后将可以各自改变各自的状态，那就需要使用clone方法。</p><p>Clone方法是Object类的一个proteced方法克隆需要实现Cloneable接口（标记接口），使用public访问修饰符重新定义clone方法</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE面向对象,继承、多态、封装、内部类的概述。
    
    </summary>
    
      <category term="JavaSE面向对象" scheme="https://www.ysmjjsy.com/categories/JavaSE%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-基础语法</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-基础语法/</id>
    <published>2017-08-16T13:33:02.000Z</published>
    <updated>2019-08-16T09:38:14.734Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 16 2019 17:38:47 GMT+0800 (GMT+08:00) --><h1 id="JavaSE-基础语法"><a href="#JavaSE-基础语法" class="headerlink" title="JavaSE-基础语法"></a>JavaSE-基础语法</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>被Java语言赋予特定含义的单词</p><p>特点：全部小写，goto和const作为保留字存在</p><div class="table-container"><table><thead><tr><th style="text-align:center">abstract</th><th style="text-align:center">assert</th><th style="text-align:center">boolean</th><th style="text-align:center">break</th><th style="text-align:center">byte</th></tr></thead><tbody><tr><td style="text-align:center"><strong>case</strong></td><td style="text-align:center"><strong>catch</strong></td><td style="text-align:center"><strong>char</strong></td><td style="text-align:center"><strong>class</strong></td><td style="text-align:center"><strong>const</strong></td></tr><tr><td style="text-align:center"><strong>continue</strong></td><td style="text-align:center"><strong>default</strong></td><td style="text-align:center"><strong>do</strong></td><td style="text-align:center"><strong>double</strong></td><td style="text-align:center"><strong>else</strong></td></tr><tr><td style="text-align:center"><strong>enum</strong></td><td style="text-align:center"><strong>extends</strong></td><td style="text-align:center"><strong>final</strong></td><td style="text-align:center"><strong>finally</strong></td><td style="text-align:center"><strong>float</strong></td></tr><tr><td style="text-align:center"><strong>for</strong></td><td style="text-align:center"><strong>goto</strong></td><td style="text-align:center"><strong>if</strong></td><td style="text-align:center"><strong>implements</strong></td><td style="text-align:center"><strong>import</strong></td></tr><tr><td style="text-align:center"><strong>instanceof</strong></td><td style="text-align:center"><strong>int</strong></td><td style="text-align:center"><strong>interface</strong></td><td style="text-align:center"><strong>long</strong></td><td style="text-align:center"><strong>native</strong></td></tr><tr><td style="text-align:center"><strong>new</strong></td><td style="text-align:center"><strong>package</strong></td><td style="text-align:center"><strong>private</strong></td><td style="text-align:center"><strong>protected</strong></td><td style="text-align:center"><strong>public</strong></td></tr><tr><td style="text-align:center"><strong>return</strong></td><td style="text-align:center"><strong>strictfp</strong></td><td style="text-align:center"><strong>short</strong></td><td style="text-align:center"><strong>static</strong></td><td style="text-align:center"><strong>super</strong></td></tr><tr><td style="text-align:center"><strong>switch</strong></td><td style="text-align:center"><strong>synchronized</strong></td><td style="text-align:center"><strong>this</strong></td><td style="text-align:center"><strong>throw</strong></td><td style="text-align:center"><strong>throws</strong></td></tr><tr><td style="text-align:center"><strong>transient</strong></td><td style="text-align:center"><strong>try</strong></td><td style="text-align:center"><strong>void</strong></td><td style="text-align:center"><strong>volatile</strong></td><td style="text-align:center"><strong>while</strong></td></tr></tbody></table></div><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>给类、接口、方法、变量等起名的字符序列</p><p>组成规则：数字、字母、下划线和$（见名知意），不能以数字开头，不能是java中的关键字，区分大小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> size01 = <span class="number">25.0F</span>;</span><br><span class="line"><span class="keyword">double</span> size_02 = <span class="number">30.23</span>;</span><br><span class="line"><span class="keyword">char</span> size$<span class="number">03</span> = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>在程序执行过程中，其值不发生改变的量，常量在编译阶段会存入到调用这个常量的方法所在类的常量池中。并且调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。</p><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><p>“a”、”hello”、等双引号括起来的常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><h4 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h4><p>1、2、123等数值类型常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="小数常量"><a href="#小数常量" class="headerlink" title="小数常量"></a>小数常量</h4><p>12.345等小数形式常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">12.32F</span>;</span><br></pre></td></tr></table></figure><h4 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h4><p>‘a’、’A’、’0’等用单引号括起来的常量</p><p>可与是英文字母、数字、标点符号以及由转义序列来表示的特殊字符。’\u0000’表示一个空白字符，即在单引号之间没有任何字符，之所以能这样表示，是因为Java采用Unicode字符集，Unicode字符以\u开头，空白字符在Unicode码表中对应的值为’\u0000’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">'A'</span>;</span><br></pre></td></tr></table></figure><h4 id="布尔常量"><a href="#布尔常量" class="headerlink" title="布尔常量"></a>布尔常量</h4><p>只有两种值类型的常量：true/false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="自定义常量"><a href="#自定义常量" class="headerlink" title="自定义常量"></a>自定义常量</h3><p>利用关键字final指示常量，表示这个变量只能被赋值一次，且常量名建议使用全大写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量就是程序运行中可变的量，定义格式：数据类型 变量名 = 初始化值;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>在Java中，每一个变量属于一种数据类型，在生命变量时，变量所属的类型位于变量之前，变量就是指在程序执行过程中值在某个范围内可以发生改变的量。声明一个变量后，必须使用赋值语句对变量进行显示初始化，变量的声明尽可能靠近变量第一次使用的地方。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h3><p>Java种基本数据类型有4类8种</p><p>分别为：</p><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">0</td><td style="text-align:center">8bit == 1byte</td><td style="text-align:center">-128~127</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">0</td><td style="text-align:center">16bit == 2byte</td><td style="text-align:center">-32768~32767</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">0</td><td style="text-align:center">32bit == 4byte</td><td style="text-align:center">-2147483648~2147483647</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">0L</td><td style="text-align:center">64bit == 8byte</td><td style="text-align:center">-9223372036854775808~9223372036854775807</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">8L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b4 = <span class="number">3</span> + <span class="number">4</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里不报错是因为右边先进行计算，得到数值然后进行判断，是否在byte的范围内，</span></span><br><span class="line"><span class="comment">如果在就不报错，如果不在就报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//byte b5 = 100+150; 报错</span></span><br></pre></td></tr></table></figure><h4 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">0.0f</td><td style="text-align:center">32bit == 4byte</td><td style="text-align:center">1.4E-45~3.4028235E38</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">0.0</td><td style="text-align:center">64bit == 8byte</td><td style="text-align:center">4.9E-324~1.7976931348623157E308</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浮点数</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">4.0F</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//float f2 = 3.14; 报错</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以看到这里会报错，是因为在定义浮点类型数据的时候如果不加修饰符默认是double类型</span></span><br><span class="line"><span class="comment">当double赋值给float，大类型转小类型则会报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">float</span> f3 = <span class="number">3.1415F</span>;</span><br><span class="line"><span class="keyword">float</span> f4 = (<span class="keyword">float</span>) <span class="number">3.1415</span>; <span class="comment">//这里加了强制类型转换，所以也不报错</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">那f3、f4有什么区别吗？</span></span><br><span class="line"><span class="comment">f3定义的是一个float类型，f4最初定义的是一个double类型，然后强制转换成float类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">‘\u0000’</td><td style="text-align:center">16bit == 2byte</td><td style="text-align:center">0~6553</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符类型</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">布尔类型</td><td style="text-align:center">false</td><td style="text-align:center">8bit == 1byte</td><td style="text-align:center">true/false</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布尔类型</span></span><br><span class="line"><span class="keyword">boolean</span> bool = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>数据类型转换:(隐式转换)<br>byte、short、char —&gt; int —&gt; long —&gt; float —&gt; double<br>byte、short、char之间不参与相互转换，直接转换成int类型参与运算<br>强制类型转换:(强制转换)<br>格式:<br>目标数据类型 变量名 = (目标数据类型) (被转换的数据)<br>强制类型转换会损失精度。</p><h3 id="2、引用类型"><a href="#2、引用类型" class="headerlink" title="2、引用类型"></a>2、引用类型</h3><p>底层结构和基本类型差别较大</p><ul><li>类类型</li></ul><p>当传入的值是一个类类型时，需要传入的是该类的对象</p><ul><li>接口类型</li></ul><p>当传入值是一个接口类型时，需要传入的是该接口的实现类对象</p><ul><li>数组类型</li><li>枚举</li><li>注解</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>+、-、*、/、%、++、—</p><p>++在前，先自增再运算，++在后先运算再自增</p><p>—同理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span>；</span><br><span class="line">b = <span class="number">4</span>；</span><br><span class="line">b = a++;<span class="comment">//在这里，++在后，先赋值再自增</span></span><br><span class="line">System.out.println(<span class="string">"a: "</span>+ a+<span class="string">"b: "</span>+b);<span class="comment">//a = 4 , b = 4</span></span><br><span class="line">c = a;</span><br><span class="line">c = ++b;</span><br><span class="line">System.out.println(<span class="string">"b: "</span>+ b+<span class="string">"c: "</span>+c);<span class="comment">//b = 5 , c = 5</span></span><br><span class="line">d = c;</span><br><span class="line">d = --a + b--;</span><br><span class="line">System.out.println(<span class="string">"a: "</span>+ a+<span class="string">"b: "</span>+b+<span class="string">"d "</span>+d);<span class="comment">//a = 3 , b = 4 , d = 8</span></span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>=、+=、-=、*=、/=、%=</p><p>=代表赋值运算符，将右边的值赋给左边</p><p>在这里需要注意+=、-=、<em>=、/=、%=。这代表的是一个运算符，相对于+、-、</em>、/，如果在等号两边数据类型不一致时，+=会进行自动类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">2</span>;</span><br><span class="line">a = a + b; <span class="comment">//这里会报错，因为a和b是byte类型，执行完相加赋值给a时会自动转为int类型，而a是byte类型，就会出现类型不匹配问题这里相当于 a = (int) a + b;</span></span><br><span class="line">a += b; <span class="comment">//这里不会报错，+=在运算时会自动进行类型转换</span></span><br></pre></td></tr></table></figure><p><strong>总结：+ 、+=举例</strong></p><p>+：在编译将右边表达式结果计算出来后，和左边的变量类型比较精度，如果左边的精度低于右边的结果的精度，编译器会显式的报错，告诉程序员去强制转型。所以（a = a+b;）会报错，最后将表达式的结果复制到变量所在的内存区</p><p>+=：编译器自动隐式直接将+=运算符后面的操作数强制装换为前面变量的类型，然后在变量所在的内存区上直接根据右边的操作数修改左边变量内存存储的二进制数值所以 （a += b;）不报错最后达到和赋值运算符相同的目的。与前者相比，由于后者是位操作，效率也较前者高。</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>==、！=、&gt;、&lt;、&gt;=、&lt;=</p><p>==代表判断是否相等，比较运算符返回值都是boolean类型</p><p>在这里需要注意的是，==比较基本数据类型时比较的是值，比较引用类型时比较的是两个对象的地址值</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>&amp;、|、^、!、&amp;&amp;、||</p><p>逻辑运算符用来连接boolean类型的表达式</p><p>&amp;(逻辑与)：有false则false</p><p>|(逻辑或)：有true则true</p><p>^(异或)：相同则false，不同则true</p><p>!(非)：非true则false，非false则true</p><p>&amp;&amp;(短路与)：和&amp;相同，不过有短路效果，左边是false，右边不执行</p><p>||(短路或)：和|相同，有短路效果，左边是true，右边不执行</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>操作二进制</p><p>&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;、&amp;、|、^、~</p><ul><li>&lt;&lt;：左移，空位补0，被移除的最高位丢弃<ul><li>3 &lt;&lt; 2 = 12 ——- 3 <em>2 </em>2 = 12</li></ul></li><li>.&gt;&gt;：右移，被移位的二进制最高位是0，右移后，空缺位补0，最高位是1.最高位补1<ul><li>3 &gt;&gt; 1 = 1 ——- 3/2=1</li></ul></li><li>.&gt;&gt;&gt;：无符号右移，被移位二进制最高位无论是0或者是1，空缺位都用0补<ul><li>3 &gt;&gt;&gt; 1 = 1 ——- 3/2=1</li></ul></li><li>&amp;：与运算，任何二进制位和0进行&amp;运算，结果是0，和1进行&amp;运算结果是原值<ul><li>6&amp;3=2</li></ul></li><li>|：或运算，任何二进制位和0进行|运算，结果是原值，和1进行|运算结果是1<ul><li>6|3=7</li></ul></li><li>^：异或运算，任何相同二进制位进行^运算，结果是0，不相同二进制位^运算结果是1<ul><li>6^3=5</li><li>一个数据对另外一个数据异或两次，该数不变</li></ul></li><li>~：反码<ul><li>~6=-7</li></ul></li></ul><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>格式：比较表达式?表达式1:表达式2;</p><p>执行流程：首先计算比较表达式的值，是true就执行表达式1，是false就执行表达式2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">a &gt; b ? ++a : ++b;</span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>If(condition) statement</p><p>这里的条件必须用括号括起来</p><p>If(condition) statement1 else statement2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">    a++;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a == b)&#123;</span><br><span class="line">    a--;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    b++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>当条件是true时，while循环执行一条语句。</p><p>While(condition) statement</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"这是一个死循环"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><p>先执行语句，再检测循环条件</p><p>Do statement while (condition);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我数到第"</span>+n+<span class="string">"个数了"</span>);</span><br><span class="line">  &#125;<span class="keyword">while</span>(n&gt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="确定循环"><a href="#确定循环" class="headerlink" title="确定循环"></a>确定循环</h3><p>for(初始化语句;判断条件语句;控制条件语句){循环体语句;}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//九九乘法表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">9</span>; x++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= x; y++) &#123;</span><br><span class="line">    System.out.println(x + <span class="string">"*"</span> + y + <span class="string">"="</span> + x * y + <span class="string">"\t"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h4><p>Java有一种功能很强的循环结构，可以用来依次处理数组中的每个元素</p><p>for(variable: collection) statement</p><h3 id="多重选择"><a href="#多重选择" class="headerlink" title="多重选择"></a>多重选择</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Switch (chioce)<span class="comment">//这里可选择数据类型有：基本数据类型，引用类型String，以及枚举和基本类型的封装类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">…</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">…</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">defalut:</span><br><span class="line">…</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在这里简单说一下break、continue、return三者的区别？</strong></p><p><strong>break语句</strong>的使用场合主要是switch语句和循环结构。在循环结构中使用break语句，如果执行了break语句，那么就退出循环，接着执行循环结构下面的第一条语句。如果在多重嵌套循环中使用break语句，当执行break语句的时候，退出的是它所在的循环结构，对外层循环没有任何影响。如果循环结构里有switch语句，并且在switch语句中使用了break语句，当执行switch语句中的break语句时，仅退出switch语句，不会退出外面的循环结构。</p><p>break可以跳出单层循环，也可以跳出多层循环（需要标签语句配合）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"我数到第"</span>+n+<span class="string">"个数了"</span>);</span><br><span class="line">  <span class="keyword">break</span>;<span class="comment">//这里可以看到，break跳出do-while循环，接着执行while循环</span></span><br><span class="line">&#125;<span class="keyword">while</span>(n&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(n&lt;<span class="number">100</span>)&#123;</span><br><span class="line">  System.out.println(<span class="string">"这是一个循环"</span>);</span><br><span class="line">  n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我数到第1个数了</span></span><br><span class="line"><span class="comment">这是一个循环</span></span><br><span class="line"><span class="comment">这是一个循环</span></span><br><span class="line"><span class="comment">这是一个循环</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>continue语句</strong>是最特殊的，因为它并没有真的退出循环，而是只结束本次循环体的执行，所以在使用continue的时候要注意这一点。</p><p>在for循环中，首先执行表达式1（注意表达式1在整个循环中仅执行一次），接着执行表达式2，如果满足条件，那么执行循环体，如果在循环体中执行了continue语句，那么就跳转到表达式3处执行，接下进行下一次循环，执行表达式2，看是否满足条件；在while循环中，如果执行了continue语句，那么就直接跳转到表达式处，开始下一次的循环判断；在do while循环体中如果执行了continue语句，那么就跳转到表达式处进行下一次的循环判断，</p><p><strong>return语句</strong>，如果在程序中遇到return语句，那么代码就退出该函数的执行，返回到函数的调用处，如果是main()函数，那么结束整个程序的运行。</p><p><a href="https://www.infoq.cn/article/HPohK0NfIssFx41yO*e2" target="_blank" rel="noopener">JavaSE12扩展Switch语句</a></p><h2 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h2><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类:BigInteger和BigDecimal。前者实现了任意精度的整数运算，后者实现了任意精度的浮点数运算。</p><p>使用静态的valueOf方法可以将普通的数值转换为大数值</p><p>处理大数值用大数值类中的add和multiply方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a = BigInteger.valueOf(<span class="number">100</span>);</span><br><span class="line">BigInteger c = a.add(b);  <span class="comment">//c=a+b;</span></span><br><span class="line">BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="number">2</span>)));<span class="comment">//d=c*(b+2)</span></span><br></pre></td></tr></table></figure><ul><li>BigInteger：任意精度的整数运算</li></ul><ul><li>BigDecimal：任意精度的浮点数运算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 下面的方法都来自：java.math.BigInteger 包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">mod</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回这个大整数和另一个大整数 other 的和、差、积、商以及余数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(BigInteger other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 如果这个大整数与另一个大整数 other 相等，返回 0；</span></span></span><br><span class="line"><span class="function"><span class="comment">如果这个大整数小于另一个大整数 other，返回负数；否则，返回正数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigInteger <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回值等于 x 的大整数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">add</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">subtract</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">multiply</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">divide</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回这个大实数和另一个大实数 other 的和、差、积、商。</span></span></span><br><span class="line"><span class="function"><span class="comment">在此，需要注意的是：想要计算商，必须给出舍入方式，例如  RoundingModel.HALF_UP */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(BigDecimal other)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 如果这个大实数与另一个大实数 other 相等，返回 0；</span></span></span><br><span class="line"><span class="function"><span class="comment">如果这个大实数小于另一个大实数 other，返回负数；否则，返回正数 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigDecimal <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigDecimal <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> scale)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回值等于 x 或者 x/10^(scale) 的大实数 */</span></span></span><br></pre></td></tr></table></figure><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><p>进制也就是进位制，是人们规定的一种进位方法。<br>对于任何一种进制—-X进制，就表示某一位置上的数运算时是逢X进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x进制就是逢x进位。</p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p><img src="/category/JavaSE-基础语法/二进制.png" alt="二进制"></p><p>用8个这样的信号来表示一个数据，这个数据的单位叫做：字节</p><p>1 byte = 8 bit</p><p>1k = 1024byte</p><p>1m = 1024k</p><p>通过数字1,0来表示开关，这样由1,0组成的数据就是二进制数据</p><p>二进制数有两个特点：它由两个基本数字0，1组成，二进制数运算规律是逢二进一。</p><p>为区别于其它进制数，二进制数的书写通常在数的右下方注上基数2，或加后面加B表示。</p><p>例如：二进制数10110011可以写成（10110011）2，或写成10110011B</p><h3 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h3><p>把二进制的数据，从右开始，每三位一组合，最左边不够的时候，补0。然后分别计算出对应的十进制数值，最后，再把每个十进制数据组合起来，就是一个八进制数据。</p><p><img src="/category/JavaSE-基础语法/八进制.png" alt="八进制"></p><h3 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h3><p>人们通常使用的是十进制。它的特点有两个：有0，1，2….9十个基本数字组成，十进制数运算是按“逢十进一”的规则进行的.</p><h3 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h3><p>把二进制的数据从右开始，每四位一组合，最左边不够的时候补0.然后分别进算出对应的的十进制数值，最后，再把每个十进制数据组合起来，就是一个十六进制数据。</p><p><img src="/category/JavaSE-基础语法/十六进制.png" alt="十六进制"></p><h3 id="不同进制的组成"><a href="#不同进制的组成" class="headerlink" title="不同进制的组成"></a>不同进制的组成</h3><div class="table-container"><table><thead><tr><th><strong>二进制</strong></th><th><strong>由0,1组成，以0b开头</strong></th></tr></thead><tbody><tr><td><strong>八进制</strong></td><td><strong>由0,1…7组成，以0开头</strong></td></tr><tr><td><strong>十进制</strong></td><td><strong>由0,1…9组成，整数默认是十进制</strong></td></tr><tr><td><strong>十六进制</strong></td><td><strong>由0,1…9,a,b,c,d,e,f(大小均可)组成，以0x开头</strong></td></tr></tbody></table></div><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><h4 id="其他进制到十进制的转换"><a href="#其他进制到十进制的转换" class="headerlink" title="其他进制到十进制的转换"></a>其他进制到十进制的转换</h4><p><img src="/category/JavaSE-基础语法/toten.png" alt="十进制"></p><p><img src="/category/JavaSE-基础语法/twoten.png" alt="进制转换"></p><h4 id="十进制到其他进制的转换"><a href="#十进制到其他进制的转换" class="headerlink" title="十进制到其他进制的转换"></a>十进制到其他进制的转换</h4><p><img src="/category/JavaSE-基础语法/tento.png" alt="十进制"></p><h4 id="8421码（进制的快速转换）"><a href="#8421码（进制的快速转换）" class="headerlink" title="8421码（进制的快速转换）"></a>8421码（进制的快速转换）</h4><p><img src="/category/JavaSE-基础语法/8421.png" alt="8421"></p><h3 id="有符号数据表示"><a href="#有符号数据表示" class="headerlink" title="有符号数据表示"></a>有符号数据表示</h3><p>在计算机内，有符号数由3种表示法：原码、反码和补码。所有的数据的运算都是采用补码进行的。</p><ul><li><strong>原码</strong><ul><li>就是二进制定点表示法，即最高位为符号位，”0“表示正，”1“表示负，其余位表示数值大小。</li></ul></li><li><strong>反码</strong><ul><li>正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。</li></ul></li><li><strong>补码</strong><ul><li>正数的补码与其原码相同；负数的补码是在其反码的末位+1。</li></ul></li></ul><p><strong>+7、-7的原码反码补码表示：</strong></p><p><img src="/category/JavaSE-基础语法/71.png" alt="原码"></p><p><img src="/category/JavaSE-基础语法/72.png" alt="反码"></p><p><img src="/category/JavaSE-基础语法/73.png" alt="补码"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE基础语法
    
    </summary>
    
      <category term="JavaSE基础语法" scheme="https://www.ysmjjsy.com/categories/JavaSE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-面向对象</title>
    <link href="https://www.ysmjjsy.com/category/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.ysmjjsy.com/category/JavaSE-面向对象/</id>
    <published>2017-08-16T13:33:02.000Z</published>
    <updated>2019-08-16T09:32:10.463Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 16 2019 17:33:28 GMT+0800 (GMT+08:00) --><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是构造对象的模板或蓝图，类可以看作是一组对象的集合。一类事物的抽象。举个很简单的例子，经常会听到很多人说：“我不是那类人”。比如那一类就可以理解为“类”。那对象呢，对象就是”我“。在类与类之间，最常见的关系有：依赖（uses-a）、聚合（has-a）、继承（is-a）</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>由类构造对象的过程称为创建类的实例，而这个示例就是对象，对于每个特定的类实例（对象）都有一组特定的实例域值，这些值的集合就是这个对象的当前状态。对象中的数据称为实例域，操作数据的过程称为方法。</p><p><strong>对象的三个主要特征：</strong></p><p><strong>对象的行为，对象的状态，对象标识</strong></p><p>对象状态的改变必须通过调用方法实现</p><p>作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。</p><p>要想使用对象，必须首先构造对象，并指定其初始状态，然后对对象应用方法。</p><p>在Java中，使用构造器构造新实例。构造器是一种特殊的方法，用来构造并初始化对象，构造器的名字应该与类名相同。</p><p>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象，任何对象变量的值都是对存储在另外一个地方的一个对象的引用，new操作符的返回值也是一个引用。如果将一个方法应用于一个值为null的对象上，就会产生错误。局部变量不会自动初始化为null，必须通过调用new或将他们呢设置为null进行初始化</p><h3 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h3><p><img src="/category/JavaSE-面向对象/对象内存图.jpg" alt="对象内存图"></p><p>在Java1.8之后永久区（PremGen）没有，方法区改为MetaSpace物理内存</p><p>具体可以看这篇文章：</p><p><a href="https://crowhawk.github.io/2017/08/09/jvm_1/" target="_blank" rel="noopener">Java内存区域与Java对象</a></p><h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><p>定义这个对象的信息</p><p>成员变量与局部变量的区别</p><div class="table-container"><table><thead><tr><th></th><th>在类中位置</th><th>在内存中位置</th><th>生命周期</th><th>初始化值</th></tr></thead><tbody><tr><td>成员变量</td><td>在类中方法外</td><td>在堆内存</td><td>随着对象创建而存在，随着对象消失而消失</td><td>有默认初始化值</td></tr><tr><td>局部变量</td><td>在方法内或者方法声明上</td><td>在栈内存</td><td>随着方法调用而存在，随着方法调用完毕而消失</td><td>没有默认初始化值，必须先定义赋值再使用</td></tr></tbody></table></div><p>注意：当局部变量名称和成员变量名称一致时，采用就近原则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    String name;<span class="comment">//默认值为null</span></span><br><span class="line">    <span class="keyword">int</span> age;<span class="comment">//默认值为0</span></span><br><span class="line">    <span class="keyword">int</span> num;<span class="comment">//默认值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">3</span>;<span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(<span class="string">"这里有"</span>+num+<span class="string">"只小猫"</span>);<span class="comment">//输出为3</span></span><br><span class="line">      Cat c = <span class="keyword">new</span> Cat();<span class="comment">//创建Cat对象</span></span><br><span class="line">        c.name=<span class="string">"大大"</span>;</span><br><span class="line">        c.age=<span class="number">18</span>;</span><br><span class="line">        System.out.println(c.name+c.age);<span class="comment">//大大18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法就是函数，函数在Java中被称为方法。方法是完成特定功能的代码块</p><p>方法在内存中位于方法区</p><p>方法是随着调用才会加载</p><p>方法与方法是平级关系，不能嵌套定义</p><p>方法定义时候参数之间用逗号隔开</p><p>方法调用升级后不用再传递数据类型</p><p>如果方法有明确返回值，一定要有return带回一个值</p><p>格式：修饰符 返回值类型 方法名 (参数类型 参数名1,参数类型 参数名2…){函数体; return 返回值;}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name,Date date)</span></span>&#123;</span><br><span class="line">  System.out.println(date+<span class="string">"吃了"</span>+name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">MyName</span><span class="params">(String firstName,String lastName)</span></span>&#123;</span><br><span class="line">  String myname = firstName+lastName;</span><br><span class="line">  <span class="keyword">return</span> myname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-面向对象/方法调用.png" alt="方法调用"></p><h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可</p><p>特点：与返回值类型无关，只看方法名和参数列表，在调用时虚拟机通过参数列表的不同来区分同名方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><p><strong>形参：</strong>方法被调用时需要传递进来的参数，如：show(int a)中的a，它只有在show被调用期间a才有意义，也就是会被分配内存空间，在方法show执行完成后，a就会被销毁释放空间，也就是不存在了</p><p><strong>实参：</strong>方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//实参</span></span><br><span class="line">  show(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int a=10;中的a在被调用之前就已经创建并初始化，在调用show方法时，他被当做参数传入，所以这个a是实参。<br>而show(int a)中的a只有在show被调用时它的生命周期才开始，而在show调用结束之后，它也随之被JVM释放掉，，所以这个a是形参。</p><p>当形式参数和返回值类型是引用类型时会和基本类型不同：</p><p>形参和返回值是类类型：实际传入的是该类对象</p><p>形参和返回值是抽象类：实际传入的是该抽象类的子类对象</p><p>形参和返回值是接口：需要的是该接口的实现类对象</p><h4 id="Java到底是值传递还是传引用？"><a href="#Java到底是值传递还是传引用？" class="headerlink" title="Java到底是值传递还是传引用？"></a>Java到底是值传递还是传引用？</h4><p>首先在Java里面有两种数据类型，基本数据类型与引用类型。</p><p>基本类型直接保存在变量中，引用类型变量保存的只是实际对象的地址，一般这种变量为”引用“，引用指向实际对象，实际对象中保存着内容。</p><p>按值调用(call by value):表示方法接收的是调用者提供的值</p><p>按引用调用(call byreference):表示方法接收的是调用者提供的变量地址</p><ul><li>一个方法不能修改一个基本数据类型的参数（数值型和布尔型）</li><li>一个方法可以改变一个对象参数的状态</li><li>一个方法不能让对象参数引用一个新的对象</li></ul><p>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。Java语言总是采用按值调用，也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。按引用调用，方法得到是对象引用及其他的拷贝同时引用同一个对象。</p><p><img src="/category/JavaSE-面向对象/数组内存图.png" alt="数组内存图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;<span class="comment">//变量num保存着1这个值</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//变量arr在栈内存保存的是这个数组在堆内存的地址值，这个地址值引用堆内存的数组实际值</span></span><br></pre></td></tr></table></figure><p>=：表示赋值运算符，对于基本数据类型，赋值运算符会直接改变变量的值，原本的值被覆盖，对于引用类型，赋值运算符改变引用中的地址值，而不是在堆内存的实际值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];<span class="comment">//这里并不会改变原本数组的值，而只是把新数组的引用赋值给arr</span></span><br></pre></td></tr></table></figure><p><img src="/category/JavaSE-面向对象/数组内存图2.png" alt="Java内存图2"></p><p>局部变量和方法参数在jvm中的储存方法是相同的，都是在栈上开辟空间来储存的，随着进入方法开辟，退出方法回收。以32位JVM为例，boolean/byte/short/char/int/float以及引用都是分配4字节空间，long/double分配8字节空间。对于每个方法来说，最多占用多少空间是一定的，这在编译时就可以计算好。</p><p>我们都知道JVM内存模型中有，stack和heap的存在，但是更准确的说，是每个线程都分配一个独享的stack，所有线程共享一个heap。对于每个方法的局部变量来说，是绝对无法被其他方法，甚至其他线程的同一方法所访问到的，更别说修改。</p><p>当我们在方法中声明一个 int i = 0，或者 Object obj = null 时，仅仅涉及stack，不影响到heap，当我们 new Object() 时，会在heap中开辟一段内存并初始化Object对象。当我们将这个对象赋予obj变量时，仅仅是stack中代表obj的那4个字节变更为这个对象的地址。</p><p>当我们声明一个数组时，如int[] arr = new int[10]，因为数组也是对象，arr实际上是引用，stack上仅仅占用4字节空间，new int[10]会在heap中开辟一个数组对象，然后arr指向它。</p><p>当我们声明一个二维数组时，如 <code>int[][] arr2 = new int[2]4]</code>，arr2同样仅在stack中占用4个字节，会在内存中开辟一个长度为2的，类型为int[]的数组，然后arr2指向这个数组。这个数组内部有两个引用（大小为4字节），分别指向两个长度为4的类型为int的数组。</p><p>所以当我们传递一个数组引用给一个方法时，数组的元素是可以被改变的，但是无法让数组引用指向新的数组。</p><p><strong>那Java是如何存储各种类型的数据呢？</strong></p><p>Java语言并不能操纵内存，一切都是由JVM来管理控制的，因此Java内存区域的划分也就是JVM的区域划分。详细底层可以参考：<a href="https://juejin.im/post/5bce68226fb9a05ce46a0476#heading-9" target="_blank" rel="noopener">Java的值传递和引用传递</a></p><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>匿名对象就是没有名字的对象（是对象的一种简化表示形式）</p><p>匿名对象调用完毕就是垃圾，可以被垃圾回收器回收。</p><p>匿名对象可以作为实际参数传递</p><p><strong>对象调用方法仅仅一次的时候：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带名字的调用</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">s.show();</span><br><span class="line">s.show();</span><br><span class="line">System.out.println(<span class="string">"-------"</span>);</span><br><span class="line"><span class="comment">//匿名对象调用方法</span></span><br><span class="line"><span class="keyword">new</span> Student().show();</span><br><span class="line"><span class="keyword">new</span> Student().show();<span class="comment">//不同的是，这里是创建了一个新的对象，并不是一个对象调用两次</span></span><br><span class="line"><span class="comment">//对于匿名对象，任何时候使用==比较，返回值是false</span></span><br><span class="line">System.out.println(<span class="string">"-------"</span>)</span><br></pre></td></tr></table></figure><p><strong>作为实际参数传递：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StudentDemo sd = <span class="keyword">new</span> StudentDemo();</span><br><span class="line">sd.method(<span class="keyword">new</span> Student());<span class="comment">//这里是method方法参数是一个学生类对象，这里使用匿名对象传入</span></span><br><span class="line"><span class="keyword">new</span> StudentDemo().method(<span class="keyword">new</span> Student());<span class="comment">//链式编程，等同于上面</span></span><br></pre></td></tr></table></figure><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>代表所在类的对象引用</p><p>方法被哪个对象调用，this就代表哪个对象</p><p>当局部变量隐藏成员变量，可以使用this</p><p>this可以看作是一个变量，它的值是当前对象的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;<span class="comment">//这个age是形参age，就近原则</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      这里的this是区分局部的形参age和成员变量this，</span></span><br><span class="line"><span class="comment">      这个this.age相当于Dog d = new Dog;d.age;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">growDog</span><span class="params">()</span></span>&#123;<span class="comment">//这个方法需要一个Dog对象的返回值</span></span><br><span class="line">        age++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//this相当于Dog类的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ageNow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"今年我"</span>+age+<span class="string">"岁了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog(<span class="number">3</span>);</span><br><span class="line">        d.growDog().ageNow();</span><br><span class="line">      <span class="comment">//这里可以说是一个链式编程，创建dog类对象调用growDog方法，返回dog类对象再调用ageNow方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序执行流程详解：</p><p><img src="/category/JavaSE-面向对象/dog.png" alt="内存图解"></p><p><img src="/category/JavaSE-面向对象/dog2.png" alt="内存图解2"></p><p>由上可以看出来，this一般出现在方法里，代表调用者，一开始this并不确定是谁，只有当谁调用了这个方法或者谁创建了这个对象，那么this就代表谁。</p><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final：最终的意思。常见的是它可以修饰类，方法，变量。</p><p>特点：</p><ul><li>final可以修饰类，该类不能被继承。</li><li>final可以修饰方法，该方法不能被重写。（覆盖，复写）</li><li>final可以修饰变量，该变量不能被重新赋值，因为这个变量其实是常量。</li></ul><p>当final修饰局部变量的问题：</p><p>基本类型：基本类型的值不能发生改变</p><p>引用类型：引用类型的地址值不能发生改变，但是该对象堆内存的值可以改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">  x = <span class="number">200</span>;</span><br><span class="line">  System.out.println(<span class="string">"x:"</span>+x);<span class="comment">//x:200</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> y = <span class="number">300</span>;</span><br><span class="line">  <span class="comment">//y = 400; 报错，无法为最终变量赋值</span></span><br><span class="line">  Student s = <span class="keyword">new</span> Student();<span class="comment">//Student类里有一个final int age = 10;</span></span><br><span class="line">  System.out.println(s.age);</span><br><span class="line">  <span class="comment">//s.age = 20;报错</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> Student ss = <span class="keyword">new</span> Student();<span class="comment">//final修饰引用类型，去掉Student上age的final</span></span><br><span class="line">  ss.age = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">//重新分配内存空间</span></span><br><span class="line">  <span class="comment">//ss = new Student(); 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final修饰变量的初始化时机：</p><p>被final修饰的变量只能赋值一次</p><p>在构造方法完毕前(非静态常量)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">finalDemo</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> num2;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//num2 = 20;报错</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">finalDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//num2 = 20;报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于继承中方法有一个现象：方法重写</p><p>所以父类的功能就会被子类给覆盖掉。</p><p>有时候我们不想让子类去覆盖掉父类的功能，只能让他使用。</p><p>这个时候，针对这种情况，Java就提供了一个关键字：final</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>针对多个对象有共同的相同的成员变量值的时候，Java就提供了一个关键字来修饰：static</p><p><strong>static的特点：</strong>（可以修饰成员变量、成员方法）</p><ul><li>随着类的加载而加载</li><li>优先于对象存在</li><li>被类的所有对象共享</li><li>可以通过类名调用（也可以通过对象名-一般不选择这种）</li></ul><p>静态修饰的内容一般我们称其为：与类相关的，类成员</p><p><strong>static关键字注意事项：</strong></p><ul><li><p>在静态方法中是没有this关键字的</p><ul><li>静态是随着类的加载而加载，this是随着对象的创建而存在。</li><li>静态比对象先存在</li></ul></li><li><p>静态方法只能访问静态的成员变量和静态的成员方法</p></li><li><ul><li><p>静态方法：</p></li><li><ul><li>成员变量：只能访问静态变量</li><li>成员方法：只能访问静态成员方法</li></ul></li><li><p>非静态方法：</p></li><li><ul><li>成员变量：可以是静态的，也可以是非静态的</li><li>成员方法：可以是静态的成员方法，也可以是非静态的成员方法</li></ul></li><li><p>静态只能访问静态</p></li></ul></li></ul><p><strong>静态变量和成员变量的区别：</strong></p><ul><li>所属不同<ul><li>静态变量属于类，所以也称为类变量</li><li>成员变量属于对象，所以也称为实例变量（对象变量）</li></ul></li><li>内存中位置不同<ul><li>静态变量存储于方法区的静态区</li><li>成与变量存储于堆内存</li></ul></li><li>内存出现时间不同<ul><li>静态变量随着类的加载而加载，随着类的消失而消失</li><li>成员变量随着对象的创建而存在，也可以通过对象调用</li></ul></li><li>调用不同<ul><li>静态变量可以通过类名调用，也可以通过对象调用</li><li>成员变量只能通过对象名调用</li></ul></li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>给对象的数据进行初始化</p><p>格式：</p><ul><li>方法名与类名相同</li><li>没有返回值类型，连void都没有</li><li>没有具体的返回值</li></ul><p>构造方法的注意事项：</p><p>如果我们没有给出构造方法，系统将自动提供一个无参构造方法</p><p>如果我们给出了构造方法，系统将不再提供默认的无参构造方法</p><p>如果我们还想使用无参构造方法，就必须自己给出。建议永远给出</p><p>给成员变量赋值有两种方式：</p><ul><li>setXxx()</li><li>构造方法</li></ul><h3 id="类的组成"><a href="#类的组成" class="headerlink" title="类的组成"></a>类的组成</h3><p>成员变量</p><p>构造方法</p><p>成员方法：</p><p>根据返回值：void与非void</p><p>根据形式参数列表：空参与非空参</p><p><strong>Student类初始化过程：</strong></p><p><img src="/category/JavaSE-面向对象/类初始化.png" alt="类初始化过程"></p><p>类初始化过程：</p><ol><li>加载class文件进内存</li><li>在栈内存开辟空间</li><li>在对内存为类对象开辟空间</li><li>对对象的成员变量进行默认初始化</li><li>对对象的成员变量进行显示初始化</li><li>通过构造方法对对象的成员变量赋值</li><li>对象初始化完毕，吧对象地址复制给变量</li></ol><p><strong>对象析构与finalize方法：</strong></p><p>在析构器中最常见的操作是回收分配给对象的存储空间，但Java不支持析构器，可以为任何一个类添加finalize方法，将在垃圾回收器清除对象之前调用。</p><p><strong>动态绑定：</strong></p><p>调用对象方法的执行过程：</p><p>编译器查看对象的声明类型和方法名</p><p>编译器查看调用方法时提供的参数类型</p><p>如果是private方法、static方法、final方法、或者构造器，那么编译器将准备的知道该调用哪个方法，这种调用方式为静态绑定。</p><p>调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。</p><p>当程序运行时，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。</p><p>虚拟机为了节省开销和时间，为每个类预先创建了一个方法表。</p><p><strong>什么时候定义成员变量：</strong></p><p>如果这个变量是用来描述这个类的信息的，那么该变量就应该定义为成员变量</p><p>变量的范围越小越好，因为能及时收回</p><p><strong>main方法格式</strong>：</p><p><img src="/category/JavaSE-面向对象/main.png" alt="main"></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>在Java中，使用{ }括起来的代码被称为代码块</p><p>根据其位置和声明不同，可以分为</p><p><strong>局部代码块：</strong></p><p>局部位置，用于限定变量的生命周期，及早释放，提高内存利用率</p><p><strong>构造代码块</strong></p><ul><li>在类中的成员位置，用{ }括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。</li></ul><p>作用：</p><p>可以把多个构造方法中的共同代码放到一起，对对象进行初始化。</p><p><strong>静态代码块：</strong></p><p>在类中的成员位置，用{ }括起来的代码，只不过它用static修饰了</p><p>对类的数据进行初始化，仅仅只执行一次</p><p>作用：</p><p>一般是对类进行初始化</p><p>面试题：</p><p>静态代码块，构造代码块，构造方法的执行顺序？</p><p>静态代码块 — 构造代码块 — 构造方法</p><p>静态代码块：只执行一次</p><p>构造代码块：每次调用构造方法都执行</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JavaSE面向对象
    
    </summary>
    
      <category term="JavaSE面向对象" scheme="https://www.ysmjjsy.com/categories/JavaSE%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>HelloJava</title>
    <link href="https://www.ysmjjsy.com/category/HelloJava/"/>
    <id>https://www.ysmjjsy.com/category/HelloJava/</id>
    <published>2017-08-06T01:23:12.000Z</published>
    <updated>2019-08-06T01:29:36.159Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 06 2019 09:30:03 GMT+0800 (GMT+08:00) --><h1 id="gt-HelloJava"><a href="#gt-HelloJava" class="headerlink" title="-&gt;HelloJava!"></a>-&gt;HelloJava!</h1><blockquote><p>Goya：<br>Java是一门伟大的艺术，至少在我看来是的了，也许如果没有Java出现会出现别的类似编程语言，但是因为它的存在，促进了互联网的&gt;发展。<br>当我第一次接触Java是在初中，那时候有的塞班系统的手机上会出现一个Java的一些小游戏或者小应用，回忆中的样子应该是如此。<br>到了大学，大二开始学习Java知道了这门著名的编程语言。<br>那时候老师也不会将很多学习Java先要了解的一些知识，只是告诉你James Gosling发明了Java，并且在Sun公司，之后Sun被Oracle收购等等一些常识。然后便开始了Java语言的学习，那时候只知道按部就班的安装那些必备软件，然后开始敲。</p></blockquote><p>学习Java我认为首先需要了解一下什么是Java？它用来干什么？它怎么实现的？它发展是什么？<br>我想在这个大时代背景下，程序员，编程，代码几乎人人皆知。而退十年来讲，都是陌生的。<br>随着时代的发展，让这些一部分人知道的事务变成众人皆知的事务，这就是互联网的进步以及大时代的笼罩下造成的氛围。你离开了这些就仿佛一个原始人，这么说也许太片面，但离了这些产品那真的会回退一个时代。<br>很多人都说互联网时代已经告去，大数据人工智能时代来临并飞速发展，那么怎么来，靠什么发展。我想这就是为什么电子信息专业的火爆以及许多人认为的“高薪资”。</p><hr><h1 id="那什么是Java"><a href="#那什么是Java" class="headerlink" title="那什么是Java"></a>那什么是Java</h1><ul><li><p>在1990年代之前，比较熟知的C、C++、SQL等著名语言被开发</p></li><li><p>在1990年代，推动编程语言发展的思想则是“提升程序员的生产力”，出现了很多快速应用程序开发，这些语言大都有相应的集成开发环境，也大多是面向对象的编程语言。像Java、Python、Ruby、Visual Basic、JavaScript、PHP等。而Java的出现则更加保守。</p></li></ul><p>所以Java的产生可以理解为一门可以提高程序员生产力的语言。<br>而那时候的Java叫Oak，是为了服务家用电器等小型系统的编程语言。<br>但那时候这种智能化电器则不像现在般火爆。于是Sun便开始改造。</p><blockquote><p>摘自维基百科：<br>Java编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在Java SE 1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装/拆箱特性。Sun对Java语言的解释是：“Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”<br>Java不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了Java程序的运行效率。但在J2SE1.4.2发布后，Java的运行速度有了大幅提升。<br>与传统类型不同，Sun公司在推出Java时就将其作为开放的技术。全球的Java开发公司被要求所设计的Java软件必须相互兼容。“Java语言靠群体的力量而非公司的力量”是Sun公司的口号之一，并获得了广大软件开发商的认同。这与微软公司所倡导的注重精英和封闭式的模式完全不同，此外，微软公司后来推出了与之竞争的.NET平台以及模仿Java的C#语言。后来Sun公司被甲骨文公司并购，Java也随之成为甲骨文公司的产品。</p></blockquote><p>总结下来就是Java是一个面向对象的拥有“简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”这些特点的语言。并且是一门开源语言（开放源代码全世界人学习或者修改加入自己的想法，但是Sun公司拥有Java的一部分权力）</p><p>那么首先我们可以分析一下，什么是编程语言：</p><blockquote><p>编程语言是用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。</p></blockquote><p><strong>所以Java就是一门我们可以根据Java的语法规则写出来的代码，它来编译成计算机识别的指令来操作计算机或者其他设备的语言。</strong></p><h2 id="那么Java如何识别我们写的代码再编译成计算机识别的指令呢？"><a href="#那么Java如何识别我们写的代码再编译成计算机识别的指令呢？" class="headerlink" title="那么Java如何识别我们写的代码再编译成计算机识别的指令呢？"></a>那么Java如何识别我们写的代码再编译成计算机识别的指令呢？</h2><p>举一个例子：我们写一个<strong>HelloWorld.java</strong><br><em>这个时候可以不用纠结这些看不懂</em><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"HelloWorld!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后通过控制台执行javac<br><img src="/category/HelloJava/javac.png" alt="javac"></p><p>可以看到在HelloWorld.java同级目录生成一个.class文件<br><img src="/category/HelloJava/javaclass.png" alt="classlocation"></p><p>接着执行java命令<br><img src="/category/HelloJava/java.png" alt="java"></p><p>可以看到我们写的代码被计算机所解释编译执行，输出HelloWorld</p><h3 id="那么这个javac是什么呢？"><a href="#那么这个javac是什么呢？" class="headerlink" title="那么这个javac是什么呢？"></a>那么这个javac是什么呢？</h3><ul><li>当安装好jdk后可以在jdk安装目录bin文件夹下看到这个脚本。</li><li>它是用来编译java程序的源代码，但是它本质是基于jdk标准类库中的javac类库实现，所以java的编译器实质是一个java程序</li><li>javac又被称为前端编译器，仅负责源代码与字节码之间的转换，而在jvm内部还存在一个后置编译器（根据热点探测技术，可以将最有价值的字节码转换为机器码执行从而提升java程序的运行效率）</li><li>javac 的意义就在于 将源码编译为字节码，同时做一些词法，语法，语义上的检查，最后生成可供jvm运行的字节码文件。</li><li>可以在lib中的tools jar包中sun.tools.javac;包下管理者java前端编译器的class文件，Main类中的main方法执行的是javac程序的执行入口。</li><li>同时在bin目录下可以看到很多脚本文件，比如java、javaw等</li></ul><h3 id="那这个-class文件又是什么呢？"><a href="#那这个-class文件又是什么呢？" class="headerlink" title="那这个.class文件又是什么呢？"></a>那这个.class文件又是什么呢？</h3><p>.class文件又称<strong>字节码文件</strong>，它就是java帮我们进行的第一道翻译工作后的结果，这道翻译工作就是javac，可以理解为将源码编译为字节码，同时做一些词法，语法，语义上的检查，最后生成的.class文件供jvm运行。这一过程就叫<strong>编译</strong>，更准确的是称为<strong>前端编译</strong>。.class文件也就是<strong>前端编译</strong>产生的代码。</p><h3 id="前端编译："><a href="#前端编译：" class="headerlink" title="前端编译："></a>前端编译：</h3><p><img src="/category/HelloJava/before.png" alt="Alt text"><br><strong>词法分析</strong>：词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，将字符序列转换为标记（token）序列的过程。这里的标记是一个字符串，是构成源代码的最小单位。在这个过程中，词法分析器还会对标记进行分类 。<br>词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。<br><strong>语法分析</strong>：语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述。<br><strong>将源代码中的字符流构造成抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方法。填充符号表： 符号表是一组符号地址和符号信息构成的表格。</strong><br><strong>注解处理器处理</strong>：我们平时使用的Java注解，本质就是用来对语法树做出修改，处理器的任务便是在编译是识别出这些注解同时修改抽象语法树。<br><strong>语义分析与字节码生成</strong>：<br>语义分析是编译过程的一个逻辑阶段， 语义分析的任务是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。<br>语义分析的一个重要部分就是类型检查。比如很多语言要求数组下标必须为整数，如果使用浮点数作为下标，编译器就必须报错。再比如，很多语言允许某些类型转换，称为自动类型转换。</p><ul><li>标注检查：语义分析的第一个步骤，用来检查包括诸如使用的变量是否已经声明、变量与赋值之间的数据类型是否能够匹配。其中有一个重要的步骤就是常量折叠<br>如：int a = 3 + 2， javap查看生成的class字节码，iconst指令向操作数栈中压入的是常量值5，这样在运行时期就不会CPU的运算量重新计算。</li><li>数据及控制流分析<br>用于检查诸如局部变量在使用前是否已经赋值，方法的每条路径上是否都有返回值，受查异常是否都被正常处理等问题。</li><li>解语法糖（desugar）<br>Java中我们经常使用的语法糖有泛型、自动装箱/拆箱、遍历循环、条件编译等.. 由于这些语法在运行时无法被识别，因此需要在编译阶段就将他们还原回简单的基础语法结构。</li><li>泛型<br>泛型的本质是参数化类型的应用，参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。<br>在Java中，泛型只在源码中存在，一旦经常编译，就会替换成原来的原生类型并且在相应的地方加上了强制类型转换代码。这一过程也叫做类型擦除</li><li>自动装箱/拆箱<br>基本类型自动装箱成包装类型，包装类型拆箱成基本类型，大多数Java程序员都已经了解。只是使用上有些地方需要注意，比方包装类型在使用“==”进行比较时，只有遇到算术运算时才会自动拆箱。</li><li>遍历循环<br>诸如 for(int i : list) {} 这样的loop循环在编译后都会转换成对数据结构iterator的调用</li><li>条件编译<br>对于if和常量搭配使用，在编译器发现不会执行到的语句块，将不会出现在编译之后的class文件当中</li><li>生成字节码class文件<br>在Compiler生成class文件时，不仅仅将前面步骤生成的信息转化成字节码，还会进行少量的代码添加和转换工作，如<init>和<clinit>就是在该阶段添加进class文件当中，如果Compiler发现代码中没有任何构造器，那么将会添加一个无参数的、访问性与当前类一致的构造器（也即经常所说的默认无参构造器）</clinit></init></li></ul><h3 id="后端编译"><a href="#后端编译" class="headerlink" title="后端编译"></a>后端编译</h3><p>在Java中，javac执行的结果就是得到一个字节码，而这个字节码其实就是一种中间代码。</p><p>然后得到的class文件并不能被机器所识别。这个时候就通过JVM来解释字节码，将其翻译成对应的机器指令，逐条读入，逐条解释执行，这是传统的JVM解释器的功能，为了解决这种效率问题，引入了JIT技术。（即使编译器）<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html" target="_blank" rel="noopener">深入浅出JIT编译</a></p><p>当JVM通过类加载器加载class文件里的字节码后，会通过解释器解释称汇编指令最终再转译成CPU可以识别的机器指令，解释器是软件来实现的，主要是为了实现同一份 Java 字节码可以在不同的硬件平台上运行，而将汇编指令转换成机器指令由硬件直接实现。<br><img src="/category/HelloJava/later.png" alt="later"><br>从软件层面上， class 文件被加载进虚拟机后，类信息会存放在方法区，在实际运行的时候会执行方法区中的代码，在 JVM 中所有的线程共享堆内存和方法区，而每个线程有自己独立的 Java 方法栈，本地方法栈（面向 native 方法），PC寄存器（存放线程执行位置），当调用一个方法的时候， Java 虚拟机会在当前线程对应的方法栈中压入一个栈帧，用来存放 Java 字节码操作数以及局部变量，这个方法执行完会弹出栈帧，一个线程会连续执行多个方法，对应不同的栈帧的压入和弹出，压入栈帧后就是 JVM 解释执行的过程了。</p><p>JAVA程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p><p>HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。</p><p>当 JVM 执行代码时，它并不立即开始编译代码。首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。</p><p>在机器上，执行java -version命令就可以看到自己安装的JDK中JIT是哪种模式:<br><img src="/category/HelloJava/javaversion.png" alt="-version"></p><h4 id="热点检测"><a href="#热点检测" class="headerlink" title="热点检测"></a>热点检测</h4><p>上面我们说过，要想触发JIT，首先需要识别出热点代码。目前主要的热点代码识别方式是热点探测（Hot Spot Detection），有以下两种：</p><ol><li>基于采样的方式探测（Sample Based Hot Spot Detection) ：周期性检测各个线程的栈顶，发现某个方法经常出险在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因干扰热点探测。</li><li>基于计数器的热点探测（Counter Based Hot Spot Detection)。采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。<br>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。<br>方法计数器。顾名思义，就是记录一个方法被调用次数的计数器。<br>回边计数器。是记录方法中的for或者while的运行次数的计数器。</li></ol><h4 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h4><p>前面提到过，JIT除了具有缓存的功能外，还会对代码做各种优化。说到这里，不得不佩服HotSpot的开发者，他们在JIT中对于代码优化真的算是面面俱到了。</p><p><strong>经过前端编译与后端编译，最终我们的java文件被机器所执行。</strong></p><h2 id="JDK、JRE与JVM："><a href="#JDK、JRE与JVM：" class="headerlink" title="JDK、JRE与JVM："></a>JDK、JRE与JVM：</h2><p><img src="/category/HelloJava/jdk.png" alt="JDK"></p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>Java Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。<br>最主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了属于自己的JDK。<br>JDK有以下三种版本：<br>J2SE， standard edition，标准版，是我们通常用的一个版本<br>J2EE， enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序<br>J2ME，micro edtion，主要用于移动设备、嵌入式设备上的java应用程序</p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>Java Runtime Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>我们刚生成的.class文件就是通过jvm来编译执行<br>Java Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的组成包括 JVM 指令集，符号表以及一些补助信息。</p><h2 id="至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。"><a href="#至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。" class="headerlink" title="至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。"></a>至此，一个HelloWorld的demo，这篇只是粗略的讲述，具体在日后整理再做分析。</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Java入门
    
    </summary>
    
      <category term="Java入门" scheme="https://www.ysmjjsy.com/categories/Java%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Java基础入门" scheme="https://www.ysmjjsy.com/tags/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
